---
alwaysApply: true
---
# Project Overview — kitchen-cpq-platform

## Mission

This repo implements a **high‑performance 3D Kitchen CPQ + CAD‑to‑CNC platform** with:

- Real‑time 3D kitchen configurator (Babylon.js 8 + WebGPU).
- Parametric geometry kernel (Rust → WASM + OpenCascade.js).
- CPQ engine (NestJS services + Postgres).
- CAD/CAM + BOM/cut‑list/CNC pipeline (OCCT‑based CAD service + DFM/Nesting services).
- Event‑driven microservices (NestJS + Kafka) and Temporal workflows.
- Multi‑tenant SaaS shell + CPQ back‑office UI (Vercel Platforms + Studio Admin).   

Everything lives in a single monorepo:

- `apps/` — Next.js frontend + API gateway/BFF.
- `services/` — domain microservices (identity, catalog, CPQ, manufacturing, optimization, workflows, AI, integrations).
- `libs/` — shared domain logic and TS utilities.
- `packages/` — 3D engine, geometry WASM, UI kit, SDK, proto defs, Python libs.
- `infra/` — Kubernetes, Terraform, observability.
- `tools/` — scripts, Nx plugins.   

## Golden Paths

We optimize for these flows:

1. **Interactive configuration loop**

   - User drags/edits a cabinet in the 3D view.
   - Browser → tRPC → BFF (`apps/api`) → Parametric Kernel Service → CPQ Service.
   - Parametric constraints + pricing update within **P95 ≤ 150 ms** (including render).   

2. **Sale → Factory**

   - Confirmed quote triggers Temporal workflows.
   - Catalog snapshot + configuration → CAD/CAM service → BOM, cut lists, CNC jobs.
   - Events propagated on Kafka to ERP/CRM/Manufacturing integrations.   

3. **Catalog & rules management (LayEdit‑like)**

   - Catalog engineers define products, parameters, rules and tests in admin tooling.
   - Changes go through: draft → validation → review → staged → production.
   - Catalog snapshots are immutable and versioned.   

## Architectural Invariants

- **Single source of truth:** Canonical parametric state and catalog types live in `libs/shared-types` and are reused across all services and the front‑end.   
- **Engines over AI:** Parametric kernel, CP‑SAT optimizers, and CAD/CAM services are authoritative. AI/LLM layers may only suggest deltas or macros; deterministic engines must validate.   
- **Event‑driven:** Cross‑service communication uses Kafka topics + Temporal workflows; direct synchronous calls are via gRPC or tRPC only where latency budgets require it.   
- **Latency budgets are explicit:** Each critical RPC/tRPC call has a P95 budget and must be measured in CI.   

When in doubt, choose the option that:
1. Preserves canonical types and deterministic behavior.
2. Keeps P95 latency under budget.
3. Minimizes cross‑service coupling.

