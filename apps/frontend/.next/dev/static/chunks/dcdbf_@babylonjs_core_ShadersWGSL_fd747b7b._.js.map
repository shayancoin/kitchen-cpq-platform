{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/minmaxRedux.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/minmaxRedux.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"minmaxReduxPixelShader\";\nconst shader = `varying vUV: vec2f;var textureSampler: texture_2d<f32>;\n#if defined(INITIAL)\nuniform texSize: vec2f;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {let coord=vec2i(fragmentInputs.vUV*(uniforms.texSize-1.0));let f1=textureLoad(textureSampler,coord,0).r;let f2=textureLoad(textureSampler,coord+vec2i(1,0),0).r;let f3=textureLoad(textureSampler,coord+vec2i(1,1),0).r;let f4=textureLoad(textureSampler,coord+vec2i(0,1),0).r;\n#ifdef DEPTH_REDUX\n#ifdef VIEW_DEPTH\nvar minz=3.4e38;if (f1 != 0.0) { minz=f1; }\nif (f2 != 0.0) { minz=min(minz,f2); }\nif (f3 != 0.0) { minz=min(minz,f3); }\nif (f4 != 0.0) { minz=min(minz,f4); }\nlet maxz=max(max(max(f1,f2),f3),f4);\n#else\nlet minz=min(min(min(f1,f2),f3),f4);let maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);\n#endif\n#else\nlet minz=min(min(min(f1,f2),f3),f4);let maxz=max(max(max(f1,f2),f3),f4);\n#endif\nfragmentOutputs.color=vec4f(minz,maxz,0.,0.);}\n#elif defined(MAIN)\nuniform texSize: vec2f;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {let coord=vec2i(fragmentInputs.vUV*(uniforms.texSize-1.0));let f1=textureLoad(textureSampler,coord,0).rg;let f2=textureLoad(textureSampler,coord+vec2i(1,0),0).rg;let f3=textureLoad(textureSampler,coord+vec2i(1,1),0).rg;let f4=textureLoad(textureSampler,coord+vec2i(0,1),0).rg;let minz=min(min(min(f1.x,f2.x),f3.x),f4.x);let maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);fragmentOutputs.color=vec4(minz,maxz,0.,0.);}\n#elif defined(ONEBEFORELAST)\nuniform texSize: vec2i;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {let coord=vec2i(fragmentInputs.vUV*vec2f(uniforms.texSize-1));let f1=textureLoad(textureSampler,coord % uniforms.texSize,0).rg;let f2=textureLoad(textureSampler,(coord+vec2i(1,0)) % uniforms.texSize,0).rg;let f3=textureLoad(textureSampler,(coord+vec2i(1,1)) % uniforms.texSize,0).rg;let f4=textureLoad(textureSampler,(coord+vec2i(0,1)) % uniforms.texSize,0).rg;let minz=min(min(min(f1.x,f2.x),f3.x),f4.x);let maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);fragmentOutputs.color=vec4(minz,maxz,0.,0.);}\n#elif defined(LAST)\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=vec4f(0.);if (true) { \ndiscard;}}\n#endif\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const minmaxReduxPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,wBAAwB,CAAC;AACtC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6Bd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,0BAA0B,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 54, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/picking.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/picking.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"pickingPixelShader\";\nconst shader = `#if defined(INSTANCES)\nflat varying vMeshID: f32;\n#else\nuniform meshID: f32;\n#endif\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var id: i32;\n#if defined(INSTANCES)\nid=i32(input.vMeshID);\n#else\nid=i32(uniforms.meshID);\n#endif\nvar color=vec3f(\nf32((id>>16) & 0xFF),\nf32((id>>8) & 0xFF),\nf32(id & 0xFF),\n)/255.0;fragmentOutputs.color=vec4f(color,1.0);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const pickingPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,oBAAoB,CAAC;AAClC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;CAiBd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,sBAAsB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 92, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/picking.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/picking.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal\";\nimport \"./ShadersInclude/morphTargetsVertex\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\n\nconst name = \"pickingVertexShader\";\nconst shader = `attribute position: vec3f;\n#if defined(INSTANCES)\nattribute instanceMeshID: f32;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<instancesDeclaration>\nuniform viewProjection: mat4x4f;\n#if defined(INSTANCES)\nflat varying vMeshID: f32;\n#endif\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvar worldPos: vec4f=finalWorld*vec4f(input.position,1.0);vertexOutputs.position=uniforms.viewProjection*worldPos;\n#if defined(INSTANCES)\nvertexOutputs.vMeshID=input.instanceMeshID;\n#endif\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const pickingVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,mCAAmC,CAAC;AAC3C,OAAO,kDAAkD,CAAC;AAC1D,OAAO,sDAAsD,CAAC;AAC9D,OAAO,gDAAgD,CAAC;AACxD,OAAO,uCAAuC,CAAC;AAC/C,OAAO,2CAA2C,CAAC;AACnD,OAAO,qCAAqC,CAAC;AAC7C,OAAO,kCAAkC,CAAC;AAC1C,OAAO,8BAA8B,CAAC;AACtC,OAAO,uCAAuC,CAAC;;;;;;;;;;;;AAE/C,MAAM,IAAI,GAAG,qBAAqB,CAAC;AACnC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;CAyBd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,uBAAuB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 158, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/boundingInfo.compute.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/boundingInfo.compute.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"boundingInfoComputeShader\";\nconst shader = `struct Results {minX : atomic<i32>,\nminY : atomic<i32>,\nminZ : atomic<i32>,\nmaxX : atomic<i32>,\nmaxY : atomic<i32>,\nmaxZ : atomic<i32>,\ndummy1 : i32,\ndummy2 : i32,};fn floatToBits(value: f32)->i32 {return bitcast<i32>(value);}\nfn bitsToFloat(value: i32)->f32 {return bitcast<f32>(value);}\nfn atomicMinFloat(atomicVar: ptr<storage,atomic<i32>,read_write>,value: f32) {let intValue=floatToBits(value);loop {let oldIntValue=atomicLoad(atomicVar);let oldValue=bitsToFloat(oldIntValue);if (value>=oldValue) {break;}\nif (atomicCompareExchangeWeak(atomicVar,oldIntValue,intValue).old_value==oldIntValue) {break;}}}\nfn atomicMaxFloat(atomicVar: ptr<storage,atomic<i32>,read_write>,value: f32) {let intValue=floatToBits(value);loop {let oldIntValue=atomicLoad(atomicVar);let oldValue=bitsToFloat(oldIntValue);if (value<=oldValue) {break;}\nif (atomicCompareExchangeWeak(atomicVar,oldIntValue,intValue).old_value==oldIntValue) {break;}}}\nfn readMatrixFromRawSampler(smp : texture_2d<f32>,index : f32)->mat4x4<f32>\n{let offset=i32(index) *4; \nlet m0=textureLoad(smp,vec2<i32>(offset+0,0),0);let m1=textureLoad(smp,vec2<i32>(offset+1,0),0);let m2=textureLoad(smp,vec2<i32>(offset+2,0),0);let m3=textureLoad(smp,vec2<i32>(offset+3,0),0);return mat4x4<f32>(m0,m1,m2,m3);}\nconst identity=mat4x4f(\nvec4f(1.0,0.0,0.0,0.0),\nvec4f(0.0,1.0,0.0,0.0),\nvec4f(0.0,0.0,1.0,0.0),\nvec4f(0.0,0.0,0.0,1.0)\n);struct Settings {morphTargetTextureInfo: vec3f,\nmorphTargetCount: f32,\nindexResult : u32,};@group(0) @binding(0) var<storage,read> positionBuffer : array<f32>;@group(0) @binding(1) var<storage,read_write> resultBuffer : array<Results>;@group(0) @binding(7) var<uniform> settings : Settings;\n#if NUM_BONE_INFLUENCERS>0\n@group(0) @binding(2) var boneSampler : texture_2d<f32>;@group(0) @binding(3) var<storage,read> indexBuffer : array<vec4f>;@group(0) @binding(4) var<storage,read> weightBuffer : array<vec4f>;\n#if NUM_BONE_INFLUENCERS>4\n@group(0) @binding(5) var<storage,read> indexExtraBuffer : array<vec4f>;@group(0) @binding(6) var<storage,read> weightExtraBuffer : array<vec4f>;\n#endif\n#endif\n#ifdef MORPHTARGETS\n@group(0) @binding(8) var morphTargets : texture_2d_array<f32>;@group(0) @binding(9) var<storage,read> morphTargetInfluences : array<f32>;@group(0) @binding(10) var<storage,read> morphTargetTextureIndices : array<f32>;\n#endif\n#ifdef MORPHTARGETS\nfn readVector3FromRawSampler(targetIndex : i32,vertexIndex : u32)->vec3f\n{ \nlet vertexID=f32(vertexIndex)*settings.morphTargetTextureInfo.x;let y=floor(vertexID/settings.morphTargetTextureInfo.y);let x=vertexID-y*settings.morphTargetTextureInfo.y;let textureUV=vec2<i32>(i32(x),i32(y));return textureLoad(morphTargets,textureUV,i32(morphTargetTextureIndices[targetIndex]),0).xyz;}\nfn readVector4FromRawSampler(targetIndex : i32,vertexIndex : u32)->vec4f\n{ \nlet vertexID=f32(vertexIndex)*settings.morphTargetTextureInfo.x;let y=floor(vertexID/settings.morphTargetTextureInfo.y);let x=vertexID-y*settings.morphTargetTextureInfo.y;let textureUV=vec2<i32>(i32(x),i32(y));return textureLoad(morphTargets,textureUV,i32(morphTargetTextureIndices[targetIndex]),0);}\n#endif\n@compute @workgroup_size(256,1,1)\nfn main(@builtin(global_invocation_id) global_id : vec3<u32>) {let index=global_id.x;if (index>=arrayLength(&positionBuffer)/3) {return;}\nlet position=vec3f(positionBuffer[index*3],positionBuffer[index*3+1],positionBuffer[index*3+2]);var finalWorld=identity;var positionUpdated=position;\n#if NUM_BONE_INFLUENCERS>0\nvar influence : mat4x4<f32>;let matricesIndices=indexBuffer[index];let matricesWeights=weightBuffer[index];influence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];\n#endif \n#if NUM_BONE_INFLUENCERS>2\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];\n#endif \n#if NUM_BONE_INFLUENCERS>3\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];\n#endif \n#if NUM_BONE_INFLUENCERS>4\nlet matricesIndicesExtra=indexExtraBuffer[index];let matricesWeightsExtra=weightExtraBuffer[index];influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.x)*matricesWeightsExtra.x;\n#if NUM_BONE_INFLUENCERS>5\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.y)*matricesWeightsExtra.y;\n#endif \n#if NUM_BONE_INFLUENCERS>6\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.z)*matricesWeightsExtra.z;\n#endif \n#if NUM_BONE_INFLUENCERS>7\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.w)*matricesWeightsExtra.w;\n#endif \n#endif \nfinalWorld=finalWorld*influence;\n#endif\n#ifdef MORPHTARGETS\nfor (var i=0; i<NUM_MORPH_INFLUENCERS; i=i+1) {if (f32(i)>=settings.morphTargetCount) {break;}\npositionUpdated=positionUpdated+(readVector3FromRawSampler(i,index)-position)*morphTargetInfluences[i];}\n#endif\nvar worldPos=finalWorld*vec4f(positionUpdated.x,positionUpdated.y,positionUpdated.z,1.0);atomicMinFloat(&resultBuffer[settings.indexResult].minX,worldPos.x);atomicMinFloat(&resultBuffer[settings.indexResult].minY,worldPos.y);atomicMinFloat(&resultBuffer[settings.indexResult].minZ,worldPos.z);atomicMaxFloat(&resultBuffer[settings.indexResult].maxX,worldPos.x);atomicMaxFloat(&resultBuffer[settings.indexResult].maxY,worldPos.y);atomicMaxFloat(&resultBuffer[settings.indexResult].maxZ,worldPos.z);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const boundingInfoComputeShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,2BAA2B,CAAC;AACzC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0Ed,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,6BAA6B,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 253, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/clearQuad.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/clearQuad.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"clearQuadVertexShader\";\nconst shader = `uniform depthValue: f32;const pos=array(\nvec2f(-1.0,1.0),\nvec2f(1.0,1.0),\nvec2f(-1.0,-1.0),\nvec2f(1.0,-1.0)\n);\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvertexOutputs.position=vec4f(pos[input.vertexIndex],uniforms.depthValue,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const clearQuadVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,uBAAuB,CAAC;AACrC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;CAad,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,yBAAyB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 287, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/clearQuad.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/clearQuad.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"clearQuadPixelShader\";\nconst shader = `uniform color: vec4f;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=uniforms.color;}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const clearQuadPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,sBAAsB,CAAC;AACpC,MAAM,MAAM,GAAG,CAAA;;CAEd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,wBAAwB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 310, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/glowMapGeneration.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/glowMapGeneration.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\n\nconst name = \"glowMapGenerationPixelShader\";\nconst shader = `#if defined(DIFFUSE_ISLINEAR) || defined(EMISSIVE_ISLINEAR)\n#include<helperFunctions>\n#endif\n#ifdef DIFFUSE\nvarying vUVDiffuse: vec2f;var diffuseSamplerSampler: sampler;var diffuseSampler: texture_2d<f32>;\n#endif\n#ifdef OPACITY\nvarying vUVOpacity: vec2f;var opacitySamplerSampler: sampler;var opacitySampler: texture_2d<f32>;uniform opacityIntensity: f32;\n#endif\n#ifdef EMISSIVE\nvarying vUVEmissive: vec2f;var emissiveSamplerSampler: sampler;var emissiveSampler: texture_2d<f32>;\n#endif\n#ifdef VERTEXALPHA\nvarying vColor: vec4f;\n#endif\nuniform glowColor: vec4f;uniform glowIntensity: f32;\n#include<clipPlaneFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#include<clipPlaneFragment>\nvar finalColor: vec4f=uniforms.glowColor;\n#ifdef DIFFUSE\nvar albedoTexture: vec4f=textureSample(diffuseSampler,diffuseSamplerSampler,fragmentInputs.vUVDiffuse);\n#ifdef DIFFUSE_ISLINEAR\nalbedoTexture=toGammaSpace(albedoTexture);\n#endif\n#ifdef GLOW\nfinalColor=vec4f(finalColor.rgb,finalColor.a*albedoTexture.a);\n#endif\n#ifdef HIGHLIGHT\nfinalColor=vec4f(finalColor.rgb,albedoTexture.a);\n#endif\n#endif\n#ifdef OPACITY\nvar opacityMap: vec4f=textureSample(opacitySampler,opacitySamplerSampler,fragmentInputs.vUVOpacity);\n#ifdef OPACITYRGB\nfinalColor=vec4f(finalColor.rgb,finalColor.a*getLuminance(opacityMap.rgb));\n#else\nfinalColor=vec4f(finalColor.rgb,finalColor.a*opacityMap.a);\n#endif\nfinalColor=vec4f(finalColor.rgb,finalColor.a*uniforms.opacityIntensity);\n#endif\n#ifdef VERTEXALPHA\nfinalColor=vec4f(finalColor.rgb,finalColor.a*fragmentInputs.vColor.a);\n#endif\n#ifdef ALPHATEST\nif (finalColor.a<ALPHATESTVALUE) {discard;}\n#endif\n#ifdef EMISSIVE\nvar emissive: vec4f=textureSample(emissiveSampler,emissiveSamplerSampler,fragmentInputs.vUVEmissive);\n#ifdef EMISSIVE_ISLINEAR\nemissive=toGammaSpace(emissive);\n#endif\nfragmentOutputs.color=emissive*finalColor*uniforms.glowIntensity;\n#else\nfragmentOutputs.color=finalColor*uniforms.glowIntensity;\n#endif\n#ifdef HIGHLIGHT\nfragmentOutputs.color=vec4f(fragmentOutputs.color.rgb,uniforms.glowColor.a);\n#endif\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const glowMapGenerationPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,kCAAkC,CAAC;AAC1C,OAAO,+CAA+C,CAAC;AACvD,OAAO,oCAAoC,CAAC;;;;;AAE5C,MAAM,IAAI,GAAG,8BAA8B,CAAC;AAC5C,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8Dd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,gCAAgC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 399, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/glowMapGeneration.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/glowMapGeneration.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal\";\nimport \"./ShadersInclude/morphTargetsVertex\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/clipPlaneVertex\";\n\nconst name = \"glowMapGenerationVertexShader\";\nconst shader = `attribute position: vec3f;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<clipPlaneVertexDeclaration>\n#include<instancesDeclaration>\nuniform viewProjection: mat4x4f;varying vPosition: vec4f;\n#ifdef UV1\nattribute uv: vec2f;\n#endif\n#ifdef UV2\nattribute uv2: vec2f;\n#endif\n#ifdef DIFFUSE\nvarying vUVDiffuse: vec2f;uniform diffuseMatrix: mat4x4f;\n#endif\n#ifdef OPACITY\nvarying vUVOpacity: vec2f;uniform opacityMatrix: mat4x4f;\n#endif\n#ifdef EMISSIVE\nvarying vUVEmissive: vec2f;uniform emissiveMatrix: mat4x4f;\n#endif\n#ifdef VERTEXALPHA\nattribute color: vec4f;varying vColor: vec4f;\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {var positionUpdated: vec3f=input.position;\n#ifdef UV1\nvar uvUpdated: vec2f=input.uv;\n#endif\n#ifdef UV2\nvar uv2Updated: vec2f=input.uv2;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvar worldPos: vec4f=finalWorld* vec4f(positionUpdated,1.0);\n#ifdef CUBEMAP\nvertexOutputs.vPosition=worldPos;vertexOutputs.position=uniforms.viewProjection*finalWorld* vec4f(input.position,1.0);\n#else\nvertexOutputs.vPosition=uniforms.viewProjection*worldPos;vertexOutputs.position=vertexOutputs.vPosition;\n#endif\n#ifdef DIFFUSE\n#ifdef DIFFUSEUV1\nvertexOutputs.vUVDiffuse= (uniforms.diffuseMatrix* vec4f(uvUpdated,1.0,0.0)).xy;\n#endif\n#ifdef DIFFUSEUV2\nvertexOutputs.vUVDiffuse= (uniforms.diffuseMatrix* vec4f(uv2Updated,1.0,0.0)).xy;\n#endif\n#endif\n#ifdef OPACITY\n#ifdef OPACITYUV1\nvertexOutputs.vUVOpacity= (uniforms.opacityMatrix* vec4f(uvUpdated,1.0,0.0)).xy;\n#endif\n#ifdef OPACITYUV2\nvertexOutputs.vUVOpacity= (uniforms.opacityMatrix* vec4f(uv2Updated,1.0,0.0)).xy;\n#endif\n#endif\n#ifdef EMISSIVE\n#ifdef EMISSIVEUV1\nvertexOutputs.vUVEmissive= (uniforms.emissiveMatrix* vec4f(uvUpdated,1.0,0.0)).xy;\n#endif\n#ifdef EMISSIVEUV2\nvertexOutputs.vUVEmissive= (uniforms.emissiveMatrix* vec4f(uv2Updated,1.0,0.0)).xy;\n#endif\n#endif\n#ifdef VERTEXALPHA\nvertexOutputs.vColor=vertexInputs.color;\n#endif\n#include<clipPlaneVertex>\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const glowMapGenerationVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,mCAAmC,CAAC;AAC3C,OAAO,kDAAkD,CAAC;AAC1D,OAAO,sDAAsD,CAAC;AAC9D,OAAO,gDAAgD,CAAC;AACxD,OAAO,6CAA6C,CAAC;AACrD,OAAO,uCAAuC,CAAC;AAC/C,OAAO,2CAA2C,CAAC;AACnD,OAAO,qCAAqC,CAAC;AAC7C,OAAO,kCAAkC,CAAC;AAC1C,OAAO,8BAA8B,CAAC;AACtC,OAAO,uCAAuC,CAAC;AAC/C,OAAO,kCAAkC,CAAC;;;;;;;;;;;;;;AAE1C,MAAM,IAAI,GAAG,+BAA+B,CAAC;AAC7C,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA0Eb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,iCAAiC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 518, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/glowMapMerge.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/glowMapMerge.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"glowMapMergePixelShader\";\nconst shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;\n#ifdef EMISSIVE\nvar textureSampler2Sampler: sampler;var textureSampler2: texture_2d<f32>;\n#endif\nuniform offset: f32;\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\nvar baseColor: vec4f=textureSample(textureSampler,textureSamplerSampler,input.vUV);\n#ifdef EMISSIVE\nbaseColor+=textureSample(textureSampler2,textureSampler2Sampler,input.vUV);baseColor*=uniforms.offset;\n#else\nbaseColor=vec4f(baseColor.rgb,abs(uniforms.offset-baseColor.a));\n#ifdef STROKE\nvar alpha: f32=smoothstep(.0,.1,baseColor.a);baseColor=vec4f(baseColor.rgb*alpha,alpha);\n#endif\n#endif\n#if LDR\nbaseColor=clamp(baseColor,vec4f(0.),vec4f(1.0));\n#endif\nfragmentOutputs.color=baseColor;\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const glowMapMergePixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,yBAAyB,CAAC;AACvC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;CAwBd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,2BAA2B,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 563, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/glowMapMerge.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/glowMapMerge.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"glowMapMergeVertexShader\";\nconst shader = `attribute position: vec2f;varying vUV: vec2f;\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {const madd: vec2f= vec2f(0.5,0.5);\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvertexOutputs.vUV=input.position*madd+madd;vertexOutputs.position= vec4f(input.position,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const glowMapMergeVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,0BAA0B,CAAC;AACxC,MAAM,MAAM,GAAG,CAAA;;;;;;;EAOb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,4BAA4B,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 591, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/glowBlurPostProcess.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/glowBlurPostProcess.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"glowBlurPostProcessPixelShader\";\nconst shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform screenSize: vec2f;uniform direction: vec2f;uniform blurWidth: f32;fn getLuminance(color: vec3f)->f32\n{return dot(color, vec3f(0.2126,0.7152,0.0722));}\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var weights: array<f32 ,7>;weights[0]=0.05;weights[1]=0.1;weights[2]=0.2;weights[3]=0.3;weights[4]=0.2;weights[5]=0.1;weights[6]=0.05;var texelSize: vec2f= vec2f(1.0/uniforms.screenSize.x,1.0/uniforms.screenSize.y);var texelStep: vec2f=texelSize*uniforms.direction*uniforms.blurWidth;var start: vec2f=input.vUV-3.0*texelStep;var baseColor: vec4f= vec4f(0.,0.,0.,0.);var texelOffset: vec2f= vec2f(0.,0.);for (var i: i32=0; i<7; i++)\n{var texel: vec4f=textureSample(textureSampler,textureSamplerSampler,start+texelOffset);baseColor=vec4f(baseColor.rgb,baseColor.a+texel.a*weights[i]);var luminance: f32=getLuminance(baseColor.rgb);var luminanceTexel: f32=getLuminance(texel.rgb);var choice: f32=step(luminanceTexel,luminance);baseColor=vec4f(choice*baseColor.rgb+(1.0-choice)*texel.rgb,baseColor.a);texelOffset+=texelStep;}\nfragmentOutputs.color=baseColor;}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const glowBlurPostProcessPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,gCAAgC,CAAC;AAC9C,MAAM,MAAM,GAAG,CAAA;;;;;;kCAMmB,CAAC;AACnC,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,kCAAkC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 618, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/layer.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/layer.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\n\nconst name = \"layerPixelShader\";\nconst shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform color: vec4f;\n#include<helperFunctions>\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\nvar baseColor: vec4f=textureSample(textureSampler,textureSamplerSampler,input.vUV);\n#if defined(CONVERT_TO_GAMMA)\nbaseColor=toGammaSpace(baseColor);\n#elif defined(CONVERT_TO_LINEAR)\nbaseColor=toLinearSpaceVec4(baseColor);\n#endif\n#ifdef ALPHATEST\nif (baseColor.a<0.4) {discard;}\n#endif\nfragmentOutputs.color=baseColor*uniforms.color;\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const layerPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,kCAAkC,CAAC;;;AAE1C,MAAM,IAAI,GAAG,kBAAkB,CAAC;AAChC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;EAiBb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,oBAAoB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 658, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/layer.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/layer.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"layerVertexShader\";\nconst shader = `attribute position: vec2f;uniform scale: vec2f;uniform offset: vec2f;uniform textureMatrix: mat4x4f;varying vUV: vec2f;const madd: vec2f= vec2f(0.5,0.5);\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvar shiftedPosition: vec2f=input.position*uniforms.scale+uniforms.offset;vertexOutputs.vUV=(uniforms.textureMatrix* vec4f(shiftedPosition*madd+madd,1.0,0.0)).xy;vertexOutputs.position= vec4f(shiftedPosition,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const layerVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,mBAAmB,CAAC;AACjC,MAAM,MAAM,GAAG,CAAA;;;;;;;EAOb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,qBAAqB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 686, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/lensFlare.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/lensFlare.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"lensFlarePixelShader\";\nconst shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform color: vec4f;\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\nvar baseColor: vec4f=textureSample(textureSampler,textureSamplerSampler,input.vUV);fragmentOutputs.color=baseColor*uniforms.color;\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const lensFlarePixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,sBAAsB,CAAC;AACpC,MAAM,MAAM,GAAG,CAAA;;;;;;;EAOb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,wBAAwB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 714, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/lensFlare.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/lensFlare.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"lensFlareVertexShader\";\nconst shader = `attribute position: vec2f;uniform viewportMatrix: mat4x4f;varying vUV: vec2f;const madd: vec2f= vec2f(0.5,0.5);\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvertexOutputs.vUV=input.position*madd+madd;vertexOutputs.position=uniforms.viewportMatrix* vec4f(input.position,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const lensFlareVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,uBAAuB,CAAC;AACrC,MAAM,MAAM,GAAG,CAAA;;;;;;;EAOb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,yBAAyB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 742, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/shadowMap.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/shadowMap.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/shadowMapFragmentExtraDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nimport \"./ShadersInclude/shadowMapFragment\";\n\nconst name = \"shadowMapPixelShader\";\nconst shader = `#include<shadowMapFragmentExtraDeclaration>\n#ifdef ALPHATEXTURE\nvarying vUV: vec2f;var diffuseSamplerSampler: sampler;var diffuseSampler: texture_2d<f32>;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#include<clipPlaneFragment>\n#ifdef ALPHATEXTURE\nvar opacityMap: vec4f=textureSample(diffuseSampler,diffuseSamplerSampler,fragmentInputs.vUV);var alphaFromAlphaTexture: f32=opacityMap.a;\n#if SM_SOFTTRANSPARENTSHADOW==1\nif (uniforms.softTransparentShadowSM.y==1.0) {opacityMap=vec4f(opacityMap.rgb* vec3f(0.3,0.59,0.11),opacityMap.a);alphaFromAlphaTexture=opacityMap.x+opacityMap.y+opacityMap.z;}\n#endif\n#ifdef ALPHATESTVALUE\nif (alphaFromAlphaTexture<ALPHATESTVALUE) {discard;}\n#endif\n#endif\n#if SM_SOFTTRANSPARENTSHADOW==1\n#ifdef ALPHATEXTURE\nif ((bayerDither8(floor(((fragmentInputs.position.xy)%(8.0)))))/64.0>=uniforms.softTransparentShadowSM.x*alphaFromAlphaTexture) {discard;}\n#else\nif ((bayerDither8(floor(((fragmentInputs.position.xy)%(8.0)))))/64.0>=uniforms.softTransparentShadowSM.x) {discard;} \n#endif\n#endif\n#include<shadowMapFragment>\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const shadowMapPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,oDAAoD,CAAC;AAC5D,OAAO,+CAA+C,CAAC;AACvD,OAAO,oCAAoC,CAAC;AAC5C,OAAO,oCAAoC,CAAC;;;;;;AAE5C,MAAM,IAAI,GAAG,sBAAsB,CAAC;AACpC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;EA0Bb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,wBAAwB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 797, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/shadowMap.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/shadowMap.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/sceneUboDeclaration\";\nimport \"./ShadersInclude/meshUboDeclaration\";\nimport \"./ShadersInclude/shadowMapVertexExtraDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal\";\nimport \"./ShadersInclude/morphTargetsVertex\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/shadowMapVertexNormalBias\";\nimport \"./ShadersInclude/shadowMapVertexMetric\";\nimport \"./ShadersInclude/clipPlaneVertex\";\n\nconst name = \"shadowMapVertexShader\";\nconst shader = `attribute position: vec3f;\n#ifdef NORMAL\nattribute normal: vec3f;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef INSTANCES\nattribute world0: vec4f;attribute world1: vec4f;attribute world2: vec4f;attribute world3: vec4f;\n#endif\n#include<helperFunctions>\n#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n#ifdef ALPHATEXTURE\nvarying vUV: vec2f;uniform diffuseMatrix: mat4x4f;\n#ifdef UV1\nattribute uv: vec2f;\n#endif\n#ifdef UV2\nattribute uv2: vec2f;\n#endif\n#endif\n#include<shadowMapVertexExtraDeclaration>\n#include<clipPlaneVertexDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {var positionUpdated: vec3f=input.position;\n#ifdef UV1\nvar uvUpdated: vec2f=input.uv;\n#endif\n#ifdef UV2\nvar uv2Updated: vec2f=input.uv2;\n#endif\n#ifdef NORMAL\nvar normalUpdated: vec3f=input.normal;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvar worldPos: vec4f=finalWorld* vec4f(positionUpdated,1.0);\n#ifdef NORMAL\nvar normWorldSM: mat3x3f= mat3x3f(finalWorld[0].xyz,finalWorld[1].xyz,finalWorld[2].xyz);\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvar vNormalW: vec3f=normalUpdated/ vec3f(dot(normWorldSM[0],normWorldSM[0]),dot(normWorldSM[1],normWorldSM[1]),dot(normWorldSM[2],normWorldSM[2]));vNormalW=normalize(normWorldSM*vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormWorldSM=transposeMat3(inverseMat3(normWorldSM));\n#endif\nvar vNormalW: vec3f=normalize(normWorldSM*normalUpdated);\n#endif\n#endif\n#include<shadowMapVertexNormalBias>\nvertexOutputs.position=scene.viewProjection*worldPos;\n#include<shadowMapVertexMetric>\n#ifdef ALPHATEXTURE\n#ifdef UV1\nvertexOutputs.vUV= (uniforms.diffuseMatrix* vec4f(uvUpdated,1.0,0.0)).xy;\n#endif\n#ifdef UV2\nvertexOutputs.vUV= (uniforms.diffuseMatrix* vec4f(uv2Updated,1.0,0.0)).xy;\n#endif\n#endif\n#include<clipPlaneVertex>\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const shadowMapVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,mCAAmC,CAAC;AAC3C,OAAO,kDAAkD,CAAC;AAC1D,OAAO,sDAAsD,CAAC;AAC9D,OAAO,gDAAgD,CAAC;AACxD,OAAO,kCAAkC,CAAC;AAC1C,OAAO,sCAAsC,CAAC;AAC9C,OAAO,qCAAqC,CAAC;AAC7C,OAAO,kDAAkD,CAAC;AAC1D,OAAO,6CAA6C,CAAC;AACrD,OAAO,2CAA2C,CAAC;AACnD,OAAO,qCAAqC,CAAC;AAC7C,OAAO,kCAAkC,CAAC;AAC1C,OAAO,8BAA8B,CAAC;AACtC,OAAO,uCAAuC,CAAC;AAC/C,OAAO,4CAA4C,CAAC;AACpD,OAAO,wCAAwC,CAAC;AAChD,OAAO,kCAAkC,CAAC;;;;;;;;;;;;;;;;;;;AAE1C,MAAM,IAAI,GAAG,uBAAuB,CAAC;AACrC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAkEb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,yBAAyB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 918, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/depthBoxBlur.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/depthBoxBlur.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"depthBoxBlurPixelShader\";\nconst shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform screenSize: vec2f;\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var colorDepth: vec4f=vec4f(0.0);for (var x: i32=-OFFSET; x<=OFFSET; x++) {for (var y: i32=-OFFSET; y<=OFFSET; y++) {colorDepth+=textureSample(textureSampler,textureSamplerSampler,input.vUV+ vec2f(f32(x),f32(y))/uniforms.screenSize);}}\nfragmentOutputs.color=(colorDepth/ f32((OFFSET*2+1)*(OFFSET*2+1)));}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const depthBoxBlurPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,yBAAyB,CAAC;AACvC,MAAM,MAAM,GAAG,CAAA;;;;qEAIsD,CAAC;AACtE,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,2BAA2B,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 943, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/lightProxy.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/lightProxy.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"lightProxyPixelShader\";\nconst shader = `flat varying vOffset: u32;flat varying vMask: u32;uniform tileMaskResolution: vec3f;var<storage,read_write> tileMaskBuffer: array<atomic<u32>>;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {let maskResolution=vec2u(uniforms.tileMaskResolution.yz);let tilePosition=vec2u(fragmentInputs.position.xy);let tileIndex=(tilePosition.x*maskResolution.x+tilePosition.y)*maskResolution.y+fragmentInputs.vOffset;atomicOr(&tileMaskBuffer[tileIndex],fragmentInputs.vMask);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const lightProxyPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,uBAAuB,CAAC;AACrC,MAAM,MAAM,GAAG,CAAA;;CAEd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,yBAAyB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 966, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/lightProxy.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/lightProxy.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/sceneUboDeclaration\";\nimport \"./ShadersInclude/clusteredLightingFunctions\";\n\nconst name = \"lightProxyVertexShader\";\nconst shader = `attribute position: vec3f;flat varying vOffset: u32;flat varying vMask: u32;\n#include<sceneUboDeclaration>\nvar lightDataTexture: texture_2d<f32>;uniform tileMaskResolution: vec3f;uniform halfTileRes: vec2f;\n#include<clusteredLightingFunctions>\n@vertex\nfn main(input: VertexInputs)->FragmentInputs {let light=getClusteredLight(lightDataTexture,vertexInputs.instanceIndex);let range=light.vLightFalloff.x;let viewPosition=scene.view*vec4f(light.vLightData.xyz,1);let viewPositionSq=viewPosition*viewPosition;let distSq=viewPositionSq.xy+viewPositionSq.z;let sinSq=(range*range)/distSq;let cosSq=max(1.0-sinSq,vec2f(0.01));let sinCos=vertexInputs.position.xy*sqrt(sinSq*cosSq);let rotatedX=mat2x2f(cosSq.x,-sinCos.x,sinCos.x,cosSq.x)*viewPosition.xz;let rotatedY=mat2x2f(cosSq.y,-sinCos.y,sinCos.y,cosSq.y)*viewPosition.yz;let projX=scene.projection*vec4f(rotatedX.x,0,rotatedX.y,1);let projY=scene.projection*vec4f(0,rotatedY.x,rotatedY.y,1);var projPosition=vec2f(projX.x/max(projX.w,0.01),projY.y/max(projY.w,0.01));projPosition=select(vertexInputs.position.xy,projPosition,cosSq>vec2(0.01));let halfTileRes=uniforms.tileMaskResolution.xy/2.0;var tilePosition=(projPosition+1.0)*halfTileRes;tilePosition=select(floor(tilePosition)-0.01,ceil(tilePosition)+0.01,vertexInputs.position.xy>vec2f(0));vertexOutputs.position=vec4f(tilePosition/halfTileRes-1.0,0,1);vertexOutputs.vOffset=vertexInputs.instanceIndex/CLUSTLIGHT_BATCH;vertexOutputs.vMask=1u<<(vertexInputs.instanceIndex % CLUSTLIGHT_BATCH);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const lightProxyVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,sCAAsC,CAAC;AAC9C,OAAO,6CAA6C,CAAC;;;;AAErD,MAAM,IAAI,GAAG,wBAAwB,CAAC;AACtC,MAAM,MAAM,GAAG,CAAA;;;;;;CAMd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,0BAA0B,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 997, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/lightingVolume.compute.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/lightingVolume.compute.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"lightingVolumeComputeShader\";\nconst shader = `struct Params {invViewProjMatrix : mat4x4f,\nstartVertexIndex: u32,\nstep: f32,\ntesselation: u32,};@group(0) @binding(0) var shadowMap : texture_2d<f32>;@group(0) @binding(1) var<uniform> params : Params;@group(0) @binding(2) var<storage,read_write> positions : array<f32>;@compute @workgroup_size(8,8,1)\nfn main(@builtin(global_invocation_id) global_id : vec3u) {let coord=global_id.xy;\n#ifdef KEEP_EDGES\nif (any(coord>=vec2u(params.tesselation)) || any(coord<=vec2u(0))) {\n#else\nif (any(coord>=vec2u(params.tesselation+1))) {\n#endif\nreturn;}\nlet stepY=floor(params.step*f32(coord.y));let depthCoord=vec2u(u32(floor(f32(coord.x)*params.step)),u32(stepY));var depth=textureLoad(shadowMap,depthCoord,0).r;\n#ifdef MOVE_FAR_DEPTH_TO_NEAR\nif (depth==1.0) {depth=0.0;}\n#endif\nlet halfTesselation=f32(params.tesselation>>1);let ndc=vec4f((f32(coord.x)-halfTesselation)/halfTesselation,(f32(coord.y)-halfTesselation)/halfTesselation,depth,1.0);var worldCoords=params.invViewProjMatrix*ndc;let idx=params.startVertexIndex+(coord.y*(params.tesselation+1)+coord.x)*3;positions[idx]=worldCoords.x/worldCoords.w;positions[idx+1]=worldCoords.y/worldCoords.w;positions[idx+2]=worldCoords.z/worldCoords.w;}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const lightingVolumeComputeShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,6BAA6B,CAAC;AAC3C,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;CAgBd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,+BAA+B,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 1034, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/background.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/background.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/backgroundUboDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/fogVertexDeclaration\";\nimport \"./ShadersInclude/lightVxUboDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/fogVertex\";\nimport \"./ShadersInclude/shadowsVertex\";\nimport \"./ShadersInclude/logDepthVertex\";\n\nconst name = \"backgroundVertexShader\";\nconst shader = `#include<backgroundUboDeclaration>\n#include<helperFunctions>\nattribute position: vec3f;\n#ifdef NORMAL\nattribute normal: vec3f;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nvarying vPositionW: vec3f;\n#ifdef NORMAL\nvarying vNormalW: vec3f;\n#endif\n#ifdef UV1\nattribute uv: vec2f;\n#endif\n#ifdef UV2\nattribute uv2: vec2f;\n#endif\n#ifdef MAINUV1\nvarying vMainUV1: vec2f;\n#endif\n#ifdef MAINUV2\nvarying vMainUV2: vec2f;\n#endif\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV==0\nvarying vDiffuseUV: vec2f;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<lightVxUboDeclaration>[0..maxSimultaneousLights]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vPositionUVW: vec3f;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vDirectionW: vec3f;\n#endif\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#ifdef REFLECTIONMAP_SKYBOX\nvertexOutputs.vPositionUVW=input.position;\n#endif\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {vertexOutputs.position=scene.viewProjection*finalWorld* vec4f(input.position,1.0);} else {vertexOutputs.position=scene.viewProjectionR*finalWorld* vec4f(input.position,1.0);}\n#else\nvertexOutputs.position=scene.viewProjection*finalWorld* vec4f(input.position,1.0);\n#endif\nvar worldPos: vec4f=finalWorld* vec4f(input.position,1.0);vertexOutputs.vPositionW= worldPos.xyz;\n#ifdef NORMAL\nvar normalWorld: mat3x3f=mat3x3f(finalWorld[0].xyz,finalWorld[1].xyz,finalWorld[2].xyz);\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\n#endif\nvertexOutputs.vNormalW=normalize(normalWorld*input.normal);\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvertexOutputs.vDirectionW=normalize((finalWorld*vec4f(input.position,0.0)).xyz);\n#ifdef EQUIRECTANGULAR_RELFECTION_FOV\nvar screenToWorld: mat3x3f=inverseMat3( mat3x3f(finalWorld*scene.viewProjection));var segment: vec3f=mix(vertexOutputs.vDirectionW,screenToWorld* vec3f(0.0,0.0,1.0),abs(fFovMultiplier-1.0));if (fFovMultiplier<=1.0) {vertexOutputs.vDirectionW=normalize(segment);} else {vertexOutputs.vDirectionW=normalize(vertexOutputs.vDirectionW+(vertexOutputs.vDirectionW-segment));}\n#endif\n#endif\n#ifndef UV1\nvar uv: vec2f=vec2f(0.,0.);\n#else\nvar uv=input.uv;\n#endif\n#ifndef UV2\nvar uv2: vec2f=vec2f(0.,0.);\n#else\nvar uv2=input.uv2;\n#endif\n#ifdef MAINUV1\nvertexOutputs.vMainUV1=uv;\n#endif\n#ifdef MAINUV2\nvertexOutputs.vMainUV2=uv2;\n#endif\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV==0\nif (uniforms.vDiffuseInfos.x==0.)\n{vertexOutputs.vDiffuseUV= (uniforms.diffuseMatrix* vec4f(uv,1.0,0.0)).xy;}\nelse\n{vertexOutputs.vDiffuseUV= (uniforms.diffuseMatrix* vec4f(uv2,1.0,0.0)).xy;}\n#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#ifdef VERTEXCOLOR\nvertexOutputs.vColor=vertexInputs.color;\n#endif\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const backgroundVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,2CAA2C,CAAC;AACnD,OAAO,kCAAkC,CAAC;AAC1C,OAAO,mCAAmC,CAAC;AAC3C,OAAO,kDAAkD,CAAC;AAC1D,OAAO,uCAAuC,CAAC;AAC/C,OAAO,6CAA6C,CAAC;AACrD,OAAO,uCAAuC,CAAC;AAC/C,OAAO,wCAAwC,CAAC;AAChD,OAAO,sCAAsC,CAAC;AAC9C,OAAO,kCAAkC,CAAC;AAC1C,OAAO,8BAA8B,CAAC;AACtC,OAAO,uCAAuC,CAAC;AAC/C,OAAO,kCAAkC,CAAC;AAC1C,OAAO,4BAA4B,CAAC;AACpC,OAAO,gCAAgC,CAAC;AACxC,OAAO,iCAAiC,CAAC;;;;;;;;;;;;;;;;;;AAEzC,MAAM,IAAI,GAAG,wBAAwB,CAAC;AACtC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkGd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,0BAA0B,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 1185, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/background.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/background.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/backgroundUboDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/reflectionFunction\";\nimport \"./ShadersInclude/imageProcessingDeclaration\";\nimport \"./ShadersInclude/lightUboDeclaration\";\nimport \"./ShadersInclude/lightsFragmentFunctions\";\nimport \"./ShadersInclude/shadowsFragmentFunctions\";\nimport \"./ShadersInclude/imageProcessingFunctions\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/intersectionFunctions\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nimport \"./ShadersInclude/lightFragment\";\nimport \"./ShadersInclude/logDepthFragment\";\nimport \"./ShadersInclude/fogFragment\";\n\nconst name = \"backgroundPixelShader\";\nconst shader = `#include<backgroundUboDeclaration>\n#include<helperFunctions>\nvarying vPositionW: vec3f;\n#ifdef MAINUV1\nvarying vMainUV1: vec2f;\n#endif \n#ifdef MAINUV2 \nvarying vMainUV2: vec2f; \n#endif \n#ifdef NORMAL\nvarying vNormalW: vec3f;\n#endif\n#ifdef DIFFUSE\n#if DIFFUSEDIRECTUV==1\n#define vDiffuseUV vMainUV1\n#elif DIFFUSEDIRECTUV==2\n#define vDiffuseUV vMainUV2\n#else\nvarying vDiffuseUV: vec2f;\n#endif\nvar diffuseSamplerSampler: sampler;var diffuseSampler: texture_2d<f32>;\n#endif\n#ifdef REFLECTION\n#ifdef REFLECTIONMAP_3D\nvar reflectionSamplerSampler: sampler;var reflectionSampler: texture_cube<f32>;\n#ifdef TEXTURELODSUPPORT\n#else\nvar reflectionLowSamplerSampler: sampler;var reflectionLowSampler: texture_cube<f32>;var reflectionHighSamplerSampler: sampler;var reflectionHighSampler: texture_cube<f32>;\n#endif\n#else\nvar reflectionSamplerSampler: sampler;var reflectionSampler: texture_2d<f32>;\n#ifdef TEXTURELODSUPPORT\n#else\nvar reflectionLowSamplerSampler: sampler;var reflectionLowSampler: texture_2d<f32>;var reflectionHighSamplerSampler: sampler;var reflectionHighSampler: texture_2d<f32>;\n#endif\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vPositionUVW: vec3f;\n#else\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vDirectionW: vec3f;\n#endif\n#endif\n#include<reflectionFunction>\n#endif\n#ifndef FROMLINEARSPACE\n#define FROMLINEARSPACE;\n#endif\n#ifndef SHADOWONLY\n#define SHADOWONLY;\n#endif\n#include<imageProcessingDeclaration>\n#include<lightUboDeclaration>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<imageProcessingFunctions>\n#include<logDepthDeclaration>\n#include<clipPlaneFragmentDeclaration>\n#include<fogFragmentDeclaration>\n#ifdef REFLECTIONFRESNEL\n#define FRESNEL_MAXIMUM_ON_ROUGH 0.25\nfn fresnelSchlickEnvironmentGGX(VdotN: f32,reflectance0: vec3f,reflectance90: vec3f,smoothness: f32)->vec3f\n{var weight: f32=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);return reflectance0+weight*(reflectance90-reflectance0)*pow5(saturate(1.0-VdotN));}\n#endif\n#ifdef PROJECTED_GROUND\n#include<intersectionFunctions>\nfn project(viewDirectionW: vec3f,eyePosition: vec3f)->vec3f {var radius: f32=uniforms.projectedGroundInfos.x;var height: f32=uniforms.projectedGroundInfos.y;var camDir: vec3f=-viewDirectionW;var skySphereDistance: f32=sphereIntersectFromOrigin(eyePosition,camDir,radius).x;var skySpherePositionW: vec3f=eyePosition+camDir*skySphereDistance;var p: vec3f=normalize(skySpherePositionW);var upEyePosition=vec3f(eyePosition.x,eyePosition.y-height,eyePosition.z);var sIntersection: f32=sphereIntersectFromOrigin(upEyePosition,p,radius).x;var h: vec3f= vec3f(0.0,-height,0.0);var dIntersection: f32=diskIntersectWithBackFaceCulling(upEyePosition,p,h,radius);p=(upEyePosition+min(sIntersection,dIntersection)*p);return p;}\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvar viewDirectionW: vec3f=normalize(scene.vEyePosition.xyz-input.vPositionW);\n#ifdef NORMAL\nvar normalW: vec3f=normalize(fragmentInputs.vNormalW);\n#else\nvar normalW: vec3f= vec3f(0.0,1.0,0.0);\n#endif\nvar shadow: f32=1.;var globalShadow: f32=0.;var shadowLightCount: f32=0.;var aggShadow: f32=0.;var numLights: f32=0.;\n#include<lightFragment>[0..maxSimultaneousLights]\n#ifdef SHADOWINUSE\nglobalShadow/=shadowLightCount;\n#else\nglobalShadow=1.0;\n#endif\n#ifndef BACKMAT_SHADOWONLY\nvar reflectionColor: vec4f= vec4f(1.,1.,1.,1.);\n#ifdef REFLECTION\n#ifdef PROJECTED_GROUND\nvar reflectionVector: vec3f=project(viewDirectionW,scene.vEyePosition.xyz);reflectionVector= (uniforms.reflectionMatrix*vec4f(reflectionVector,1.)).xyz;\n#else\nvar reflectionVector: vec3f=computeReflectionCoords( vec4f(fragmentInputs.vPositionW,1.0),normalW);\n#endif\n#ifdef REFLECTIONMAP_OPPOSITEZ\nreflectionVector.z*=-1.0;\n#endif\n#ifdef REFLECTIONMAP_3D\nvar reflectionCoords: vec3f=reflectionVector;\n#else\nvar reflectionCoords: vec2f=reflectionVector.xy;\n#ifdef REFLECTIONMAP_PROJECTION\nreflectionCoords/=reflectionVector.z;\n#endif\nreflectionCoords.y=1.0-reflectionCoords.y;\n#endif\n#ifdef REFLECTIONBLUR\nvar reflectionLOD: f32=uniforms.vReflectionInfos.y;\n#ifdef TEXTURELODSUPPORT\nreflectionLOD=reflectionLOD*log2(uniforms.vReflectionMicrosurfaceInfos.x)*uniforms.vReflectionMicrosurfaceInfos.y+uniforms.vReflectionMicrosurfaceInfos.z;reflectionColor=textureSampleLevel(reflectionSampler,reflectionSamplerSampler,reflectionCoords,reflectionLOD);\n#else\nvar lodReflectionNormalized: f32=saturate(reflectionLOD);var lodReflectionNormalizedDoubled: f32=lodReflectionNormalized*2.0;var reflectionSpecularMid: vec4f=textureSample(reflectionSampler,reflectionSamplerSampler,reflectionCoords);if(lodReflectionNormalizedDoubled<1.0){reflectionColor=mix(\ntextureSample(reflectionrHighSampler,reflectionrHighSamplerSampler,reflectionCoords),\nreflectionSpecularMid,\nlodReflectionNormalizedDoubled\n);} else {reflectionColor=mix(\nreflectionSpecularMid,\ntextureSample(reflectionLowSampler,reflectionLowSamplerSampler,reflectionCoords),\nlodReflectionNormalizedDoubled-1.0\n);}\n#endif\n#else\nvar reflectionSample: vec4f=textureSample(reflectionSampler,reflectionSamplerSampler,reflectionCoords);reflectionColor=reflectionSample;\n#endif\n#ifdef RGBDREFLECTION\nreflectionColor=vec4f(fromRGBD(reflectionColor).rgb,reflectionColor.a);\n#endif\n#ifdef GAMMAREFLECTION\nreflectionColor=vec4f(toLinearSpaceVec3(reflectionColor.rgb),reflectionColor.a);\n#endif\n#ifdef REFLECTIONBGR\nreflectionColor=vec4f(reflectionColor.bgr,reflectionColor.a);\n#endif\nreflectionColor=vec4f(reflectionColor.rgb*uniforms.vReflectionInfos.x,reflectionColor.a);\n#endif\nvar diffuseColor: vec3f= vec3f(1.,1.,1.);var finalAlpha: f32=uniforms.alpha;\n#ifdef DIFFUSE\nvar diffuseMap: vec4f=textureSample(diffuseSampler,diffuseSamplerSampler,input.vDiffuseUV);\n#ifdef GAMMADIFFUSE\ndiffuseMap=vec4f(toLinearSpaceVec3(diffuseMap.rgb),diffuseMap.a);\n#endif\ndiffuseMap=vec4f(diffuseMap.rgb *uniforms.vDiffuseInfos.y,diffuseMap.a);\n#ifdef DIFFUSEHASALPHA\nfinalAlpha*=diffuseMap.a;\n#endif\ndiffuseColor=diffuseMap.rgb;\n#endif\n#ifdef REFLECTIONFRESNEL\nvar colorBase: vec3f=diffuseColor;\n#else\nvar colorBase: vec3f=reflectionColor.rgb*diffuseColor;\n#endif\ncolorBase=max(colorBase,vec3f(0.0));\n#ifdef USERGBCOLOR\nvar finalColor: vec3f=colorBase;\n#else\n#ifdef USEHIGHLIGHTANDSHADOWCOLORS\nvar mainColor: vec3f=mix(uniforms.vPrimaryColorShadow.rgb,uniforms.vPrimaryColor.rgb,colorBase);\n#else\nvar mainColor: vec3f=uniforms.vPrimaryColor.rgb;\n#endif\nvar finalColor: vec3f=colorBase*mainColor;\n#endif\n#ifdef REFLECTIONFRESNEL\nvar reflectionAmount: vec3f=uniforms.vReflectionControl.xxx;var reflectionReflectance0: vec3f=uniforms.vReflectionControl.yyy;var reflectionReflectance90: vec3f=uniforms.vReflectionControl.zzz;var VdotN: f32=dot(normalize(scene.vEyePosition.xyz),normalW);var planarReflectionFresnel: vec3f=fresnelSchlickEnvironmentGGX(saturate(VdotN),reflectionReflectance0,reflectionReflectance90,1.0);reflectionAmount*=planarReflectionFresnel;\n#ifdef REFLECTIONFALLOFF\nvar reflectionDistanceFalloff: f32=1.0-saturate(length(vPositionW.xyz-uniforms.vBackgroundCenter)*uniforms.vReflectionControl.w);reflectionDistanceFalloff*=reflectionDistanceFalloff;reflectionAmount*=reflectionDistanceFalloff;\n#endif\nfinalColor=mix(finalColor,reflectionColor.rgb,saturateVec3(reflectionAmount));\n#endif\n#ifdef OPACITYFRESNEL\nvar viewAngleToFloor: f32=dot(normalW,normalize(scene.vEyePosition.xyz-uniforms.vBackgroundCenter));const startAngle: f32=0.1;var fadeFactor: f32=saturate(viewAngleToFloor/startAngle);finalAlpha*=fadeFactor*fadeFactor;\n#endif\n#ifdef SHADOWINUSE\nfinalColor=mix(finalColor*uniforms.shadowLevel,finalColor,globalShadow);\n#endif\nvar color: vec4f= vec4f(finalColor,finalAlpha);\n#else\nvar color: vec4f= vec4f(uniforms.vPrimaryColor.rgb,(1.0-clamp(globalShadow,0.,1.))*uniforms.alpha);\n#endif\n#include<logDepthFragment>\n#include<fogFragment>\n#ifdef IMAGEPROCESSINGPOSTPROCESS\n#if !defined(SKIPFINALCOLORCLAMP)\ncolor=vec4f(clamp(color.rgb,vec3f(0.),vec3f(30.0)),color.a);\n#endif\n#else\ncolor=applyImageProcessing(color);\n#endif\n#ifdef PREMULTIPLYALPHA\ncolor=vec4f(color.rgb *color.a,color.a);\n#endif\n#ifdef NOISE\ncolor=vec4f(color.rgb+dither(fragmentInputs.vPositionW.xy,0.5),color.a);color=max(color,vec4f(0.0));\n#endif\nfragmentOutputs.color=color;\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const backgroundPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,2CAA2C,CAAC;AACnD,OAAO,kCAAkC,CAAC;AAC1C,OAAO,qCAAqC,CAAC;AAC7C,OAAO,6CAA6C,CAAC;AACrD,OAAO,sCAAsC,CAAC;AAC9C,OAAO,0CAA0C,CAAC;AAClD,OAAO,2CAA2C,CAAC;AACnD,OAAO,2CAA2C,CAAC;AACnD,OAAO,sCAAsC,CAAC;AAC9C,OAAO,+CAA+C,CAAC;AACvD,OAAO,yCAAyC,CAAC;AACjD,OAAO,wCAAwC,CAAC;AAChD,OAAO,oCAAoC,CAAC;AAC5C,OAAO,gCAAgC,CAAC;AACxC,OAAO,mCAAmC,CAAC;AAC3C,OAAO,8BAA8B,CAAC;;;;;;;;;;;;;;;;;;AAEtC,MAAM,IAAI,GAAG,uBAAuB,CAAC;AACrC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsMd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,yBAAyB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 1436, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/pbr.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/pbr.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/pbrUboDeclaration\";\nimport \"./ShadersInclude/uvAttributeDeclaration\";\nimport \"./ShadersInclude/mainUVVaryingDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/pbrBRDFFunctions\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/prePassVertexDeclaration\";\nimport \"./ShadersInclude/samplerVertexDeclaration\";\nimport \"./ShadersInclude/harmonicsFunctions\";\nimport \"./ShadersInclude/bumpVertexDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/fogVertexDeclaration\";\nimport \"./ShadersInclude/lightVxUboDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal\";\nimport \"./ShadersInclude/morphTargetsVertex\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/prePassVertex\";\nimport \"./ShadersInclude/uvVariableDeclaration\";\nimport \"./ShadersInclude/samplerVertexImplementation\";\nimport \"./ShadersInclude/bumpVertex\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/fogVertex\";\nimport \"./ShadersInclude/shadowsVertex\";\nimport \"./ShadersInclude/vertexColorMixing\";\nimport \"./ShadersInclude/logDepthVertex\";\n\nconst name = \"pbrVertexShader\";\nconst shader = `#define PBR_VERTEX_SHADER\n#include<pbrUboDeclaration>\n#define CUSTOM_VERTEX_BEGIN\nattribute position: vec3f;\n#ifdef NORMAL\nattribute normal: vec3f;\n#endif\n#ifdef TANGENT\nattribute tangent: vec4f;\n#endif\n#ifdef UV1\nattribute uv: vec2f;\n#endif\n#include<uvAttributeDeclaration>[2..7]\n#include<mainUVVaryingDeclaration>[1..7]\n#ifdef VERTEXCOLOR\nattribute color: vec4f;\n#endif\n#include<helperFunctions>\n#include<pbrBRDFFunctions>\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n#include<samplerVertexDeclaration>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo)\n#include<samplerVertexDeclaration>(_DEFINENAME_,BASE_WEIGHT,_VARYINGNAME_,BaseWeight)\n#include<samplerVertexDeclaration>(_DEFINENAME_,BASE_DIFFUSE_ROUGHNESS,_VARYINGNAME_,BaseDiffuseRoughness)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)\n#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)\n#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)\n#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)\n#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler)\n#include<samplerVertexDeclaration>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance)\n#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance)\n#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal)\n#ifdef CLEARCOAT\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat)\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness)\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump)\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint)\n#endif\n#ifdef IRIDESCENCE\n#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence)\n#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness)\n#endif\n#ifdef SHEEN\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness)\n#endif\n#ifdef ANISOTROPIC\n#include<samplerVertexDeclaration>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy)\n#endif\n#ifdef SUBSURFACE\n#include<samplerVertexDeclaration>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYCOLOR_TEXTURE,_VARYINGNAME_,TranslucencyColor)\n#endif\nvarying vPositionW: vec3f;\n#if DEBUGMODE>0\nvarying vClipSpacePosition: vec4f;\n#endif\n#ifdef NORMAL\nvarying vNormalW: vec3f;\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\nvarying vEnvironmentIrradiance: vec3f;\n#include<harmonicsFunctions>\n#endif\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vColor: vec4f;\n#endif\n#include<bumpVertexDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<lightVxUboDeclaration>[0..maxSimultaneousLights]\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vPositionUVW: vec3f;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vDirectionW: vec3f;\n#endif\n#if defined(CLUSTLIGHT_BATCH) && CLUSTLIGHT_BATCH>0\nvarying vViewDepth: f32;\n#endif\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvar positionUpdated: vec3f=vertexInputs.position;\n#ifdef NORMAL\nvar normalUpdated: vec3f=vertexInputs.normal;\n#endif\n#ifdef TANGENT\nvar tangentUpdated: vec4f=vertexInputs.tangent;\n#endif\n#ifdef UV1\nvar uvUpdated: vec2f=vertexInputs.uv;\n#endif\n#ifdef UV2\nvar uv2Updated: vec2f=vertexInputs.uv2;\n#endif\n#ifdef VERTEXCOLOR\nvar colorUpdated: vec4f=vertexInputs.color;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvertexOutputs.vPositionUVW=positionUpdated;\n#endif\n#define CUSTOM_VERTEX_UPDATE_POSITION\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n#include<instancesVertex>\n#if defined(PREPASS) && ((defined(PREPASS_VELOCITY) || defined(PREPASS_VELOCITY_LINEAR)) && !defined(BONES_VELOCITY_ENABLED)\nvertexOutputs.vCurrentPosition=scene.viewProjection*finalWorld*vec4f(positionUpdated,1.0);vertexOutputs.vPreviousPosition=uniforms.previousViewProjection*finalPreviousWorld*vec4f(positionUpdated,1.0);\n#endif\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvar worldPos: vec4f=finalWorld* vec4f(positionUpdated,1.0);vertexOutputs.vPositionW= worldPos.xyz;\n#ifdef PREPASS\n#include<prePassVertex>\n#endif\n#ifdef NORMAL\nvar normalWorld: mat3x3f= mat3x3f(finalWorld[0].xyz,finalWorld[1].xyz,finalWorld[2].xyz);\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvertexOutputs.vNormalW=normalUpdated/ vec3f(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));vertexOutputs.vNormalW=normalize(normalWorld*vertexOutputs.vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\n#endif\nvertexOutputs.vNormalW=normalize(normalWorld*normalUpdated);\n#endif\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\n#if BASE_DIFFUSE_MODEL != BRDF_DIFFUSE_MODEL_LAMBERT && BASE_DIFFUSE_MODEL != BRDF_DIFFUSE_MODEL_LEGACY\nvar viewDirectionW: vec3f=normalize(scene.vEyePosition.xyz-vertexOutputs.vPositionW);var NdotV: f32=max(dot(vertexOutputs.vNormalW,viewDirectionW),0.0);var roughNormal: vec3f=mix(vertexOutputs.vNormalW,viewDirectionW,(0.5*(1.0-NdotV))*uniforms.baseDiffuseRoughness);var reflectionVector: vec3f= (uniforms.reflectionMatrix* vec4f(roughNormal,0)).xyz;\n#else\nvar reflectionVector: vec3f= (uniforms.reflectionMatrix* vec4f(vertexOutputs.vNormalW,0)).xyz;\n#endif\n#ifdef REFLECTIONMAP_OPPOSITEZ\nreflectionVector.z*=-1.0;\n#endif\nvertexOutputs.vEnvironmentIrradiance=computeEnvironmentIrradiance(reflectionVector);\n#endif\n#endif\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {vertexOutputs.position=scene.viewProjection*worldPos;} else {vertexOutputs.position=scene.viewProjectionR*worldPos;}\n#else\nvertexOutputs.position=scene.viewProjection*worldPos;\n#endif\n#if DEBUGMODE>0\nvertexOutputs.vClipSpacePosition=vertexOutputs.position;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvertexOutputs.vDirectionW=normalize((finalWorld*vec4f(positionUpdated,0.0)).xyz);\n#endif\n#if defined(CLUSTLIGHT_BATCH) && CLUSTLIGHT_BATCH>0\nvertexOutputs.vViewDepth=(scene.view*worldPos).z;\n#endif\n#ifndef UV1\nvar uvUpdated: vec2f= vec2f(0.,0.);\n#endif\n#ifdef MAINUV1\nvertexOutputs.vMainUV1=uvUpdated;\n#endif\n#ifndef UV2\nvar uv2Updated: vec2f= vec2f(0.,0.);\n#endif\n#ifdef MAINUV2\nvertexOutputs.vMainUV2=uv2Updated;\n#endif\n#include<uvVariableDeclaration>[3..7]\n#include<samplerVertexImplementation>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo,_MATRIXNAME_,albedo,_INFONAME_,AlbedoInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,BASE_WEIGHT,_VARYINGNAME_,BaseWeight,_MATRIXNAME_,baseWeight,_INFONAME_,BaseWeightInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,BASE_DIFFUSE_ROUGHNESS,_VARYINGNAME_,BaseDiffuseRoughness,_MATRIXNAME_,baseDiffuseRoughness,_INFONAME_,BaseDiffuseRoughnessInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity,_MATRIXNAME_,reflectivity,_INFONAME_,ReflectivityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler,_MATRIXNAME_,microSurfaceSampler,_INFONAME_,MicroSurfaceSamplerInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance,_MATRIXNAME_,metallicReflectance,_INFONAME_,MetallicReflectanceInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance,_MATRIXNAME_,reflectance,_INFONAME_,ReflectanceInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_MATRIXNAME_,decal,_INFONAME_,DecalInfos.x)\n#ifdef CLEARCOAT\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat,_MATRIXNAME_,clearCoat,_INFONAME_,ClearCoatInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness,_MATRIXNAME_,clearCoatRoughness,_INFONAME_,ClearCoatInfos.z)\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump,_MATRIXNAME_,clearCoatBump,_INFONAME_,ClearCoatBumpInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint,_MATRIXNAME_,clearCoatTint,_INFONAME_,ClearCoatTintInfos.x)\n#endif\n#ifdef IRIDESCENCE\n#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence,_MATRIXNAME_,iridescence,_INFONAME_,IridescenceInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness,_MATRIXNAME_,iridescenceThickness,_INFONAME_,IridescenceInfos.z)\n#endif\n#ifdef SHEEN\n#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen,_MATRIXNAME_,sheen,_INFONAME_,SheenInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness,_MATRIXNAME_,sheenRoughness,_INFONAME_,SheenInfos.z)\n#endif\n#ifdef ANISOTROPIC\n#include<samplerVertexImplementation>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy,_MATRIXNAME_,anisotropy,_INFONAME_,AnisotropyInfos.x)\n#endif\n#ifdef SUBSURFACE\n#include<samplerVertexImplementation>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness,_MATRIXNAME_,thickness,_INFONAME_,ThicknessInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity,_MATRIXNAME_,refractionIntensity,_INFONAME_,RefractionIntensityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity,_MATRIXNAME_,translucencyIntensity,_INFONAME_,TranslucencyIntensityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SS_TRANSLUCENCYCOLOR_TEXTURE,_VARYINGNAME_,TranslucencyColor,_MATRIXNAME_,translucencyColor,_INFONAME_,TranslucencyColorInfos.x)\n#endif\n#include<bumpVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const pbrVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,oCAAoC,CAAC;AAC5C,OAAO,yCAAyC,CAAC;AACjD,OAAO,2CAA2C,CAAC;AACnD,OAAO,kCAAkC,CAAC;AAC1C,OAAO,mCAAmC,CAAC;AAC3C,OAAO,mCAAmC,CAAC;AAC3C,OAAO,kDAAkD,CAAC;AAC1D,OAAO,uCAAuC,CAAC;AAC/C,OAAO,2CAA2C,CAAC;AACnD,OAAO,2CAA2C,CAAC;AACnD,OAAO,qCAAqC,CAAC;AAC7C,OAAO,wCAAwC,CAAC;AAChD,OAAO,6CAA6C,CAAC;AACrD,OAAO,uCAAuC,CAAC;AAC/C,OAAO,wCAAwC,CAAC;AAChD,OAAO,sDAAsD,CAAC;AAC9D,OAAO,gDAAgD,CAAC;AACxD,OAAO,sCAAsC,CAAC;AAC9C,OAAO,2CAA2C,CAAC;AACnD,OAAO,qCAAqC,CAAC;AAC7C,OAAO,kCAAkC,CAAC;AAC1C,OAAO,8BAA8B,CAAC;AACtC,OAAO,uCAAuC,CAAC;AAC/C,OAAO,gCAAgC,CAAC;AACxC,OAAO,wCAAwC,CAAC;AAChD,OAAO,8CAA8C,CAAC;AACtD,OAAO,6BAA6B,CAAC;AACrC,OAAO,kCAAkC,CAAC;AAC1C,OAAO,4BAA4B,CAAC;AACpC,OAAO,gCAAgC,CAAC;AACxC,OAAO,oCAAoC,CAAC;AAC5C,OAAO,iCAAiC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEzC,MAAM,IAAI,GAAG,iBAAiB,CAAC;AAC/B,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA8Nb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,mBAAmB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 1743, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/pbr.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/pbr.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/prePassDeclaration\";\nimport \"./ShadersInclude/oitDeclaration\";\nimport \"./ShadersInclude/pbrUboDeclaration\";\nimport \"./ShadersInclude/pbrFragmentExtraDeclaration\";\nimport \"./ShadersInclude/lightUboDeclaration\";\nimport \"./ShadersInclude/pbrFragmentSamplersDeclaration\";\nimport \"./ShadersInclude/imageProcessingDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/subSurfaceScatteringFunctions\";\nimport \"./ShadersInclude/importanceSampling\";\nimport \"./ShadersInclude/pbrHelperFunctions\";\nimport \"./ShadersInclude/imageProcessingFunctions\";\nimport \"./ShadersInclude/shadowsFragmentFunctions\";\nimport \"./ShadersInclude/harmonicsFunctions\";\nimport \"./ShadersInclude/pbrDirectLightingSetupFunctions\";\nimport \"./ShadersInclude/pbrDirectLightingFalloffFunctions\";\nimport \"./ShadersInclude/pbrBRDFFunctions\";\nimport \"./ShadersInclude/hdrFilteringFunctions\";\nimport \"./ShadersInclude/pbrDirectLightingFunctions\";\nimport \"./ShadersInclude/pbrIBLFunctions\";\nimport \"./ShadersInclude/bumpFragmentMainFunctions\";\nimport \"./ShadersInclude/bumpFragmentFunctions\";\nimport \"./ShadersInclude/reflectionFunction\";\nimport \"./ShadersInclude/pbrBlockAlbedoOpacity\";\nimport \"./ShadersInclude/pbrBlockReflectivity\";\nimport \"./ShadersInclude/pbrBlockAmbientOcclusion\";\nimport \"./ShadersInclude/pbrBlockAlphaFresnel\";\nimport \"./ShadersInclude/pbrBlockAnisotropic\";\nimport \"./ShadersInclude/pbrBlockReflection\";\nimport \"./ShadersInclude/pbrBlockSheen\";\nimport \"./ShadersInclude/pbrBlockClearcoat\";\nimport \"./ShadersInclude/pbrBlockIridescence\";\nimport \"./ShadersInclude/pbrBlockSubSurface\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nimport \"./ShadersInclude/pbrBlockNormalGeometric\";\nimport \"./ShadersInclude/bumpFragment\";\nimport \"./ShadersInclude/pbrBlockNormalFinal\";\nimport \"./ShadersInclude/depthPrePass\";\nimport \"./ShadersInclude/pbrBlockLightmapInit\";\nimport \"./ShadersInclude/pbrBlockGeometryInfo\";\nimport \"./ShadersInclude/pbrBlockReflectance0\";\nimport \"./ShadersInclude/pbrBlockReflectance\";\nimport \"./ShadersInclude/pbrBlockDirectLighting\";\nimport \"./ShadersInclude/lightFragment\";\nimport \"./ShadersInclude/pbrBlockFinalLitComponents\";\nimport \"./ShadersInclude/pbrBlockFinalUnlitComponents\";\nimport \"./ShadersInclude/pbrBlockFinalColorComposition\";\nimport \"./ShadersInclude/logDepthFragment\";\nimport \"./ShadersInclude/fogFragment\";\nimport \"./ShadersInclude/pbrBlockImageProcessing\";\nimport \"./ShadersInclude/pbrBlockPrePass\";\nimport \"./ShadersInclude/oitFragment\";\nimport \"./ShadersInclude/pbrDebug\";\n\nconst name = \"pbrPixelShader\";\nconst shader = `#define PBR_FRAGMENT_SHADER\n#define CUSTOM_FRAGMENT_BEGIN\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\n#include<oitDeclaration>\n#ifndef FROMLINEARSPACE\n#define FROMLINEARSPACE\n#endif\n#include<pbrUboDeclaration>\n#include<pbrFragmentExtraDeclaration>\n#include<lightUboDeclaration>[0..maxSimultaneousLights]\n#include<pbrFragmentSamplersDeclaration>\n#include<imageProcessingDeclaration>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#include<helperFunctions>\n#include<subSurfaceScatteringFunctions>\n#include<importanceSampling>\n#include<pbrHelperFunctions>\n#include<imageProcessingFunctions>\n#include<shadowsFragmentFunctions>\n#include<harmonicsFunctions>\n#include<pbrDirectLightingSetupFunctions>\n#include<pbrDirectLightingFalloffFunctions>\n#include<pbrBRDFFunctions>\n#include<hdrFilteringFunctions>\n#include<pbrDirectLightingFunctions>\n#include<pbrIBLFunctions>\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#ifdef REFLECTION\n#include<reflectionFunction>\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\n#include<pbrBlockAlbedoOpacity>\n#include<pbrBlockReflectivity>\n#include<pbrBlockAmbientOcclusion>\n#include<pbrBlockAlphaFresnel>\n#include<pbrBlockAnisotropic>\n#include<pbrBlockReflection>\n#include<pbrBlockSheen>\n#include<pbrBlockClearcoat>\n#include<pbrBlockIridescence>\n#include<pbrBlockSubSurface>\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\n#include<pbrBlockNormalGeometric>\n#include<bumpFragment>\n#include<pbrBlockNormalFinal>\nvar albedoOpacityOut: albedoOpacityOutParams;\n#ifdef ALBEDO\nvar albedoTexture: vec4f=textureSample(albedoSampler,albedoSamplerSampler,fragmentInputs.vAlbedoUV+uvOffset);\n#endif\n#ifdef BASE_WEIGHT\nvar baseWeightTexture: vec4f=textureSample(baseWeightSampler,baseWeightSamplerSampler,fragmentInputs.vBaseWeightUV+uvOffset);\n#endif\n#ifdef OPACITY\nvar opacityMap: vec4f=textureSample(opacitySampler,opacitySamplerSampler,fragmentInputs.vOpacityUV+uvOffset);\n#endif\n#ifdef DECAL\nvar decalColor: vec4f=textureSample(decalSampler,decalSamplerSampler,fragmentInputs.vDecalUV+uvOffset);\n#endif\nalbedoOpacityOut=albedoOpacityBlock(\nuniforms.vAlbedoColor\n#ifdef ALBEDO\n,albedoTexture\n,uniforms.vAlbedoInfos\n#endif\n,uniforms.baseWeight\n#ifdef BASE_WEIGHT\n,baseWeightTexture\n,uniforms.vBaseWeightInfos\n#endif\n#ifdef OPACITY\n,opacityMap\n,uniforms.vOpacityInfos\n#endif\n#ifdef DETAIL\n,detailColor\n,uniforms.vDetailInfos\n#endif\n#ifdef DECAL\n,decalColor\n,uniforms.vDecalInfos\n#endif\n);var surfaceAlbedo: vec3f=albedoOpacityOut.surfaceAlbedo;var alpha: f32=albedoOpacityOut.alpha;\n#define CUSTOM_FRAGMENT_UPDATE_ALPHA\n#include<depthPrePass>\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\nvar aoOut: ambientOcclusionOutParams;\n#ifdef AMBIENT\nvar ambientOcclusionColorMap: vec3f=textureSample(ambientSampler,ambientSamplerSampler,fragmentInputs.vAmbientUV+uvOffset).rgb;\n#endif\naoOut=ambientOcclusionBlock(\n#ifdef AMBIENT\nambientOcclusionColorMap,\nuniforms.vAmbientInfos\n#endif\n);\n#include<pbrBlockLightmapInit>\n#ifdef UNLIT\nvar diffuseBase: vec3f= vec3f(1.,1.,1.);\n#else\nvar baseColor: vec3f=surfaceAlbedo;var reflectivityOut: reflectivityOutParams;\n#if defined(REFLECTIVITY)\nvar surfaceMetallicOrReflectivityColorMap: vec4f=textureSample(reflectivitySampler,reflectivitySamplerSampler,fragmentInputs.vReflectivityUV+uvOffset);var baseReflectivity: vec4f=surfaceMetallicOrReflectivityColorMap;\n#ifndef METALLICWORKFLOW\n#ifdef REFLECTIVITY_GAMMA\nsurfaceMetallicOrReflectivityColorMap=toLinearSpaceVec4(surfaceMetallicOrReflectivityColorMap);\n#endif\nsurfaceMetallicOrReflectivityColorMap=vec4f(surfaceMetallicOrReflectivityColorMap.rgb*uniforms.vReflectivityInfos.y,surfaceMetallicOrReflectivityColorMap.a);\n#endif\n#endif\n#if defined(MICROSURFACEMAP)\nvar microSurfaceTexel: vec4f=textureSample(microSurfaceSampler,microSurfaceSamplerSampler,fragmentInputs.vMicroSurfaceSamplerUV+uvOffset)*uniforms.vMicroSurfaceSamplerInfos.y;\n#endif\n#ifdef BASE_DIFFUSE_ROUGHNESS\nvar baseDiffuseRoughnessTexture: f32=textureSample(baseDiffuseRoughnessSampler,baseDiffuseRoughnessSamplerSampler,fragmentInputs.vBaseDiffuseRoughnessUV+uvOffset).x;\n#endif\n#ifdef METALLICWORKFLOW\nvar metallicReflectanceFactors: vec4f=uniforms.vMetallicReflectanceFactors;\n#ifdef REFLECTANCE\nvar reflectanceFactorsMap: vec4f=textureSample(reflectanceSampler,reflectanceSamplerSampler,fragmentInputs.vReflectanceUV+uvOffset);\n#ifdef REFLECTANCE_GAMMA\nreflectanceFactorsMap=toLinearSpaceVec4(reflectanceFactorsMap);\n#endif\nmetallicReflectanceFactors=vec4f(metallicReflectanceFactors.rgb*reflectanceFactorsMap.rgb,metallicReflectanceFactors.a);\n#endif\n#ifdef METALLIC_REFLECTANCE\nvar metallicReflectanceFactorsMap: vec4f=textureSample(metallicReflectanceSampler,metallicReflectanceSamplerSampler,fragmentInputs.vMetallicReflectanceUV+uvOffset);\n#ifdef METALLIC_REFLECTANCE_GAMMA\nmetallicReflectanceFactorsMap=toLinearSpaceVec4(metallicReflectanceFactorsMap);\n#endif\n#ifndef METALLIC_REFLECTANCE_USE_ALPHA_ONLY\nmetallicReflectanceFactors=vec4f(metallicReflectanceFactors.rgb*metallicReflectanceFactorsMap.rgb,metallicReflectanceFactors.a);\n#endif\nmetallicReflectanceFactors.a*=metallicReflectanceFactorsMap.a;\n#endif\n#endif\nreflectivityOut=reflectivityBlock(\nuniforms.vReflectivityColor\n#ifdef METALLICWORKFLOW\n,surfaceAlbedo\n,metallicReflectanceFactors\n#endif\n,uniforms.baseDiffuseRoughness\n#ifdef BASE_DIFFUSE_ROUGHNESS\n,baseDiffuseRoughnessTexture\n,uniforms.vBaseDiffuseRoughnessInfos\n#endif\n#ifdef REFLECTIVITY\n,uniforms.vReflectivityInfos\n,surfaceMetallicOrReflectivityColorMap\n#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\n,aoOut.ambientOcclusionColor\n#endif\n#ifdef MICROSURFACEMAP\n,microSurfaceTexel\n#endif\n#ifdef DETAIL\n,detailColor\n,uniforms.vDetailInfos\n#endif\n);var microSurface: f32=reflectivityOut.microSurface;var roughness: f32=reflectivityOut.roughness;var diffuseRoughness: f32=reflectivityOut.diffuseRoughness;\n#ifdef METALLICWORKFLOW\nsurfaceAlbedo=reflectivityOut.surfaceAlbedo;\n#endif\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\naoOut.ambientOcclusionColor=reflectivityOut.ambientOcclusionColor;\n#endif\n#ifdef ALPHAFRESNEL\n#if defined(ALPHATEST) || defined(ALPHABLEND)\nvar alphaFresnelOut: alphaFresnelOutParams;alphaFresnelOut=alphaFresnelBlock(\nnormalW,\nviewDirectionW,\nalpha,\nmicroSurface\n);alpha=alphaFresnelOut.alpha;\n#endif\n#endif\n#include<pbrBlockGeometryInfo>\n#ifdef ANISOTROPIC\nvar anisotropicOut: anisotropicOutParams;\n#ifdef ANISOTROPIC_TEXTURE\nvar anisotropyMapData: vec3f=textureSample(anisotropySampler,anisotropySamplerSampler,fragmentInputs.vAnisotropyUV+uvOffset).rgb*uniforms.vAnisotropyInfos.y;\n#endif\nanisotropicOut=anisotropicBlock(\nuniforms.vAnisotropy,\nroughness,\n#ifdef ANISOTROPIC_TEXTURE\nanisotropyMapData,\n#endif\nTBN,\nnormalW,\nviewDirectionW\n);\n#endif\n#ifdef REFLECTION\nvar reflectionOut: reflectionOutParams;\n#ifndef USE_CUSTOM_REFLECTION\nreflectionOut=reflectionBlock(\nfragmentInputs.vPositionW\n,normalW\n,alphaG\n,uniforms.vReflectionMicrosurfaceInfos\n,uniforms.vReflectionInfos\n,uniforms.vReflectionColor\n#ifdef ANISOTROPIC\n,anisotropicOut\n#endif\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\n,NdotVUnclamped\n#endif\n#ifdef LINEARSPECULARREFLECTION\n,roughness\n#endif\n,reflectionSampler\n,reflectionSamplerSampler\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX)\n,fragmentInputs.vEnvironmentIrradiance\n#endif\n#if (defined(USESPHERICALFROMREFLECTIONMAP) && (!defined(NORMAL) || !defined(USESPHERICALINVERTEX))) || (defined(USEIRRADIANCEMAP) && defined(REFLECTIONMAP_3D))\n,uniforms.reflectionMatrix\n#endif\n#ifdef USEIRRADIANCEMAP\n,irradianceSampler\n,irradianceSamplerSampler\n#ifdef USE_IRRADIANCE_DOMINANT_DIRECTION\n,uniforms.vReflectionDominantDirection\n#endif\n#endif\n#ifndef LODBASEDMICROSFURACE\n,reflectionLowSampler\n,reflectionLowSamplerSampler\n,reflectionHighSampler\n,reflectionHighSamplerSampler\n#endif\n#ifdef REALTIME_FILTERING\n,uniforms.vReflectionFilteringInfo\n#ifdef IBL_CDF_FILTERING\n,icdfSampler\n,icdfSamplerSampler\n#endif\n#endif\n,viewDirectionW\n,diffuseRoughness\n,surfaceAlbedo\n);\n#else\n#define CUSTOM_REFLECTION\n#endif\n#endif\n#include<pbrBlockReflectance0>\n#ifdef SHEEN\nvar sheenOut: sheenOutParams;\n#ifdef SHEEN_TEXTURE\nvar sheenMapData: vec4f=textureSample(sheenSampler,sheenSamplerSampler,fragmentInputs.vSheenUV+uvOffset);\n#endif\n#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)\nvar sheenMapRoughnessData: vec4f=textureSample(sheenRoughnessSampler,sheenRoughnessSamplerSampler,fragmentInputs.vSheenRoughnessUV+uvOffset)*uniforms.vSheenInfos.w;\n#endif\nsheenOut=sheenBlock(\nuniforms.vSheenColor\n#ifdef SHEEN_ROUGHNESS\n,uniforms.vSheenRoughness\n#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)\n,sheenMapRoughnessData\n#endif\n#endif\n,roughness\n#ifdef SHEEN_TEXTURE\n,sheenMapData\n,uniforms.vSheenInfos.y\n#endif\n,reflectanceF0\n#ifdef SHEEN_LINKWITHALBEDO\n,baseColor\n,surfaceAlbedo\n#endif\n#ifdef ENVIRONMENTBRDF\n,NdotV\n,environmentBrdf\n#endif\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\n,AARoughnessFactors\n,uniforms.vReflectionMicrosurfaceInfos\n,uniforms.vReflectionInfos\n,uniforms.vReflectionColor\n,uniforms.vLightingIntensity\n,reflectionSampler\n,reflectionSamplerSampler\n,reflectionOut.reflectionCoords\n,NdotVUnclamped\n#ifndef LODBASEDMICROSFURACE\n,reflectionLowSampler\n,reflectionLowSamplerSampler\n,reflectionHighSampler\n,reflectionHighSamplerSampler\n#endif\n#ifdef REALTIME_FILTERING\n,uniforms.vReflectionFilteringInfo\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)\n,seo\n#endif\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)\n,eho\n#endif\n#endif\n);\n#ifdef SHEEN_LINKWITHALBEDO\nsurfaceAlbedo=sheenOut.surfaceAlbedo;\n#endif\n#endif\n#ifdef CLEARCOAT\n#ifdef CLEARCOAT_TEXTURE\nvar clearCoatMapData: vec2f=textureSample(clearCoatSampler,clearCoatSamplerSampler,fragmentInputs.vClearCoatUV+uvOffset).rg*uniforms.vClearCoatInfos.y;\n#endif\n#endif\n#ifdef IRIDESCENCE\nvar iridescenceOut: iridescenceOutParams;\n#ifdef IRIDESCENCE_TEXTURE\nvar iridescenceMapData: vec2f=textureSample(iridescenceSampler,iridescenceSamplerSampler,fragmentInputs.vIridescenceUV+uvOffset).rg*uniforms.vIridescenceInfos.y;\n#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\nvar iridescenceThicknessMapData: vec2f=textureSample(iridescenceThicknessSampler,iridescenceThicknessSamplerSampler,fragmentInputs.vIridescenceThicknessUV+uvOffset).rg*uniforms.vIridescenceInfos.w;\n#endif\niridescenceOut=iridescenceBlock(\nuniforms.vIridescenceParams\n,NdotV\n,specularEnvironmentR0\n#ifdef IRIDESCENCE_TEXTURE\n,iridescenceMapData\n#endif\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\n,iridescenceThicknessMapData\n#endif\n#ifdef CLEARCOAT\n,NdotVUnclamped\n,uniforms.vClearCoatParams\n#ifdef CLEARCOAT_TEXTURE\n,clearCoatMapData\n#endif\n#endif\n);var iridescenceIntensity: f32=iridescenceOut.iridescenceIntensity;specularEnvironmentR0=iridescenceOut.specularEnvironmentR0;\n#endif\nvar clearcoatOut: clearcoatOutParams;\n#ifdef CLEARCOAT\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\nvar clearCoatMapRoughnessData: vec4f=textureSample(clearCoatRoughnessSampler,clearCoatRoughnessSamplerSampler,fragmentInputs.vClearCoatRoughnessUV+uvOffset)*uniforms.vClearCoatInfos.w;\n#endif\n#if defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)\nvar clearCoatTintMapData: vec4f=textureSample(clearCoatTintSampler,clearCoatTintSamplerSampler,fragmentInputs.vClearCoatTintUV+uvOffset);\n#endif\n#ifdef CLEARCOAT_BUMP\nvar clearCoatBumpMapData: vec4f=textureSample(clearCoatBumpSampler,clearCoatBumpSamplerSampler,fragmentInputs.vClearCoatBumpUV+uvOffset);\n#endif\nclearcoatOut=clearcoatBlock(\nfragmentInputs.vPositionW\n,geometricNormalW\n,viewDirectionW\n,uniforms.vClearCoatParams\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\n,clearCoatMapRoughnessData\n#endif\n,specularEnvironmentR0\n#ifdef CLEARCOAT_TEXTURE\n,clearCoatMapData\n#endif\n#ifdef CLEARCOAT_TINT\n,uniforms.vClearCoatTintParams\n,uniforms.clearCoatColorAtDistance\n,uniforms.vClearCoatRefractionParams\n#ifdef CLEARCOAT_TINT_TEXTURE\n,clearCoatTintMapData\n#endif\n#endif\n#ifdef CLEARCOAT_BUMP\n,uniforms.vClearCoatBumpInfos\n,clearCoatBumpMapData\n,fragmentInputs.vClearCoatBumpUV\n#if defined(TANGENT) && defined(NORMAL)\n,mat3x3<f32>(input.vTBN0,input.vTBN1,input.vTBN2)\n#else\n,uniforms.vClearCoatTangentSpaceParams\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n,uniforms.normalMatrix\n#endif\n#endif\n#if defined(FORCENORMALFORWARD) && defined(NORMAL)\n,faceNormal\n#endif\n#ifdef REFLECTION\n,uniforms.vReflectionMicrosurfaceInfos\n,uniforms.vReflectionInfos\n,uniforms.vReflectionColor\n,uniforms.vLightingIntensity\n,reflectionSampler\n,reflectionSamplerSampler\n#ifndef LODBASEDMICROSFURACE\n,reflectionLowSampler\n,reflectionLowSamplerSampler\n,reflectionHighSampler\n,reflectionHighSamplerSampler\n#endif\n#ifdef REALTIME_FILTERING\n,uniforms.vReflectionFilteringInfo\n#endif\n#endif\n#if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)\n,select(-1.,1.,fragmentInputs.frontFacing)\n#endif\n);\n#else\nclearcoatOut.specularEnvironmentR0=specularEnvironmentR0;\n#endif\n#include<pbrBlockReflectance>\nvar subSurfaceOut: subSurfaceOutParams;\n#ifdef SUBSURFACE\n#ifdef SS_THICKNESSANDMASK_TEXTURE\nvar thicknessMap: vec4f=textureSample(thicknessSampler,thicknessSamplerSampler,fragmentInputs.vThicknessUV+uvOffset);\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\nvar refractionIntensityMap: vec4f=textureSample(refractionIntensitySampler,refractionIntensitySamplerSampler,fragmentInputs.vRefractionIntensityUV+uvOffset);\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\nvar translucencyIntensityMap: vec4f=textureSample(translucencyIntensitySampler,translucencyIntensitySamplerSampler,fragmentInputs.vTranslucencyIntensityUV+uvOffset);\n#endif\n#ifdef SS_TRANSLUCENCYCOLOR_TEXTURE\nvar translucencyColorMap: vec4f=textureSample(translucencyColorSampler,translucencyColorSamplerSampler,fragmentInputs.vTranslucencyColorUV+uvOffset);\n#ifdef SS_TRANSLUCENCYCOLOR_TEXTURE_GAMMA\ntranslucencyColorMap=toLinearSpaceVec4(translucencyColorMap);\n#endif\n#endif\nsubSurfaceOut=subSurfaceBlock(\nuniforms.vSubSurfaceIntensity\n,uniforms.vThicknessParam\n,uniforms.vTintColor\n,normalW\n#ifdef LEGACY_SPECULAR_ENERGY_CONSERVATION\n,vec3f(max(colorSpecularEnvironmentReflectance.r,max(colorSpecularEnvironmentReflectance.g,colorSpecularEnvironmentReflectance.b)))\n#else\n,baseSpecularEnvironmentReflectance\n#endif\n#ifdef SS_THICKNESSANDMASK_TEXTURE\n,thicknessMap\n#endif\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\n,refractionIntensityMap\n#endif\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\n,translucencyIntensityMap\n#endif\n#ifdef REFLECTION\n#ifdef SS_TRANSLUCENCY\n,uniforms.reflectionMatrix\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\n,reflectionOut.irradianceVector\n#endif\n#if defined(REALTIME_FILTERING)\n,reflectionSampler\n,reflectionSamplerSampler\n,uniforms.vReflectionFilteringInfo\n#ifdef IBL_CDF_FILTERING\n,icdfSampler\n,icdfSamplerSampler\n#endif\n#endif\n#endif\n#ifdef USEIRRADIANCEMAP\n,irradianceSampler\n,irradianceSamplerSampler\n#endif\n#endif\n#endif\n#if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)\n,surfaceAlbedo\n#endif\n#ifdef SS_REFRACTION\n,fragmentInputs.vPositionW\n,viewDirectionW\n,scene.view\n,uniforms.vRefractionInfos\n,uniforms.refractionMatrix\n,uniforms.vRefractionMicrosurfaceInfos\n,uniforms.vLightingIntensity\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\n,alpha\n#endif\n#ifdef SS_LODINREFRACTIONALPHA\n,NdotVUnclamped\n#endif\n#ifdef SS_LINEARSPECULARREFRACTION\n,roughness\n#endif\n,alphaG\n,refractionSampler\n,refractionSamplerSampler\n#ifndef LODBASEDMICROSFURACE\n,refractionLowSampler\n,refractionLowSamplerSampler\n,refractionHighSampler\n,refractionHighSamplerSampler\n#endif\n#ifdef ANISOTROPIC\n,anisotropicOut\n#endif\n#ifdef REALTIME_FILTERING\n,uniforms.vRefractionFilteringInfo\n#endif\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\n,uniforms.vRefractionPosition\n,uniforms.vRefractionSize\n#endif\n#ifdef SS_DISPERSION\n,uniforms.dispersion\n#endif\n#endif\n#ifdef SS_TRANSLUCENCY\n,uniforms.vDiffusionDistance\n,uniforms.vTranslucencyColor\n#ifdef SS_TRANSLUCENCYCOLOR_TEXTURE\n,translucencyColorMap\n#endif\n#endif\n);\n#ifdef SS_REFRACTION\nsurfaceAlbedo=subSurfaceOut.surfaceAlbedo;\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\nalpha=subSurfaceOut.alpha;\n#endif\n#endif\n#else\nsubSurfaceOut.specularEnvironmentReflectance=colorSpecularEnvironmentReflectance;\n#endif\n#include<pbrBlockDirectLighting>\n#include<lightFragment>[0..maxSimultaneousLights]\n#include<pbrBlockFinalLitComponents>\n#endif \n#include<pbrBlockFinalUnlitComponents>\n#define CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION\n#include<pbrBlockFinalColorComposition>\n#include<logDepthFragment>\n#include<fogFragment>(color,finalColor)\n#include<pbrBlockImageProcessing>\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\n#ifdef PREPASS\n#include<pbrBlockPrePass>\n#endif\n#if !defined(PREPASS) && !defined(ORDER_INDEPENDENT_TRANSPARENCY)\nfragmentOutputs.color=finalColor;\n#endif\n#include<oitFragment>\n#if ORDER_INDEPENDENT_TRANSPARENCY\nif (fragDepth==nearestDepth) {fragmentOutputs.frontColor=vec4f(fragmentOutputs.frontColor.rgb+finalColor.rgb*finalColor.a*alphaMultiplier,1.0-alphaMultiplier*(1.0-finalColor.a));} else {fragmentOutputs.backColor+=finalColor;}\n#endif\n#include<pbrDebug>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const pbrPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,qCAAqC,CAAC;AAC7C,OAAO,iCAAiC,CAAC;AACzC,OAAO,oCAAoC,CAAC;AAC5C,OAAO,8CAA8C,CAAC;AACtD,OAAO,sCAAsC,CAAC;AAC9C,OAAO,iDAAiD,CAAC;AACzD,OAAO,6CAA6C,CAAC;AACrD,OAAO,+CAA+C,CAAC;AACvD,OAAO,sCAAsC,CAAC;AAC9C,OAAO,yCAAyC,CAAC;AACjD,OAAO,kCAAkC,CAAC;AAC1C,OAAO,gDAAgD,CAAC;AACxD,OAAO,qCAAqC,CAAC;AAC7C,OAAO,qCAAqC,CAAC;AAC7C,OAAO,2CAA2C,CAAC;AACnD,OAAO,2CAA2C,CAAC;AACnD,OAAO,qCAAqC,CAAC;AAC7C,OAAO,kDAAkD,CAAC;AAC1D,OAAO,oDAAoD,CAAC;AAC5D,OAAO,mCAAmC,CAAC;AAC3C,OAAO,wCAAwC,CAAC;AAChD,OAAO,6CAA6C,CAAC;AACrD,OAAO,kCAAkC,CAAC;AAC1C,OAAO,4CAA4C,CAAC;AACpD,OAAO,wCAAwC,CAAC;AAChD,OAAO,qCAAqC,CAAC;AAC7C,OAAO,wCAAwC,CAAC;AAChD,OAAO,uCAAuC,CAAC;AAC/C,OAAO,2CAA2C,CAAC;AACnD,OAAO,uCAAuC,CAAC;AAC/C,OAAO,sCAAsC,CAAC;AAC9C,OAAO,qCAAqC,CAAC;AAC7C,OAAO,gCAAgC,CAAC;AACxC,OAAO,oCAAoC,CAAC;AAC5C,OAAO,sCAAsC,CAAC;AAC9C,OAAO,qCAAqC,CAAC;AAC7C,OAAO,oCAAoC,CAAC;AAC5C,OAAO,0CAA0C,CAAC;AAClD,OAAO,+BAA+B,CAAC;AACvC,OAAO,sCAAsC,CAAC;AAC9C,OAAO,+BAA+B,CAAC;AACvC,OAAO,uCAAuC,CAAC;AAC/C,OAAO,uCAAuC,CAAC;AAC/C,OAAO,uCAAuC,CAAC;AAC/C,OAAO,sCAAsC,CAAC;AAC9C,OAAO,yCAAyC,CAAC;AACjD,OAAO,gCAAgC,CAAC;AACxC,OAAO,6CAA6C,CAAC;AACrD,OAAO,+CAA+C,CAAC;AACvD,OAAO,gDAAgD,CAAC;AACxD,OAAO,mCAAmC,CAAC;AAC3C,OAAO,8BAA8B,CAAC;AACtC,OAAO,0CAA0C,CAAC;AAClD,OAAO,kCAAkC,CAAC;AAC1C,OAAO,8BAA8B,CAAC;AACtC,OAAO,2BAA2B,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEnC,MAAM,IAAI,GAAG,gBAAgB,CAAC;AAC9B,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAojBd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,kBAAkB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 2440, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/openpbr.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/openpbr.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/openpbrUboDeclaration\";\nimport \"./ShadersInclude/uvAttributeDeclaration\";\nimport \"./ShadersInclude/mainUVVaryingDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/pbrBRDFFunctions\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/prePassVertexDeclaration\";\nimport \"./ShadersInclude/samplerVertexDeclaration\";\nimport \"./ShadersInclude/harmonicsFunctions\";\nimport \"./ShadersInclude/openpbrNormalMapVertexDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/fogVertexDeclaration\";\nimport \"./ShadersInclude/lightVxUboDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal\";\nimport \"./ShadersInclude/morphTargetsVertex\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/prePassVertex\";\nimport \"./ShadersInclude/uvVariableDeclaration\";\nimport \"./ShadersInclude/samplerVertexImplementation\";\nimport \"./ShadersInclude/openpbrNormalMapVertex\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/fogVertex\";\nimport \"./ShadersInclude/shadowsVertex\";\nimport \"./ShadersInclude/vertexColorMixing\";\nimport \"./ShadersInclude/logDepthVertex\";\n\nconst name = \"openpbrVertexShader\";\nconst shader = `#define OPENPBR_VERTEX_SHADER\n#include<openpbrUboDeclaration>\n#define CUSTOM_VERTEX_BEGIN\nattribute position: vec3f;\n#ifdef NORMAL\nattribute normal: vec3f;\n#endif\n#ifdef TANGENT\nattribute tangent: vec4f;\n#endif\n#ifdef UV1\nattribute uv: vec2f;\n#endif\n#include<uvAttributeDeclaration>[2..7]\n#include<mainUVVaryingDeclaration>[1..7]\n#ifdef VERTEXCOLOR\nattribute color: vec4f;\n#endif\n#include<helperFunctions>\n#include<pbrBRDFFunctions>\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n#include<samplerVertexDeclaration>(_DEFINENAME_,BASE_COLOR,_VARYINGNAME_,BaseColor)\n#include<samplerVertexDeclaration>(_DEFINENAME_,BASE_WEIGHT,_VARYINGNAME_,BaseWeight)\n#include<samplerVertexDeclaration>(_DEFINENAME_,BASE_DIFFUSE_ROUGHNESS,_VARYINGNAME_,BaseDiffuseRoughness)\n#include<samplerVertexDeclaration>(_DEFINENAME_,BASE_METALNESS,_VARYINGNAME_,BaseMetalness)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR_WEIGHT,_VARYINGNAME_,SpecularWeight)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR_COLOR,_VARYINGNAME_,SpecularColor)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR_ROUGHNESS,_VARYINGNAME_,SpecularRoughness)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR_ROUGHNESS_ANISOTROPY,_VARYINGNAME_,SpecularRoughnessAnisotropy)\n#include<samplerVertexDeclaration>(_DEFINENAME_,COAT_WEIGHT,_VARYINGNAME_,CoatWeight)\n#include<samplerVertexDeclaration>(_DEFINENAME_,COAT_COLOR,_VARYINGNAME_,CoatColor)\n#include<samplerVertexDeclaration>(_DEFINENAME_,COAT_ROUGHNESS,_VARYINGNAME_,CoatRoughness)\n#include<samplerVertexDeclaration>(_DEFINENAME_,COAT_ROUGHNESS_ANISOTROPY,_VARYINGNAME_,CoatRoughnessAnisotropy)\n#include<samplerVertexDeclaration>(_DEFINENAME_,COAT_DARKENING,_VARYINGNAME_,CoatDarkening)\n#include<samplerVertexDeclaration>(_DEFINENAME_,FUZZ_WEIGHT,_VARYINGNAME_,FuzzWeight)\n#include<samplerVertexDeclaration>(_DEFINENAME_,FUZZ_COLOR,_VARYINGNAME_,FuzzColor)\n#include<samplerVertexDeclaration>(_DEFINENAME_,FUZZ_ROUGHNESS,_VARYINGNAME_,FuzzRoughness)\n#include<samplerVertexDeclaration>(_DEFINENAME_,GEOMETRY_NORMAL,_VARYINGNAME_,GeometryNormal)\n#include<samplerVertexDeclaration>(_DEFINENAME_,GEOMETRY_TANGENT,_VARYINGNAME_,GeometryTangent)\n#include<samplerVertexDeclaration>(_DEFINENAME_,GEOMETRY_COAT_NORMAL,_VARYINGNAME_,GeometryCoatNormal)\n#include<samplerVertexDeclaration>(_DEFINENAME_,GEOMETRY_OPACITY,_VARYINGNAME_,GeometryOpacity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSION_COLOR,_VARYINGNAME_,EmissionColor)\n#include<samplerVertexDeclaration>(_DEFINENAME_,THIN_FILM_WEIGHT,_VARYINGNAME_,ThinFilmWeight)\n#include<samplerVertexDeclaration>(_DEFINENAME_,THIN_FILM_THICKNESS,_VARYINGNAME_,ThinFilmThickness)\n#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT_OCCLUSION,_VARYINGNAME_,AmbientOcclusion)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)\nvarying vPositionW: vec3f;\n#if DEBUGMODE>0\nvarying vClipSpacePosition: vec4f;\n#endif\n#ifdef NORMAL\nvarying vNormalW: vec3f;\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\nvarying vEnvironmentIrradiance: vec3f;\n#include<harmonicsFunctions>\n#endif\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vColor: vec4f;\n#endif\n#include<openpbrNormalMapVertexDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<lightVxUboDeclaration>[0..maxSimultaneousLights]\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vPositionUVW: vec3f;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vDirectionW: vec3f;\n#endif\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvar positionUpdated: vec3f=vertexInputs.position;\n#ifdef NORMAL\nvar normalUpdated: vec3f=vertexInputs.normal;\n#endif\n#ifdef TANGENT\nvar tangentUpdated: vec4f=vertexInputs.tangent;\n#endif\n#ifdef UV1\nvar uvUpdated: vec2f=vertexInputs.uv;\n#endif\n#ifdef UV2\nvar uv2Updated: vec2f=vertexInputs.uv2;\n#endif\n#ifdef VERTEXCOLOR\nvar colorUpdated: vec4f=vertexInputs.color;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvertexOutputs.vPositionUVW=positionUpdated;\n#endif\n#define CUSTOM_VERTEX_UPDATE_POSITION\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n#include<instancesVertex>\n#if defined(PREPASS) && ((defined(PREPASS_VELOCITY) || defined(PREPASS_VELOCITY_LINEAR)) && !defined(BONES_VELOCITY_ENABLED)\nvertexOutputs.vCurrentPosition=scene.viewProjection*finalWorld*vec4f(positionUpdated,1.0);vertexOutputs.vPreviousPosition=uniforms.previousViewProjection*finalPreviousWorld*vec4f(positionUpdated,1.0);\n#endif\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvar worldPos: vec4f=finalWorld* vec4f(positionUpdated,1.0);vertexOutputs.vPositionW= worldPos.xyz;\n#ifdef PREPASS\n#include<prePassVertex>\n#endif\n#ifdef NORMAL\nvar normalWorld: mat3x3f= mat3x3f(finalWorld[0].xyz,finalWorld[1].xyz,finalWorld[2].xyz);\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvertexOutputs.vNormalW=normalUpdated/ vec3f(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));vertexOutputs.vNormalW=normalize(normalWorld*vertexOutputs.vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\n#endif\nvertexOutputs.vNormalW=normalize(normalWorld*normalUpdated);\n#endif\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\n#if BASE_DIFFUSE_MODEL != BRDF_DIFFUSE_MODEL_LAMBERT && BASE_DIFFUSE_MODEL != BRDF_DIFFUSE_MODEL_LEGACY\nvar viewDirectionW: vec3f=normalize(scene.vEyePosition.xyz-vertexOutputs.vPositionW);var NdotV: f32=max(dot(vertexOutputs.vNormalW,viewDirectionW),0.0);var roughNormal: vec3f=mix(vertexOutputs.vNormalW,viewDirectionW,(0.5*(1.0-NdotV))*uniforms.vBaseDiffuseRoughness);var reflectionVector: vec3f= (uniforms.reflectionMatrix* vec4f(roughNormal,0)).xyz;\n#else\nvar reflectionVector: vec3f= (uniforms.reflectionMatrix* vec4f(vertexOutputs.vNormalW,0)).xyz;\n#endif\n#ifdef REFLECTIONMAP_OPPOSITEZ\nreflectionVector.z*=-1.0;\n#endif\nvertexOutputs.vEnvironmentIrradiance=computeEnvironmentIrradiance(reflectionVector);\n#endif\n#endif\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {vertexOutputs.position=scene.viewProjection*worldPos;} else {vertexOutputs.position=scene.viewProjectionR*worldPos;}\n#else\nvertexOutputs.position=scene.viewProjection*worldPos;\n#endif\n#if DEBUGMODE>0\nvertexOutputs.vClipSpacePosition=vertexOutputs.position;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvertexOutputs.vDirectionW=normalize((finalWorld*vec4f(positionUpdated,0.0)).xyz);\n#endif\n#ifndef UV1\nvar uvUpdated: vec2f= vec2f(0.,0.);\n#endif\n#ifdef MAINUV1\nvertexOutputs.vMainUV1=uvUpdated;\n#endif\n#ifndef UV2\nvar uv2Updated: vec2f= vec2f(0.,0.);\n#endif\n#ifdef MAINUV2\nvertexOutputs.vMainUV2=uv2Updated;\n#endif\n#include<uvVariableDeclaration>[3..7]\n#include<samplerVertexImplementation>(_DEFINENAME_,BASE_COLOR,_VARYINGNAME_,BaseColor,_MATRIXNAME_,baseColor,_INFONAME_,BaseColorInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,BASE_WEIGHT,_VARYINGNAME_,BaseWeight,_MATRIXNAME_,baseWeight,_INFONAME_,BaseWeightInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,BASE_DIFFUSE_ROUGHNESS,_VARYINGNAME_,BaseDiffuseRoughness,_MATRIXNAME_,baseDiffuseRoughness,_INFONAME_,BaseDiffuseRoughnessInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,BASE_METALNESS,_VARYINGNAME_,BaseMetalness,_MATRIXNAME_,baseMetalness,_INFONAME_,BaseMetalnessInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR_WEIGHT,_VARYINGNAME_,SpecularWeight,_MATRIXNAME_,specularWeight,_INFONAME_,SpecularWeightInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR_COLOR,_VARYINGNAME_,SpecularColor,_MATRIXNAME_,specularColor,_INFONAME_,SpecularColorInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR_ROUGHNESS,_VARYINGNAME_,SpecularRoughness,_MATRIXNAME_,specularRoughness,_INFONAME_,SpecularRoughnessInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR_ROUGHNESS_ANISOTROPY,_VARYINGNAME_,SpecularRoughnessAnisotropy,_MATRIXNAME_,specularRoughnessAnisotropy,_INFONAME_,SpecularRoughnessAnisotropyInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,COAT_WEIGHT,_VARYINGNAME_,CoatWeight,_MATRIXNAME_,coatWeight,_INFONAME_,CoatWeightInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,COAT_COLOR,_VARYNAME_,CoatColor,_MATRIXNAME_,coatColor,_INFONAME_,CoatColorInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,COAT_ROUGHNESS,_VARYINGNAME_,CoatRoughness,_MATRIXNAME_,coatRoughness,_INFONAME_,CoatRoughnessInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,COAT_ROUGHNESS_ANISOTROPY,_VARYINGNAME_,CoatRoughnessAnisotropy,_MATRIXNAME_,coatRoughnessAnisotropy,_INFONAME_,CoatRoughnessAnisotropyInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,COAT_DARKENING,_VARYINGNAME_,CoatDarkening,_MATRIXNAME_,coatDarkening,_INFONAME_,CoatDarkeningInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,FUZZ_WEIGHT,_VARYINGNAME_,FuzzWeight,_MATRIXNAME_,fuzzWeight,_INFONAME_,FuzzWeightInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,FUZZ_COLOR,_VARYINGNAME_,FuzzColor,_MATRIXNAME_,fuzzColor,_INFONAME_,FuzzColorInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,FUZZ_ROUGHNESS,_VARYINGNAME_,FuzzRoughness,_MATRIXNAME_,fuzzRoughness,_INFONAME_,FuzzRoughnessInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,GEOMETRY_NORMAL,_VARYINGNAME_,GeometryNormal,_MATRIXNAME_,geometryNormal,_INFONAME_,GeometryNormalInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,GEOMETRY_TANGENT,_VARYINGNAME_,GeometryTangent,_MATRIXNAME_,geometryTangent,_INFONAME_,GeometryTangentInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,GEOMETRY_COAT_NORMAL,_VARYINGNAME_,GeometryCoatNormal,_MATRIXNAME_,geometryCoatNormal,_INFONAME_,GeometryCoatNormalInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,GEOMETRY_OPACITY,_VARYINGNAME_,GeometryOpacity,_MATRIXNAME_,geometryOpacity,_INFONAME_,GeometryOpacityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,EMISSION_COLOR,_VARYINGNAME_,EmissionColor,_MATRIXNAME_,emissionColor,_INFONAME_,EmissionColorInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,THIN_FILM_WEIGHT,_VARYINGNAME_,ThinFilmWeight,_MATRIXNAME_,thinFilmWeight,_INFONAME_,ThinFilmWeightInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,THIN_FILM_THICKNESS,_VARYINGNAME_,ThinFilmThickness,_MATRIXNAME_,thinFilmThickness,_INFONAME_,ThinFilmThicknessInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT_OCCLUSION,_VARYINGNAME_,AmbientOcclusion,_MATRIXNAME_,ambientOcclusion,_INFONAME_,AmbientOcclusionInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_MATRIXNAME_,decal,_INFONAME_,DecalInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)\n#include<openpbrNormalMapVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const openpbrVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,wCAAwC,CAAC;AAChD,OAAO,yCAAyC,CAAC;AACjD,OAAO,2CAA2C,CAAC;AACnD,OAAO,kCAAkC,CAAC;AAC1C,OAAO,mCAAmC,CAAC;AAC3C,OAAO,mCAAmC,CAAC;AAC3C,OAAO,kDAAkD,CAAC;AAC1D,OAAO,uCAAuC,CAAC;AAC/C,OAAO,2CAA2C,CAAC;AACnD,OAAO,2CAA2C,CAAC;AACnD,OAAO,qCAAqC,CAAC;AAC7C,OAAO,oDAAoD,CAAC;AAC5D,OAAO,6CAA6C,CAAC;AACrD,OAAO,uCAAuC,CAAC;AAC/C,OAAO,wCAAwC,CAAC;AAChD,OAAO,sDAAsD,CAAC;AAC9D,OAAO,gDAAgD,CAAC;AACxD,OAAO,sCAAsC,CAAC;AAC9C,OAAO,2CAA2C,CAAC;AACnD,OAAO,qCAAqC,CAAC;AAC7C,OAAO,kCAAkC,CAAC;AAC1C,OAAO,8BAA8B,CAAC;AACtC,OAAO,uCAAuC,CAAC;AAC/C,OAAO,gCAAgC,CAAC;AACxC,OAAO,wCAAwC,CAAC;AAChD,OAAO,8CAA8C,CAAC;AACtD,OAAO,yCAAyC,CAAC;AACjD,OAAO,kCAAkC,CAAC;AAC1C,OAAO,4BAA4B,CAAC;AACpC,OAAO,gCAAgC,CAAC;AACxC,OAAO,oCAAoC,CAAC;AAC5C,OAAO,iCAAiC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEzC,MAAM,IAAI,GAAG,qBAAqB,CAAC;AACnC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAkMb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,uBAAuB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 2719, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/openpbr.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/openpbr.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/prePassDeclaration\";\nimport \"./ShadersInclude/oitDeclaration\";\nimport \"./ShadersInclude/openpbrUboDeclaration\";\nimport \"./ShadersInclude/pbrFragmentExtraDeclaration\";\nimport \"./ShadersInclude/lightUboDeclaration\";\nimport \"./ShadersInclude/openpbrFragmentSamplersDeclaration\";\nimport \"./ShadersInclude/imageProcessingDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/subSurfaceScatteringFunctions\";\nimport \"./ShadersInclude/importanceSampling\";\nimport \"./ShadersInclude/pbrHelperFunctions\";\nimport \"./ShadersInclude/imageProcessingFunctions\";\nimport \"./ShadersInclude/shadowsFragmentFunctions\";\nimport \"./ShadersInclude/harmonicsFunctions\";\nimport \"./ShadersInclude/pbrDirectLightingSetupFunctions\";\nimport \"./ShadersInclude/pbrDirectLightingFalloffFunctions\";\nimport \"./ShadersInclude/pbrBRDFFunctions\";\nimport \"./ShadersInclude/hdrFilteringFunctions\";\nimport \"./ShadersInclude/pbrDirectLightingFunctions\";\nimport \"./ShadersInclude/pbrIBLFunctions\";\nimport \"./ShadersInclude/openpbrNormalMapFragmentMainFunctions\";\nimport \"./ShadersInclude/openpbrNormalMapFragmentFunctions\";\nimport \"./ShadersInclude/reflectionFunction\";\nimport \"./ShadersInclude/openpbrDielectricReflectance\";\nimport \"./ShadersInclude/openpbrConductorReflectance\";\nimport \"./ShadersInclude/openpbrBlockAmbientOcclusion\";\nimport \"./ShadersInclude/openpbrGeometryInfo\";\nimport \"./ShadersInclude/openpbrIblFunctions\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nimport \"./ShadersInclude/pbrBlockNormalGeometric\";\nimport \"./ShadersInclude/openpbrNormalMapFragment\";\nimport \"./ShadersInclude/openpbrBlockNormalFinal\";\nimport \"./ShadersInclude/openpbrBaseLayerData\";\nimport \"./ShadersInclude/openpbrCoatLayerData\";\nimport \"./ShadersInclude/openpbrThinFilmLayerData\";\nimport \"./ShadersInclude/openpbrFuzzLayerData\";\nimport \"./ShadersInclude/depthPrePass\";\nimport \"./ShadersInclude/openpbrEnvironmentLighting\";\nimport \"./ShadersInclude/openpbrDirectLightingInit\";\nimport \"./ShadersInclude/openpbrDirectLighting\";\nimport \"./ShadersInclude/logDepthFragment\";\nimport \"./ShadersInclude/fogFragment\";\nimport \"./ShadersInclude/pbrBlockImageProcessing\";\nimport \"./ShadersInclude/pbrBlockPrePass\";\nimport \"./ShadersInclude/oitFragment\";\nimport \"./ShadersInclude/pbrDebug\";\n\nconst name = \"openpbrPixelShader\";\nconst shader = `#define OPENPBR_FRAGMENT_SHADER\n#define CUSTOM_FRAGMENT_BEGIN\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\n#include<oitDeclaration>\n#ifndef FROMLINEARSPACE\n#define FROMLINEARSPACE\n#endif\n#include<openpbrUboDeclaration>\n#include<pbrFragmentExtraDeclaration>\n#include<lightUboDeclaration>[0..maxSimultaneousLights]\n#include<openpbrFragmentSamplersDeclaration>\n#include<imageProcessingDeclaration>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#include<helperFunctions>\n#include<subSurfaceScatteringFunctions>\n#include<importanceSampling>\n#include<pbrHelperFunctions>\n#include<imageProcessingFunctions>\n#include<shadowsFragmentFunctions>\n#include<harmonicsFunctions>\n#include<pbrDirectLightingSetupFunctions>\n#include<pbrDirectLightingFalloffFunctions>\n#include<pbrBRDFFunctions>\n#include<hdrFilteringFunctions>\n#include<pbrDirectLightingFunctions>\n#include<pbrIBLFunctions>\n#include<openpbrNormalMapFragmentMainFunctions>\n#include<openpbrNormalMapFragmentFunctions>\n#ifdef REFLECTION\n#include<reflectionFunction>\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\n#include<openpbrDielectricReflectance>\n#include<openpbrConductorReflectance>\n#include<openpbrBlockAmbientOcclusion>\n#include<openpbrGeometryInfo>\n#include<openpbrIblFunctions>\nfn layer(slab_bottom: vec3f,slab_top: vec3f,lerp_factor: f32,bottom_multiplier: vec3f,top_multiplier: vec3f)->vec3f {return mix(slab_bottom*bottom_multiplier,slab_top*top_multiplier,lerp_factor);}\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\n#include<pbrBlockNormalGeometric>\nvar coatNormalW: vec3f=normalW;\n#include<openpbrNormalMapFragment>\n#include<openpbrBlockNormalFinal>\n#include<openpbrBaseLayerData>\n#include<openpbrCoatLayerData>\n#include<openpbrThinFilmLayerData>\n#include<openpbrFuzzLayerData>\nvar subsurface_weight: f32=0.0f;var transmission_weight: f32=0.0f;\n#define CUSTOM_FRAGMENT_UPDATE_ALPHA\n#include<depthPrePass>\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\nvar aoOut: ambientOcclusionOutParams;\n#ifdef AMBIENT_OCCLUSION\nvar ambientOcclusionFromTexture: vec3f=textureSample(ambientOcclusionSampler,ambientOcclusionSamplerSampler,fragmentInputs.vAmbientOcclusionUV+uvOffset).rgb;\n#endif\naoOut=ambientOcclusionBlock(\n#ifdef AMBIENT_OCCLUSION\nambientOcclusionFromTexture,\nuniforms.vAmbientOcclusionInfos\n#endif\n);\n#ifdef ANISOTROPIC_COAT\nlet coatGeoInfo: geometryInfoAnisoOutParams=geometryInfoAniso(\ncoatNormalW,viewDirectionW.xyz,coat_roughness,geometricNormalW\n,vec3f(geometry_coat_tangent.x,geometry_coat_tangent.y,coat_roughness_anisotropy),TBN\n);\n#else\nlet coatGeoInfo: geometryInfoOutParams=geometryInfo(\ncoatNormalW,viewDirectionW.xyz,coat_roughness,geometricNormalW\n);\n#endif\nspecular_roughness=mix(specular_roughness,pow(min(1.0f,pow(specular_roughness,4.0f)+2.0f*pow(coat_roughness,4.0f)),0.25f),coat_weight);\n#ifdef ANISOTROPIC_BASE\nlet baseGeoInfo: geometryInfoAnisoOutParams=geometryInfoAniso(\nnormalW,viewDirectionW.xyz,specular_roughness,geometricNormalW\n,vec3f(geometry_tangent.x,geometry_tangent.y,specular_roughness_anisotropy),TBN\n);\n#else\nlet baseGeoInfo: geometryInfoOutParams=geometryInfo(\nnormalW,viewDirectionW.xyz,specular_roughness,geometricNormalW\n);\n#endif\n#ifdef FUZZ\nlet fuzzNormalW=normalize(mix(normalW,coatNormalW,coat_weight));var fuzzTangent=normalize(TBN[0]);fuzzTangent=normalize(fuzzTangent-dot(fuzzTangent,fuzzNormalW)*fuzzNormalW);let fuzzBitangent=cross(fuzzNormalW,fuzzTangent);let fuzzGeoInfo: geometryInfoOutParams=geometryInfo(\nfuzzNormalW,viewDirectionW.xyz,fuzz_roughness,geometricNormalW\n);\n#endif\nlet coatReflectance: ReflectanceParams=dielectricReflectance(\ncoat_ior \n,1.0f \n,vec3f(1.0f)\n,coat_weight\n);\n#ifdef THIN_FILM\nlet thin_film_outside_ior: f32=mix(1.0f,coat_ior,coat_weight);\n#endif\nlet baseDielectricReflectance: ReflectanceParams=dielectricReflectance(\nspecular_ior \n,mix(1.0f,coat_ior,coat_weight) \n,specular_color\n,specular_weight\n);let baseConductorReflectance: ReflectanceParams=conductorReflectance(base_color,specular_color,specular_weight);var material_surface_ibl: vec3f=vec3f(0.f,0.f,0.f);\n#include<openpbrEnvironmentLighting>\nvar material_surface_direct: vec3f=vec3f(0.f,0.f,0.f);\n#if defined(LIGHT0)\nvar aggShadow: f32=0.f;var numLights: f32=0.f;\n#include<openpbrDirectLightingInit>[0..maxSimultaneousLights]\n#include<openpbrDirectLighting>[0..maxSimultaneousLights]\n#endif\nvar material_surface_emission: vec3f=uniforms.vEmissionColor;\n#ifdef EMISSION_COLOR\nlet emissionColorTex: vec3f=textureSample(emissionColorSampler,emissionColorSamplerSampler,uniforms.vEmissionColorUV+uvOffset).rgb;\n#ifdef EMISSION_COLOR_GAMMA\nmaterial_surface_emission*=toLinearSpace(emissionColorTex.rgb);\n#else\nmaterial_surface_emission*=emissionColorTex.rgb;\n#endif\nmaterial_surface_emission*= uniforms.vEmissionColorInfos.y;\n#endif\nmaterial_surface_emission*=uniforms.vLightingIntensity.y;\n#define CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION\nvar finalColor: vec4f=vec4f(material_surface_ibl+material_surface_direct+material_surface_emission,alpha);\n#define CUSTOM_FRAGMENT_BEFORE_FOG\nfinalColor=max(finalColor,vec4f(0.0));\n#include<logDepthFragment>\n#include<fogFragment>(color,finalColor)\n#include<pbrBlockImageProcessing>\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\n#ifdef PREPASS\n#include<pbrBlockPrePass>\n#endif\n#if !defined(PREPASS) && !defined(ORDER_INDEPENDENT_TRANSPARENCY)\nfragmentOutputs.color=finalColor;\n#endif\n#include<oitFragment>\n#if ORDER_INDEPENDENT_TRANSPARENCY\nif (fragDepth==nearestDepth) {fragmentOutputs.frontColor=vec4f(fragmentOutputs.frontColor.rgb+finalColor.rgb*finalColor.a*alphaMultiplier,1.0-alphaMultiplier*(1.0-finalColor.a));} else {fragmentOutputs.backColor+=finalColor;}\n#endif\n#include<pbrDebug>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const openpbrPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,qCAAqC,CAAC;AAC7C,OAAO,iCAAiC,CAAC;AACzC,OAAO,wCAAwC,CAAC;AAChD,OAAO,8CAA8C,CAAC;AACtD,OAAO,sCAAsC,CAAC;AAC9C,OAAO,qDAAqD,CAAC;AAC7D,OAAO,6CAA6C,CAAC;AACrD,OAAO,+CAA+C,CAAC;AACvD,OAAO,sCAAsC,CAAC;AAC9C,OAAO,yCAAyC,CAAC;AACjD,OAAO,kCAAkC,CAAC;AAC1C,OAAO,gDAAgD,CAAC;AACxD,OAAO,qCAAqC,CAAC;AAC7C,OAAO,qCAAqC,CAAC;AAC7C,OAAO,2CAA2C,CAAC;AACnD,OAAO,2CAA2C,CAAC;AACnD,OAAO,qCAAqC,CAAC;AAC7C,OAAO,kDAAkD,CAAC;AAC1D,OAAO,oDAAoD,CAAC;AAC5D,OAAO,mCAAmC,CAAC;AAC3C,OAAO,wCAAwC,CAAC;AAChD,OAAO,6CAA6C,CAAC;AACrD,OAAO,kCAAkC,CAAC;AAC1C,OAAO,wDAAwD,CAAC;AAChE,OAAO,oDAAoD,CAAC;AAC5D,OAAO,qCAAqC,CAAC;AAC7C,OAAO,+CAA+C,CAAC;AACvD,OAAO,8CAA8C,CAAC;AACtD,OAAO,+CAA+C,CAAC;AACvD,OAAO,sCAAsC,CAAC;AAC9C,OAAO,sCAAsC,CAAC;AAC9C,OAAO,oCAAoC,CAAC;AAC5C,OAAO,0CAA0C,CAAC;AAClD,OAAO,2CAA2C,CAAC;AACnD,OAAO,0CAA0C,CAAC;AAClD,OAAO,uCAAuC,CAAC;AAC/C,OAAO,uCAAuC,CAAC;AAC/C,OAAO,2CAA2C,CAAC;AACnD,OAAO,uCAAuC,CAAC;AAC/C,OAAO,+BAA+B,CAAC;AACvC,OAAO,6CAA6C,CAAC;AACrD,OAAO,4CAA4C,CAAC;AACpD,OAAO,wCAAwC,CAAC;AAChD,OAAO,mCAAmC,CAAC;AAC3C,OAAO,8BAA8B,CAAC;AACtC,OAAO,0CAA0C,CAAC;AAClD,OAAO,kCAAkC,CAAC;AAC1C,OAAO,8BAA8B,CAAC;AACtC,OAAO,2BAA2B,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEnC,MAAM,IAAI,GAAG,oBAAoB,CAAC;AAClC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkJd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,sBAAsB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 2984, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/procedural.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/procedural.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"proceduralVertexShader\";\nconst shader = `attribute position: vec2f;varying vPosition: vec2f;varying vUV: vec2f;const madd: vec2f= vec2f(0.5,0.5);\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvertexOutputs.vPosition=input.position;vertexOutputs.vUV=input.position*madd+madd;vertexOutputs.position= vec4f(input.position,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const proceduralVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,wBAAwB,CAAC;AACtC,MAAM,MAAM,GAAG,CAAA;;;;;;;EAOb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,0BAA0B,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 3012, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/hdrFiltering.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/hdrFiltering.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"hdrFilteringVertexShader\";\nconst shader = `attribute position: vec2f;varying direction: vec3f;uniform up: vec3f;uniform right: vec3f;uniform front: vec3f;\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvar view: mat3x3f= mat3x3f(uniforms.up,uniforms.right,uniforms.front);vertexOutputs.direction=view*vec3f(input.position,1.0);vertexOutputs.position= vec4f(input.position,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const hdrFilteringVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,0BAA0B,CAAC;AACxC,MAAM,MAAM,GAAG,CAAA;;;;;;;EAOb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,4BAA4B,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 3040, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/hdrFiltering.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/hdrFiltering.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/importanceSampling\";\nimport \"./ShadersInclude/pbrBRDFFunctions\";\nimport \"./ShadersInclude/hdrFilteringFunctions\";\n\nconst name = \"hdrFilteringPixelShader\";\nconst shader = `#include<helperFunctions>\n#include<importanceSampling>\n#include<pbrBRDFFunctions>\n#include<hdrFilteringFunctions>\nuniform alphaG: f32;var inputTextureSampler: sampler;var inputTexture: texture_cube<f32>;uniform vFilteringInfo: vec2f;uniform hdrScale: f32;varying direction: vec3f;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var color: vec3f=radiance(uniforms.alphaG,inputTexture,inputTextureSampler,input.direction,uniforms.vFilteringInfo);fragmentOutputs.color= vec4f(color*uniforms.hdrScale,1.0);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const hdrFilteringPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,kCAAkC,CAAC;AAC1C,OAAO,qCAAqC,CAAC;AAC7C,OAAO,mCAAmC,CAAC;AAC3C,OAAO,wCAAwC,CAAC;;;;;;AAEhD,MAAM,IAAI,GAAG,yBAAyB,CAAC;AACvC,MAAM,MAAM,GAAG,CAAA;;;;;iOAKkN,CAAC;AAClO,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,2BAA2B,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 3074, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/hdrIrradianceFiltering.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/hdrIrradianceFiltering.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"hdrIrradianceFilteringVertexShader\";\nconst shader = `attribute position: vec2f;varying direction: vec3f;uniform up: vec3f;uniform right: vec3f;uniform front: vec3f;\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvar view: mat3x3f= mat3x3f(uniforms.up,uniforms.right,uniforms.front);vertexOutputs.direction=view*vec3f(input.position,1.0);vertexOutputs.position= vec4f(input.position,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const hdrIrradianceFilteringVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,oCAAoC,CAAC;AAClD,MAAM,MAAM,GAAG,CAAA;;;;;;;EAOb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,sCAAsC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 3102, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/hdrIrradianceFiltering.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/hdrIrradianceFiltering.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/importanceSampling\";\nimport \"./ShadersInclude/pbrBRDFFunctions\";\nimport \"./ShadersInclude/hdrFilteringFunctions\";\n\nconst name = \"hdrIrradianceFilteringPixelShader\";\nconst shader = `#include<helperFunctions>\n#include<importanceSampling>\n#include<pbrBRDFFunctions>\n#include<hdrFilteringFunctions>\nvar inputTextureSampler: sampler;var inputTexture: texture_cube<f32>;\n#ifdef IBL_CDF_FILTERING\nvar icdfTextureSampler: sampler;var icdfTexture: texture_2d<f32>;\n#endif\nuniform vFilteringInfo: vec2f;uniform hdrScale: f32;varying direction: vec3f;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var color: vec3f=irradiance(inputTexture,inputTextureSampler,input.direction,uniforms.vFilteringInfo,0.0,vec3f(1.0),input.direction\n#ifdef IBL_CDF_FILTERING\n,icdfTexture,icdfTextureSampler\n#endif\n);fragmentOutputs.color= vec4f(color*uniforms.hdrScale,1.0);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const hdrIrradianceFilteringPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,kCAAkC,CAAC;AAC1C,OAAO,qCAAqC,CAAC;AAC7C,OAAO,mCAAmC,CAAC;AAC3C,OAAO,wCAAwC,CAAC;;;;;;AAEhD,MAAM,IAAI,GAAG,mCAAmC,CAAC;AACjD,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;8DAa+C,CAAC;AAC/D,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,qCAAqC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 3144, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/gaussianSplatting.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/gaussianSplatting.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/gaussianSplattingFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\n\nconst name = \"gaussianSplattingPixelShader\";\nconst shader = `#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\nvarying vColor: vec4f;varying vPosition: vec2f;\n#include<gaussianSplattingFragmentDeclaration>\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#include<clipPlaneFragment>\nfragmentOutputs.color=gaussianColor(input.vColor,input.vPosition);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,+CAA+C,CAAC;AACvD,OAAO,sCAAsC,CAAC;AAC9C,OAAO,yCAAyC,CAAC;AACjD,OAAO,uDAAuD,CAAC;AAC/D,OAAO,oCAAoC,CAAC;;;;;;;AAE5C,MAAM,IAAI,GAAG,8BAA8B,CAAC;AAC5C,MAAM,MAAM,GAAG,CAAA;;;;;;;;;CASd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,gCAAgC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 3184, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/gaussianSplatting.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/gaussianSplatting.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/sceneUboDeclaration\";\nimport \"./ShadersInclude/meshUboDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/fogVertexDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/gaussianSplatting\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/fogVertex\";\nimport \"./ShadersInclude/logDepthVertex\";\n\nconst name = \"gaussianSplattingVertexShader\";\nconst shader = `#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n#include<helperFunctions>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<logDepthDeclaration>\nattribute splatIndex0: vec4f;attribute splatIndex1: vec4f;attribute splatIndex2: vec4f;attribute splatIndex3: vec4f;attribute position: vec3f;uniform invViewport: vec2f;uniform dataTextureSize: vec2f;uniform focal: vec2f;uniform kernelSize: f32;uniform eyePosition: vec3f;uniform viewDirectionFactor: vec3f;var covariancesATexture: texture_2d<f32>;var covariancesBTexture: texture_2d<f32>;var centersTexture: texture_2d<f32>;var colorsTexture: texture_2d<f32>;\n#if SH_DEGREE>0\nvar shTexture0: texture_2d<u32>;\n#endif\n#if SH_DEGREE>1\nvar shTexture1: texture_2d<u32>;\n#endif\n#if SH_DEGREE>2\nvar shTexture2: texture_2d<u32>;\n#endif\nvarying vColor: vec4f;varying vPosition: vec2f;\n#include<gaussianSplatting>\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {let splatIndex: f32=getSplatIndex(i32(input.position.z+0.5),input.splatIndex0,input.splatIndex1,input.splatIndex2,input.splatIndex3);var splat: Splat=readSplat(splatIndex,uniforms.dataTextureSize);var covA: vec3f=splat.covA.xyz;var covB: vec3f=vec3f(splat.covA.w,splat.covB.xy);let worldPos: vec4f=mesh.world*vec4f(splat.center.xyz,1.0);vertexOutputs.vPosition=input.position.xy;\n#if SH_DEGREE>0\nlet worldRot: mat3x3f= mat3x3f(mesh.world[0].xyz,mesh.world[1].xyz,mesh.world[2].xyz);let normWorldRot: mat3x3f=inverseMat3(worldRot);var dir: vec3f=normalize(normWorldRot*(worldPos.xyz-uniforms.eyePosition.xyz));dir*=uniforms.viewDirectionFactor;vertexOutputs.vColor=vec4f(splat.color.xyz+computeSH(splat,dir),splat.color.w);\n#else\nvertexOutputs.vColor=splat.color;\n#endif\nvertexOutputs.position=gaussianSplatting(input.position.xy,worldPos.xyz,vec2f(1.0,1.0),covA,covB,mesh.world,scene.view,scene.projection,uniforms.focal,uniforms.invViewport,uniforms.kernelSize);\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<logDepthVertex>\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,sCAAsC,CAAC;AAC9C,OAAO,qCAAqC,CAAC;AAC7C,OAAO,kCAAkC,CAAC;AAC1C,OAAO,6CAA6C,CAAC;AACrD,OAAO,uCAAuC,CAAC;AAC/C,OAAO,sCAAsC,CAAC;AAC9C,OAAO,oCAAoC,CAAC;AAC5C,OAAO,kCAAkC,CAAC;AAC1C,OAAO,4BAA4B,CAAC;AACpC,OAAO,iCAAiC,CAAC;;;;;;;;;;;;AAEzC,MAAM,IAAI,GAAG,+BAA+B,CAAC;AAC7C,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8Bd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,iCAAiC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 3255, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/gaussianSplattingDepth.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/gaussianSplattingDepth.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/gaussianSplattingFragmentDeclaration\";\nimport \"./ShadersInclude/shadowMapFragmentExtraDeclaration\";\n\nconst name = \"gaussianSplattingDepthPixelShader\";\nconst shader = `#include<gaussianSplattingFragmentDeclaration>\n#include<shadowMapFragmentExtraDeclaration>\nvarying vPosition: vec2f;varying vColor: vec4f;fn checkDiscard(inPosition: vec2f,inColor: vec4f)->vec4f {var A : f32=-dot(inPosition,inPosition);var alpha : f32=exp(A)*inColor.a;\n#if defined(SM_SOFTTRANSPARENTSHADOW) && SM_SOFTTRANSPARENTSHADOW==1\nif (A<-4.) {discard;}\n#else\nif (A<-1.) {discard;}\n#endif\nreturn vec4f(inColor.rgb,alpha);}\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=checkDiscard(fragmentInputs.vPosition,fragmentInputs.vColor);\n#if defined(SM_SOFTTRANSPARENTSHADOW) && SM_SOFTTRANSPARENTSHADOW==1\nvar alpha : f32=fragmentOutputs.color.a;\n#endif\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingDepthPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,uDAAuD,CAAC;AAC/D,OAAO,oDAAoD,CAAC;;;;AAE5D,MAAM,IAAI,GAAG,mCAAmC,CAAC;AACjD,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;CAgBd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,qCAAqC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 3296, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/gaussianSplattingDepth.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/gaussianSplattingDepth.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/sceneUboDeclaration\";\nimport \"./ShadersInclude/meshUboDeclaration\";\nimport \"./ShadersInclude/gaussianSplatting\";\n\nconst name = \"gaussianSplattingDepthVertexShader\";\nconst shader = `#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\nattribute splatIndex0: vec4f;attribute splatIndex1: vec4f;attribute splatIndex2: vec4f;attribute splatIndex3: vec4f;attribute position: vec3f;uniform invViewport: vec2f;uniform dataTextureSize: vec2f;uniform focal: vec2f;uniform kernelSize: f32;var covariancesATexture: texture_2d<f32>;var covariancesBTexture: texture_2d<f32>;var centersTexture: texture_2d<f32>;var colorsTexture: texture_2d<f32>;varying vPosition: vec2f;varying vColor: vec4f;\n#include<gaussianSplatting>\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {let splatIndex: f32=getSplatIndex(i32(input.position.z+0.5),input.splatIndex0,input.splatIndex1,input.splatIndex2,input.splatIndex3);var splat: Splat=readSplat(splatIndex,uniforms.dataTextureSize);var covA: vec3f=splat.covA.xyz;var covB: vec3f=vec3f(splat.covA.w,splat.covB.xy);let worldPos: vec4f=mesh.world*vec4f(splat.center.xyz,1.0);vertexOutputs.vPosition=input.position.xy;vertexOutputs.vColor=splat.color;vertexOutputs.position=gaussianSplatting(input.position.xy,worldPos.xyz,vec2f(1.0,1.0),covA,covB,mesh.world,scene.view,scene.projection,uniforms.focal,uniforms.invViewport,uniforms.kernelSize);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingDepthVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,sCAAsC,CAAC;AAC9C,OAAO,qCAAqC,CAAC;AAC7C,OAAO,oCAAoC,CAAC;;;;;AAE5C,MAAM,IAAI,GAAG,oCAAoC,CAAC;AAClD,MAAM,MAAM,GAAG,CAAA;;;;;8oBAK+nB,CAAC;AAC/oB,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,sCAAsC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 3328, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/default.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/default.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/defaultUboDeclaration\";\nimport \"./ShadersInclude/prePassDeclaration\";\nimport \"./ShadersInclude/oitDeclaration\";\nimport \"./ShadersInclude/mainUVVaryingDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/lightUboDeclaration\";\nimport \"./ShadersInclude/lightsFragmentFunctions\";\nimport \"./ShadersInclude/shadowsFragmentFunctions\";\nimport \"./ShadersInclude/samplerFragmentDeclaration\";\nimport \"./ShadersInclude/fresnelFunction\";\nimport \"./ShadersInclude/reflectionFunction\";\nimport \"./ShadersInclude/imageProcessingDeclaration\";\nimport \"./ShadersInclude/imageProcessingFunctions\";\nimport \"./ShadersInclude/bumpFragmentMainFunctions\";\nimport \"./ShadersInclude/bumpFragmentFunctions\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nimport \"./ShadersInclude/bumpFragment\";\nimport \"./ShadersInclude/decalFragment\";\nimport \"./ShadersInclude/depthPrePass\";\nimport \"./ShadersInclude/lightFragment\";\nimport \"./ShadersInclude/logDepthFragment\";\nimport \"./ShadersInclude/fogFragment\";\nimport \"./ShadersInclude/oitFragment\";\n\nconst name = \"defaultPixelShader\";\nconst shader = `#include<defaultUboDeclaration>\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\n#include<oitDeclaration>\n#define CUSTOM_FRAGMENT_BEGIN\nvarying vPositionW: vec3f;\n#ifdef NORMAL\nvarying vNormalW: vec3f;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vColor: vec4f;\n#endif\n#if defined(CLUSTLIGHT_BATCH) && CLUSTLIGHT_BATCH>0\nvarying vViewDepth: f32;\n#endif\n#include<mainUVVaryingDeclaration>[1..7]\n#include<helperFunctions>\n#include<lightUboDeclaration>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_SAMPLERNAME_,decal)\n#ifdef REFRACTION\n#ifdef REFRACTIONMAP_3D\nvar refractionCubeSamplerSampler: sampler;var refractionCubeSampler: texture_cube<f32>;\n#else\nvar refraction2DSamplerSampler: sampler;var refraction2DSampler: texture_2d<f32>;\n#endif\n#endif\n#if defined(SPECULARTERM)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)\n#endif\n#include<fresnelFunction>\n#ifdef REFLECTION\n#ifdef REFLECTIONMAP_3D\nvar reflectionCubeSamplerSampler: sampler;var reflectionCubeSampler: texture_cube<f32>;\n#else\nvar reflection2DSamplerSampler: sampler;var reflection2DSampler: texture_2d<f32>;\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vPositionUVW: vec3f;\n#else\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vDirectionW: vec3f;\n#endif\n#endif\n#include<reflectionFunction>\n#endif\n#include<imageProcessingDeclaration>\n#include<imageProcessingFunctions>\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvar viewDirectionW: vec3f=normalize(scene.vEyePosition.xyz-fragmentInputs.vPositionW);var baseColor: vec4f= vec4f(1.,1.,1.,1.);var diffuseColor: vec3f=uniforms.vDiffuseColor.rgb;var alpha: f32=uniforms.vDiffuseColor.a;\n#ifdef NORMAL\nvar normalW: vec3f=normalize(fragmentInputs.vNormalW);\n#else\nvar normalW: vec3f=normalize(cross(dpdx(fragmentInputs.vPositionW),dpdy(fragmentInputs.vPositionW)))* scene.vEyePosition.w;\n#endif\n#include<bumpFragment>\n#ifdef TWOSIDEDLIGHTING\nnormalW=select(-normalW,normalW,fragmentInputs.frontFacing);\n#endif\n#ifdef DIFFUSE\nbaseColor=textureSample(diffuseSampler,diffuseSamplerSampler,fragmentInputs.vDiffuseUV+uvOffset);\n#if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)\nif (baseColor.a<uniforms.alphaCutOff) {discard;}\n#endif\n#ifdef ALPHAFROMDIFFUSE\nalpha*=baseColor.a;\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_ALPHA\nbaseColor=vec4f(baseColor.rgb*uniforms.vDiffuseInfos.y,baseColor.a);\n#endif\n#if defined(DECAL) && !defined(DECAL_AFTER_DETAIL)\nvar decalColor: vec4f=textureSample(decalSampler,decalSamplerSampler,fragmentInputs.vDecalUV+uvOffset);\n#include<decalFragment>(surfaceAlbedo,baseColor,GAMMADECAL,_GAMMADECAL_NOTUSED_)\n#endif\n#include<depthPrePass>\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nbaseColor=vec4f(baseColor.rgb*fragmentInputs.vColor.rgb,baseColor.a);\n#endif\n#ifdef DETAIL\nbaseColor=vec4f(baseColor.rgb*2.0*mix(0.5,detailColor.r,uniforms.vDetailInfos.y),baseColor.a);\n#endif\n#if defined(DECAL) && defined(DECAL_AFTER_DETAIL)\nvar decalColor: vec4f=textureSample(decalSampler,decalSamplerSampler,fragmentInputs.vDecalUV+uvOffset);\n#include<decalFragment>(surfaceAlbedo,baseColor,GAMMADECAL,_GAMMADECAL_NOTUSED_)\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE\nvar baseAmbientColor: vec3f= vec3f(1.,1.,1.);\n#ifdef AMBIENT\nbaseAmbientColor=textureSample(ambientSampler,ambientSamplerSampler,fragmentInputs.vAmbientUV+uvOffset).rgb*uniforms.vAmbientInfos.y;\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\nvar glossiness: f32=uniforms.vSpecularColor.a;var specularColor: vec3f=uniforms.vSpecularColor.rgb;\n#ifdef SPECULARTERM\n#ifdef SPECULAR\nvar specularMapColor: vec4f=textureSample(specularSampler,specularSamplerSampler,fragmentInputs.vSpecularUV+uvOffset);specularColor=specularMapColor.rgb;\n#ifdef GLOSSINESS\nglossiness=glossiness*specularMapColor.a;\n#endif\n#endif\n#endif\nvar diffuseBase: vec3f= vec3f(0.,0.,0.);var info: lightingInfo;\n#ifdef SPECULARTERM\nvar specularBase: vec3f= vec3f(0.,0.,0.);\n#endif\nvar shadow: f32=1.;var aggShadow: f32=0.;var numLights: f32=0.;\n#ifdef LIGHTMAP\nvar lightmapColor: vec4f=textureSample(lightmapSampler,lightmapSamplerSampler,fragmentInputs.vLightmapUV+uvOffset);\n#ifdef RGBDLIGHTMAP\nlightmapColor=vec4f(fromRGBD(lightmapColor),lightmapColor.a);\n#endif\nlightmapColor=vec4f(lightmapColor.rgb*uniforms.vLightmapInfos.y,lightmapColor.a);\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\naggShadow=aggShadow/numLights;var refractionColor: vec4f= vec4f(0.,0.,0.,1.);\n#ifdef REFRACTION\nvar refractionVector: vec3f=normalize(refract(-viewDirectionW,normalW,uniforms.vRefractionInfos.y));\n#ifdef REFRACTIONMAP_3D\n#ifdef USE_LOCAL_REFRACTIONMAP_CUBIC\nrefractionVector=parallaxCorrectNormal(fragmentInputs.vPositionW,refractionVector,uniforms.vRefractionSize,uniforms.vRefractionPosition);\n#endif\nrefractionVector.y=refractionVector.y*uniforms.vRefractionInfos.w;var refractionLookup: vec4f=textureSample(refractionCubeSampler,refractionCubeSamplerSampler,refractionVector);if (dot(refractionVector,viewDirectionW)<1.0) {refractionColor=refractionLookup;}\n#else\nvar vRefractionUVW: vec3f= (uniforms.refractionMatrix*(scene.view* vec4f(fragmentInputs.vPositionW+refractionVector*uniforms.vRefractionInfos.z,1.0))).xyz;var refractionCoords: vec2f=vRefractionUVW.xy/vRefractionUVW.z;refractionCoords.y=1.0-refractionCoords.y;refractionColor=textureSample(refraction2DSampler,refraction2DSamplerSampler,refractionCoords);\n#endif\n#ifdef RGBDREFRACTION\nrefractionColor=vec4f(fromRGBD(refractionColor),refractionColor.a);\n#endif\n#ifdef IS_REFRACTION_LINEAR\nrefractionColor=vec4f(toGammaSpaceVec3(refractionColor.rgb),refractionColor.a);\n#endif\nrefractionColor=vec4f(refractionColor.rgb*uniforms.vRefractionInfos.x,refractionColor.a);\n#endif\nvar reflectionColor: vec4f= vec4f(0.,0.,0.,1.);\n#ifdef REFLECTION\nvar vReflectionUVW: vec3f=computeReflectionCoords( vec4f(fragmentInputs.vPositionW,1.0),normalW);\n#ifdef REFLECTIONMAP_OPPOSITEZ\nvReflectionUVW=vec3f(vReflectionUVW.x,vReflectionUVW.y,vReflectionUVW.z*-1.0);\n#endif\n#ifdef REFLECTIONMAP_3D\n#ifdef ROUGHNESS\nvar bias: f32=uniforms.vReflectionInfos.y;\n#ifdef SPECULARTERM\n#ifdef SPECULAR\n#ifdef GLOSSINESS\nbias*=(1.0-specularMapColor.a);\n#endif\n#endif\n#endif\nreflectionColor=textureSampleLevel(reflectionCubeSampler,reflectionCubeSamplerSampler,vReflectionUVW,bias);\n#else\nreflectionColor=textureSample(reflectionCubeSampler,reflectionCubeSamplerSampler,vReflectionUVW);\n#endif\n#else\nvar coords: vec2f=vReflectionUVW.xy;\n#ifdef REFLECTIONMAP_PROJECTION\ncoords/=vReflectionUVW.z;\n#endif\ncoords.y=1.0-coords.y;reflectionColor=textureSample(reflection2DSampler,reflection2DSamplerSampler,coords);\n#endif\n#ifdef RGBDREFLECTION\nreflectionColor=vec4f(fromRGBD(reflectionColor),reflectionColor.a);\n#endif\n#ifdef IS_REFLECTION_LINEAR\nreflectionColor=vec4f(toGammaSpaceVec3(reflectionColor.rgb),reflectionColor.a);\n#endif\nreflectionColor=vec4f(reflectionColor.rgb*uniforms.vReflectionInfos.x,reflectionColor.a);\n#ifdef REFLECTIONFRESNEL\nvar reflectionFresnelTerm: f32=computeFresnelTerm(viewDirectionW,normalW,uniforms.reflectionRightColor.a,uniforms.reflectionLeftColor.a);\n#ifdef REFLECTIONFRESNELFROMSPECULAR\n#ifdef SPECULARTERM\nreflectionColor=vec4f(reflectionColor.rgb*specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*uniforms.reflectionRightColor.rgb,reflectionColor.a);\n#else\nreflectionColor=vec4f(reflectionColor.rgb*uniforms.reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*uniforms.reflectionRightColor.rgb,reflectionColor.a);\n#endif\n#else\nreflectionColor=vec4f(reflectionColor.rgb*uniforms.reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*uniforms.reflectionRightColor.rgb,reflectionColor.a);\n#endif\n#endif\n#endif\n#ifdef REFRACTIONFRESNEL\nvar refractionFresnelTerm: f32=computeFresnelTerm(viewDirectionW,normalW,uniforms.refractionRightColor.a,uniforms.refractionLeftColor.a);refractionColor=vec4f(refractionColor.rgb*uniforms.refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*uniforms.refractionRightColor.rgb,refractionColor.a);\n#endif\n#ifdef OPACITY\nvar opacityMap: vec4f=textureSample(opacitySampler,opacitySamplerSampler,fragmentInputs.vOpacityUV+uvOffset);\n#ifdef OPACITYRGB\nopacityMap=vec4f(opacityMap.rgb* vec3f(0.3,0.59,0.11),opacityMap.a);alpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* uniforms.vOpacityInfos.y;\n#else\nalpha*=opacityMap.a*uniforms.vOpacityInfos.y;\n#endif\n#endif\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=fragmentInputs.vColor.a;\n#endif\n#ifdef OPACITYFRESNEL\nvar opacityFresnelTerm: f32=computeFresnelTerm(viewDirectionW,normalW,uniforms.opacityParts.z,uniforms.opacityParts.w);alpha+=uniforms.opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*uniforms.opacityParts.y;\n#endif\n#ifdef ALPHATEST\n#ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS\nif (alpha<uniforms.alphaCutOff) {discard;}\n#endif\n#ifndef ALPHABLEND\nalpha=1.0;\n#endif\n#endif\nvar emissiveColor: vec3f=uniforms.vEmissiveColor;\n#ifdef EMISSIVE\nemissiveColor+=textureSample(emissiveSampler,emissiveSamplerSampler,fragmentInputs.vEmissiveUV+uvOffset).rgb*uniforms.vEmissiveInfos.y;\n#endif\n#ifdef EMISSIVEFRESNEL\nvar emissiveFresnelTerm: f32=computeFresnelTerm(viewDirectionW,normalW,uniforms.emissiveRightColor.a,uniforms.emissiveLeftColor.a);emissiveColor*=uniforms.emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*uniforms.emissiveRightColor.rgb;\n#endif\n#ifdef DIFFUSEFRESNEL\nvar diffuseFresnelTerm: f32=computeFresnelTerm(viewDirectionW,normalW,uniforms.diffuseRightColor.a,uniforms.diffuseLeftColor.a);diffuseBase*=uniforms.diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*uniforms.diffuseRightColor.rgb;\n#endif\n#ifdef EMISSIVEASILLUMINATION\nvar finalDiffuse: vec3f=clamp(diffuseBase*diffuseColor+uniforms.vAmbientColor,vec3f(0.0),vec3f(1.0))*baseColor.rgb;\n#else\n#ifdef LINKEMISSIVEWITHDIFFUSE\nvar finalDiffuse: vec3f=clamp((diffuseBase+emissiveColor)*diffuseColor+uniforms.vAmbientColor,vec3f(0.0),vec3f(1.0))*baseColor.rgb;\n#else\nvar finalDiffuse: vec3f=clamp(diffuseBase*diffuseColor+emissiveColor+uniforms.vAmbientColor,vec3f(0.0),vec3f(1.0))*baseColor.rgb;\n#endif\n#endif\n#ifdef SPECULARTERM\nvar finalSpecular: vec3f=specularBase*specularColor;\n#ifdef SPECULAROVERALPHA\nalpha=clamp(alpha+dot(finalSpecular, vec3f(0.3,0.59,0.11)),0.0,1.0);\n#endif\n#else\nvar finalSpecular: vec3f= vec3f(0.0);\n#endif\n#ifdef REFLECTIONOVERALPHA\nalpha=clamp(alpha+dot(reflectionColor.rgb, vec3f(0.3,0.59,0.11)),0.0,1.0);\n#endif\n#ifdef EMISSIVEASILLUMINATION\nvar color: vec4f= vec4f(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+emissiveColor+refractionColor.rgb,0.0,1.0),alpha);\n#else\nvar color: vec4f= vec4f(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+refractionColor.rgb,alpha);\n#endif\n#ifdef LIGHTMAP\n#ifndef LIGHTMAPEXCLUDED\n#ifdef USELIGHTMAPASSHADOWMAP\ncolor=vec4f(color.rgb*lightmapColor.rgb,color.a);\n#else\ncolor=vec4f(color.rgb+lightmapColor.rgb,color.a);\n#endif\n#endif\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_FOG\ncolor=vec4f(max(color.rgb,vec3f(0.)),color.a);\n#include<logDepthFragment>\n#include<fogFragment>\n#ifdef IMAGEPROCESSINGPOSTPROCESS\ncolor=vec4f(toLinearSpaceVec3(color.rgb),color.a);\n#else\n#ifdef IMAGEPROCESSING\ncolor=vec4f(toLinearSpaceVec3(color.rgb),color.a);color=applyImageProcessing(color);\n#endif\n#endif\ncolor=vec4f(color.rgb,color.a*mesh.visibility);\n#ifdef PREMULTIPLYALPHA\ncolor=vec4f(color.rgb*color.a, color.a);\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\n#ifdef PREPASS\n#if SCENE_MRT_COUNT>0\nvar writeGeometryInfo: f32=select(0.0,1.0,color.a>0.4);var fragData: array<vec4<f32>,SCENE_MRT_COUNT>;\n#ifdef PREPASS_COLOR\nfragData[PREPASS_COLOR_INDEX]=color; \n#endif\n#ifdef PREPASS_POSITION\nfragData[PREPASS_POSITION_INDEX]=vec4f(fragmentInputs.vPositionW,writeGeometryInfo);\n#endif\n#ifdef PREPASS_LOCAL_POSITION\nfragData[PREPASS_LOCAL_POSITION_INDEX]=vec4f(fragmentInputs.vPosition,writeGeometryInfo);\n#endif\n#ifdef PREPASS_VELOCITY\nvar a: vec2f=(fragmentInputs.vCurrentPosition.xy/fragmentInputs.vCurrentPosition.w)*0.5+0.5;var b: vec2f=(fragmentInputs.vPreviousPosition.xy/fragmentInputs.vPreviousPosition.w)*0.5+0.5;var velocity: vec2f=abs(a-b);velocity= vec2f(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;fragData[PREPASS_VELOCITY_INDEX]= vec4f(velocity,0.0,writeGeometryInfo);\n#elif defined(PREPASS_VELOCITY_LINEAR)\nvar velocity : vec2f=vec2f(0.5)*((fragmentInputs.vPreviousPosition.xy/fragmentInputs.vPreviousPosition.w) -\n(fragmentInputs.vCurrentPosition.xy/fragmentInputs.vCurrentPosition.w));fragData[PREPASS_VELOCITY_LINEAR_INDEX]=vec4f(velocity,0.0,writeGeometryInfo);\n#endif\n#ifdef PREPASS_IRRADIANCE\nfragData[PREPASS_IRRADIANCE_INDEX]=vec4f(0.0,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_DEPTH\nfragData[PREPASS_DEPTH_INDEX]=vec4f(fragmentInputs.vViewPos.z,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_SCREENSPACE_DEPTH\nfragData[PREPASS_SCREENSPACE_DEPTH_INDEX]=vec4f(fragmentInputs.position.z,0.0,0.0,writeGeometryInfo);\n#endif\n#ifdef PREPASS_NORMALIZED_VIEW_DEPTH\nfragData[PREPASS_NORMALIZED_VIEW_DEPTH_INDEX]=vec4f(fragmentInputs.vNormViewDepth,0.0,0.0,writeGeometryInfo);\n#endif\n#ifdef PREPASS_NORMAL\n#ifdef PREPASS_NORMAL_WORLDSPACE\nfragData[PREPASS_NORMAL_INDEX]=vec4f(normalW,writeGeometryInfo);\n#else\nfragData[PREPASS_NORMAL_INDEX]=vec4f(normalize((scene.view*vec4f(normalW,0.0)).rgb),writeGeometryInfo);\n#endif\n#endif\n#ifdef PREPASS_WORLD_NORMAL\nfragData[PREPASS_WORLD_NORMAL_INDEX]=vec4f(normalW*0.5+0.5,writeGeometryInfo);\n#endif\n#ifdef PREPASS_ALBEDO\nfragData[PREPASS_ALBEDO_INDEX]=vec4f(baseColor.rgb,writeGeometryInfo);\n#endif\n#ifdef PREPASS_ALBEDO_SQRT\nfragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4f(sqrt(baseColor.rgb),writeGeometryInfo);\n#endif\n#ifdef PREPASS_REFLECTIVITY\n#if defined(SPECULAR)\nfragData[PREPASS_REFLECTIVITY_INDEX]=vec4f(toLinearSpaceVec4(specularMapColor))*writeGeometryInfo; \n#else\nfragData[PREPASS_REFLECTIVITY_INDEX]=vec4f(toLinearSpaceVec3(specularColor),1.0)*writeGeometryInfo;\n#endif\n#endif\n#if SCENE_MRT_COUNT>0\nfragmentOutputs.fragData0=fragData[0];\n#endif\n#if SCENE_MRT_COUNT>1\nfragmentOutputs.fragData1=fragData[1];\n#endif\n#if SCENE_MRT_COUNT>2\nfragmentOutputs.fragData2=fragData[2];\n#endif\n#if SCENE_MRT_COUNT>3\nfragmentOutputs.fragData3=fragData[3];\n#endif\n#if SCENE_MRT_COUNT>4\nfragmentOutputs.fragData4=fragData[4];\n#endif\n#if SCENE_MRT_COUNT>5\nfragmentOutputs.fragData5=fragData[5];\n#endif\n#if SCENE_MRT_COUNT>6\nfragmentOutputs.fragData6=fragData[6];\n#endif\n#if SCENE_MRT_COUNT>7\nfragmentOutputs.fragData7=fragData[7];\n#endif\n#endif\n#endif\n#if !defined(PREPASS) && !defined(ORDER_INDEPENDENT_TRANSPARENCY)\nfragmentOutputs.color=color;\n#endif\n#include<oitFragment>\n#if ORDER_INDEPENDENT_TRANSPARENCY\nif (fragDepth==nearestDepth) {fragmentOutputs.frontColor=vec4f(fragmentOutputs.frontColor.rgb+color.rgb*color.a*alphaMultiplier,1.0-alphaMultiplier*(1.0-color.a));} else {fragmentOutputs.backColor+=color;}\n#endif\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const defaultPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,wCAAwC,CAAC;AAChD,OAAO,qCAAqC,CAAC;AAC7C,OAAO,iCAAiC,CAAC;AACzC,OAAO,2CAA2C,CAAC;AACnD,OAAO,kCAAkC,CAAC;AAC1C,OAAO,sCAAsC,CAAC;AAC9C,OAAO,0CAA0C,CAAC;AAClD,OAAO,2CAA2C,CAAC;AACnD,OAAO,6CAA6C,CAAC;AACrD,OAAO,kCAAkC,CAAC;AAC1C,OAAO,qCAAqC,CAAC;AAC7C,OAAO,6CAA6C,CAAC;AACrD,OAAO,2CAA2C,CAAC;AACnD,OAAO,4CAA4C,CAAC;AACpD,OAAO,wCAAwC,CAAC;AAChD,OAAO,+CAA+C,CAAC;AACvD,OAAO,sCAAsC,CAAC;AAC9C,OAAO,yCAAyC,CAAC;AACjD,OAAO,oCAAoC,CAAC;AAC5C,OAAO,+BAA+B,CAAC;AACvC,OAAO,gCAAgC,CAAC;AACxC,OAAO,+BAA+B,CAAC;AACvC,OAAO,gCAAgC,CAAC;AACxC,OAAO,mCAAmC,CAAC;AAC3C,OAAO,8BAA8B,CAAC;AACtC,OAAO,8BAA8B,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEtC,MAAM,IAAI,GAAG,oBAAoB,CAAC;AAClC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8Wd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,sBAAsB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 3767, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/default.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/default.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/defaultUboDeclaration\";\nimport \"./ShadersInclude/uvAttributeDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/prePassVertexDeclaration\";\nimport \"./ShadersInclude/mainUVVaryingDeclaration\";\nimport \"./ShadersInclude/samplerVertexDeclaration\";\nimport \"./ShadersInclude/bumpVertexDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/fogVertexDeclaration\";\nimport \"./ShadersInclude/lightVxFragmentDeclaration\";\nimport \"./ShadersInclude/lightVxUboDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal\";\nimport \"./ShadersInclude/morphTargetsVertex\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/prePassVertex\";\nimport \"./ShadersInclude/uvVariableDeclaration\";\nimport \"./ShadersInclude/samplerVertexImplementation\";\nimport \"./ShadersInclude/bumpVertex\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/fogVertex\";\nimport \"./ShadersInclude/shadowsVertex\";\nimport \"./ShadersInclude/vertexColorMixing\";\nimport \"./ShadersInclude/logDepthVertex\";\n\nconst name = \"defaultVertexShader\";\nconst shader = `#include<defaultUboDeclaration>\n#define CUSTOM_VERTEX_BEGIN\nattribute position: vec3f;\n#ifdef NORMAL\nattribute normal: vec3f;\n#endif\n#ifdef TANGENT\nattribute tangent: vec4f;\n#endif\n#ifdef UV1\nattribute uv: vec2f;\n#endif\n#include<uvAttributeDeclaration>[2..7]\n#ifdef VERTEXCOLOR\nattribute color: vec4f;\n#endif\n#include<helperFunctions>\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n#include<mainUVVaryingDeclaration>[1..7]\n#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)\n#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)\n#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)\n#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)\n#if defined(SPECULARTERM)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)\n#endif\n#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal)\nvarying vPositionW: vec3f;\n#ifdef NORMAL\nvarying vNormalW: vec3f;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vColor: vec4f;\n#endif\n#include<bumpVertexDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vPositionUVW: vec3f;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vDirectionW: vec3f;\n#endif\n#if defined(CLUSTLIGHT_BATCH) && CLUSTLIGHT_BATCH>0\nvarying vViewDepth: f32;\n#endif\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvar positionUpdated: vec3f=vertexInputs.position;\n#ifdef NORMAL\nvar normalUpdated: vec3f=vertexInputs.normal;\n#endif\n#ifdef TANGENT\nvar tangentUpdated: vec4f=vertexInputs.tangent;\n#endif\n#ifdef UV1\nvar uvUpdated: vec2f=vertexInputs.uv;\n#endif\n#ifdef UV2\nvar uv2Updated: vec2f=vertexInputs.uv2;\n#endif\n#ifdef VERTEXCOLOR\nvar colorUpdated: vec4f=vertexInputs.color;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvertexOutputs.vPositionUVW=positionUpdated;\n#endif\n#define CUSTOM_VERTEX_UPDATE_POSITION\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n#include<instancesVertex>\n#if defined(PREPASS) && ((defined(PREPASS_VELOCITY) || defined(PREPASS_VELOCITY_LINEAR)) && !defined(BONES_VELOCITY_ENABLED)\nvertexOutputs.vCurrentPosition=scene.viewProjection*finalWorld*vec4f(positionUpdated,1.0);vertexOutputs.vPreviousPosition=uniforms.previousViewProjection*finalPreviousWorld*vec4f(positionUpdated,1.0);\n#endif\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvar worldPos: vec4f=finalWorld*vec4f(positionUpdated,1.0);\n#ifdef NORMAL\nvar normalWorld: mat3x3f= mat3x3f(finalWorld[0].xyz,finalWorld[1].xyz,finalWorld[2].xyz);\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvertexOutputs.vNormalW=normalUpdated/ vec3f(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));vertexOutputs.vNormalW=normalize(normalWorld*vertexOutputs.vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\n#endif\nvertexOutputs.vNormalW=normalize(normalWorld*normalUpdated);\n#endif\n#endif\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {vertexOutputs.position=scene.viewProjection*worldPos;} else {vertexOutputs.position=scene.viewProjectionR*worldPos;}\n#else\nvertexOutputs.position=scene.viewProjection*worldPos;\n#endif\nvertexOutputs.vPositionW= worldPos.xyz;\n#ifdef PREPASS\n#include<prePassVertex>\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvertexOutputs.vDirectionW=normalize((finalWorld* vec4f(positionUpdated,0.0)).xyz);\n#endif\n#if defined(CLUSTLIGHT_BATCH) && CLUSTLIGHT_BATCH>0\nvertexOutputs.vViewDepth=(scene.view*worldPos).z;\n#endif\n#ifndef UV1\nvar uvUpdated: vec2f=vec2f(0.,0.);\n#endif\n#ifdef MAINUV1\nvertexOutputs.vMainUV1=uvUpdated;\n#endif\n#ifndef UV2\nvar uv2Updated: vec2f=vec2f(0.,0.);\n#endif\n#ifdef MAINUV2\nvertexOutputs.vMainUV2=uv2Updated;\n#endif\n#include<uvVariableDeclaration>[3..7]\n#include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)\n#if defined(SPECULARTERM)\n#include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)\n#endif\n#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_MATRIXNAME_,decal,_INFONAME_,DecalInfos.x)\n#include<bumpVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const defaultVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,wCAAwC,CAAC;AAChD,OAAO,yCAAyC,CAAC;AACjD,OAAO,kCAAkC,CAAC;AAC1C,OAAO,mCAAmC,CAAC;AAC3C,OAAO,kDAAkD,CAAC;AAC1D,OAAO,uCAAuC,CAAC;AAC/C,OAAO,2CAA2C,CAAC;AACnD,OAAO,2CAA2C,CAAC;AACnD,OAAO,2CAA2C,CAAC;AACnD,OAAO,wCAAwC,CAAC;AAChD,OAAO,6CAA6C,CAAC;AACrD,OAAO,uCAAuC,CAAC;AAC/C,OAAO,6CAA6C,CAAC;AACrD,OAAO,wCAAwC,CAAC;AAChD,OAAO,sDAAsD,CAAC;AAC9D,OAAO,gDAAgD,CAAC;AACxD,OAAO,sCAAsC,CAAC;AAC9C,OAAO,2CAA2C,CAAC;AACnD,OAAO,qCAAqC,CAAC;AAC7C,OAAO,kCAAkC,CAAC;AAC1C,OAAO,8BAA8B,CAAC;AACtC,OAAO,uCAAuC,CAAC;AAC/C,OAAO,gCAAgC,CAAC;AACxC,OAAO,wCAAwC,CAAC;AAChD,OAAO,8CAA8C,CAAC;AACtD,OAAO,6BAA6B,CAAC;AACrC,OAAO,kCAAkC,CAAC;AAC1C,OAAO,4BAA4B,CAAC;AACpC,OAAO,gCAAgC,CAAC;AACxC,OAAO,oCAAoC,CAAC;AAC5C,OAAO,iCAAiC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEzC,MAAM,IAAI,GAAG,qBAAqB,CAAC;AACnC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqJd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,uBAAuB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 3999, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/greasedLine.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/greasedLine.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"greasedLinePixelShader\";\nconst shader = `var grlColors: texture_2d<f32>;var grlColorsSampler: sampler;uniform grlUseColors: f32;uniform grlUseDash: f32;uniform grlDashArray: f32;uniform grlDashOffset: f32;uniform grlDashRatio: f32;uniform grlVisibility: f32;uniform grlColorsWidth: f32;uniform grl_colorModeAndColorDistributionType: vec2f;uniform grlColor: vec3f;varying grlCounters: f32;varying grlColorPointer: f32;\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\nlet grlColorMode: f32=uniforms.grl_colorModeAndColorDistributionType.x;let grlColorDistributionType: f32=uniforms.grl_colorModeAndColorDistributionType.y;var outColor=vec4(uniforms.grlColor,1.);outColor.a=step(fragmentInputs.grlCounters,uniforms.grlVisibility);if (outColor.a==0.0) {discard;}\nif (uniforms.grlUseDash==1.0) {let dashPosition=(fragmentInputs.grlCounters+uniforms.grlDashOffset) % uniforms.grlDashArray;outColor.a*=ceil(dashPosition-(uniforms.grlDashArray*uniforms.grlDashRatio));if (outColor.a==0.0) {discard;}}\nif (uniforms.grlUseColors==1.) {\n#ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\nlet grlColor: vec4f=textureSample(grlColors,grlColorsSampler,vec2f(fragmentInputs.grlCounters,0.));\n#else\nlet lookup: vec2f=vec2(fract(fragmentInputs.grlColorPointer/uniforms.grlColorsWidth),1.0-floor(fragmentInputs.grlColorPointer/uniforms.grlColorsWidth));let grlColor: vec4f=textureSample(grlColors,grlColorsSampler,lookup);\n#endif\nif (grlColorMode==COLOR_MODE_SET) {outColor=grlColor;} else if (grlColorMode==COLOR_MODE_ADD) {outColor+=grlColor;} else if (grlColorMode==COLOR_MODE_MULTIPLY) {outColor*=grlColor;}}\n#if !defined(PREPASS) && !defined(ORDER_INDEPENDENT_TRANSPARENCY)\nfragmentOutputs.color=outColor;\n#endif\n#if ORDER_INDEPENDENT_TRANSPARENCY\nif (fragDepth==nearestDepth) {fragmentOutputs.frontColor=vec4f(fragmentOutputs.frontColor.rgb+outColor.rgb*outColor.a*alphaMultiplier,1.0-alphaMultiplier*(1.0-outColor.a));} else {fragmentOutputs.backColor+=outColor;}\n#endif\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const greasedLinePixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,wBAAwB,CAAC;AACtC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;CAsBd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,0BAA0B,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 4042, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/greasedLine.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/greasedLine.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/sceneUboDeclaration\";\nimport \"./ShadersInclude/meshUboDeclaration\";\nimport \"./ShadersInclude/instancesVertex\";\n\nconst name = \"greasedLineVertexShader\";\nconst shader = `#include<instancesDeclaration>\n#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\nattribute grl_widths: f32;\n#ifdef GREASED_LINE_USE_OFFSETS\nattribute grl_offsets: vec3f; \n#endif\nattribute grl_colorPointers: f32;attribute position: vec3f;varying grlCounters: f32;varying grlColorPointer: f32;\n#ifdef GREASED_LINE_CAMERA_FACING\nattribute grl_nextAndCounters: vec4f;attribute grl_previousAndSide: vec4f;uniform grlResolution: vec2f;uniform grlAspect: f32;uniform grlWidth: f32;uniform grlSizeAttenuation: f32;fn grlFix(i: vec4f,aspect: f32)->vec2f {var res=i.xy/i.w;res.x*=aspect;return res;}\n#else\nattribute grl_slopes: vec3f;attribute grl_counters: f32;\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\nvertexOutputs.grlColorPointer=input.grl_colorPointers;let grlMatrix: mat4x4f=scene.viewProjection*mesh.world ;\n#ifdef GREASED_LINE_CAMERA_FACING\nlet grlBaseWidth: f32=uniforms.grlWidth;let grlPrevious: vec3f=input.grl_previousAndSide.xyz;let grlSide: f32=input.grl_previousAndSide.w;let grlNext: vec3f=input.grl_nextAndCounters.xyz;vertexOutputs.grlCounters=input.grl_nextAndCounters.w;let grlWidth:f32=grlBaseWidth*input.grl_widths;\n#ifdef GREASED_LINE_USE_OFFSETS\nvar grlPositionOffset: vec3f=input.grl_offsets;\n#else\nvar grlPositionOffset=vec3f(0.);\n#endif\nlet positionUpdated: vec3f=vertexInputs.position+grlPositionOffset;let worldDir: vec3f=normalize(grlNext-grlPrevious);let nearPosition: vec3f=positionUpdated+(worldDir*0.001);let grlFinalPosition: vec4f=grlMatrix*vec4f(positionUpdated,1.0);let screenNearPos: vec4f=grlMatrix*vec4(nearPosition,1.0);let grlLinePosition: vec2f=grlFix(grlFinalPosition,uniforms.grlAspect);let grlLineNearPosition: vec2f=grlFix(screenNearPos,uniforms.grlAspect);let grlDir: vec2f=normalize(grlLineNearPosition-grlLinePosition);var grlNormal: vec4f=vec4f(-grlDir.y,grlDir.x,0.0,1.0);let grlHalfWidth: f32=0.5*grlWidth;\n#if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\ngrlNormal.x*=-grlHalfWidth;grlNormal.y*=-grlHalfWidth;\n#else\ngrlNormal.x*=grlHalfWidth;grlNormal.y*=grlHalfWidth;\n#endif\ngrlNormal*=scene.projection;if (uniforms.grlSizeAttenuation==1.) {grlNormal.x*=grlFinalPosition.w;grlNormal.y*=grlFinalPosition.w;let pr=vec4f(uniforms.grlResolution,0.0,1.0)*scene.projection;grlNormal.x/=pr.x;grlNormal.y/=pr.y;}\nvertexOutputs.position=vec4f(grlFinalPosition.xy+grlNormal.xy*grlSide,grlFinalPosition.z,grlFinalPosition.w);\n#else\nvertexOutputs.grlCounters=input.grl_counters;vertexOutputs.position=grlMatrix*vec4f((vertexInputs.position+input.grl_offsets)+input.grl_slopes*input.grl_widths,1.0) ;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const greasedLineVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,uCAAuC,CAAC;AAC/C,OAAO,sCAAsC,CAAC;AAC9C,OAAO,qCAAqC,CAAC;AAC7C,OAAO,kCAAkC,CAAC;;;;;;AAE1C,MAAM,IAAI,GAAG,yBAAyB,CAAC;AACvC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuCd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,2BAA2B,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 4110, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/color.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/color.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nimport \"./ShadersInclude/fogFragment\";\n\nconst name = \"colorPixelShader\";\nconst shader = `#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\n#define VERTEXCOLOR\nvarying vColor: vec4f;\n#else\nuniform color: vec4f;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nfragmentOutputs.color=input.vColor;\n#else\nfragmentOutputs.color=uniforms.color;\n#endif\n#include<fogFragment>(color,fragmentOutputs.color)\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const colorPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,+CAA+C,CAAC;AACvD,OAAO,yCAAyC,CAAC;AACjD,OAAO,oCAAoC,CAAC;AAC5C,OAAO,8BAA8B,CAAC;;;;;;AAEtC,MAAM,IAAI,GAAG,kBAAkB,CAAC;AAChC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;EAoBb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,oBAAoB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 4159, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/color.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/color.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/fogVertexDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/fogVertex\";\nimport \"./ShadersInclude/vertexColorMixing\";\n\nconst name = \"colorVertexShader\";\nconst shader = `attribute position: vec3f;\n#ifdef VERTEXCOLOR\nattribute color: vec4f;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#ifdef FOG\nuniform view: mat4x4f;\n#endif\n#include<instancesDeclaration>\nuniform viewProjection: mat4x4f;\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vColor: vec4f;\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#ifdef VERTEXCOLOR\nvar colorUpdated: vec4f=vertexInputs.color;\n#endif\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvar worldPos: vec4f=finalWorld* vec4f(input.position,1.0);vertexOutputs.position=uniforms.viewProjection*worldPos;\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<vertexColorMixing>\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const colorVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,mCAAmC,CAAC;AAC3C,OAAO,kDAAkD,CAAC;AAC1D,OAAO,6CAA6C,CAAC;AACrD,OAAO,uCAAuC,CAAC;AAC/C,OAAO,uCAAuC,CAAC;AAC/C,OAAO,kCAAkC,CAAC;AAC1C,OAAO,8BAA8B,CAAC;AACtC,OAAO,uCAAuC,CAAC;AAC/C,OAAO,kCAAkC,CAAC;AAC1C,OAAO,4BAA4B,CAAC;AACpC,OAAO,oCAAoC,CAAC;;;;;;;;;;;;;AAE5C,MAAM,IAAI,GAAG,mBAAmB,CAAC;AACjC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA+Bb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,qBAAqB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 4233, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/meshUVSpaceRenderer.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/meshUVSpaceRenderer.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal\";\nimport \"./ShadersInclude/morphTargetsVertex\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\n\nconst name = \"meshUVSpaceRendererVertexShader\";\nconst shader = `attribute position: vec3f;attribute normal: vec3f;attribute uv: vec2f;uniform projMatrix: mat4x4f;varying vDecalTC: vec2f;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<instancesDeclaration>\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {var positionUpdated: vec3f=input.position;var normalUpdated: vec3f=input.normal;\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvar worldPos: vec4f=finalWorld* vec4f(positionUpdated,1.0);var normWorldSM: mat3x3f= mat3x3f(finalWorld[0].xyz,finalWorld[1].xyz,finalWorld[2].xyz);var vNormalW: vec3f;\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvNormalW=normalUpdated/ vec3f(dot(normWorldSM[0],normWorldSM[0]),dot(normWorldSM[1],normWorldSM[1]),dot(normWorldSM[2],normWorldSM[2]));vNormalW=normalize(normWorldSM*vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormWorldSM=transposeMat3(inverseMat3(normWorldSM));\n#endif\nvNormalW=normalize(normWorldSM*normalUpdated);\n#endif\nvar normalView: vec3f=normalize((uniforms.projMatrix* vec4f(vNormalW,0.0)).xyz);var decalTC: vec3f=(uniforms.projMatrix*worldPos).xyz;vertexOutputs.vDecalTC=decalTC.xy;vertexOutputs.position=vec4f(input.uv*2.0-1.0,select(decalTC.z,2.,normalView.z>0.0),1.0);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const meshUVSpaceRendererVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,mCAAmC,CAAC;AAC3C,OAAO,kDAAkD,CAAC;AAC1D,OAAO,sDAAsD,CAAC;AAC9D,OAAO,gDAAgD,CAAC;AACxD,OAAO,uCAAuC,CAAC;AAC/C,OAAO,2CAA2C,CAAC;AACnD,OAAO,qCAAqC,CAAC;AAC7C,OAAO,kCAAkC,CAAC;AAC1C,OAAO,8BAA8B,CAAC;AACtC,OAAO,uCAAuC,CAAC;;;;;;;;;;;;AAE/C,MAAM,IAAI,GAAG,iCAAiC,CAAC;AAC/C,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;mQAsBoP,CAAC;AACpQ,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,mCAAmC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 4296, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/meshUVSpaceRenderer.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/meshUVSpaceRenderer.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"meshUVSpaceRendererPixelShader\";\nconst shader = `varying vDecalTC: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {if (input.vDecalTC.x<0. || input.vDecalTC.x>1. || input.vDecalTC.y<0. || input.vDecalTC.y>1.) {discard;}\nfragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,input.vDecalTC);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const meshUVSpaceRendererPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,gCAAgC,CAAC;AAC9C,MAAM,MAAM,GAAG,CAAA;;;CAGd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,kCAAkC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 4320, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/meshUVSpaceRendererMasker.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/meshUVSpaceRendererMasker.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"meshUVSpaceRendererMaskerVertexShader\";\nconst shader = `attribute uv: vec2f;varying vUV: vec2f;@vertex\nfn main(input : VertexInputs)->FragmentInputs {vertexOutputs.position= vec4f( vec2f(input.uv.x,input.uv.y)*2.0-1.0,0.,1.0);vertexOutputs.vUV=input.uv;}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const meshUVSpaceRendererMaskerVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,uCAAuC,CAAC;AACrD,MAAM,MAAM,GAAG,CAAA;wJACyI,CAAC;AACzJ,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,yCAAyC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 4342, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/meshUVSpaceRendererMasker.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/meshUVSpaceRendererMasker.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"meshUVSpaceRendererMaskerPixelShader\";\nconst shader = `varying vUV: vec2f;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color= vec4f(1.0,1.0,1.0,1.0);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const meshUVSpaceRendererMaskerPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,sCAAsC,CAAC;AACpD,MAAM,MAAM,GAAG,CAAA;;CAEd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,wCAAwC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 4365, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/meshUVSpaceRendererFinaliser.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/meshUVSpaceRendererFinaliser.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"meshUVSpaceRendererFinaliserPixelShader\";\nconst shader = `#define DISABLE_UNIFORMITY_ANALYSIS\nvarying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;var maskTextureSamplerSampler: sampler;var maskTextureSampler: texture_2d<f32>;uniform textureSize: vec2f;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var mask: vec4f=textureSample(maskTextureSampler,maskTextureSamplerSampler,input.vUV).rgba;if (mask.r>0.5) {fragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,input.vUV);} else {var texelSize: vec2f=4.0/uniforms.textureSize;var uv_p01: vec2f=input.vUV+ vec2f(-1.0,0.0)*texelSize;var uv_p21: vec2f=input.vUV+ vec2f(1.0,0.0)*texelSize;var uv_p10: vec2f=input.vUV+ vec2f(0.0,-1.0)*texelSize;var uv_p12: vec2f=input.vUV+ vec2f(0.0,1.0)*texelSize;var mask_p01: f32=textureSample(maskTextureSampler,maskTextureSamplerSampler,uv_p01).r;var mask_p21: f32=textureSample(maskTextureSampler,maskTextureSamplerSampler,uv_p21).r;var mask_p10: f32=textureSample(maskTextureSampler,maskTextureSamplerSampler,uv_p10).r;var mask_p12: f32=textureSample(maskTextureSampler,maskTextureSamplerSampler,uv_p12).r;var col: vec4f= vec4f(0.0,0.0,0.0,0.0);var total_weight: f32=0.0;if (mask_p01>0.5) {col+=textureSample(textureSampler,textureSamplerSampler,uv_p01);total_weight+=1.0;}\nif (mask_p21>0.5) {col+=textureSample(textureSampler,textureSamplerSampler,uv_p21);total_weight+=1.0;}\nif (mask_p10>0.5) {col+=textureSample(textureSampler,textureSamplerSampler,uv_p10);total_weight+=1.0;}\nif (mask_p12>0.5) {col+=textureSample(textureSampler,textureSamplerSampler,uv_p12);total_weight+=1.0;}\nif (total_weight>0.0) {fragmentOutputs.color=col/total_weight;} else {fragmentOutputs.color=col;}}}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const meshUVSpaceRendererFinaliserPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,yCAAyC,CAAC;AACvD,MAAM,MAAM,GAAG,CAAA;;;;;;;CAOd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,2CAA2C,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 4393, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/meshUVSpaceRendererFinaliser.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/meshUVSpaceRendererFinaliser.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"meshUVSpaceRendererFinaliserVertexShader\";\nconst shader = `attribute position: vec3f;attribute uv: vec2f;uniform worldViewProjection: mat4x4f;varying vUV: vec2f;@vertex\nfn main(input : VertexInputs)->FragmentInputs {vertexOutputs.position=uniforms.worldViewProjection* vec4f(input.position,1.0);vertexOutputs.positionvUV=input.uv;}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const meshUVSpaceRendererFinaliserVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,0CAA0C,CAAC;AACxD,MAAM,MAAM,GAAG,CAAA;;CAEd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,4CAA4C,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 4416, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/lodCube.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/lodCube.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"lodCubePixelShader\";\nconst shader = `const GammaEncodePowerApprox=1.0/2.2;varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_cube<f32>;uniform lod: f32;uniform gamma: i32;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {let uv=fragmentInputs.vUV*2.0-1.0;\n#ifdef POSITIVEX\nfragmentOutputs.color=textureSampleLevel(textureSampler,textureSamplerSampler,vec3f(1.001,uv.y,uv.x),uniforms.lod);\n#endif\n#ifdef NEGATIVEX\nfragmentOutputs.color=textureSampleLevel(textureSampler,textureSamplerSampler,vec3f(-1.001,uv.y,uv.x),uniforms.lod);\n#endif\n#ifdef POSITIVEY\nfragmentOutputs.color=textureSampleLevel(textureSampler,textureSamplerSampler,vec3f(uv.y,1.001,uv.x),uniforms.lod);\n#endif\n#ifdef NEGATIVEY\nfragmentOutputs.color=textureSampleLevel(textureSampler,textureSamplerSampler,vec3f(uv.y,-1.001,uv.x),uniforms.lod);\n#endif\n#ifdef POSITIVEZ\nfragmentOutputs.color=textureSampleLevel(textureSampler,textureSamplerSampler,vec3f(uv,1.001),uniforms.lod);\n#endif\n#ifdef NEGATIVEZ\nfragmentOutputs.color=textureSampleLevel(textureSampler,textureSamplerSampler,vec3f(uv,-1.001),uniforms.lod);\n#endif\nif (uniforms.gamma==0) {fragmentOutputs.color=vec4f(pow(fragmentOutputs.color.rgb,vec3f(GammaEncodePowerApprox)),fragmentOutputs.color.a);}}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const lodCubePixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,oBAAoB,CAAC;AAClC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;CAqBd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,sBAAsB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 4458, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/lod.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/lod.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"lodPixelShader\";\nconst shader = `const GammaEncodePowerApprox=1.0/2.2;varying vUV: vec2f;var textureSampler: texture_2d<f32>;uniform lod: f32;uniform gamma: i32;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {let textureSize=textureDimensions(textureSampler);fragmentOutputs.color=textureLoad(textureSampler,vec2u(fragmentInputs.vUV*vec2f(textureSize)),u32(uniforms.lod));if (uniforms.gamma==0) {fragmentOutputs.color=vec4f(pow(fragmentOutputs.color.rgb,vec3f(GammaEncodePowerApprox)),fragmentOutputs.color.a);}}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const lodPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,gBAAgB,CAAC;AAC9B,MAAM,MAAM,GAAG,CAAA;;CAEd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,kBAAkB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 4481, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/rgbdDecode.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/rgbdDecode.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\n\nconst name = \"rgbdDecodePixelShader\";\nconst shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;\n#include<helperFunctions>\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=vec4f(fromRGBD(textureSample(textureSampler,textureSamplerSampler,input.vUV)),1.0);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const rgbdDecodePixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,kCAAkC,CAAC;;;AAE1C,MAAM,IAAI,GAAG,uBAAuB,CAAC;AACrC,MAAM,MAAM,GAAG,CAAA;;;;4JAI6I,CAAC;AAC7J,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,yBAAyB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 4508, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/rgbdEncode.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/rgbdEncode.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\n\nconst name = \"rgbdEncodePixelShader\";\nconst shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;\n#include<helperFunctions>\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=toRGBD(textureSample(textureSampler,textureSamplerSampler,input.vUV).rgb);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const rgbdEncodePixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,kCAAkC,CAAC;;;AAE1C,MAAM,IAAI,GAAG,uBAAuB,CAAC;AACrC,MAAM,MAAM,GAAG,CAAA;;;;mJAIoI,CAAC;AACpJ,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,yBAAyB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 4535, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/copyTextureToTexture.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/copyTextureToTexture.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\n\nconst name = \"copyTextureToTexturePixelShader\";\nconst shader = `uniform conversion: f32;\n#ifndef NO_SAMPLER\nvar textureSamplerSampler: sampler;\n#endif\nvar textureSampler: texture_2d<f32>;uniform lodLevel : f32;varying vUV: vec2f;\n#include<helperFunctions>\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#ifdef NO_SAMPLER\nvar color: vec4f=textureLoad(textureSampler,vec2u(fragmentInputs.position.xy),u32(uniforms.lodLevel));\n#else\nvar color: vec4f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV,uniforms.lodLevel);\n#endif\n#ifdef DEPTH_TEXTURE\nfragmentOutputs.fragDepth=color.r;\n#else\nif (uniforms.conversion==1.) {color=toLinearSpaceVec4(color);} else if (uniforms.conversion==2.) {color=toGammaSpace(color);}\nfragmentOutputs.color=color;\n#endif\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const copyTextureToTexturePixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,kCAAkC,CAAC;;;AAE1C,MAAM,IAAI,GAAG,iCAAiC,CAAC;AAC/C,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;CAoBd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,mCAAmC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 4578, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/gpuUpdateParticles.compute.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/gpuUpdateParticles.compute.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"gpuUpdateParticlesComputeShader\";\nconst shader = `struct Particle {position : vec3<f32>,\nage : f32,\nsize : vec3<f32>,\nlife : f32,\nseed : vec4<f32>,\ndirection : vec3<f32>,\ndummy0: f32,\n#ifdef CUSTOMEMITTER\ninitialPosition : vec3<f32>,\ndummy1: f32,\n#endif\n#ifndef COLORGRADIENTS\ncolor : vec4<f32>,\n#endif\n#ifndef BILLBOARD\ninitialDirection : vec3<f32>,\ndummy2: f32,\n#endif\n#ifdef NOISE\nnoiseCoordinates1 : vec3<f32>,\ndummy3: f32,\nnoiseCoordinates2 : vec3<f32>,\ndummy4: f32,\n#endif\n#ifdef ANGULARSPEEDGRADIENTS\nangle : f32,\n#else\nangle : vec2<f32>,\n#endif\n#ifdef ANIMATESHEET\ncellIndex : f32,\n#ifdef ANIMATESHEETRANDOMSTART\ncellStartOffset : f32,\n#endif\n#endif\n};struct Particles {particles : array<Particle>,};struct SimParams {currentCount : f32,\ntimeDelta : f32,\nstopFactor : f32,\nrandomTextureSize: i32,\nlifeTime : vec2<f32>,\nemitPower : vec2<f32>,\n#ifndef COLORGRADIENTS\ncolor1 : vec4<f32>,\ncolor2 : vec4<f32>,\n#endif\nsizeRange : vec2<f32>,\nscaleRange : vec4<f32>,\nangleRange : vec4<f32>,\ngravity : vec3<f32>,\n#ifdef LIMITVELOCITYGRADIENTS\nlimitVelocityDamping : f32,\n#endif\n#ifdef ANIMATESHEET\ncellInfos : vec4<f32>,\n#endif\n#ifdef NOISE\nnoiseStrength : vec3<f32>,\n#endif\n#ifdef FLOWMAP\nflowMapProjection : mat4x4<f32>,\nflowMapStrength : f32,\n#endif\n#ifndef LOCAL\nemitterWM : mat4x4<f32>,\n#endif\n#ifdef BOXEMITTER\ndirection1 : vec3<f32>,\ndirection2 : vec3<f32>,\nminEmitBox : vec3<f32>,\nmaxEmitBox : vec3<f32>,\n#endif\n#ifdef CONEEMITTER\nradius : vec2<f32>,\nconeAngle : f32,\nheight : vec2<f32>,\n#ifdef DIRECTEDCONEEMITTER\ndirection1 : vec3<f32>,\ndirection2 : vec3<f32>,\n#else\ndirectionRandomizer : f32,\n#endif\n#endif\n#ifdef CYLINDEREMITTER\nradius : f32,\nheight : f32,\nradiusRange : f32,\n#ifdef DIRECTEDCYLINDEREMITTER\ndirection1 : vec3<f32>,\ndirection2 : vec3<f32>,\n#else\ndirectionRandomizer : f32,\n#endif\n#endif\n#ifdef HEMISPHERICEMITTER\nradius : f32,\nradiusRange : f32,\ndirectionRandomizer : f32,\n#endif\n#ifdef POINTEMITTER\ndirection1 : vec3<f32>,\ndirection2 : vec3<f32>,\n#endif\n#ifdef SPHEREEMITTER\nradius : f32,\nradiusRange : f32,\n#ifdef DIRECTEDSPHEREEMITTER\ndirection1 : vec3<f32>,\ndirection2 : vec3<f32>,\n#else\ndirectionRandomizer : f32,\n#endif\n#endif\n};@binding(0) @group(0) var<uniform> params : SimParams;@binding(1) @group(0) var<storage,read> particlesIn : Particles;@binding(2) @group(0) var<storage,read_write> particlesOut : Particles;@binding(3) @group(0) var randomTexture : texture_2d<f32>;@binding(4) @group(0) var randomTexture2 : texture_2d<f32>;\n#ifdef SIZEGRADIENTS\n@binding(0) @group(1) var sizeGradientSampler : sampler;@binding(1) @group(1) var sizeGradientTexture : texture_2d<f32>;\n#endif \n#ifdef ANGULARSPEEDGRADIENTS\n@binding(2) @group(1) var angularSpeedGradientSampler : sampler;@binding(3) @group(1) var angularSpeedGradientTexture : texture_2d<f32>;\n#endif \n#ifdef VELOCITYGRADIENTS\n@binding(4) @group(1) var velocityGradientSampler : sampler;@binding(5) @group(1) var velocityGradientTexture : texture_2d<f32>;\n#endif\n#ifdef LIMITVELOCITYGRADIENTS\n@binding(6) @group(1) var limitVelocityGradientSampler : sampler;@binding(7) @group(1) var limitVelocityGradientTexture : texture_2d<f32>;\n#endif\n#ifdef DRAGGRADIENTS\n@binding(8) @group(1) var dragGradientSampler : sampler;@binding(9) @group(1) var dragGradientTexture : texture_2d<f32>;\n#endif\n#ifdef NOISE\n@binding(10) @group(1) var noiseSampler : sampler;@binding(11) @group(1) var noiseTexture : texture_2d<f32>;\n#endif\n#ifdef FLOWMAP\n@binding(12) @group(1) var flowMapSampler : sampler;@binding(13) @group(1) var flowMapTexture : texture_2d<f32>;\n#endif\nfn getRandomVec3(offset : f32,vertexID : f32)->vec3<f32> {return textureLoad(randomTexture2,vec2<i32>(i32(vertexID*offset/params.currentCount*f32(params.randomTextureSize)) % params.randomTextureSize,0),0).rgb;}\nfn getRandomVec4(offset : f32,vertexID : f32)->vec4<f32> {return textureLoad(randomTexture,vec2<i32>(i32(vertexID*offset/params.currentCount*f32(params.randomTextureSize)) % params.randomTextureSize,0),0);}\n@compute @workgroup_size(64)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {let index : u32=GlobalInvocationID.x;let vertexID : f32=f32(index);if (index>=u32(params.currentCount)) {return;}\nlet PI : f32=3.14159;let timeDelta : f32=params.timeDelta;let newAge : f32=particlesIn.particles[index].age+timeDelta;let life : f32=particlesIn.particles[index].life;let seed : vec4<f32>=particlesIn.particles[index].seed;let direction : vec3<f32>=particlesIn.particles[index].direction;if (newAge>=life && params.stopFactor != 0.) {var newPosition : vec3<f32>;var newDirection : vec3<f32>;let randoms : vec4<f32>=getRandomVec4(seed.x,vertexID);let outLife : f32=params.lifeTime.x+(params.lifeTime.y-params.lifeTime.x)*randoms.r;particlesOut.particles[index].life=outLife;particlesOut.particles[index].age=newAge-life;particlesOut.particles[index].seed=seed;var sizex : f32;\n#ifdef SIZEGRADIENTS \nsizex=textureSampleLevel(sizeGradientTexture,sizeGradientSampler,vec2<f32>(0.,0.),0.).r;\n#else\nsizex=params.sizeRange.x+(params.sizeRange.y-params.sizeRange.x)*randoms.g;\n#endif\nparticlesOut.particles[index].size=vec3<f32>(\nsizex,\nparams.scaleRange.x+(params.scaleRange.y-params.scaleRange.x)*randoms.b,\nparams.scaleRange.z+(params.scaleRange.w-params.scaleRange.z)*randoms.a);\n#ifndef COLORGRADIENTS\nparticlesOut.particles[index].color=params.color1+(params.color2-params.color1)*randoms.b;\n#endif\n#ifndef ANGULARSPEEDGRADIENTS \nparticlesOut.particles[index].angle=vec2<f32>(\nparams.angleRange.z+(params.angleRange.w-params.angleRange.z)*randoms.r,\nparams.angleRange.x+(params.angleRange.y-params.angleRange.x)*randoms.a);\n#else\nparticlesOut.particles[index].angle=params.angleRange.z+(params.angleRange.w-params.angleRange.z)*randoms.r;\n#endif \n#if defined(POINTEMITTER)\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);let randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);newPosition=vec3<f32>(0.,0.,0.);newDirection=params.direction1+(params.direction2-params.direction1)*randoms3;\n#elif defined(BOXEMITTER)\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);let randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);newPosition=params.minEmitBox+(params.maxEmitBox-params.minEmitBox)*randoms2;newDirection=params.direction1+(params.direction2-params.direction1)*randoms3; \n#elif defined(HEMISPHERICEMITTER)\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);let randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);let phi : f32=2.0*PI*randoms2.x;let theta : f32=acos(-1.0+2.0*randoms2.y);let randX : f32=cos(phi)*sin(theta);let randY : f32=cos(theta);let randZ : f32=sin(phi)*sin(theta);newPosition=(params.radius-(params.radius*params.radiusRange*randoms2.z))*vec3<f32>(randX,abs(randY),randZ);newDirection=normalize(newPosition+params.directionRandomizer*randoms3);\n#elif defined(SPHEREEMITTER)\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);let randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);let phi : f32=2.0*PI*randoms2.x;let theta : f32=acos(-1.0+2.0*randoms2.y);let randX : f32=cos(phi)*sin(theta);let randY : f32=cos(theta);let randZ : f32=sin(phi)*sin(theta);newPosition=(params.radius-(params.radius*params.radiusRange*randoms2.z))*vec3<f32>(randX,randY,randZ);\n#ifdef DIRECTEDSPHEREEMITTER\nnewDirection=normalize(params.direction1+(params.direction2-params.direction1)*randoms3);\n#else\nnewDirection=normalize(newPosition+params.directionRandomizer*randoms3);\n#endif\n#elif defined(CYLINDEREMITTER)\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);let randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);let yPos : f32=(-0.5+randoms2.x)*params.height;var angle : f32=randoms2.y*PI*2.;let inverseRadiusRangeSquared : f32=(1.-params.radiusRange)*(1.-params.radiusRange);let positionRadius : f32=params.radius*sqrt(inverseRadiusRangeSquared+randoms2.z*(1.-inverseRadiusRangeSquared));let xPos : f32=positionRadius*cos(angle);let zPos : f32=positionRadius*sin(angle);newPosition=vec3<f32>(xPos,yPos,zPos);\n#ifdef DIRECTEDCYLINDEREMITTER\nnewDirection=params.direction1+(params.direction2-params.direction1)*randoms3;\n#else\nangle=angle+(-0.5+randoms3.x)*PI*params.directionRandomizer;newDirection=vec3<f32>(cos(angle),(-0.5+randoms3.y)*params.directionRandomizer,sin(angle));newDirection=normalize(newDirection);\n#endif\n#elif defined(CONEEMITTER)\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);let s : f32=2.0*PI*randoms2.x;\n#ifdef CONEEMITTERSPAWNPOINT\nlet h : f32=0.0001;\n#else\nvar h : f32=randoms2.y*params.height.y;h=1.-h*h; \n#endif\nvar lRadius : f32=params.radius.x-params.radius.x*randoms2.z*params.radius.y;lRadius=lRadius*h;let randX : f32=lRadius*sin(s);let randZ : f32=lRadius*cos(s);let randY : f32=h *params.height.x;newPosition=vec3<f32>(randX,randY,randZ); \nlet randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);\n#ifdef DIRECTEDCONEEMITTER\nnewDirection=params.direction1+(params.direction2-params.direction1)*randoms3;\n#else\nif (abs(cos(params.coneAngle))==1.0) {newDirection=vec3<f32>(0.,1.0,0.);} else {newDirection=normalize(newPosition+params.directionRandomizer*randoms3); }\n#endif\n#elif defined(CUSTOMEMITTER)\nnewPosition=particlesIn.particles[index].initialPosition;particlesOut.particles[index].initialPosition=newPosition;\n#else \nnewPosition=vec3<f32>(0.,0.,0.);newDirection=2.0*(getRandomVec3(seed.w,vertexID)-vec3<f32>(0.5,0.5,0.5));\n#endif\nlet power : f32=params.emitPower.x+(params.emitPower.y-params.emitPower.x)*randoms.a;\n#ifdef LOCAL\nparticlesOut.particles[index].position=newPosition;\n#else\nparticlesOut.particles[index].position=(params.emitterWM*vec4<f32>(newPosition,1.)).xyz;\n#endif\n#ifdef CUSTOMEMITTER\nparticlesOut.particles[index].direction=direction;\n#ifndef BILLBOARD \nparticlesOut.particles[index].initialDirection=direction;\n#endif\n#else\n#ifdef LOCAL\nlet initial : vec3<f32>=newDirection;\n#else \nlet initial : vec3<f32>=(params.emitterWM*vec4<f32>(newDirection,0.)).xyz;\n#endif\nparticlesOut.particles[index].direction=initial*power;\n#ifndef BILLBOARD \nparticlesOut.particles[index].initialDirection=initial;\n#endif\n#endif\n#ifdef ANIMATESHEET \nparticlesOut.particles[index].cellIndex=params.cellInfos.x;\n#ifdef ANIMATESHEETRANDOMSTART\nparticlesOut.particles[index].cellStartOffset=randoms.a*outLife;\n#endif \n#endif\n#ifdef NOISE\nparticlesOut.particles[index].noiseCoordinates1=particlesIn.particles[index].noiseCoordinates1;particlesOut.particles[index].noiseCoordinates2=particlesIn.particles[index].noiseCoordinates2;\n#endif\n} else {var directionScale : f32=timeDelta;particlesOut.particles[index].age=newAge;let ageGradient : f32=newAge/life;\n#ifdef VELOCITYGRADIENTS\ndirectionScale=directionScale*textureSampleLevel(velocityGradientTexture,velocityGradientSampler,vec2<f32>(ageGradient,0.),0.).r;\n#endif\n#ifdef DRAGGRADIENTS\ndirectionScale=directionScale*(1.0-textureSampleLevel(dragGradientTexture,dragGradientSampler,vec2<f32>(ageGradient,0.),0.).r);\n#endif\nlet position : vec3<f32>=particlesIn.particles[index].position;\n#if defined(CUSTOMEMITTER)\nparticlesOut.particles[index].position=position+(direction-position)*ageGradient; \nparticlesOut.particles[index].initialPosition=particlesIn.particles[index].initialPosition;\n#else\nparticlesOut.particles[index].position=position+direction*directionScale;\n#endif\nparticlesOut.particles[index].life=life;particlesOut.particles[index].seed=seed;\n#ifndef COLORGRADIENTS \nparticlesOut.particles[index].color=particlesIn.particles[index].color;\n#endif\n#ifdef SIZEGRADIENTS\nparticlesOut.particles[index].size=vec3<f32>(\ntextureSampleLevel(sizeGradientTexture,sizeGradientSampler,vec2<f32>(ageGradient,0.),0.).r,\nparticlesIn.particles[index].size.yz);\n#else\nparticlesOut.particles[index].size=particlesIn.particles[index].size;\n#endif \n#ifndef BILLBOARD \nparticlesOut.particles[index].initialDirection=particlesIn.particles[index].initialDirection;\n#endif\n#ifdef CUSTOMEMITTER\nparticlesOut.particles[index].direction=direction;\n#else\nvar updatedDirection : vec3<f32>=direction+params.gravity*timeDelta;\n#ifdef FLOWMAP\nvar clipSpace=(params.flowMapProjection*vec4f(position,1.));var ndcSpace=clipSpace.xyz/clipSpace.w;var flowMapUV=ndcSpace.xy*0.5+0.5;var flowMapValue=textureSampleLevel(flowMapTexture,flowMapSampler,flowMapUV,0.);var flowMapDirection=(flowMapValue.xyz*2.0-1.0)*flowMapValue.w;updatedDirection+=flowMapDirection*timeDelta*params.flowMapStrength;\n#endif\n#ifdef LIMITVELOCITYGRADIENTS\nlet limitVelocity : f32=textureSampleLevel(limitVelocityGradientTexture,limitVelocityGradientSampler,vec2<f32>(ageGradient,0.),0.).r;let currentVelocity : f32=length(updatedDirection);if (currentVelocity>limitVelocity) {updatedDirection=updatedDirection*params.limitVelocityDamping;}\n#endif\nparticlesOut.particles[index].direction=updatedDirection;\n#ifdef NOISE\nlet noiseCoordinates1 : vec3<f32>=particlesIn.particles[index].noiseCoordinates1;let noiseCoordinates2 : vec3<f32>=particlesIn.particles[index].noiseCoordinates2;let fetchedR : f32=textureSampleLevel(noiseTexture,noiseSampler,vec2<f32>(noiseCoordinates1.x,noiseCoordinates1.y)*vec2<f32>(0.5,0.5)+vec2<f32>(0.5,0.5),0.).r;let fetchedG : f32=textureSampleLevel(noiseTexture,noiseSampler,vec2<f32>(noiseCoordinates1.z,noiseCoordinates2.x)*vec2<f32>(0.5,0.5)+vec2<f32>(0.5,0.5),0.).r;let fetchedB : f32=textureSampleLevel(noiseTexture,noiseSampler,vec2<f32>(noiseCoordinates2.y,noiseCoordinates2.z)*vec2<f32>(0.5,0.5)+vec2<f32>(0.5,0.5),0.).r;let force : vec3<f32>=vec3<f32>(-1.+2.*fetchedR,-1.+2.*fetchedG,-1.+2.*fetchedB)*params.noiseStrength;particlesOut.particles[index].direction=particlesOut.particles[index].direction+force*timeDelta;particlesOut.particles[index].noiseCoordinates1=noiseCoordinates1;particlesOut.particles[index].noiseCoordinates2=noiseCoordinates2;\n#endif \n#endif \n#ifdef ANGULARSPEEDGRADIENTS\nlet angularSpeed : f32=textureSampleLevel(angularSpeedGradientTexture,angularSpeedGradientSampler,vec2<f32>(ageGradient,0.),0.).r;particlesOut.particles[index].angle=particlesIn.particles[index].angle+angularSpeed*timeDelta;\n#else\nlet angle : vec2<f32>=particlesIn.particles[index].angle;particlesOut.particles[index].angle=vec2<f32>(angle.x+angle.y*timeDelta,angle.y);\n#endif\n#ifdef ANIMATESHEET \nvar offsetAge : f32=particlesOut.particles[index].age;let dist : f32=params.cellInfos.y-params.cellInfos.x;\n#ifdef ANIMATESHEETRANDOMSTART\nlet cellStartOffset : f32=particlesIn.particles[index].cellStartOffset;particlesOut.particles[index].cellStartOffset=cellStartOffset;offsetAge=offsetAge+cellStartOffset;\n#else\nlet cellStartOffset : f32=0.;\n#endif \nvar ratio : f32;if (params.cellInfos.w==1.0) {ratio=clamp(((cellStartOffset+params.cellInfos.z*offsetAge) % life)/life,0.,1.0);}\nelse {ratio=clamp((cellStartOffset+params.cellInfos.z*offsetAge)/life,0.,1.0);}\nparticlesOut.particles[index].cellIndex=f32(i32(params.cellInfos.x+ratio*dist));\n#endif\n}}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const gpuUpdateParticlesComputeShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,iCAAiC,CAAC;AAC/C,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgSd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,mCAAmC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 4887, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/particles.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/particles.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/imageProcessingDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/imageProcessingFunctions\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nimport \"./ShadersInclude/logDepthFragment\";\nimport \"./ShadersInclude/fogFragment\";\n\nconst name = \"particlesPixelShader\";\nconst shader = `varying vUV: vec2f;varying vColor: vec4f;uniform textureMask: vec4f;var diffuseSamplerSampler: sampler;var diffuseSampler: texture_2d<f32>;\n#include<clipPlaneFragmentDeclaration>\n#include<imageProcessingDeclaration>\n#include<logDepthDeclaration>\n#include<helperFunctions>\n#include<imageProcessingFunctions>\n#ifdef RAMPGRADIENT\nvarying remapRanges: vec4f;var rampSamplerSampler: sampler;var rampSampler: texture_2d<f32>;\n#endif\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvar textureColor: vec4f=textureSample(diffuseSampler,diffuseSamplerSampler,input.vUV);var baseColor: vec4f=(textureColor*uniforms.textureMask+( vec4f(1.,1.,1.,1.)-uniforms.textureMask))*input.vColor;\n#ifdef RAMPGRADIENT\nvar alpha: f32=baseColor.a;var remappedColorIndex: f32=clamp((alpha-input.remapRanges.x)/input.remapRanges.y,0.0,1.0);var rampColor: vec4f=textureSample(rampSampler,rampSamplerSampler,vec2f(1.0-remappedColorIndex,0.));baseColor=vec4f(baseColor.rgb*rampColor.rgb,baseColor.a);var finalAlpha: f32=baseColor.a;baseColor.a=clamp((alpha*rampColor.a-input.remapRanges.z)/input.remapRanges.w,0.0,1.0);\n#endif\n#ifdef BLENDMULTIPLYMODE\nvar sourceAlpha: f32=input.vColor.a*textureColor.a;baseColor=vec4f(baseColor.rgb*sourceAlpha+ vec3f(1.0)*(1.0-sourceAlpha),baseColor.a);\n#endif\n#include<logDepthFragment>\n#include<fogFragment>(color,baseColor)\n#ifdef IMAGEPROCESSINGPOSTPROCESS\nbaseColor=vec4f(toLinearSpaceVec3(baseColor.rgb),baseColor.a);\n#else\n#ifdef IMAGEPROCESSING\nbaseColor=vec4f(toLinearSpaceVec3(baseColor.rgb),baseColor.a);baseColor=applyImageProcessing(baseColor);\n#endif\n#endif\nfragmentOutputs.color=baseColor;\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const particlesPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,+CAA+C,CAAC;AACvD,OAAO,6CAA6C,CAAC;AACrD,OAAO,sCAAsC,CAAC;AAC9C,OAAO,kCAAkC,CAAC;AAC1C,OAAO,2CAA2C,CAAC;AACnD,OAAO,yCAAyC,CAAC;AACjD,OAAO,oCAAoC,CAAC;AAC5C,OAAO,mCAAmC,CAAC;AAC3C,OAAO,8BAA8B,CAAC;;;;;;;;;;;AAEtC,MAAM,IAAI,GAAG,sBAAsB,CAAC;AACpC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAiCb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,wBAAwB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 4959, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/particles.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/particles.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/fogVertexDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/fogVertex\";\nimport \"./ShadersInclude/logDepthVertex\";\n\nconst name = \"particlesVertexShader\";\nconst shader = `attribute position: vec3f;attribute color: vec4f;attribute angle: f32;attribute size: vec2f;\n#ifdef ANIMATESHEET\nattribute cellIndex: f32;\n#endif\n#ifndef BILLBOARD\nattribute direction: vec3f;\n#endif\n#ifdef BILLBOARDSTRETCHED\nattribute direction: vec3f;\n#endif\n#ifdef RAMPGRADIENT\nattribute remapData: vec4f;\n#endif\nattribute offset: vec2f;uniform view: mat4x4f;uniform projection: mat4x4f;uniform translationPivot: vec2f;\n#ifdef ANIMATESHEET\nuniform particlesInfos: vec3f; \n#endif\nvarying vUV: vec2f;varying vColor: vec4f;\n#ifdef RAMPGRADIENT\nvarying remapRanges: vec4f;\n#endif\n#if defined(BILLBOARD) && !defined(BILLBOARDY) && !defined(BILLBOARDSTRETCHED)\nuniform invView: mat4x4f;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<logDepthDeclaration>\n#ifdef BILLBOARD\nuniform eyePosition: vec3f;\n#endif\nfn rotate(yaxis: vec3f,rotatedCorner: vec3f)->vec3f {var xaxis: vec3f=normalize(cross( vec3f(0.,1.0,0.),yaxis));var zaxis: vec3f=normalize(cross(yaxis,xaxis));var row0: vec3f= vec3f(xaxis.x,xaxis.y,xaxis.z);var row1: vec3f= vec3f(yaxis.x,yaxis.y,yaxis.z);var row2: vec3f= vec3f(zaxis.x,zaxis.y,zaxis.z);var rotMatrix: mat3x3f= mat3x3f(row0,row1,row2);var alignedCorner: vec3f=rotMatrix*rotatedCorner;return vertexInputs.position+alignedCorner;}\n#ifdef BILLBOARDSTRETCHED\nfn rotateAlign(toCamera: vec3f,rotatedCorner: vec3f)->vec3f {var normalizedToCamera: vec3f=normalize(toCamera);var normalizedCrossDirToCamera: vec3f=normalize(cross(normalize(vertexInputs.direction),normalizedToCamera));var row0: vec3f= vec3f(normalizedCrossDirToCamera.x,normalizedCrossDirToCamera.y,normalizedCrossDirToCamera.z);var row2: vec3f= vec3f(normalizedToCamera.x,normalizedToCamera.y,normalizedToCamera.z);\n#ifdef BILLBOARDSTRETCHED_LOCAL\nvar row1: vec3f=normalize(vertexInputs.direction);\n#else\nvar crossProduct: vec3f=normalize(cross(normalizedToCamera,normalizedCrossDirToCamera));var row1: vec3f= vec3f(crossProduct.x,crossProduct.y,crossProduct.z);\n#endif\nvar rotMatrix: mat3x3f= mat3x3f(row0,row1,row2);var alignedCorner: vec3f=rotMatrix*rotatedCorner;return vertexInputs.position+alignedCorner;}\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvar cornerPos: vec2f;var vPositionW: vec3f;cornerPos=( vec2f(input.offset.x-0.5,input.offset.y -0.5)-uniforms.translationPivot)*input.size;\n#ifdef BILLBOARD\nvar rotatedCorner: vec3f;\n#ifdef BILLBOARDY\nrotatedCorner.x=cornerPos.x*cos(input.angle)-cornerPos.y*sin(input.angle)+uniforms.translationPivot.x;rotatedCorner.z=cornerPos.x*sin(input.angle)+cornerPos.y*cos(input.angle)+uniforms.translationPivot.y;rotatedCorner.y=0.;var yaxis: vec3f=input.position-uniforms.eyePosition;yaxis.y=0.;vPositionW=rotate(normalize(yaxis),rotatedCorner);var viewPos: vec3f=(uniforms.view* vec4f(vPositionW,1.0)).xyz;\n#elif defined(BILLBOARDSTRETCHED)\nrotatedCorner.x=cornerPos.x*cos(input.angle)-cornerPos.y*sin(input.angle)+uniforms.translationPivot.x;rotatedCorner.y=cornerPos.x*sin(input.angle)+cornerPos.y*cos(input.angle)+uniforms.translationPivot.y;rotatedCorner.z=0.;var toCamera: vec3f=input.position-uniforms.eyePosition;vPositionW=rotateAlign(toCamera,rotatedCorner);var viewPos: vec3f=(uniforms.view* vec4f(vPositionW,1.0)).xyz;\n#else\nrotatedCorner.x=cornerPos.x*cos(input.angle)-cornerPos.y*sin(input.angle)+uniforms.translationPivot.x;rotatedCorner.y=cornerPos.x*sin(input.angle)+cornerPos.y*cos(input.angle)+uniforms.translationPivot.y;rotatedCorner.z=0.;var viewPos: vec3f=(uniforms.view* vec4f(input.position,1.0)).xyz+rotatedCorner;vPositionW=(uniforms.invView* vec4f(viewPos,1)).xyz;\n#endif\n#ifdef RAMPGRADIENT\nvertexOutputs.remapRanges=input.remapData;\n#endif\nvertexOutputs.position=uniforms.projection* vec4f(viewPos,1.0);\n#else\nvar rotatedCorner: vec3f;rotatedCorner.x=cornerPos.x*cos(input.angle)-cornerPos.y*sin(input.angle)+uniforms.translationPivot.x;rotatedCorner.z=cornerPos.x*sin(input.angle)+cornerPos.y*cos(input.angle)+uniforms.translationPivot.y;rotatedCorner.y=0.;var yaxis: vec3f=normalize(vertexInputs.direction);vPositionW=rotate(yaxis,rotatedCorner);vertexOutputs.position=uniforms.projection*uniforms.view* vec4f(vPositionW,1.0);\n#endif\nvertexOutputs.vColor=input.color;\n#ifdef ANIMATESHEET\nvar rowOffset: f32=floor(input.cellIndex*uniforms.particlesInfos.z);var columnOffset: f32=input.cellIndex-rowOffset/uniforms.particlesInfos.z;var uvScale: vec2f=uniforms.particlesInfos.xy;var uvOffset: vec2f= vec2f(input.offset.x ,1.0-input.offset.y);vertexOutputs.vUV=(uvOffset+ vec2f(columnOffset,rowOffset))*uvScale;\n#else\nvertexOutputs.vUV=input.offset;\n#endif\n#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6) || defined(FOG)\nvar worldPos: vec4f= vec4f(vPositionW,1.0);\n#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const particlesVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,6CAA6C,CAAC;AACrD,OAAO,uCAAuC,CAAC;AAC/C,OAAO,sCAAsC,CAAC;AAC9C,OAAO,kCAAkC,CAAC;AAC1C,OAAO,4BAA4B,CAAC;AACpC,OAAO,iCAAiC,CAAC;;;;;;;;AAEzC,MAAM,IAAI,GAAG,uBAAuB,CAAC;AACrC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA0Eb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,yBAAyB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 5066, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/ssao2.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/ssao2.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"ssao2PixelShader\";\nconst shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;\n#ifdef SSAO\nconst scales: array<f32,16>=array<f32,16>(\n0.1,\n0.11406250000000001,\n0.131640625,\n0.15625,\n0.187890625,\n0.2265625,\n0.272265625,\n0.325,\n0.384765625,\n0.4515625,\n0.525390625,\n0.60625,\n0.694140625,\n0.7890625,\n0.891015625,\n1.0\n);uniform near: f32;uniform radius: f32;var depthSamplerSampler: sampler;var depthSampler: texture_2d<f32>;var randomSamplerSampler: sampler;var randomSampler: texture_2d<f32>;var normalSamplerSampler: sampler;var normalSampler: texture_2d<f32>;uniform randTextureTiles: f32;uniform samplesFactor: f32;uniform sampleSphere: array<vec3f,SAMPLES>;uniform totalStrength: f32;uniform base: f32;\n#ifdef ORTHOGRAPHIC_CAMERA\nuniform viewport: vec4f;\n#else\nuniform xViewport: f32;uniform yViewport: f32;\n#endif\nuniform depthProjection: mat3x3f;uniform maxZ: f32;uniform minZAspect: f32;uniform texelSize: vec2f;uniform projection: mat4x4f;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var random: vec3f=textureSampleLevel(randomSampler,randomSamplerSampler,input.vUV*uniforms.randTextureTiles,0.0).rgb;var depth: f32=textureSampleLevel(depthSampler,depthSamplerSampler,input.vUV,0.0).r;var depthSign: f32=sign(depth);depth=depth*depthSign;var normal: vec3f=textureSampleLevel(normalSampler,normalSamplerSampler,input.vUV,0.0).rgb;var occlusion: f32=0.0;var correctedRadius: f32=min(uniforms.radius,uniforms.minZAspect*depth/uniforms.near);\n#ifdef ORTHOGRAPHIC_CAMERA\nvar vViewRay: vec3f= vec3f(mix(uniforms.viewport.x,uniforms.viewport.y,input.vUV.x),mix(uniforms.viewport.z,uniforms.viewport.w,input.vUV.y),depthSign);\n#else\nvar vViewRay: vec3f= vec3f((input.vUV.x*2.0-1.0)*uniforms.xViewport,(input.vUV.y*2.0-1.0)*uniforms.yViewport,depthSign);\n#endif\nvar vDepthFactor: vec3f=uniforms.depthProjection* vec3f(1.0,1.0,depth);var origin: vec3f=vViewRay*vDepthFactor;var rvec: vec3f=random*2.0-1.0;rvec.z=0.0;var dotProduct: f32=dot(rvec,normal);rvec=select( vec3f(-rvec.y,0.0,rvec.x),rvec,1.0-abs(dotProduct)>1e-2);var tangent: vec3f=normalize(rvec-normal*dot(rvec,normal));var bitangent: vec3f=cross(normal,tangent);var tbn: mat3x3f= mat3x3f(tangent,bitangent,normal);var difference: f32;for (var i: i32=0; i<SAMPLES; i++) {var samplePosition: vec3f=scales[(i+ i32(random.x*16.0)) % 16]*tbn*uniforms.sampleSphere[(i+ i32(random.y*16.0)) % 16];samplePosition=samplePosition*correctedRadius+origin;var offset: vec4f= vec4f(samplePosition,1.0);offset=uniforms.projection*offset;offset=vec4f(offset.xyz/offset.w,offset.w);offset=vec4f(offset.xy*0.5+0.5,offset.z,offset.w);if (offset.x<0.0 || offset.y<0.0 || offset.x>1.0 || offset.y>1.0) {continue;}\nvar sampleDepth: f32=abs(textureSampleLevel(depthSampler,depthSamplerSampler,offset.xy,0.0).r);difference=depthSign*samplePosition.z-sampleDepth;var rangeCheck: f32=1.0-smoothstep(correctedRadius*0.5,correctedRadius,difference);occlusion+=step(EPSILON,difference)*rangeCheck;}\nocclusion=occlusion*(1.0-smoothstep(uniforms.maxZ*0.75,uniforms.maxZ,depth));var ao: f32=1.0-uniforms.totalStrength*occlusion*uniforms.samplesFactor;var result: f32=clamp(ao+uniforms.base,0.0,1.0);fragmentOutputs.color= vec4f( vec3f(result),1.0);}\n#else\n#ifdef BLUR\nuniform outSize: f32;uniform soften: f32;uniform tolerance: f32;uniform samples: i32;\n#ifndef BLUR_BYPASS\nvar depthSamplerSampler: sampler;var depthSampler: texture_2d<f32>;\n#ifdef BLUR_LEGACY\nfn blur13Bilateral(image: texture_2d<f32>,imageSampler: sampler,uv: vec2f,step: vec2f)->f32 {var result: f32=0.0;var off1: vec2f= vec2f(1.411764705882353)*step;var off2: vec2f= vec2f(3.2941176470588234)*step;var off3: vec2f= vec2f(5.176470588235294)*step;var compareDepth: f32=abs(textureSampleLevel(depthSampler,depthSamplerSampler,uv,0.0).r);var sampleDepth: f32;var weight: f32;var weightSum: f32=30.0;result+=textureSampleLevel(image,imageSampler,uv,0.0).r*30.0;sampleDepth=abs(textureSampleLevel(depthSampler,depthSamplerSampler,uv+off1,0.0).r);weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);weightSum+= weight;result+=textureSampleLevel(image,imageSampler,uv+off1,0.0).r*weight;sampleDepth=abs(textureSampleLevel(depthSampler,depthSamplerSampler,uv-off1,0.0).r);weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);weightSum+= weight;result+=textureSampleLevel(image,imageSampler,uv-off1,0.0).r*weight;sampleDepth=abs(textureSampleLevel(depthSampler,depthSamplerSampler,uv+off2,0.0).r);weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);weightSum+=weight;result+=textureSampleLevel(image,imageSampler,uv+off2,0.0).r*weight;sampleDepth=abs(textureSampleLevel(depthSampler,depthSamplerSampler,uv-off2,0.0).r);weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);weightSum+=weight;result+=textureSampleLevel(image,imageSampler,uv-off2,0.0).r*weight;sampleDepth=abs(textureSampleLevel(depthSampler,depthSamplerSampler,uv+off3,0.0).r);weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);weightSum+=weight;result+=textureSampleLevel(image,imageSampler,uv+off3,0.0).r*weight;sampleDepth=abs(textureSampleLevel(depthSampler,depthSamplerSampler,uv-off3,0.0).r);weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);weightSum+=weight;result+=textureSampleLevel(image,imageSampler,uv-off3,0.0).r*weight;return result/weightSum;}\n#endif\n#endif\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var result: f32=0.0;\n#ifdef BLUR_BYPASS\nresult=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV,0.0).r;\n#else\n#ifdef BLUR_H\nvar step: vec2f= vec2f(1.0/uniforms.outSize,0.0);\n#else\nvar step: vec2f= vec2f(0.0,1.0/uniforms.outSize);\n#endif\n#ifdef BLUR_LEGACY\nresult=blur13Bilateral(textureSampler,textureSamplerSampler,input.vUV,step);\n#else\nvar compareDepth: f32=abs(textureSampleLevel(depthSampler,depthSamplerSampler,input.vUV,0.0).r);var weightSum: f32=0.0;for (var i: i32=-uniforms.samples; i<uniforms.samples; i+=2)\n{var samplePos: vec2f=input.vUV+step*( f32(i)+0.5);var sampleDepth: f32=abs(textureSampleLevel(depthSampler,depthSamplerSampler,samplePos,0.0).r);var falloff: f32=smoothstep(0.0,\nf32(uniforms.samples),\nf32(uniforms.samples)-abs( f32(i))*uniforms.soften);var minDivider: f32=uniforms.tolerance*0.5+0.003;var weight: f32=falloff/( minDivider+abs(compareDepth-sampleDepth));result+=textureSampleLevel(textureSampler,textureSamplerSampler,samplePos,0.0).r*weight;weightSum+=weight;}\nresult/=weightSum;\n#endif\n#endif\nfragmentOutputs.color=vec4f(result,result,result,1.0);}\n#endif\n#endif\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const ssao2PixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,kBAAkB,CAAC;AAChC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmEd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,oBAAoB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 5154, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/ssaoCombine.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/ssaoCombine.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"ssaoCombinePixelShader\";\nconst shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;var originalColorSampler: sampler;var originalColor: texture_2d<f32>;uniform viewport: vec4f;\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\nvar uv: vec2f=uniforms.viewport.xy+input.vUV*uniforms.viewport.zw;var ssaoColor: vec4f=textureSample(textureSampler,textureSamplerSampler,uv);var sceneColor: vec4f=textureSample(originalColor,originalColorSampler,uv);fragmentOutputs.color=sceneColor*ssaoColor;\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const ssaoCombinePixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,wBAAwB,CAAC;AACtC,MAAM,MAAM,GAAG,CAAA;;;;;;;;CAQd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,0BAA0B,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 5183, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/screenSpaceReflection2.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/screenSpaceReflection2.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/pbrBRDFFunctions\";\nimport \"./ShadersInclude/screenSpaceRayTrace\";\n\nconst name = \"screenSpaceReflection2PixelShader\";\nconst shader = `var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;varying vUV: vec2f;\n#ifdef SSR_SUPPORTED\nvar reflectivitySamplerSampler: sampler;var reflectivitySampler: texture_2d<f32>;var normalSampler: texture_2d<f32>;var depthSampler: texture_2d<f32>;\n#ifdef SSRAYTRACE_USE_BACK_DEPTHBUFFER\nvar backDepthSampler: texture_2d<f32>;uniform backSizeFactor: f32;\n#endif\n#ifdef SSR_USE_ENVIRONMENT_CUBE\nvar envCubeSamplerSampler: sampler;var envCubeSampler: texture_cube<f32>;\n#ifdef SSR_USE_LOCAL_REFLECTIONMAP_CUBIC\nuniform vReflectionPosition: vec3f;uniform vReflectionSize: vec3f;\n#endif\n#endif\nuniform view: mat4x4f;uniform invView: mat4x4f;uniform projection: mat4x4f;uniform invProjectionMatrix: mat4x4f;uniform projectionPixel: mat4x4f;uniform nearPlaneZ: f32;uniform farPlaneZ: f32;uniform stepSize: f32;uniform maxSteps: f32;uniform strength: f32;uniform thickness: f32;uniform roughnessFactor: f32;uniform reflectionSpecularFalloffExponent: f32;uniform maxDistance: f32;uniform selfCollisionNumSkip: f32;uniform reflectivityThreshold: f32;\n#include<helperFunctions>\n#include<pbrBRDFFunctions>\n#include<screenSpaceRayTrace>\nfn hash(a: vec3f)->vec3f\n{var result=fract(a*0.8);result+=dot(result,result.yxz+19.19);return fract((result.xxy+result.yxx)*result.zyx);}\nfn computeAttenuationForIntersection(ihitPixel: vec2f,hitUV: vec2f,vsRayOrigin: vec3f,vsHitPoint: vec3f,reflectionVector: vec3f,maxRayDistance: f32,numIterations: f32)->f32 {var attenuation: f32=1.0;\n#ifdef SSR_ATTENUATE_SCREEN_BORDERS\nvar dCoords: vec2f=smoothstep(vec2f(0.2),vec2f(0.6),abs( vec2f(0.5,0.5)-hitUV.xy));attenuation*=clamp(1.0-(dCoords.x+dCoords.y),0.0,1.0);\n#endif\n#ifdef SSR_ATTENUATE_INTERSECTION_DISTANCE\nattenuation*=1.0-clamp(distance(vsRayOrigin,vsHitPoint)/maxRayDistance,0.0,1.0);\n#endif\n#ifdef SSR_ATTENUATE_INTERSECTION_NUMITERATIONS\nattenuation*=1.0-(numIterations/uniforms.maxSteps);\n#endif\n#ifdef SSR_ATTENUATE_BACKFACE_REFLECTION\nvar reflectionNormal: vec3f=texelFetch(normalSampler,hitPixel,0).xyz;var directionBasedAttenuation: f32=smoothstep(-0.17,0.0,dot(reflectionNormal,-reflectionVector));attenuation*=directionBasedAttenuation;\n#endif\nreturn attenuation;}\n#endif\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#ifdef SSR_SUPPORTED\nvar colorFull: vec4f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV,0.0);var color: vec3f=colorFull.rgb;var reflectivity: vec4f=max(textureSampleLevel(reflectivitySampler,reflectivitySamplerSampler,input.vUV,0.0),vec4f(0.0));\n#ifndef SSR_DISABLE_REFLECTIVITY_TEST\nif (max(reflectivity.r,max(reflectivity.g,reflectivity.b))<=uniforms.reflectivityThreshold) {\n#ifdef SSR_USE_BLUR\nfragmentOutputs.color= vec4f(0.);\n#else\nfragmentOutputs.color=colorFull;\n#endif\nreturn fragmentOutputs;}\n#endif\n#ifdef SSR_INPUT_IS_GAMMA_SPACE\ncolor=toLinearSpaceVec3(color);\n#endif\nvar texSize: vec2f= vec2f(textureDimensions(depthSampler,0));var csNormal: vec3f=textureLoad(normalSampler,vec2<i32>(input.vUV*texSize),0).xyz; \n#ifdef SSR_DECODE_NORMAL\ncsNormal=csNormal*2.0-1.0;\n#endif\n#ifdef SSR_NORMAL_IS_IN_WORLDSPACE\ncsNormal=(uniforms.view* vec4f(csNormal,0.0)).xyz;\n#endif\nvar depth: f32=textureLoad(depthSampler,vec2<i32>(input.vUV*texSize),0).r;\n#ifdef SSRAYTRACE_SCREENSPACE_DEPTH\ndepth=linearizeDepth(depth,uniforms.nearPlaneZ,uniforms.farPlaneZ);\n#endif\nvar csPosition: vec3f=computeViewPosFromUVDepth(input.vUV,depth,uniforms.projection,uniforms.invProjectionMatrix);\n#ifdef ORTHOGRAPHIC_CAMERA\nvar csViewDirection: vec3f= vec3f(0.,0.,1.);\n#else\nvar csViewDirection: vec3f=normalize(csPosition);\n#endif\nvar csReflectedVector: vec3f=reflect(csViewDirection,csNormal);\n#ifdef SSR_USE_ENVIRONMENT_CUBE\nvar wReflectedVector: vec3f=(uniforms.invView* vec4f(csReflectedVector,0.0)).xyz;\n#ifdef SSR_USE_LOCAL_REFLECTIONMAP_CUBIC\nvar worldPos: vec4f=uniforms.invView* vec4f(csPosition,1.0);wReflectedVector=parallaxCorrectNormal(worldPos.xyz,normalize(wReflectedVector),uniforms.vReflectionSize,uniforms.vReflectionPosition);\n#endif\n#ifdef SSR_INVERTCUBICMAP\nwReflectedVector.y*=-1.0;\n#endif\n#ifdef SSRAYTRACE_RIGHT_HANDED_SCENE\nwReflectedVector.z*=-1.0;\n#endif\nvar envColor: vec3f=textureSampleLevel(envCubeSampler,envCubeSamplerSampler,wReflectedVector,0.0).xyz;\n#ifdef SSR_ENVIRONMENT_CUBE_IS_GAMMASPACE\nenvColor=toLinearSpaceVec3(envColor);\n#endif\n#else\nvar envColor: vec3f=color;\n#endif\nvar reflectionAttenuation: f32=1.0;var rayHasHit: bool=false;var startPixel: vec2f;var hitPixel: vec2f;var hitPoint: vec3f;var numIterations: f32;\n#ifdef SSRAYTRACE_DEBUG\nvar debugColor: vec3f;\n#endif\n#ifdef SSR_ATTENUATE_FACING_CAMERA\nreflectionAttenuation*=1.0-smoothstep(0.25,0.5,dot(-csViewDirection,csReflectedVector));\n#endif\nif (reflectionAttenuation>0.0) {\n#ifdef SSR_USE_BLUR\nvar jitt: vec3f= vec3f(0.);\n#else\nvar roughness: f32=1.0-reflectivity.a;var jitt: vec3f=mix( vec3f(0.0),hash(csPosition)- vec3f(0.5),roughness)*uniforms.roughnessFactor; \n#endif\nvar uv2: vec2f=input.vUV*texSize;var c: f32=(uv2.x+uv2.y)*0.25;var jitter: f32=((c)%(1.0)); \nrayHasHit=traceScreenSpaceRay1(\ncsPosition,\nnormalize(csReflectedVector+jitt),\nuniforms.projectionPixel,\ndepthSampler,\ntexSize,\n#ifdef SSRAYTRACE_USE_BACK_DEPTHBUFFER\nbackDepthSampler,\nuniforms.backSizeFactor,\n#endif\nuniforms.thickness,\nuniforms.nearPlaneZ,\nuniforms.farPlaneZ,\nuniforms.stepSize,\njitter,\nuniforms.maxSteps,\nuniforms.maxDistance,\nuniforms.selfCollisionNumSkip,\n&startPixel,\n&hitPixel,\n&hitPoint,\n&numIterations\n#ifdef SSRAYTRACE_DEBUG\n,&debugColor\n#endif\n);}\n#ifdef SSRAYTRACE_DEBUG\nfragmentOutputs.color= vec4f(debugColor,1.);return fragmentOutputs;\n#endif\nvar F0: vec3f=reflectivity.rgb;var fresnel: vec3f=fresnelSchlickGGXVec3(max(dot(csNormal,-csViewDirection),0.0),F0, vec3f(1.));var SSR: vec3f=envColor;if (rayHasHit) {var reflectedColor: vec3f=textureLoad(textureSampler,vec2<i32>(hitPixel),0).rgb;\n#ifdef SSR_INPUT_IS_GAMMA_SPACE\nreflectedColor=toLinearSpaceVec3(reflectedColor);\n#endif\nreflectionAttenuation*=computeAttenuationForIntersection(hitPixel,hitPixel/texSize,csPosition,hitPoint,csReflectedVector,uniforms.maxDistance,numIterations);SSR=reflectedColor*reflectionAttenuation+(1.0-reflectionAttenuation)*envColor;}\n#ifndef SSR_BLEND_WITH_FRESNEL\nSSR*=fresnel;\n#endif\n#ifdef SSR_USE_BLUR\nvar blur_radius: f32=0.0;var roughness: f32=1.0-reflectivity.a*(1.0-uniforms.roughnessFactor);if (roughness>0.001) {var cone_angle: f32=min(roughness,0.999)*3.14159265*0.5;var cone_len: f32=distance(startPixel,hitPixel);var op_len: f32=2.0*tan(cone_angle)*cone_len; \nvar a: f32=op_len;var h: f32=cone_len;var a2: f32=a*a;var fh2: f32=4.0f*h*h;blur_radius=(a*(sqrt(a2+fh2)-a))/(4.0f*h);}\nfragmentOutputs.color= vec4f(SSR,blur_radius/255.0); \n#else\n#ifdef SSR_BLEND_WITH_FRESNEL\nvar reflectionMultiplier: vec3f=clamp(pow(fresnel*uniforms.strength, vec3f(uniforms.reflectionSpecularFalloffExponent)),vec3f(0.0),vec3f(1.0));\n#else\nvar reflectionMultiplier: vec3f=clamp(pow(reflectivity.rgb*uniforms.strength, vec3f(uniforms.reflectionSpecularFalloffExponent)),vec3f(0.0),vec3f(1.0));\n#endif\nvar colorMultiplier: vec3f=1.0-reflectionMultiplier;var finalColor: vec3f=(color*colorMultiplier)+(SSR*reflectionMultiplier);\n#ifdef SSR_OUTPUT_IS_GAMMA_SPACE\nfinalColor=toGammaSpaceVec3(finalColor);\n#endif\nfragmentOutputs.color= vec4f(finalColor,colorFull.a);\n#endif\n#else\nfragmentOutputs.color=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV,0.0);\n#endif\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const screenSpaceReflection2PixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,kCAAkC,CAAC;AAC1C,OAAO,mCAAmC,CAAC;AAC3C,OAAO,sCAAsC,CAAC;;;;;AAE9C,MAAM,IAAI,GAAG,mCAAmC,CAAC;AACjD,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4Jd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,qCAAqC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 5366, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/screenSpaceReflection2Blur.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/screenSpaceReflection2Blur.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"screenSpaceReflection2BlurPixelShader\";\nconst shader = `var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;varying vUV: vec2f;uniform texelOffsetScale: vec2f;const weights: array<f32,8>=array<f32,8>(0.071303,0.131514,0.189879,0.321392,0.452906, 0.584419,0.715932,0.847445);fn processSample(uv: vec2f,i: f32,stepSize: vec2f,accumulator: ptr<function,vec4f>,denominator: ptr<function,f32>)\n{var offsetUV: vec2f=stepSize*i+uv;var coefficient: f32=weights[ i32(2.0-abs(i))];*accumulator+=textureSampleLevel(textureSampler,textureSamplerSampler,offsetUV,0.0)*coefficient;*denominator+=coefficient;}\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var colorFull: vec4f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV,0.0);if (dot(colorFull, vec4f(1.0))==0.0) {fragmentOutputs.color=colorFull;return fragmentOutputs;}\nvar blurRadius: f32=colorFull.a*255.0; \nvar stepSize: vec2f=uniforms.texelOffsetScale.xy*blurRadius;var accumulator: vec4f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV,0.0)*0.214607;var denominator: f32=0.214607;processSample(input.vUV,1.0,stepSize,&accumulator,&denominator);processSample(input.vUV,1.0*0.2,stepSize,&accumulator,&denominator);processSample(input.vUV,1.0*0.4,stepSize,&accumulator,&denominator);processSample(input.vUV,1.0*0.6,stepSize,&accumulator,&denominator);processSample(input.vUV,1.0*0.8,stepSize,&accumulator,&denominator);processSample(input.vUV,1.0*1.2,stepSize,&accumulator,&denominator);processSample(input.vUV,1.0*1.4,stepSize,&accumulator,&denominator);processSample(input.vUV,1.0*1.6,stepSize,&accumulator,&denominator);processSample(input.vUV,1.0*1.8,stepSize,&accumulator,&denominator);processSample(input.vUV,1.0*2.0,stepSize,&accumulator,&denominator);processSample(input.vUV,-1.0,stepSize,&accumulator,&denominator);processSample(input.vUV,-1.0*0.2,stepSize,&accumulator,&denominator);processSample(input.vUV,-1.0*0.4,stepSize,&accumulator,&denominator);processSample(input.vUV,-1.0*0.6,stepSize,&accumulator,&denominator);processSample(input.vUV,-1.0*0.8,stepSize,&accumulator,&denominator);processSample(input.vUV,-1.0*1.2,stepSize,&accumulator,&denominator);processSample(input.vUV,-1.0*1.4,stepSize,&accumulator,&denominator);processSample(input.vUV,-1.0*1.6,stepSize,&accumulator,&denominator);processSample(input.vUV,-1.0*1.8,stepSize,&accumulator,&denominator);processSample(input.vUV,-1.0*2.0,stepSize,&accumulator,&denominator);fragmentOutputs.color= vec4f(accumulator.rgb/denominator,colorFull.a);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const screenSpaceReflection2BlurPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,uCAAuC,CAAC;AACrD,MAAM,MAAM,GAAG,CAAA;;;;;;CAMd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,yCAAyC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 5393, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/screenSpaceReflection2BlurCombiner.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/screenSpaceReflection2BlurCombiner.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/pbrBRDFFunctions\";\nimport \"./ShadersInclude/screenSpaceRayTrace\";\n\nconst name = \"screenSpaceReflection2BlurCombinerPixelShader\";\nconst shader = `var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>; \nvar mainSamplerSampler: sampler;var mainSampler: texture_2d<f32>;var reflectivitySamplerSampler: sampler;var reflectivitySampler: texture_2d<f32>;uniform strength: f32;uniform reflectionSpecularFalloffExponent: f32;uniform reflectivityThreshold: f32;varying vUV: vec2f;\n#include<helperFunctions>\n#ifdef SSR_BLEND_WITH_FRESNEL\n#include<pbrBRDFFunctions>\n#include<screenSpaceRayTrace>\nuniform projection: mat4x4f;uniform invProjectionMatrix: mat4x4f;\n#ifdef SSR_NORMAL_IS_IN_WORLDSPACE\nuniform view: mat4x4f;\n#endif\nvar normalSampler: texture_2d<f32>;var depthSampler: texture_2d<f32>;\n#ifdef SSRAYTRACE_SCREENSPACE_DEPTH\nuniform nearPlaneZ: f32;uniform farPlaneZ: f32;\n#endif\n#endif\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#ifdef SSRAYTRACE_DEBUG\nfragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,input.vUV);\n#else\nvar SSR: vec3f=textureSample(textureSampler,textureSamplerSampler,input.vUV).rgb;var color: vec4f=textureSample(mainSampler,textureSamplerSampler,input.vUV);var reflectivity: vec4f=textureSample(reflectivitySampler,reflectivitySamplerSampler,input.vUV);\n#ifndef SSR_DISABLE_REFLECTIVITY_TEST\nif (max(reflectivity.r,max(reflectivity.g,reflectivity.b))<=uniforms.reflectivityThreshold) {fragmentOutputs.color=color;return fragmentOutputs;}\n#endif\n#ifdef SSR_INPUT_IS_GAMMA_SPACE\ncolor=toLinearSpaceVec4(color);\n#endif\n#ifdef SSR_BLEND_WITH_FRESNEL\nvar texSize: vec2f= vec2f(textureDimensions(depthSampler,0));var csNormal: vec3f=textureLoad(normalSampler,vec2<i32>(input.vUV*texSize),0).xyz;\n#ifdef SSR_DECODE_NORMAL\ncsNormal=csNormal*2.0-1.0;\n#endif\n#ifdef SSR_NORMAL_IS_IN_WORLDSPACE\ncsNormal=(uniforms.view*vec4f(csNormal,0.0)).xyz;\n#endif\nvar depth: f32=textureLoad(depthSampler,vec2<i32>(input.vUV*texSize),0).r;\n#ifdef SSRAYTRACE_SCREENSPACE_DEPTH\ndepth=linearizeDepth(depth,uniforms.nearPlaneZ,uniforms.farPlaneZ);\n#endif\nvar csPosition: vec3f=computeViewPosFromUVDepth(input.vUV,depth,uniforms.projection,uniforms.invProjectionMatrix);var csViewDirection: vec3f=normalize(csPosition);var F0: vec3f=reflectivity.rgb;var fresnel: vec3f=fresnelSchlickGGXVec3(max(dot(csNormal,-csViewDirection),0.0),F0, vec3f(1.));var reflectionMultiplier: vec3f=clamp(pow(fresnel*uniforms.strength, vec3f(uniforms.reflectionSpecularFalloffExponent)),vec3f(0.0),vec3f(1.0));\n#else\nvar reflectionMultiplier: vec3f=clamp(pow(reflectivity.rgb*uniforms.strength, vec3f(uniforms.reflectionSpecularFalloffExponent)),vec3f(0.0),vec3f(1.0));\n#endif\nvar colorMultiplier: vec3f=1.0-reflectionMultiplier;var finalColor: vec3f=(color.rgb*colorMultiplier)+(SSR*reflectionMultiplier);\n#ifdef SSR_OUTPUT_IS_GAMMA_SPACE\nfinalColor=toGammaSpaceVec3(finalColor);\n#endif\nfragmentOutputs.color= vec4f(finalColor,color.a);\n#endif\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const screenSpaceReflection2BlurCombinerPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,kCAAkC,CAAC;AAC1C,OAAO,mCAAmC,CAAC;AAC3C,OAAO,sCAAsC,CAAC;;;;;AAE9C,MAAM,IAAI,GAAG,+CAA+C,CAAC;AAC7D,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkDd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,iDAAiD,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 5470, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/taa.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/taa.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"taaPixelShader\";\nconst shader = `varying vUV: vec2f;var textureSampler: texture_2d<f32>;var historySampler: texture_2d<f32>;\n#ifdef TAA_REPROJECT_HISTORY\nvar historySamplerSampler: sampler;var velocitySampler: texture_2d<f32>;\n#endif\nuniform factor: f32;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {let pos=vec2i(fragmentInputs.position.xy);let c=textureLoad(textureSampler,pos,0);\n#ifdef TAA_REPROJECT_HISTORY\nlet v=textureLoad(velocitySampler,pos,0);var h=textureSample(historySampler,historySamplerSampler,input.vUV+v.xy);\n#else\nvar h=textureLoad(historySampler,pos,0);\n#endif\n#ifdef TAA_CLAMP_HISTORY\nvar cmin=vec4f(1);var cmax=vec4f(0);for (var x=-1; x<=1; x+=1) {for (var y=-1; y<=1; y+=1) {let c=textureLoad(textureSampler,pos+vec2i(x,y),0);cmin=min(cmin,c);cmax=max(cmax,c);}}\nh=clamp(h,cmin,cmax);\n#endif\nfragmentOutputs.color= mix(h,c,uniforms.factor);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const taaPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,gBAAgB,CAAC;AAC9B,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;CAgBd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,kBAAkB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 5507, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/postprocess.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/postprocess.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"postprocessVertexShader\";\nconst shader = `attribute position: vec2<f32>;uniform scale: vec2<f32>;varying vUV: vec2<f32>;const madd=vec2(0.5,0.5);\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvertexOutputs.vUV=(vertexInputs.position*madd+madd)*uniforms.scale;vertexOutputs.position=vec4(vertexInputs.position,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const postprocessVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,yBAAyB,CAAC;AACvC,MAAM,MAAM,GAAG,CAAA;;;;;;;;CAQd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,2BAA2B,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 5536, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/kernelBlur.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/kernelBlur.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/kernelBlurVaryingDeclaration\";\nimport \"./ShadersInclude/packingFunctions\";\nimport \"./ShadersInclude/kernelBlurFragment\";\nimport \"./ShadersInclude/kernelBlurFragment2\";\n\nconst name = \"kernelBlurPixelShader\";\nconst shader = `var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform delta: vec2f;varying sampleCenter: vec2f;\n#ifdef DOF\nvar circleOfConfusionSamplerSampler: sampler;var circleOfConfusionSampler: texture_2d<f32>;fn sampleCoC(offset: vec2f)->f32 {var coc: f32=textureSample(circleOfConfusionSampler,circleOfConfusionSamplerSampler,offset).r;return coc; }\n#endif\n#include<kernelBlurVaryingDeclaration>[0..varyingCount]\n#ifdef PACKEDFLOAT\n#include<packingFunctions>\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var computedWeight: f32=0.0;\n#ifdef PACKEDFLOAT\nvar blend: f32=0.;\n#else\nvar blend: vec4f= vec4f(0.);\n#endif\n#ifdef DOF\nvar sumOfWeights: f32=CENTER_WEIGHT; \nvar factor: f32=0.0;\n#ifdef PACKEDFLOAT\nblend+=unpack(textureSample(textureSampler,textureSamplerSampler,input.sampleCenter))*CENTER_WEIGHT;\n#else\nblend+=textureSample(textureSampler,textureSamplerSampler,input.sampleCenter)*CENTER_WEIGHT;\n#endif\n#endif\n#include<kernelBlurFragment>[0..varyingCount]\n#include<kernelBlurFragment2>[0..depCount]\n#ifdef PACKEDFLOAT\nfragmentOutputs.color=pack(blend);\n#else\nfragmentOutputs.color=blend;\n#endif\n#ifdef DOF\nfragmentOutputs.color/=sumOfWeights;\n#endif\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const kernelBlurPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,+CAA+C,CAAC;AACvD,OAAO,mCAAmC,CAAC;AAC3C,OAAO,qCAAqC,CAAC;AAC7C,OAAO,sCAAsC,CAAC;;;;;;AAE9C,MAAM,IAAI,GAAG,uBAAuB,CAAC;AACrC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAmCb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,yBAAyB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 5600, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/kernelBlur.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/kernelBlur.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/kernelBlurVaryingDeclaration\";\nimport \"./ShadersInclude/kernelBlurVertex\";\n\nconst name = \"kernelBlurVertexShader\";\nconst shader = `attribute position: vec2f;uniform delta: vec2f;varying sampleCenter: vec2f;\n#include<kernelBlurVaryingDeclaration>[0..varyingCount]\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {const madd: vec2f= vec2f(0.5,0.5);\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvertexOutputs.sampleCenter=(input.position*madd+madd);\n#include<kernelBlurVertex>[0..varyingCount]\nvertexOutputs.position= vec4f(input.position,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const kernelBlurVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,+CAA+C,CAAC;AACvD,OAAO,mCAAmC,CAAC;;;;AAE3C,MAAM,IAAI,GAAG,wBAAwB,CAAC;AACtC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;EAUb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,0BAA0B,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 5635, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/pass.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/pass.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"passPixelShader\";\nconst shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,input.vUV);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const passPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,iBAAiB,CAAC;AAC/B,MAAM,MAAM,GAAG,CAAA;;;uIAGwH,CAAC;AACxI,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,mBAAmB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 5659, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/passCube.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/passCube.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"passCubePixelShader\";\nconst shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_cube<f32>;\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var uv: vec2f=input.vUV*2.0-1.0;\n#ifdef POSITIVEX\nfragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,vec3f(1.001,uv.y,uv.x));\n#endif\n#ifdef NEGATIVEX\nfragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,vec3f(-1.001,uv.y,uv.x));\n#endif\n#ifdef POSITIVEY\nfragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,vec3f(uv.y,1.001,uv.x));\n#endif\n#ifdef NEGATIVEY\nfragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,vec3f(uv.y,-1.001,uv.x));\n#endif\n#ifdef POSITIVEZ\nfragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,vec3f(uv,1.001));\n#endif\n#ifdef NEGATIVEZ\nfragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,vec3f(uv,-1.001));\n#endif\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const passCubePixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,qBAAqB,CAAC;AACnC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;EAsBb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,uBAAuB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 5702, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/vrDistortionCorrection.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/vrDistortionCorrection.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"vrDistortionCorrectionPixelShader\";\nconst shader = `#define DISABLE_UNIFORMITY_ANALYSIS\nvarying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform LensCenter: vec2f;uniform Scale: vec2f;uniform ScaleIn: vec2f;uniform HmdWarpParam: vec4f;fn HmdWarp(in01: vec2f)->vec2f {var theta: vec2f=(in01-uniforms.LensCenter)*uniforms.ScaleIn; \nvar rSq: f32=theta.x*theta.x+theta.y*theta.y;var rvector: vec2f=theta*(uniforms.HmdWarpParam.x+uniforms.HmdWarpParam.y*rSq+uniforms.HmdWarpParam.z*rSq*rSq+uniforms.HmdWarpParam.w*rSq*rSq*rSq);return uniforms.LensCenter+uniforms.Scale*rvector;}\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var tc: vec2f=HmdWarp(input.vUV);if (tc.x <0.0 || tc.x>1.0 || tc.y<0.0 || tc.y>1.0) {fragmentOutputs.color=vec4f(0.0,0.0,0.0,0.0);}\nelse{fragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,tc);}}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const vrDistortionCorrectionPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,mCAAmC,CAAC;AACjD,MAAM,MAAM,GAAG,CAAA;;;;;;qFAMsE,CAAC;AACtF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,qCAAqC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 5729, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/imageProcessing.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/imageProcessing.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/imageProcessingDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/imageProcessingFunctions\";\n\nconst name = \"imageProcessingPixelShader\";\nconst shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;\n#include<imageProcessingDeclaration>\n#include<helperFunctions>\n#include<imageProcessingFunctions>\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var result: vec4f=textureSample(textureSampler,textureSamplerSampler,input.vUV);result=vec4f(max(result.rgb,vec3f(0.)),result.a);\n#ifdef IMAGEPROCESSING\n#ifndef FROMLINEARSPACE\nresult=vec4f(toLinearSpaceVec3(result.rgb),result.a);\n#endif\nresult=applyImageProcessing(result);\n#else\n#ifdef FROMLINEARSPACE\nresult=applyImageProcessing(result);\n#endif\n#endif\nfragmentOutputs.color=result;}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const imageProcessingPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,6CAA6C,CAAC;AACrD,OAAO,kCAAkC,CAAC;AAC1C,OAAO,2CAA2C,CAAC;;;;;AAEnD,MAAM,IAAI,GAAG,4BAA4B,CAAC;AAC1C,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;+BAiBgB,CAAC;AAChC,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,8BAA8B,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 5773, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/sharpen.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/sharpen.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"sharpenPixelShader\";\nconst shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform screenSize: vec2f;uniform sharpnessAmounts: vec2f;\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var onePixel: vec2f= vec2f(1.0,1.0)/uniforms.screenSize;var color: vec4f=textureSample(textureSampler,textureSamplerSampler,input.vUV);var edgeDetection: vec4f=textureSample(textureSampler,textureSamplerSampler,input.vUV+onePixel*vec2f(0,-1)) +\ntextureSample(textureSampler,textureSamplerSampler,input.vUV+onePixel*vec2f(-1,0)) +\ntextureSample(textureSampler,textureSamplerSampler,input.vUV+onePixel*vec2f(1,0)) +\ntextureSample(textureSampler,textureSamplerSampler,input.vUV+onePixel*vec2f(0,1)) -\ncolor*4.0;fragmentOutputs.color=max(vec4f(color.rgb*uniforms.sharpnessAmounts.y,color.a)-(uniforms.sharpnessAmounts.x* vec4f(edgeDetection.rgb,0)),vec4f(0.));}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const sharpenPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,oBAAoB,CAAC;AAClC,MAAM,MAAM,GAAG,CAAA;;;;;;;gKAOiJ,CAAC;AACjK,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,sBAAsB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 5801, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/grain.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/grain.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\n\nconst name = \"grainPixelShader\";\nconst shader = `#include<helperFunctions>\nvarying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform intensity: f32;uniform animatedSeed: f32;\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,input.vUV);var seed: vec2f=input.vUV*uniforms.animatedSeed;var grain: f32=dither(seed,uniforms.intensity);var lum: f32=getLuminance(fragmentOutputs.color.rgb);var grainAmount: f32=(cos(-PI+(lum*PI*2.))+1.)/2.;fragmentOutputs.color=vec4f(fragmentOutputs.color.rgb+grain*grainAmount,fragmentOutputs.color.a);fragmentOutputs.color=vec4f(max(fragmentOutputs.color.rgb,vec3f(0.0)),fragmentOutputs.color.a);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const grainPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,kCAAkC,CAAC;;;AAE1C,MAAM,IAAI,GAAG,kBAAkB,CAAC;AAChC,MAAM,MAAM,GAAG,CAAA;;;;6gBAI8f,CAAC;AAC9gB,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,oBAAoB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 5828, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/chromaticAberration.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/chromaticAberration.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"chromaticAberrationPixelShader\";\nconst shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform chromatic_aberration: f32;uniform radialIntensity: f32;uniform direction: vec2f;uniform centerPosition: vec2f;uniform screen_width: f32;uniform screen_height: f32;\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var centered_screen_pos: vec2f= vec2f(input.vUV.x-uniforms.centerPosition.x,input.vUV.y-uniforms.centerPosition.y);var directionOfEffect: vec2f=uniforms.direction;if(directionOfEffect.x==0. && directionOfEffect.y==0.){directionOfEffect=normalize(centered_screen_pos);}\nvar radius2: f32=centered_screen_pos.x*centered_screen_pos.x\n+ centered_screen_pos.y*centered_screen_pos.y;var radius: f32=sqrt(radius2);var ref_indices: vec3f= vec3f(-0.3,0.0,0.3);var ref_shiftX: f32=uniforms.chromatic_aberration*pow(radius,uniforms.radialIntensity)*directionOfEffect.x/uniforms.screen_width;var ref_shiftY: f32=uniforms.chromatic_aberration*pow(radius,uniforms.radialIntensity)*directionOfEffect.y/uniforms.screen_height;var ref_coords_r: vec2f=vec2f(input.vUV.x+ref_indices.r*ref_shiftX,input.vUV.y+ref_indices.r*ref_shiftY*0.5);var ref_coords_g: vec2f=vec2f(input.vUV.x+ref_indices.g*ref_shiftX,input.vUV.y+ref_indices.g*ref_shiftY*0.5);var ref_coords_b: vec2f=vec2f(input.vUV.x+ref_indices.b*ref_shiftX,input.vUV.y+ref_indices.b*ref_shiftY*0.5);var r=textureSample(textureSampler,textureSamplerSampler,ref_coords_r);var g=textureSample(textureSampler,textureSamplerSampler,ref_coords_g);var b=textureSample(textureSampler,textureSamplerSampler,ref_coords_b);var a=clamp(r.a+g.a+b.a,0.,1.);fragmentOutputs.color=vec4f(r.r,g.g,b.b,a);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const chromaticAberrationPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,gCAAgC,CAAC;AAC9C,MAAM,MAAM,GAAG,CAAA;;;;;m+BAKo9B,CAAC;AACp+B,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,kCAAkC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 5854, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/depthOfFieldMerge.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/depthOfFieldMerge.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"depthOfFieldMergePixelShader\";\nconst shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;var circleOfConfusionSamplerSampler: sampler;var circleOfConfusionSampler: texture_2d<f32>;var blurStep0Sampler: sampler;var blurStep0: texture_2d<f32>;\n#if BLUR_LEVEL>0\nvar blurStep1Sampler: sampler;var blurStep1: texture_2d<f32>;\n#endif\n#if BLUR_LEVEL>1\nvar blurStep2Sampler: sampler;var blurStep2: texture_2d<f32>;\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var coc: f32=textureSampleLevel(circleOfConfusionSampler,circleOfConfusionSamplerSampler,input.vUV,0.0).r;\n#if BLUR_LEVEL==0\nvar original: vec4f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV,0.0);var blurred0: vec4f=textureSampleLevel(blurStep0,blurStep0Sampler,input.vUV,0.0);fragmentOutputs.color=mix(original,blurred0,coc);\n#endif\n#if BLUR_LEVEL==1\nif(coc<0.5){var original: vec4f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV,0.0);var blurred1: vec4f=textureSampleLevel(blurStep1,blurStep1Sampler,input.vUV,0.0);fragmentOutputs.color=mix(original,blurred1,coc/0.5);}else{var blurred0: vec4f=textureSampleLevel(blurStep0,blurStep0Sampler,input.vUV,0.0);var blurred1: vec4f=textureSampleLevel(blurStep1,blurStep1Sampler,input.vUV,0.0);fragmentOutputs.color=mix(blurred1,blurred0,(coc-0.5)/0.5);}\n#endif\n#if BLUR_LEVEL==2\nif(coc<0.33){var original: vec4f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV,0.0);var blurred2: vec4f=textureSampleLevel(blurStep2,blurStep2Sampler,input.vUV,0.0);fragmentOutputs.color=mix(original,blurred2,coc/0.33);}else if(coc<0.66){var blurred1: vec4f=textureSampleLevel(blurStep1,blurStep1Sampler,input.vUV,0.0);var blurred2: vec4f=textureSampleLevel(blurStep2,blurStep2Sampler,input.vUV,0.0);fragmentOutputs.color=mix(blurred2,blurred1,(coc-0.33)/0.33);}else{var blurred0: vec4f=textureSampleLevel(blurStep0,blurStep0Sampler,input.vUV,0.0);var blurred1: vec4f=textureSampleLevel(blurStep1,blurStep1Sampler,input.vUV,0.0);fragmentOutputs.color=mix(blurred1,blurred0,(coc-0.66)/0.34);}\n#endif\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const depthOfFieldMergePixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,8BAA8B,CAAC;AAC5C,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;CAoBd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,gCAAgC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 5895, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/circleOfConfusion.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/circleOfConfusion.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"circleOfConfusionPixelShader\";\nconst shader = `varying vUV: vec2f;var depthSamplerSampler: sampler;var depthSampler: texture_2d<f32>;\n#ifndef COC_DEPTH_NOT_NORMALIZED\nuniform cameraMinMaxZ: vec2f;\n#endif\nuniform focusDistance: f32;uniform cocPrecalculation: f32;\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var depth: f32=textureSample(depthSampler,depthSamplerSampler,input.vUV).r;\n#define CUSTOM_COC_DEPTH\n#ifdef COC_DEPTH_NOT_NORMALIZED\nlet pixelDistance=depth*1000.0;\n#else\nlet pixelDistance: f32=(uniforms.cameraMinMaxZ.x+uniforms.cameraMinMaxZ.y*depth)*1000.0; \n#endif\n#define CUSTOM_COC_PIXELDISTANCE\nvar coc: f32=abs(uniforms.cocPrecalculation*((uniforms.focusDistance-pixelDistance)/pixelDistance));coc=clamp(coc,0.0,1.0);fragmentOutputs.color= vec4f(coc,coc,coc,1.0);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const circleOfConfusionPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,8BAA8B,CAAC;AAC5C,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;CAgBd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,gCAAgC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 5932, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/bloomMerge.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/bloomMerge.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"bloomMergePixelShader\";\nconst shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;var bloomBlurSampler: sampler;var bloomBlur: texture_2d<f32>;uniform bloomWeight: f32;\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,input.vUV);var blurred: vec3f=textureSample(bloomBlur,bloomBlurSampler,input.vUV).rgb;fragmentOutputs.color=vec4f(fragmentOutputs.color.rgb+(blurred.rgb*uniforms.bloomWeight),fragmentOutputs.color.a);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const bloomMergePixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,uBAAuB,CAAC;AACrC,MAAM,MAAM,GAAG,CAAA;;;;CAId,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,yBAAyB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 5957, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/extractHighlights.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/extractHighlights.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\n\nconst name = \"extractHighlightsPixelShader\";\nconst shader = `#include<helperFunctions>\nvarying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform threshold: f32;uniform exposure: f32;\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,input.vUV);var luma: f32=dot(LuminanceEncodeApprox,fragmentOutputs.color.rgb*uniforms.exposure);fragmentOutputs.color=vec4f(step(uniforms.threshold,luma)*fragmentOutputs.color.rgb,fragmentOutputs.color.a);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const extractHighlightsPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,kCAAkC,CAAC;;;AAE1C,MAAM,IAAI,GAAG,8BAA8B,CAAC;AAC5C,MAAM,MAAM,GAAG,CAAA;;;;yUAI0T,CAAC;AAC1U,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,gCAAgC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 5984, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/fxaa.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/fxaa.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"fxaaPixelShader\";\nconst shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform texelSize: vec2f;varying sampleCoordS: vec2f;varying sampleCoordE: vec2f;varying sampleCoordN: vec2f;varying sampleCoordW: vec2f;varying sampleCoordNW: vec2f;varying sampleCoordSE: vec2f;varying sampleCoordNE: vec2f;varying sampleCoordSW: vec2f;const fxaaQualitySubpix: f32=1.0;const fxaaQualityEdgeThreshold: f32=0.166;const fxaaQualityEdgeThresholdMin: f32=0.0833;const kLumaCoefficients: vec3f= vec3f(0.2126,0.7152,0.0722);fn FxaaLuma(rgba: vec4f)->f32 {return dot(rgba.rgb,kLumaCoefficients);} \n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var posM: vec2f;posM.x=input.vUV.x;posM.y=input.vUV.y;var rgbyM: vec4f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV,0.0);var lumaM: f32=FxaaLuma(rgbyM);var lumaS: f32=FxaaLuma(textureSampleLevel(textureSampler,textureSamplerSampler,input.sampleCoordS,0.0));var lumaE: f32=FxaaLuma(textureSampleLevel(textureSampler,textureSamplerSampler,input.sampleCoordE,0.0));var lumaN: f32=FxaaLuma(textureSampleLevel(textureSampler,textureSamplerSampler,input.sampleCoordN,0.0));var lumaW: f32=FxaaLuma(textureSampleLevel(textureSampler,textureSamplerSampler,input.sampleCoordW,0.0));var maxSM: f32=max(lumaS,lumaM);var minSM: f32=min(lumaS,lumaM);var maxESM: f32=max(lumaE,maxSM);var minESM: f32=min(lumaE,minSM);var maxWN: f32=max(lumaN,lumaW);var minWN: f32=min(lumaN,lumaW);var rangeMax: f32=max(maxWN,maxESM);var rangeMin: f32=min(minWN,minESM);var rangeMaxScaled: f32=rangeMax*fxaaQualityEdgeThreshold;var range: f32=rangeMax-rangeMin;var rangeMaxClamped: f32=max(fxaaQualityEdgeThresholdMin,rangeMaxScaled);\n#ifndef MALI\nif(range<rangeMaxClamped) \n{fragmentOutputs.color=rgbyM;return fragmentOutputs;}\n#endif\nvar lumaNW: f32=FxaaLuma(textureSampleLevel(textureSampler,textureSamplerSampler,input.sampleCoordNW,0.0));var lumaSE: f32=FxaaLuma(textureSampleLevel(textureSampler,textureSamplerSampler,input.sampleCoordSE,0.0));var lumaNE: f32=FxaaLuma(textureSampleLevel(textureSampler,textureSamplerSampler,input.sampleCoordNE,0.0));var lumaSW: f32=FxaaLuma(textureSampleLevel(textureSampler,textureSamplerSampler,input.sampleCoordSW,0.0));var lumaNS: f32=lumaN+lumaS;var lumaWE: f32=lumaW+lumaE;var subpixRcpRange: f32=1.0/range;var subpixNSWE: f32=lumaNS+lumaWE;var edgeHorz1: f32=(-2.0*lumaM)+lumaNS;var edgeVert1: f32=(-2.0*lumaM)+lumaWE;var lumaNESE: f32=lumaNE+lumaSE;var lumaNWNE: f32=lumaNW+lumaNE;var edgeHorz2: f32=(-2.0*lumaE)+lumaNESE;var edgeVert2: f32=(-2.0*lumaN)+lumaNWNE;var lumaNWSW: f32=lumaNW+lumaSW;var lumaSWSE: f32=lumaSW+lumaSE;var edgeHorz4: f32=(abs(edgeHorz1)*2.0)+abs(edgeHorz2);var edgeVert4: f32=(abs(edgeVert1)*2.0)+abs(edgeVert2);var edgeHorz3: f32=(-2.0*lumaW)+lumaNWSW;var edgeVert3: f32=(-2.0*lumaS)+lumaSWSE;var edgeHorz: f32=abs(edgeHorz3)+edgeHorz4;var edgeVert: f32=abs(edgeVert3)+edgeVert4;var subpixNWSWNESE: f32=lumaNWSW+lumaNESE;var lengthSign: f32=uniforms.texelSize.x;var horzSpan: bool=edgeHorz>=edgeVert;var subpixA: f32=subpixNSWE*2.0+subpixNWSWNESE;if (!horzSpan)\n{lumaN=lumaW;}\nif (!horzSpan) \n{lumaS=lumaE;}\nif (horzSpan) \n{lengthSign=uniforms.texelSize.y;}\nvar subpixB: f32=(subpixA*(1.0/12.0))-lumaM;var gradientN: f32=lumaN-lumaM;var gradientS: f32=lumaS-lumaM;var lumaNN: f32=lumaN+lumaM;var lumaSS: f32=lumaS+lumaM;var pairN: bool=abs(gradientN)>=abs(gradientS);var gradient: f32=max(abs(gradientN),abs(gradientS));if (pairN)\n{lengthSign=-lengthSign;}\nvar subpixC: f32=clamp(abs(subpixB)*subpixRcpRange,0.0,1.0);var posB: vec2f;posB.x=posM.x;posB.y=posM.y;var offNP: vec2f;offNP.x=select(uniforms.texelSize.x,0.0,(!horzSpan));offNP.y=select(uniforms.texelSize.y,0.0,(horzSpan));if (!horzSpan) \n{posB.x+=lengthSign*0.5;}\nif (horzSpan)\n{posB.y+=lengthSign*0.5;}\nvar posN: vec2f;posN.x=posB.x-offNP.x*1.5;posN.y=posB.y-offNP.y*1.5;var posP: vec2f;posP.x=posB.x+offNP.x*1.5;posP.y=posB.y+offNP.y*1.5;var subpixD: f32=((-2.0)*subpixC)+3.0;var lumaEndN: f32=FxaaLuma(textureSampleLevel(textureSampler,textureSamplerSampler,posN,0.0));var subpixE: f32=subpixC*subpixC;var lumaEndP: f32=FxaaLuma(textureSampleLevel(textureSampler,textureSamplerSampler,posP,0.0));if (!pairN) \n{lumaNN=lumaSS;}\nvar gradientScaled: f32=gradient*1.0/4.0;var lumaMM: f32=lumaM-lumaNN*0.5;var subpixF: f32=subpixD*subpixE;var lumaMLTZero: bool=lumaMM<0.0;lumaEndN-=lumaNN*0.5;lumaEndP-=lumaNN*0.5;var doneN: bool=abs(lumaEndN)>=gradientScaled;var doneP: bool=abs(lumaEndP)>=gradientScaled;if (!doneN) \n{posN.x-=offNP.x*3.0;}\nif (!doneN) \n{posN.y-=offNP.y*3.0;}\nvar doneNP: bool=(!doneN) || (!doneP);if (!doneP) \n{posP.x+=offNP.x*3.0;}\nif (!doneP)\n{posP.y+=offNP.y*3.0;}\nif (doneNP)\n{if (!doneN) {lumaEndN=FxaaLuma(textureSampleLevel(textureSampler,textureSamplerSampler,posN.xy,0.0));}\nif (!doneP) {lumaEndP=FxaaLuma(textureSampleLevel(textureSampler,textureSamplerSampler,posP.xy,0.0));}\nif (!doneN) {lumaEndN=lumaEndN-lumaNN*0.5;}\nif (!doneP) {lumaEndP=lumaEndP-lumaNN*0.5;}\ndoneN=abs(lumaEndN)>=gradientScaled;doneP=abs(lumaEndP)>=gradientScaled;if (!doneN) {posN.x-=offNP.x*12.0;}\nif (!doneN) {posN.y-=offNP.y*12.0;}\ndoneNP=(!doneN) || (!doneP);if (!doneP) {posP.x+=offNP.x*12.0;}\nif (!doneP) {posP.y+=offNP.y*12.0;}}\nvar dstN: f32=posM.x-posN.x;var dstP: f32=posP.x-posM.x;if (!horzSpan)\n{dstN=posM.y-posN.y;}\nif (!horzSpan) \n{dstP=posP.y-posM.y;}\nvar goodSpanN: bool=(lumaEndN<0.0) != lumaMLTZero;var spanLength: f32=(dstP+dstN);var goodSpanP: bool=(lumaEndP<0.0) != lumaMLTZero;var spanLengthRcp: f32=1.0/spanLength;var directionN: bool=dstN<dstP;var dst: f32=min(dstN,dstP);var goodSpan: bool=select(goodSpanP,goodSpanN,directionN);var subpixG: f32=subpixF*subpixF;var pixelOffset: f32=(dst*(-spanLengthRcp))+0.5;var subpixH: f32=subpixG*fxaaQualitySubpix;var pixelOffsetGood: f32=select(0.0,pixelOffset,goodSpan);var pixelOffsetSubpix: f32=max(pixelOffsetGood,subpixH);if (!horzSpan)\n{posM.x+=pixelOffsetSubpix*lengthSign;}\nif (horzSpan)\n{posM.y+=pixelOffsetSubpix*lengthSign;}\n#ifdef MALI\nif(range<rangeMaxClamped) \n{fragmentOutputs.color=rgbyM;}\nelse\n{fragmentOutputs.color=textureSampleLevel(textureSampler,textureSamplerSampler,posM,0.0);}\n#else\nfragmentOutputs.color=textureSampleLevel(textureSampler,textureSamplerSampler,posM,0.0);\n#endif\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const fxaaPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,iBAAiB,CAAC;AAC/B,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAsDb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,mBAAmB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 6059, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/fxaa.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/fxaa.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"fxaaVertexShader\";\nconst shader = `attribute position: vec2f;uniform texelSize: vec2f;varying vUV: vec2f;varying sampleCoordS: vec2f;varying sampleCoordE: vec2f;varying sampleCoordN: vec2f;varying sampleCoordW: vec2f;varying sampleCoordNW: vec2f;varying sampleCoordSE: vec2f;varying sampleCoordNE: vec2f;varying sampleCoordSW: vec2f;const madd: vec2f= vec2f(0.5,0.5);\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvertexOutputs.vUV=(input.position*madd+madd);vertexOutputs.sampleCoordS=vertexOutputs.vUV+ vec2f( 0.0,1.0)*uniforms.texelSize;vertexOutputs.sampleCoordE=vertexOutputs.vUV+ vec2f( 1.0,0.0)*uniforms.texelSize;vertexOutputs.sampleCoordN=vertexOutputs.vUV+ vec2f( 0.0,-1.0)*uniforms.texelSize;vertexOutputs.sampleCoordW=vertexOutputs.vUV+ vec2f(-1.0,0.0)*uniforms.texelSize;vertexOutputs.sampleCoordNW=vertexOutputs.vUV+ vec2f(-1.0,-1.0)*uniforms.texelSize;vertexOutputs.sampleCoordSE=vertexOutputs.vUV+ vec2f( 1.0,1.0)*uniforms.texelSize;vertexOutputs.sampleCoordNE=vertexOutputs.vUV+ vec2f( 1.0,-1.0)*uniforms.texelSize;vertexOutputs.sampleCoordSW=vertexOutputs.vUV+ vec2f(-1.0,1.0)*uniforms.texelSize;vertexOutputs.position=vec4f(input.position,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const fxaaVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,kBAAkB,CAAC;AAChC,MAAM,MAAM,GAAG,CAAA;;;;;;;EAOb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,oBAAoB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 6087, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/blackAndWhite.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/blackAndWhite.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"blackAndWhitePixelShader\";\nconst shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform degree: f32;\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var color: vec3f=textureSample(textureSampler,textureSamplerSampler,input.vUV).rgb;var luminance: f32=dot(color, vec3f(0.3,0.59,0.11)); \nvar blackAndWhite: vec3f= vec3f(luminance,luminance,luminance);fragmentOutputs.color= vec4f(color-((color-blackAndWhite)*uniforms.degree),1.0);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const blackAndWhitePixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,0BAA0B,CAAC;AACxC,MAAM,MAAM,GAAG,CAAA;;;;iJAIkI,CAAC;AAClJ,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,4BAA4B,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 6112, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/anaglyph.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/anaglyph.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"anaglyphPixelShader\";\nconst shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;var leftSamplerSampler: sampler;var leftSampler: texture_2d<f32>;\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var leftFrag: vec4f=textureSample(leftSampler,leftSamplerSampler,input.vUV);leftFrag= vec4f(1.0,leftFrag.g,leftFrag.b,1.0);var rightFrag: vec4f=textureSample(textureSampler,textureSamplerSampler,input.vUV);rightFrag= vec4f(rightFrag.r,1.0,1.0,1.0);fragmentOutputs.color= vec4f(rightFrag.rgb*leftFrag.rgb,1.0);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const anaglyphPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,qBAAqB,CAAC;AACnC,MAAM,MAAM,GAAG,CAAA;;;wWAGyV,CAAC;AACzW,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,uBAAuB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 6136, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/convolution.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/convolution.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"convolutionPixelShader\";\nconst shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform screenSize: vec2f;uniform kernel: array<f32,9>;\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var onePixel: vec2f= vec2f(1.0,1.0)/uniforms.screenSize;var colorSum: vec4f =\ntextureSample(textureSampler,textureSamplerSampler,input.vUV+onePixel* vec2f(-1,-1))*uniforms.kernel[0] +\ntextureSample(textureSampler,textureSamplerSampler,input.vUV+onePixel* vec2f(0,-1))*uniforms.kernel[1] +\ntextureSample(textureSampler,textureSamplerSampler,input.vUV+onePixel* vec2f(1,-1))*uniforms.kernel[2] +\ntextureSample(textureSampler,textureSamplerSampler,input.vUV+onePixel* vec2f(-1,0))*uniforms.kernel[3] +\ntextureSample(textureSampler,textureSamplerSampler,input.vUV+onePixel* vec2f(0,0))*uniforms.kernel[4] +\ntextureSample(textureSampler,textureSamplerSampler,input.vUV+onePixel* vec2f(1,0))*uniforms.kernel[5] +\ntextureSample(textureSampler,textureSamplerSampler,input.vUV+onePixel* vec2f(-1,1))*uniforms.kernel[6] +\ntextureSample(textureSampler,textureSamplerSampler,input.vUV+onePixel* vec2f(0,1))*uniforms.kernel[7] +\ntextureSample(textureSampler,textureSamplerSampler,input.vUV+onePixel* vec2f(1,1))*uniforms.kernel[8];var kernelWeight: f32 =\nuniforms.kernel[0] +\nuniforms.kernel[1] +\nuniforms.kernel[2] +\nuniforms.kernel[3] +\nuniforms.kernel[4] +\nuniforms.kernel[5] +\nuniforms.kernel[6] +\nuniforms.kernel[7] +\nuniforms.kernel[8];if (kernelWeight<=0.0) {kernelWeight=1.0;}\nfragmentOutputs.color= vec4f((colorSum/kernelWeight).rgb,1);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const convolutionPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,wBAAwB,CAAC;AACtC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;8DAsB+C,CAAC;AAC/D,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,0BAA0B,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 6179, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/colorCorrection.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/colorCorrection.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"colorCorrectionPixelShader\";\nconst shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;varying vUV: vec2f;var colorTableSampler: sampler;var colorTable: texture_2d<f32>;const SLICE_COUNT: f32=16.0; \nfn sampleAs3DTexture(uv: vec3f,width: f32)->vec4f {var sliceSize: f32=1.0/width; \nvar slicePixelSize: f32=sliceSize/width; \nvar sliceInnerSize: f32=slicePixelSize*(width-1.0); \nvar zSlice0: f32=min(floor(uv.z*width),width-1.0);var zSlice1: f32=min(zSlice0+1.0,width-1.0);var xOffset: f32=slicePixelSize*0.5+uv.x*sliceInnerSize;var s0: f32=xOffset+(zSlice0*sliceSize);var s1: f32=xOffset+(zSlice1*sliceSize);var slice0Color: vec4f=textureSample(colorTable,colorTableSampler,vec2f(s0,uv.y));var slice1Color: vec4f=textureSample(colorTable,colorTableSampler,vec2f(s1,uv.y));var zOffset: f32=((uv.z*width)%(1.0));return mix(slice0Color,slice1Color,zOffset);}\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var screen_color: vec4f=textureSample(textureSampler,textureSamplerSampler,input.vUV);fragmentOutputs.color=sampleAs3DTexture(screen_color.rgb,SLICE_COUNT);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const colorCorrectionPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,4BAA4B,CAAC;AAC1C,MAAM,MAAM,GAAG,CAAA;;;;;;;+MAOgM,CAAC;AAChN,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,8BAA8B,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 6207, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/motionBlur.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/motionBlur.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"motionBlurPixelShader\";\nconst shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform motionStrength: f32;uniform motionScale: f32;uniform screenSize: vec2f;\n#ifdef OBJECT_BASED\nvar velocitySamplerSampler: sampler;var velocitySampler: texture_2d<f32>;\n#else\nvar depthSamplerSampler: sampler;var depthSampler: texture_2d<f32>;uniform inverseViewProjection: mat4x4f;uniform prevViewProjection: mat4x4f;uniform projection: mat4x4f;\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#ifdef GEOMETRY_SUPPORTED\n#ifdef OBJECT_BASED\nvar texelSize: vec2f=1.0/uniforms.screenSize;var velocityColor: vec4f=textureSampleLevel(velocitySampler,velocitySamplerSampler,input.vUV,0.0);velocityColor=vec4f(velocityColor.rg*2.0- vec2f(1.0),velocityColor.b,velocityColor.a);let signs=sign(velocityColor.rg);var velocity=pow(abs(velocityColor.rg),vec2f(3.0))*signs*velocityColor.a;velocity*=uniforms.motionScale*uniforms.motionStrength;var speed: f32=length(velocity/texelSize);var samplesCount: i32= i32(clamp(speed,1.0,SAMPLES));velocity=normalize(velocity)*texelSize;var hlim: f32= f32(-samplesCount)*0.5+0.5;var result: vec4f=textureSampleLevel(textureSampler,textureSamplerSampler, input.vUV,0.0);for (var i: i32=1; i< i32(SAMPLES); i++)\n{if (i>=samplesCount) {break;}\nvar offset: vec2f=input.vUV+velocity*(hlim+ f32(i));result+=textureSampleLevel(textureSampler,textureSamplerSampler, offset,0.0);}\nfragmentOutputs.color=vec4f(result.rgb/ f32(samplesCount),1.0);\n#else\nvar result: vec4f=textureSampleLevel(textureSampler,textureSamplerSampler, input.vUV,0.0);var texelSize: vec2f=1.0/uniforms.screenSize;var depth: f32=textureSampleLevel(depthSampler,depthSamplerSampler,input.vUV,0.0).r;if (depth==0.0) {fragmentOutputs.color=result;return fragmentOutputs;}\ndepth=uniforms.projection[2].z+uniforms.projection[3].z/depth; \nvar cpos: vec4f= vec4f(input.vUV*2.0-1.0,depth,1.0);cpos=uniforms.inverseViewProjection*cpos;cpos/=cpos.w;var ppos: vec4f=uniforms.prevViewProjection*cpos;ppos/=ppos.w;ppos=vec4f(ppos.xy*0.5+0.5,ppos.zw);var velocity: vec2f=(ppos.xy-input.vUV)*uniforms.motionScale*uniforms.motionStrength;var speed: f32=length(velocity/texelSize);var nSamples: i32= i32(clamp(speed,1.0,SAMPLES));for (var i: i32=1; i< i32(SAMPLES); i++) {if (i>=nSamples) {break;}\nvar offset1: vec2f=input.vUV+velocity*( f32(i)/ f32(nSamples-1)-0.5);result+=textureSampleLevel(textureSampler,textureSamplerSampler, offset1,0.0);}\nfragmentOutputs.color=result/ f32(nSamples);\n#endif\n#else\nfragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler, input.vUV);\n#endif\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const motionBlurPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,uBAAuB,CAAC;AACrC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;CA0Bd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,yBAAyB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 6254, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/filter.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/filter.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"filterPixelShader\";\nconst shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform kernelMatrix: mat4x4f;\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var baseColor: vec3f=textureSample(textureSampler,textureSamplerSampler,input.vUV).rgb;var updatedColor: vec3f=(uniforms.kernelMatrix* vec4f(baseColor,1.0)).rgb;fragmentOutputs.color= vec4f(updatedColor,1.0);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const filterPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,mBAAmB,CAAC;AACjC,MAAM,MAAM,GAAG,CAAA;;;mQAGoP,CAAC;AACpQ,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,qBAAqB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 6278, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/highlights.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/highlights.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"highlightsPixelShader\";\nconst shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;const RGBLuminanceCoefficients: vec3f= vec3f(0.2126,0.7152,0.0722);\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var tex: vec4f=textureSample(textureSampler,textureSamplerSampler,input.vUV);var c: vec3f=tex.rgb;var luma: f32=dot(c.rgb,RGBLuminanceCoefficients);fragmentOutputs.color= vec4f(pow(c, vec3f(25.0-luma*15.0)),tex.a); }`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const highlightsPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,uBAAuB,CAAC;AACrC,MAAM,MAAM,GAAG,CAAA;;;0QAG2P,CAAC;AAC3Q,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,yBAAyB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 6302, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/displayPass.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/displayPass.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"displayPassPixelShader\";\nconst shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;var passSamplerSampler: sampler;var passSampler: texture_2d<f32>;\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=textureSample(passSampler,passSamplerSampler,input.vUV);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const displayPassPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,wBAAwB,CAAC;AACtC,MAAM,MAAM,GAAG,CAAA;;;iIAGkH,CAAC;AAClI,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,0BAA0B,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 6326, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/tonemap.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/tonemap.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"tonemapPixelShader\";\nconst shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform _ExposureAdjustment: f32;\n#if defined(HABLE_TONEMAPPING)\nconst A: f32=0.15;const B: f32=0.50;const C: f32=0.10;const D: f32=0.20;const E: f32=0.02;const F: f32=0.30;const W: f32=11.2;\n#endif\nfn Luminance(c: vec3f)->f32\n{return dot(c, vec3f(0.22,0.707,0.071));}\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var colour: vec3f=textureSample(textureSampler,textureSamplerSampler,input.vUV).rgb;\n#if defined(REINHARD_TONEMAPPING)\nvar lum: f32=Luminance(colour.rgb); \nvar lumTm: f32=lum*uniforms._ExposureAdjustment;var scale: f32=lumTm/(1.0+lumTm); \ncolour*=scale/lum;\n#elif defined(HABLE_TONEMAPPING)\ncolour*=uniforms._ExposureAdjustment;const ExposureBias: f32=2.0;var x: vec3f=ExposureBias*colour;var curr: vec3f=((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;x= vec3f(W,W,W);var whiteScale: vec3f=1.0/(((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F);colour=curr*whiteScale;\n#elif defined(OPTIMIZED_HEJIDAWSON_TONEMAPPING)\ncolour*=uniforms._ExposureAdjustment;var X: vec3f=max( vec3f(0.0,0.0,0.0),colour-0.004);var retColor: vec3f=(X*(6.2*X+0.5))/(X*(6.2*X+1.7)+0.06);colour=retColor*retColor;\n#elif defined(PHOTOGRAPHIC_TONEMAPPING)\ncolour= vec3f(1.0,1.0,1.0)-exp2(-uniforms._ExposureAdjustment*colour);\n#endif\nfragmentOutputs.color= vec4f(colour.rgb,1.0);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const tonemapPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,oBAAoB,CAAC;AAClC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;+CAoBgC,CAAC;AAChD,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,sBAAsB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 6367, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/subSurfaceScattering.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/subSurfaceScattering.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/fibonacci\";\nimport \"./ShadersInclude/subSurfaceScatteringFunctions\";\nimport \"./ShadersInclude/diffusionProfile\";\n\nconst name = \"subSurfaceScatteringPixelShader\";\nconst shader = `#include<helperFunctions>\n#include<fibonacci>\n#include<subSurfaceScatteringFunctions>\n#include<diffusionProfile>\nvarying vUV: vec2f;uniform texelSize: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;var irradianceSamplerSampler: sampler;var irradianceSampler: texture_2d<f32>;var depthSamplerSampler: sampler;var depthSampler: texture_2d<f32>;var albedoSamplerSampler: sampler;var albedoSampler: texture_2d<f32>;uniform viewportSize: vec2f;uniform metersPerUnit: f32;const LOG2_E=1.4426950408889634;const SSS_PIXELS_PER_SAMPLE=4.;const _SssSampleBudget=40u;\n#define SSS_BILATERAL_FILTER true\nfn EvalBurleyDiffusionProfile(r: f32,S: vec3f)->vec3f\n{let exp_13=exp2(((LOG2_E*(-1.0/3.0))*r)*S); \nlet expSum=exp_13*(1.+exp_13*exp_13); \nreturn (S*rcp(8.*PI))*expSum; }\nfn SampleBurleyDiffusionProfile(u_: f32,rcpS: f32)->vec2f\n{let u=1.-u_; \nlet g=1.+(4.*u)*(2.*u+sqrt(1.+(4.*u)*u));let n=exp2(log2(g)*(-1.0/3.0)); \nlet p=(g*n)*n; \nlet c=1.+p+n; \nlet d=(3./LOG2_E*2.)+(3./LOG2_E)*log2(u); \nlet x=(3./LOG2_E)*log2(c)-d; \nlet rcpExp=((c*c)*c)*rcp((4.*u)*((c*c)+(4.*u)*(4.*u)));let r=x*rcpS;let rcpPdf=(8.*PI*rcpS)*rcpExp; \nreturn vec2f(r,rcpPdf);}\nfn ComputeBilateralWeight(xy2: f32,z_: f32,mmPerUnit: f32,S: vec3f,rcpPdf: f32)->vec3f\n{\n#ifndef SSS_BILATERAL_FILTER\nlet z=0.;\n#else\nlet z=z_;\n#endif\nlet r=sqrt(xy2+(z*mmPerUnit)*(z*mmPerUnit));let area=rcpPdf;\n#ifdef SSS_CLAMP_ARTIFACT\nreturn clamp(EvalBurleyDiffusionProfile(r,S)*area,vec3f(0.0),vec3f(1.0));\n#else\nreturn EvalBurleyDiffusionProfile(r,S)*area;\n#endif\n}\nfn EvaluateSample(i: u32,n: u32,S: vec3f,d: f32,centerPosVS: vec3f,mmPerUnit: f32,pixelsPerMm: f32,\nphase: f32,totalIrradiance: ptr<function,vec3f>,totalWeight: ptr<function,vec3f>)\n{let scale =rcp(f32(n));let offset=rcp(f32(n))*0.5;let sinPhase=sin(phase);let cosPhase=cos(phase);let bdp=SampleBurleyDiffusionProfile(f32(i)*scale+offset,d);let r=bdp.x;let rcpPdf=bdp.y;let phi=SampleDiskGolden(i,n).y;let sinPhi=sin(phi);let cosPhi=cos(phi);let sinPsi=cosPhase*sinPhi+sinPhase*cosPhi; \nlet cosPsi=cosPhase*cosPhi-sinPhase*sinPhi; \nlet vec=r*vec2f(cosPsi,sinPsi);let position=fragmentInputs.vUV+round((pixelsPerMm*r)*vec2(cosPsi,sinPsi))*uniforms.texelSize;let xy2 =r*r;let textureRead=textureSampleLevel(irradianceSampler,irradianceSamplerSampler,position,0.);let viewZ=textureSampleLevel(depthSampler,depthSamplerSampler,position,0.).r;let irradiance =textureRead.rgb;if (testLightingForSSS(textureRead.a))\n{let relZ=viewZ-centerPosVS.z;let weight=ComputeBilateralWeight(xy2,relZ,mmPerUnit,S,rcpPdf);*totalIrradiance+=weight*irradiance;*totalWeight +=weight;}\nelse\n{}}\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {let irradianceAndDiffusionProfile =textureSampleLevel(irradianceSampler,irradianceSamplerSampler,fragmentInputs.vUV,0.);let centerIrradiance=irradianceAndDiffusionProfile.rgb;let diffusionProfileIndex=u32(round(irradianceAndDiffusionProfile.a*255.));var centerDepth =0.;let inputColor=textureSampleLevel(textureSampler,textureSamplerSampler,fragmentInputs.vUV,0.);let passedStencilTest=testLightingForSSS(irradianceAndDiffusionProfile.a);if (passedStencilTest)\n{centerDepth=textureSampleLevel(depthSampler,depthSamplerSampler,fragmentInputs.vUV,0.).r;}\nif (!passedStencilTest) { \nfragmentOutputs.color=inputColor;return fragmentOutputs;}\nlet distScale =1.;let S =uniforms.diffusionS[diffusionProfileIndex];let d =uniforms.diffusionD[diffusionProfileIndex];let filterRadius=uniforms.filterRadii[diffusionProfileIndex];let centerPosNDC=fragmentInputs.vUV;let cornerPosNDC=fragmentInputs.vUV+0.5*uniforms.texelSize;let centerPosVS =vec3f(centerPosNDC*uniforms.viewportSize,1.0)*centerDepth; \nlet cornerPosVS =vec3f(cornerPosNDC*uniforms.viewportSize,1.0)*centerDepth; \nlet mmPerUnit =1000.*(uniforms.metersPerUnit*rcp(distScale));let unitsPerMm=rcp(mmPerUnit);let unitsPerPixel=2.*abs(cornerPosVS.x-centerPosVS.x);let pixelsPerMm =rcp(unitsPerPixel)*unitsPerMm;let filterArea =PI*square(filterRadius*pixelsPerMm);let sampleCount =u32(filterArea*rcp(SSS_PIXELS_PER_SAMPLE));let sampleBudget=_SssSampleBudget;let albedo =textureSampleLevel(albedoSampler,albedoSamplerSampler,fragmentInputs.vUV,0.).rgb;if (distScale==0. || sampleCount<1)\n{\n#ifdef DEBUG_SSS_SAMPLES\nlet green=vec3f(0.,1.,0.);fragmentOutputs.color=vec4f(green,1.0);return fragmentOutputs;\n#endif\nfragmentOutputs.color=vec4f(inputColor.rgb+albedo*centerIrradiance,1.0);return fragmentOutputs;}\n#ifdef DEBUG_SSS_SAMPLES\nlet red =vec3f(1.,0.,0.);let blue=vec3f(0.,0.,1.);fragmentOutputs.color=vec4f(mix(blue,red,clamp(f32(sampleCount)/f32(sampleBudget),0.0,1.0)),1.0);return fragmentOutputs;\n#endif\nlet phase=0.;let n=min(sampleCount,sampleBudget);var totalIrradiance=vec3f(0.);var totalWeight =vec3f(0.);for (var i=0u; i<n; i++)\n{EvaluateSample(i,n,S,d,centerPosVS,mmPerUnit,pixelsPerMm,\nphase,&totalIrradiance,&totalWeight);}\ntotalWeight=max(totalWeight,vec3f(HALF_MIN));fragmentOutputs.color=vec4f(inputColor.rgb+albedo*max(totalIrradiance/totalWeight,vec3f(0.0)),1.);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const subSurfaceScatteringPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,kCAAkC,CAAC;AAC1C,OAAO,4BAA4B,CAAC;AACpC,OAAO,gDAAgD,CAAC;AACxD,OAAO,mCAAmC,CAAC;;;;;;AAE3C,MAAM,IAAI,GAAG,iCAAiC,CAAC;AAC/C,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8Dd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,mCAAmC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 6458, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/fluidRenderingParticleDepth.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/fluidRenderingParticleDepth.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"fluidRenderingParticleDepthVertexShader\";\nconst shader = `attribute position: vec3f;attribute offset: vec2f;uniform view: mat4x4f;uniform projection: mat4x4f;uniform size: vec2f;varying uv: vec2f;varying viewPos: vec3f;varying sphereRadius: f32;\n#ifdef FLUIDRENDERING_VELOCITY\nattribute velocity: vec3f;varying velocityNorm: f32;\n#endif\n@vertex\nfn main(input: VertexInputs)->FragmentInputs {var cornerPos: vec3f=vec3f(\nvec2f(input.offset.x-0.5,input.offset.y-0.5)*uniforms.size,\n0.0\n);vertexOutputs.viewPos=(uniforms.view*vec4f(input.position,1.0)).xyz;vertexOutputs.position=uniforms.projection*vec4f(vertexOutputs.viewPos+cornerPos,1.0);vertexOutputs.uv=input.offset;vertexOutputs.sphereRadius=uniforms.size.x/2.0;\n#ifdef FLUIDRENDERING_VELOCITY\nvertexOutputs.velocityNorm=length(velocity);\n#endif\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const fluidRenderingParticleDepthVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,yCAAyC,CAAC;AACvD,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;CAad,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,2CAA2C,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 6492, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/fluidRenderingParticleDepth.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/fluidRenderingParticleDepth.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"fluidRenderingParticleDepthPixelShader\";\nconst shader = `uniform projection: mat4x4f;varying uv: vec2f;varying viewPos: vec3f;varying sphereRadius: f32;\n#ifdef FLUIDRENDERING_VELOCITY\nvarying velocityNorm: f32;\n#endif\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var normalxy: vec2f=input.uv*2.0-1.0;var r2: f32=dot(normalxy,normalxy);if (r2>1.0) {discard;}\nvar normal: vec3f=vec3f(normalxy,sqrt(1.0-r2));\n#ifndef FLUIDRENDERING_RHS\nnormal.z=-normal.z;\n#endif\nvar realViewPos: vec4f=vec4f(input.viewPos+normal*input.sphereRadius,1.0);var clipSpacePos: vec4f=uniforms.projection*realViewPos;fragmentOutputs.fragDepth=clipSpacePos.z/clipSpacePos.w;\n#ifdef FLUIDRENDERING_RHS\nrealViewPos.z=-realViewPos.z;\n#endif\n#ifdef FLUIDRENDERING_VELOCITY\nfragmentOutputs.color=vec4f(realViewPos.z,input.velocityNorm,0.,1.);\n#else\nfragmentOutputs.color=vec4f(realViewPos.z,0.,0.,1.);\n#endif\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const fluidRenderingParticleDepthPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,wCAAwC,CAAC;AACtD,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;CAoBd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,0CAA0C,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 6533, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/fluidRenderingParticleThickness.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/fluidRenderingParticleThickness.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"fluidRenderingParticleThicknessVertexShader\";\nconst shader = `attribute position: vec3f;attribute offset: vec2f;uniform view: mat4x4f;uniform projection: mat4x4f;uniform size: vec2f;varying uv: vec2f;@vertex\nfn main(input: VertexInputs)->FragmentInputs {var cornerPos: vec3f=vec3f(\nvec2f(input.offset.x-0.5,input.offset.y-0.5)*uniforms.size,\n0.0\n);var viewPos: vec3f=(uniforms.view*vec4f(input.position,1.0)).xyz+cornerPos;vertexOutputs.position=uniforms.projection*vec4f(viewPos,1.0);vertexOutputs.uv=input.offset;}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const fluidRenderingParticleThicknessVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,6CAA6C,CAAC;AAC3D,MAAM,MAAM,GAAG,CAAA;;;;;CAKd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,+CAA+C,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 6559, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/fluidRenderingParticleThickness.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/fluidRenderingParticleThickness.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"fluidRenderingParticleThicknessPixelShader\";\nconst shader = `uniform particleAlpha: f32;varying uv: vec2f;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var normalxy: vec2f=input.uv*2.0-1.0;var r2: f32=dot(normalxy,normalxy);if (r2>1.0) {discard;}\nvar thickness: f32=sqrt(1.0-r2);fragmentOutputs.color=vec4f(vec3f(uniforms.particleAlpha*thickness),1.0);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const fluidRenderingParticleThicknessPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,4CAA4C,CAAC;AAC1D,MAAM,MAAM,GAAG,CAAA;;;CAGd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,8CAA8C,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 6583, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/fluidRenderingParticleDiffuse.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/fluidRenderingParticleDiffuse.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"fluidRenderingParticleDiffuseVertexShader\";\nconst shader = `attribute position: vec3f;attribute offset: vec2f;attribute color: vec4f;uniform view: mat4x4f;uniform projection: mat4x4f;uniform size: vec2f;varying uv: vec2f;varying diffuseColor: vec3f;@vertex\nfn main(input: VertexInputs)->FragmentInputs {var cornerPos: vec3f=vec3f(\nvec2f(input.offset.x-0.5,input.offset.y-0.5)*uniforms.size,\n0.0\n);var viewPos: vec3f=(uniforms.view*vec4f(input.position,1.0)).xyz+cornerPos;vertexOutputs.position=uniforms.projection*vec4f(viewPos,1.0);vertexOutputs.uv=input.offset;vertexOutputs.diffuseColor=input.color.rgb;}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const fluidRenderingParticleDiffuseVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,2CAA2C,CAAC;AACzD,MAAM,MAAM,GAAG,CAAA;;;;;CAKd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,6CAA6C,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 6609, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/fluidRenderingParticleDiffuse.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/fluidRenderingParticleDiffuse.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"fluidRenderingParticleDiffusePixelShader\";\nconst shader = `uniform particleAlpha: f32;varying uv: vec2f;varying diffuseColor: vec3f;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var normalxy: vec2f=input.uv*2.0-1.0;var r2: f32=dot(normalxy,normalxy);if (r2>1.0) {discard;}\nfragmentOutputs.color=vec4f(input.diffuseColor,1.0);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const fluidRenderingParticleDiffusePixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,0CAA0C,CAAC;AACxD,MAAM,MAAM,GAAG,CAAA;;;CAGd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,4CAA4C,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 6633, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/fluidRenderingBilateralBlur.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/fluidRenderingBilateralBlur.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"fluidRenderingBilateralBlurPixelShader\";\nconst shader = `var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform maxFilterSize: i32;uniform blurDir: vec2f;uniform projectedParticleConstant: f32;uniform depthThreshold: f32;varying vUV: vec2f;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var depth: f32=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV,0.).x;if (depth>=1e6 || depth<=0.) {fragmentOutputs.color=vec4f(vec3f(depth),1.);return fragmentOutputs;}\nvar filterSize: i32=min(uniforms.maxFilterSize,i32(ceil(uniforms.projectedParticleConstant/depth)));var sigma: f32=f32(filterSize)/3.0;var two_sigma2: f32=2.0*sigma*sigma;var sigmaDepth: f32=uniforms.depthThreshold/3.0;var two_sigmaDepth2: f32=2.0*sigmaDepth*sigmaDepth;var sum: f32=0.;var wsum: f32=0.;var sumVel: f32=0.;for (var x: i32=-filterSize; x<=filterSize; x++) {var coords: vec2f=vec2f(f32(x));var sampleDepthVel: vec2f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV+coords*uniforms.blurDir,0.).rg;var r: f32=dot(coords,coords);var w: f32=exp(-r/two_sigma2);var rDepth: f32=sampleDepthVel.r-depth;var wd: f32=exp(-rDepth*rDepth/two_sigmaDepth2);sum+=sampleDepthVel.r*w*wd;sumVel+=sampleDepthVel.g*w*wd;wsum+=w*wd;}\nfragmentOutputs.color=vec4f(sum/wsum,sumVel/wsum,0.,1.);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const fluidRenderingBilateralBlurPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,wCAAwC,CAAC;AACtD,MAAM,MAAM,GAAG,CAAA;;;;CAId,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,0CAA0C,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 6658, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/fluidRenderingStandardBlur.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/fluidRenderingStandardBlur.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"fluidRenderingStandardBlurPixelShader\";\nconst shader = `var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform filterSize: i32;uniform blurDir: vec2f;varying vUV: vec2f;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var s: vec4f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV,0.);if (s.r==0.) {fragmentOutputs.color=vec4f(0.,0.,0.,1.);return fragmentOutputs;}\nvar sigma: f32=f32(uniforms.filterSize)/3.0;var twoSigma2: f32=2.0*sigma*sigma;var sum: vec4f=vec4f(0.);var wsum: f32=0.;for (var x: i32=-uniforms.filterSize; x<=uniforms.filterSize; x++) {var coords: vec2f=vec2f(f32(x));var sampl: vec4f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV+coords*uniforms.blurDir,0.);var w: f32=exp(-coords.x*coords.x/twoSigma2);sum+=sampl*w;wsum+=w;}\nsum/=wsum;fragmentOutputs.color=vec4f(sum.rgb,1.);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const fluidRenderingStandardBlurPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,uCAAuC,CAAC;AACrD,MAAM,MAAM,GAAG,CAAA;;;;CAId,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,yCAAyC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 6683, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/fluidRenderingRender.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/fluidRenderingRender.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"fluidRenderingRenderPixelShader\";\nconst shader = `#define DISABLE_UNIFORMITY_ANALYSIS\n#define IOR 1.333\n#define ETA 1.0/IOR\n#define F0 0.02\nvar textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;var depthSamplerSampler: sampler;var depthSampler: texture_2d<f32>;\n#ifdef FLUIDRENDERING_DIFFUSETEXTURE\nvar diffuseSamplerSampler: sampler;var diffuseSampler: texture_2d<f32>;\n#else\nuniform diffuseColor: vec3f;\n#endif\n#ifdef FLUIDRENDERING_FIXED_THICKNESS\nuniform thickness: f32;var bgDepthSamplerSampler: sampler;var bgDepthSampler: texture_2d<f32>;\n#else\nuniform minimumThickness: f32;var thicknessSamplerSampler: sampler;var thicknessSampler: texture_2d<f32>;\n#endif\n#ifdef FLUIDRENDERING_ENVIRONMENT\nvar reflectionSamplerSampler: sampler;var reflectionSampler: texture_cube<f32>;\n#endif\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)\nvar debugSamplerSampler: sampler;var debugSampler: texture_2d<f32>;\n#endif\nuniform viewMatrix: mat4x4f;uniform projectionMatrix: mat4x4f;uniform invProjectionMatrix: mat4x4f;uniform texelSize: vec2f;uniform dirLight: vec3f;uniform cameraFar: f32;uniform density: f32;uniform refractionStrength: f32;uniform fresnelClamp: f32;uniform specularPower: f32;varying vUV: vec2f;fn computeViewPosFromUVDepth(texCoord: vec2f,depth: f32)->vec3f {var ndc: vec4f=vec4f(texCoord*2.0-1.0,0.0,1.0);\n#ifdef FLUIDRENDERING_RHS\nndc.z=-uniforms.projectionMatrix[2].z+uniforms.projectionMatrix[3].z/depth;\n#else\nndc.z=uniforms.projectionMatrix[2].z+uniforms.projectionMatrix[3].z/depth;\n#endif\nndc.w=1.0;var eyePos: vec4f=uniforms.invProjectionMatrix*ndc;return eyePos.xyz/eyePos.w;}\nfn getViewPosFromTexCoord(texCoord: vec2f)->vec3f {var depth: f32=textureSampleLevel(depthSampler,depthSamplerSampler,texCoord,0.).x;return computeViewPosFromUVDepth(texCoord,depth);}\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var texCoord: vec2f=input.vUV;\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)\nvar color: vec4f=textureSample(debugSampler,debugSamplerSampler,texCoord);\n#ifdef FLUIDRENDERING_DEBUG_DEPTH\nfragmentOutputs.color=vec4f(color.rgb/vec3f(2.0),1.);if (color.r>0.999 && color.g>0.999) {fragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,texCoord);}\n#else\nfragmentOutputs.color=vec4f(color.rgb,1.);if (color.r<0.001 && color.g<0.001 && color.b<0.001) {fragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,texCoord);}\n#endif\nreturn fragmentOutputs;\n#endif\nvar depthVel: vec2f=textureSampleLevel(depthSampler,depthSamplerSampler,texCoord,0.).rg;var depth: f32=depthVel.r;\n#ifndef FLUIDRENDERING_FIXED_THICKNESS\nvar thickness: f32=textureSample(thicknessSampler,thicknessSamplerSampler,texCoord).x;\n#else\nvar thickness: f32=uniforms.thickness;var bgDepth: f32=textureSample(bgDepthSampler,bgDepthSamplerSampler,texCoord).x;var depthNonLinear: f32=uniforms.projectionMatrix[2].z+uniforms.projectionMatrix[3].z/depth;depthNonLinear=depthNonLinear*0.5+0.5;\n#endif\nvar backColor: vec4f=textureSample(textureSampler,textureSamplerSampler,texCoord);\n#ifndef FLUIDRENDERING_FIXED_THICKNESS\nif (depth>=uniforms.cameraFar || depth<=0. || thickness<=uniforms.minimumThickness) {\n#else\nif (depth>=uniforms.cameraFar || depth<=0. || bgDepth<=depthNonLinear) {\n#endif\n#ifdef FLUIDRENDERING_COMPOSITE_MODE\nfragmentOutputs.color=vec4f(backColor.rgb*backColor.a,backColor.a);\n#else\nfragmentOutputs.color=backColor;\n#endif\nreturn fragmentOutputs;}\nvar viewPos: vec3f=computeViewPosFromUVDepth(texCoord,depth);var ddx: vec3f=getViewPosFromTexCoord(texCoord+vec2f(uniforms.texelSize.x,0.))-viewPos;var ddy: vec3f=getViewPosFromTexCoord(texCoord+vec2f(0.,uniforms.texelSize.y))-viewPos;var ddx2: vec3f=viewPos-getViewPosFromTexCoord(texCoord+vec2f(-uniforms.texelSize.x,0.));if (abs(ddx.z)>abs(ddx2.z)) {ddx=ddx2;}\nvar ddy2: vec3f=viewPos-getViewPosFromTexCoord(texCoord+vec2f(0.,-uniforms.texelSize.y));if (abs(ddy.z)>abs(ddy2.z)) {ddy=ddy2;}\nvar normal: vec3f=normalize(cross(ddy,ddx));\n#ifdef FLUIDRENDERING_RHS\nnormal=-normal;\n#endif\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_SHOWNORMAL)\nfragmentOutputs.color=vec4f(normal*0.5+0.5,1.0);return fragmentOutputs;\n#endif\nvar rayDir: vec3f=normalize(viewPos); \n#ifdef FLUIDRENDERING_DIFFUSETEXTURE\nvar diffuseColor: vec3f=textureSampleLevel(diffuseSampler,diffuseSamplerSampler,texCoord,0.0).rgb;\n#else\nvar diffuseColor: vec3f=uniforms.diffuseColor;\n#endif\nvar lightDir: vec3f=normalize((uniforms.viewMatrix*vec4f(-uniforms.dirLight,0.)).xyz);var H: vec3f =normalize(lightDir-rayDir);var specular: f32 =pow(max(0.0,dot(H,normal)),uniforms.specularPower);\n#ifdef FLUIDRENDERING_DEBUG_DIFFUSERENDERING\nvar diffuse: f32 =max(0.0,dot(lightDir,normal))*1.0;fragmentOutputs.color=vec4f(vec3f(0.1) /*ambient*/+vec3f(0.42,0.50,1.00)*diffuse+vec3f(0,0,0.2)+specular,1.);return fragmentOutputs;\n#endif\nvar refractionDir: vec3f=refract(rayDir,normal,ETA);var transmitted: vec4f=textureSampleLevel(textureSampler,textureSamplerSampler,vec2f(texCoord+refractionDir.xy*thickness*uniforms.refractionStrength),0.0);\n#ifdef FLUIDRENDERING_COMPOSITE_MODE\nif (transmitted.a==0.) {transmitted.a=thickness;}\n#endif\nvar transmittance: vec3f=exp(-uniforms.density*thickness*(1.0-diffuseColor)); \nvar refractionColor: vec3f=transmitted.rgb*transmittance;\n#ifdef FLUIDRENDERING_ENVIRONMENT\nvar reflectionDir: vec3f=reflect(rayDir,normal);var reflectionColor: vec3f=(textureSample(reflectionSampler,reflectionSamplerSampler,reflectionDir).rgb);var fresnel: f32=clamp(F0+(1.0-F0)*pow(1.0-dot(normal,-rayDir),5.0),0.,uniforms.fresnelClamp);var finalColor: vec3f=mix(refractionColor,reflectionColor,fresnel)+specular;\n#else\nvar finalColor: vec3f=refractionColor+specular;\n#endif\n#ifdef FLUIDRENDERING_VELOCITY\nvar velocity: f32=depthVel.g;finalColor=mix(finalColor,vec3f(1.0),smoothstep(0.3,1.0,velocity/6.0));\n#endif\nfragmentOutputs.color=vec4f(finalColor,transmitted.a);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const fluidRenderingRenderPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,iCAAiC,CAAC;AAC/C,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4Fd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,mCAAmC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 6796, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/bilateralBlur.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/bilateralBlur.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"bilateralBlurPixelShader\";\nconst shader = `var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;var normalSamplerSampler: sampler;var normalSampler: texture_2d<f32>;var depthSamplerSampler: sampler;var depthSampler: texture_2d<f32>;uniform filterSize: i32;uniform blurDir: vec2f;uniform depthThreshold: f32;uniform normalThreshold: f32;varying vUV: vec2f;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var color: vec3f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV,0.).rgb;var depth: f32=textureSampleLevel(depthSampler,depthSamplerSampler,input.vUV,0.).x;if (depth>=1e6 || depth<=0.) {fragmentOutputs.color= vec4f(color,1.);return fragmentOutputs;}\nvar normal: vec3f=textureSampleLevel(normalSampler,normalSamplerSampler,input.vUV,0.).rgb;\n#ifdef DECODE_NORMAL\nnormal=normal*2.0-1.0;\n#endif\nvar sigma: f32= f32(uniforms.filterSize);var two_sigma2: f32=2.0*sigma*sigma;var sigmaDepth: f32=uniforms.depthThreshold;var two_sigmaDepth2: f32=2.0*sigmaDepth*sigmaDepth;var sigmaNormal: f32=uniforms.normalThreshold;var two_sigmaNormal2: f32=2.0*sigmaNormal*sigmaNormal;var sum: vec3f= vec3f(0.);var wsum: f32=0.;for (var x: i32=-uniforms.filterSize; x<=uniforms.filterSize; x++) {var coords=vec2f(f32(x));var sampleColor: vec3f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV+coords*uniforms.blurDir,0.).rgb;var sampleDepth: f32=textureSampleLevel(depthSampler,depthSamplerSampler,input.vUV+coords*uniforms.blurDir,0.).r;var sampleNormal: vec3f=textureSampleLevel(normalSampler,normalSamplerSampler,input.vUV+coords*uniforms.blurDir,0.).rgb;\n#ifdef DECODE_NORMAL\nsampleNormal=sampleNormal*2.0-1.0;\n#endif\nvar r: f32=dot(coords,coords);var w: f32=exp(-r/two_sigma2);var depthDelta: f32=abs(sampleDepth-depth);var wd: f32=step(depthDelta,uniforms.depthThreshold);var normalDelta: vec3f=abs(sampleNormal-normal);var wn: f32=step(normalDelta.x+normalDelta.y+normalDelta.z,uniforms.normalThreshold);sum+=sampleColor*w*wd*wn;wsum+=w*wd*wn;}\nfragmentOutputs.color= vec4f(sum/wsum,1.);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const bilateralBlurPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,0BAA0B,CAAC;AACxC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;CAYd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,4BAA4B,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 6829, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/bilateralBlurQuality.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/bilateralBlurQuality.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"bilateralBlurQualityPixelShader\";\nconst shader = `var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;var normalSamplerSampler: sampler;var normalSampler: texture_2d<f32>;var depthSamplerSampler: sampler;var depthSampler: texture_2d<f32>;uniform filterSize: i32;uniform blurDir: vec2f;uniform depthThreshold: f32;uniform normalThreshold: f32;varying vUV: vec2f;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var color: vec3f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV,0.).rgb;var depth: f32=textureSampleLevel(depthSampler,depthSamplerSampler,input.vUV,0.).x;if (depth>=1e6 || depth<=0.) {fragmentOutputs.color= vec4f(color,1.);return fragmentOutputs;}\nvar normal: vec3f=textureSampleLevel(normalSampler,normalSamplerSampler,input.vUV,0.).rgb;\n#ifdef DECODE_NORMAL\nnormal=normal*2.0-1.0;\n#endif\nvar sigma: f32= f32(uniforms.filterSize);var two_sigma2: f32=2.0*sigma*sigma;var sigmaDepth: f32=uniforms.depthThreshold;var two_sigmaDepth2: f32=2.0*sigmaDepth*sigmaDepth;var sigmaNormal: f32=uniforms.normalThreshold;var two_sigmaNormal2: f32=2.0*sigmaNormal*sigmaNormal;var sum: vec3f= vec3f(0.);var wsum: f32=0.;for (var x: i32=-uniforms.filterSize; x<=uniforms.filterSize; x++) {for (var y: i32=-uniforms.filterSize; y<=uniforms.filterSize; y++) {var coords: vec2f= vec2f(f32(x),f32(y))*uniforms.blurDir;var sampleColor: vec3f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV+coords,0.).rgb;var sampleDepth: f32=textureSampleLevel(depthSampler,depthSamplerSampler,input.vUV+coords,0.).r;var sampleNormal: vec3f=textureSampleLevel(normalSampler,normalSamplerSampler,input.vUV+coords,0.).rgb;\n#ifdef DECODE_NORMAL\nsampleNormal=sampleNormal*2.0-1.0;\n#endif\nvar r: f32=dot(coords,coords);var w: f32=exp(-r/two_sigma2);var rDepth: f32=sampleDepth-depth;var wd: f32=exp(-rDepth*rDepth/two_sigmaDepth2);var rNormal: f32=abs(sampleNormal.x-normal.x)+abs(sampleNormal.y-normal.y)+abs(sampleNormal.z-normal.z);var wn: f32=exp(-rNormal*rNormal/two_sigmaNormal2);sum+=sampleColor*w*wd*wn;wsum+=w*wd*wn;}}\nfragmentOutputs.color= vec4f(sum/wsum,1.);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const bilateralBlurQualityPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,iCAAiC,CAAC;AAC/C,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;CAYd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,mCAAmC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 6862, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/rsmGlobalIllumination.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/rsmGlobalIllumination.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"rsmGlobalIlluminationPixelShader\";\nconst shader = `/**\n* The implementation is an application of the formula found in http:\n* For better results,it also adds a random (noise) rotation to the RSM samples (the noise artifacts are easier to remove than the banding artifacts).\n*/\nvarying vUV: vec2f;uniform rsmLightMatrix: mat4x4f;uniform rsmInfo: vec4f;uniform rsmInfo2: vec4f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;var normalSamplerSampler: sampler;var normalSampler: texture_2d<f32>;var rsmPositionWSampler: sampler;var rsmPositionW: texture_2d<f32>;var rsmNormalWSampler: sampler;var rsmNormalW: texture_2d<f32>;var rsmFluxSampler: sampler;var rsmFlux: texture_2d<f32>;var rsmSamples: texture_2d<f32>;\n#ifdef TRANSFORM_NORMAL\nuniform invView: mat4x4f;\n#endif\nfn mod289(x: f32)->f32{return x-floor(x*(1.0/289.0))*289.0;}\nfn mod289Vec4(x: vec4f)->vec4f {return x-floor(x*(1.0/289.0))* 289.0;}\nfn perm(x: vec4f)->vec4f {return mod289Vec4(((x*34.0)+1.0)*x) ;}\nfn noise(p: vec3f)->f32{var a: vec3f=floor(p);var d: vec3f=p-a;d=d*d*(3.0-2.0*d);var b: vec4f=a.xxyy+ vec4f(0.0,1.0,0.0,1.0);var k1: vec4f=perm(b.xyxy);var k2: vec4f=perm(k1.xyxy+b.zzww);var c: vec4f=k2+a.zzzz;var k3: vec4f=perm(c);var k4: vec4f=perm(c+1.0);var o1: vec4f=fract(k3*(1.0/41.0));var o2: vec4f=fract(k4*(1.0/41.0));var o3: vec4f=o2*d.z+o1*(1.0-d.z);var o4: vec2f=o3.yw*d.x+o3.xz*(1.0-d.x);return o4.y*d.y+o4.x*(1.0-d.y);}\nfn computeIndirect(p: vec3f,n: vec3f)->vec3f {var indirectDiffuse: vec3f= vec3f(0.);var numSamples: i32= i32(uniforms.rsmInfo.x);var radius: f32=uniforms.rsmInfo.y;var intensity: f32=uniforms.rsmInfo.z;var edgeArtifactCorrection: f32=uniforms.rsmInfo.w;var texRSM: vec4f=uniforms.rsmLightMatrix* vec4f(p,1.);texRSM=vec4f(texRSM.xy/texRSM.w,texRSM.z,texRSM.w);texRSM=vec4f(texRSM.xy*0.5+0.5,texRSM.z,texRSM.w);var angle: f32=noise(p*uniforms.rsmInfo2.x);var c: f32=cos(angle);var s: f32=sin(angle);for (var i: i32=0; i<numSamples; i++) {var rsmSample: vec3f=textureLoad(rsmSamples,vec2<i32>(i,0),0).xyz;var weightSquare: f32=rsmSample.z;if (uniforms.rsmInfo2.y==1.0){rsmSample=vec3f(rsmSample.x*c+rsmSample.y*s,-rsmSample.x*s+rsmSample.y*c,rsmSample.z);}\nvar uv: vec2f=texRSM.xy+rsmSample.xy*radius;if (uv.x<0. || uv.x>1. || uv.y<0. || uv.y>1.) {continue;}\nvar vplPositionW: vec3f=textureSampleLevel(rsmPositionW,rsmPositionWSampler,uv,0.).xyz;var vplNormalW: vec3f=textureSampleLevel(rsmNormalW,rsmNormalWSampler,uv,0.).xyz*2.0-1.0;var vplFlux: vec3f=textureSampleLevel(rsmFlux,rsmFluxSampler,uv,0.).rgb;vplPositionW-=vplNormalW*edgeArtifactCorrection; \nvar dist2: f32=dot(vplPositionW-p,vplPositionW-p);indirectDiffuse+=vplFlux*weightSquare*max(0.,dot(n,vplPositionW-p))*max(0.,dot(vplNormalW,p-vplPositionW))/(dist2*dist2);}\nreturn clamp(indirectDiffuse*intensity,vec3f(0.0),vec3f(1.0));}\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var positionW: vec3f=textureSample(textureSampler,textureSamplerSampler,input.vUV).xyz;var normalW: vec3f=textureSample(normalSampler,normalSamplerSampler,input.vUV).xyz;\n#ifdef DECODE_NORMAL\nnormalW=normalW*2.0-1.0;\n#endif\n#ifdef TRANSFORM_NORMAL\nnormalW=(uniforms.invView* vec4f(normalW,0.)).xyz;\n#endif\nfragmentOutputs.color=vec4f(computeIndirect(positionW,normalW),1.0);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const rsmGlobalIlluminationPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,kCAAkC,CAAC;AAChD,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;CA0Bd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,oCAAoC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 6909, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/rsmFullGlobalIllumination.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/rsmFullGlobalIllumination.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"rsmFullGlobalIlluminationPixelShader\";\nconst shader = `/**\n* The implementation is a direct application of the formula found in http:\n*/\nvarying vUV: vec2f;uniform rsmLightMatrix: mat4x4f;uniform rsmInfo: vec4f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;var normalSamplerSampler: sampler;var normalSampler: texture_2d<f32>;var rsmPositionW: texture_2d<f32>;var rsmNormalW: texture_2d<f32>;var rsmFlux: texture_2d<f32>;\n#ifdef TRANSFORM_NORMAL\nuniform invView: mat4x4f;\n#endif\nfn computeIndirect(p: vec3f,n: vec3f)->vec3f {var indirectDiffuse: vec3f= vec3f(0.);var intensity: f32=uniforms.rsmInfo.z;var edgeArtifactCorrection: f32=uniforms.rsmInfo.w;var texRSM: vec4f=uniforms.rsmLightMatrix* vec4f(p,1.);texRSM=vec4f(texRSM.xy/texRSM.w,texRSM.z,texRSM.w);texRSM=vec4f(texRSM.xy*0.5+0.5,texRSM.z,texRSM.w);var width: i32= i32(uniforms.rsmInfo.x);var height: i32= i32(uniforms.rsmInfo.y);for (var j: i32=0; j<height; j++) {for (var i: i32=0; i<width; i++) {var uv=vec2<i32>(i,j);var vplPositionW: vec3f=textureLoad(rsmPositionW,uv,0).xyz;var vplNormalW: vec3f=textureLoad(rsmNormalW,uv,0).xyz*2.0-1.0;var vplFlux: vec3f=textureLoad(rsmFlux,uv,0).rgb;vplPositionW-=vplNormalW*edgeArtifactCorrection; \nvar dist2: f32=dot(vplPositionW-p,vplPositionW-p);indirectDiffuse+=vplFlux*max(0.,dot(n,vplPositionW-p))*max(0.,dot(vplNormalW,p-vplPositionW))/(dist2*dist2);}}\nreturn clamp(indirectDiffuse*intensity,vec3f(0.0),vec3f(1.0));}\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var positionW: vec3f=textureSample(textureSampler,textureSamplerSampler,fragmentInputs.vUV).xyz;var normalW: vec3f=textureSample(normalSampler,normalSamplerSampler,fragmentInputs.vUV).xyz;\n#ifdef DECODE_NORMAL\nnormalW=normalW*2.0-1.0;\n#endif\n#ifdef TRANSFORM_NORMAL\nnormalW=(uniforms.invView* vec4f(normalW,0.)).xyz;\n#endif\nfragmentOutputs.color=vec4f(computeIndirect(positionW,normalW),1.0);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const rsmFullGlobalIlluminationPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,sCAAsC,CAAC;AACpD,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;CAmBd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,wCAAwC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 6949, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/depth.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/depth.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/packingFunctions\";\nimport \"./ShadersInclude/clipPlaneFragment\";\n\nconst name = \"depthPixelShader\";\nconst shader = `#ifdef ALPHATEST\nvarying vUV: vec2f;var diffuseSamplerSampler: sampler;var diffuseSampler: texture_2d<f32>;\n#endif\n#include<clipPlaneFragmentDeclaration>\nvarying vDepthMetric: f32;\n#ifdef PACKED\n#include<packingFunctions>\n#endif\n#ifdef STORE_CAMERASPACE_Z\nvarying vViewPos: vec4f;\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#include<clipPlaneFragment>\n#ifdef ALPHATEST\nif (textureSample(diffuseSampler,diffuseSamplerSampler,input.vUV).a<0.4) {discard;}\n#endif\n#ifdef STORE_CAMERASPACE_Z\n#ifdef PACKED\nfragmentOutputs.color=pack(input.vViewPos.z);\n#else\nfragmentOutputs.color= vec4f(input.vViewPos.z,0.0,0.0,1.0);\n#endif\n#else\n#ifdef NONLINEARDEPTH\n#ifdef PACKED\nfragmentOutputs.color=pack(input.position.z);\n#else\nfragmentOutputs.color= vec4f(input.position.z,0.0,0.0,0.0);\n#endif\n#else\n#ifdef PACKED\nfragmentOutputs.color=pack(input.vDepthMetric);\n#else\nfragmentOutputs.color= vec4f(input.vDepthMetric,0.0,0.0,1.0);\n#endif\n#endif\n#endif\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const depthPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,+CAA+C,CAAC;AACvD,OAAO,mCAAmC,CAAC;AAC3C,OAAO,oCAAoC,CAAC;;;;;AAE5C,MAAM,IAAI,GAAG,kBAAkB,CAAC;AAChC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAuCb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,oBAAoB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 7015, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/depth.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/depth.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal\";\nimport \"./ShadersInclude/morphTargetsVertex\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/clipPlaneVertex\";\n\nconst name = \"depthVertexShader\";\nconst shader = `attribute position: vec3f;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<clipPlaneVertexDeclaration>\n#include<instancesDeclaration>\nuniform viewProjection: mat4x4f;uniform depthValues: vec2f;\n#if defined(ALPHATEST) || defined(NEED_UV)\nvarying vUV: vec2f;uniform diffuseMatrix: mat4x4f;\n#ifdef UV1\nattribute uv: vec2f;\n#endif\n#ifdef UV2\nattribute uv2: vec2f;\n#endif\n#endif\n#ifdef STORE_CAMERASPACE_Z\nuniform view: mat4x4f;varying vViewPos: vec4f;\n#endif\nvarying vDepthMetric: f32;\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {var positionUpdated: vec3f=input.position;\n#ifdef UV1\nvar uvUpdated: vec2f=input.uv;\n#endif\n#ifdef UV2\nvar uv2Updated: vec2f=input.uv2;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvar worldPos: vec4f=finalWorld* vec4f(positionUpdated,1.0);\n#include<clipPlaneVertex>\nvertexOutputs.position=uniforms.viewProjection*worldPos;\n#ifdef STORE_CAMERASPACE_Z\nvertexOutputs.vViewPos=uniforms.view*worldPos;\n#else\n#ifdef USE_REVERSE_DEPTHBUFFER\nvertexOutputs.vDepthMetric=((-vertexOutputs.position.z+uniforms.depthValues.x)/(uniforms.depthValues.y));\n#else\nvertexOutputs.vDepthMetric=((vertexOutputs.position.z+uniforms.depthValues.x)/(uniforms.depthValues.y));\n#endif\n#endif\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\n#ifdef UV1\nvertexOutputs.vUV= (uniforms.diffuseMatrix* vec4f(uvUpdated,1.0,0.0)).xy;\n#endif\n#ifdef UV2\nvertexOutputs.vUV= (uniforms.diffuseMatrix* vec4f(uv2Updated,1.0,0.0)).xy;\n#endif\n#endif\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const depthVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,mCAAmC,CAAC;AAC3C,OAAO,kDAAkD,CAAC;AAC1D,OAAO,sDAAsD,CAAC;AAC9D,OAAO,gDAAgD,CAAC;AACxD,OAAO,6CAA6C,CAAC;AACrD,OAAO,uCAAuC,CAAC;AAC/C,OAAO,2CAA2C,CAAC;AACnD,OAAO,qCAAqC,CAAC;AAC7C,OAAO,kCAAkC,CAAC;AAC1C,OAAO,8BAA8B,CAAC;AACtC,OAAO,uCAAuC,CAAC;AAC/C,OAAO,kCAAkC,CAAC;;;;;;;;;;;;;;AAE1C,MAAM,IAAI,GAAG,mBAAmB,CAAC;AACjC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwDd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,qBAAqB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 7116, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/geometry.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/geometry.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/bumpFragmentMainFunctions\";\nimport \"./ShadersInclude/bumpFragmentFunctions\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nimport \"./ShadersInclude/bumpFragment\";\n\nconst name = \"geometryPixelShader\";\nconst shader = `#ifdef BUMP\nvarying vWorldView0: vec4f;varying vWorldView1: vec4f;varying vWorldView2: vec4f;varying vWorldView3: vec4f;varying vNormalW: vec3f;\n#else\nvarying vNormalV: vec3f;\n#endif\nvarying vViewPos: vec4f;\n#if defined(POSITION) || defined(BUMP)\nvarying vPositionW: vec3f;\n#endif\n#if defined(VELOCITY) || defined(VELOCITY_LINEAR)\nvarying vCurrentPosition: vec4f;varying vPreviousPosition: vec4f;\n#endif\n#ifdef NEED_UV\nvarying vUV: vec2f;\n#endif\n#ifdef BUMP\nuniform vBumpInfos: vec3f;uniform vTangentSpaceParams: vec2f;\n#endif\n#if defined(REFLECTIVITY)\n#if defined(ORMTEXTURE) || defined(SPECULARGLOSSINESSTEXTURE) || defined(REFLECTIVITYTEXTURE)\nvar reflectivitySamplerSampler: sampler;var reflectivitySampler: texture_2d<f32>;varying vReflectivityUV: vec2f;\n#else\n#ifdef METALLIC_TEXTURE\nvar metallicSamplerSampler: sampler;var metallicSampler: texture_2d<f32>;varying vMetallicUV: vec2f;\n#endif\n#ifdef ROUGHNESS_TEXTURE\nvar roughnessSamplerSampler: sampler;var roughnessSampler: texture_2d<f32>;varying vRoughnessUV: vec2f;\n#endif\n#endif\n#ifdef ALBEDOTEXTURE\nvarying vAlbedoUV: vec2f;var albedoSamplerSampler: sampler;var albedoSampler: texture_2d<f32>;\n#endif\n#ifdef REFLECTIVITYCOLOR\nuniform reflectivityColor: vec3f;\n#endif\n#ifdef ALBEDOCOLOR\nuniform albedoColor: vec3f;\n#endif\n#ifdef METALLIC\nuniform metallic: f32;\n#endif\n#if defined(ROUGHNESS) || defined(GLOSSINESS)\nuniform glossiness: f32;\n#endif\n#endif\n#if defined(ALPHATEST) && defined(NEED_UV)\nvar diffuseSamplerSampler: sampler;var diffuseSampler: texture_2d<f32>;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#include<helperFunctions>\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#include<clipPlaneFragment>\n#ifdef ALPHATEST\nif (textureSample(diffuseSampler,diffuseSamplerSampler,input.vUV).a<0.4) {discard;}\n#endif\nvar normalOutput: vec3f;\n#ifdef BUMP\nvar normalW: vec3f=normalize(input.vNormalW);\n#include<bumpFragment>\n#ifdef NORMAL_WORLDSPACE\nnormalOutput=normalW;\n#else\nnormalOutput=normalize( (mat4x4f(input.vWorldView0,input.vWorldView1,input.vWorldView2,input.vWorldView3)* vec4f(normalW,0.0)).xyz);\n#endif\n#elif defined(HAS_NORMAL_ATTRIBUTE)\nnormalOutput=normalize(input.vNormalV);\n#elif defined(POSITION)\nnormalOutput=normalize(-cross(dpdx(input.vPositionW),dpdy(input.vPositionW)));\n#endif\n#ifdef ENCODE_NORMAL\nnormalOutput=normalOutput*0.5+0.5;\n#endif\nvar fragData: array<vec4<f32>,SCENE_MRT_COUNT>;\n#ifdef DEPTH\nfragData[DEPTH_INDEX]=vec4f(input.vViewPos.z/input.vViewPos.w,0.0,0.0,1.0);\n#endif\n#ifdef NORMAL\nfragData[NORMAL_INDEX]=vec4f(normalOutput,1.0);\n#endif\n#ifdef SCREENSPACE_DEPTH\nfragData[SCREENSPACE_DEPTH_INDEX]=vec4f(fragmentInputs.position.z,0.0,0.0,1.0);\n#endif\n#ifdef POSITION\nfragData[POSITION_INDEX]= vec4f(input.vPositionW,1.0);\n#endif\n#ifdef VELOCITY\nvar a: vec2f=(input.vCurrentPosition.xy/input.vCurrentPosition.w)*0.5+0.5;var b: vec2f=(input.vPreviousPosition.xy/input.vPreviousPosition.w)*0.5+0.5;var velocity: vec2f=abs(a-b);velocity= vec2f(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;fragData[VELOCITY_INDEX]= vec4f(velocity,0.0,1.0);\n#endif\n#ifdef VELOCITY_LINEAR\nvar velocity : vec2f=vec2f(0.5)*((input.vPreviousPosition.xy /\ninput.vPreviousPosition.w) -\n(input.vCurrentPosition.xy /\ninput.vCurrentPosition.w));fragData[VELOCITY_LINEAR_INDEX]=vec4f(velocity,0.0,1.0);\n#endif\n#ifdef REFLECTIVITY\nvar reflectivity: vec4f= vec4f(0.0,0.0,0.0,1.0);\n#ifdef METALLICWORKFLOW\nvar metal: f32=1.0;var roughness: f32=1.0;\n#ifdef ORMTEXTURE\nmetal*=textureSample(reflectivitySampler,reflectivitySamplerSampler,input.vReflectivityUV).b;roughness*=textureSample(reflectivitySampler,reflectivitySamplerSampler,input.vReflectivityUV).g;\n#else\n#ifdef METALLIC_TEXTURE\nmetal*=textureSample(metallicSampler,metallicSamplerSampler,input.vMetallicUV).r;\n#endif\n#ifdef ROUGHNESS_TEXTURE\nroughness*=textureSample(roughnessSampler,roughnessSamplerSampler,input.vRoughnessUV).r;\n#endif\n#endif\n#ifdef METALLIC\nmetal*=uniforms.metallic;\n#endif\n#ifdef ROUGHNESS\nroughness*=(1.0-uniforms.glossiness); \n#endif\nreflectivity=vec4f(reflectivity.rgb,reflectivity.a-roughness);var color: vec3f= vec3f(1.0);\n#ifdef ALBEDOTEXTURE\ncolor=textureSample(albedoSampler,albedoSamplerSampler,input.vAlbedoUV).rgb;\n#ifdef GAMMAALBEDO\ncolor=toLinearSpaceVec4(color);\n#endif\n#endif\n#ifdef ALBEDOCOLOR\ncolor*=uniforms.albedoColor.xyz;\n#endif\nreflectivity=vec4f(mix( vec3f(0.04),color,metal),reflectivity.a);\n#else\n#if defined(SPECULARGLOSSINESSTEXTURE) || defined(REFLECTIVITYTEXTURE)\nreflectivity=textureSample(reflectivitySampler,reflectivitySamplerSampler,input.vReflectivityUV);\n#ifdef GAMMAREFLECTIVITYTEXTURE\nreflectivity=vec4f(toLinearSpaceVec3(reflectivity.rgb),reflectivity.a);\n#endif\n#else \n#ifdef REFLECTIVITYCOLOR\nreflectivity=vec4f(toLinearSpaceVec3(uniforms.reflectivityColor.xyz),1.0);\n#endif\n#endif\n#ifdef GLOSSINESSS\nreflectivity=vec4f(reflectivity.rgb,reflectivity.a*glossiness); \n#endif\n#endif\nfragData[REFLECTIVITY_INDEX]=reflectivity;\n#endif\n#if SCENE_MRT_COUNT>0\nfragmentOutputs.fragData0=fragData[0];\n#endif\n#if SCENE_MRT_COUNT>1\nfragmentOutputs.fragData1=fragData[1];\n#endif\n#if SCENE_MRT_COUNT>2\nfragmentOutputs.fragData2=fragData[2];\n#endif\n#if SCENE_MRT_COUNT>3\nfragmentOutputs.fragData3=fragData[3];\n#endif\n#if SCENE_MRT_COUNT>4\nfragmentOutputs.fragData4=fragData[4];\n#endif\n#if SCENE_MRT_COUNT>5\nfragmentOutputs.fragData5=fragData[5];\n#endif\n#if SCENE_MRT_COUNT>6\nfragmentOutputs.fragData6=fragData[6];\n#endif\n#if SCENE_MRT_COUNT>7\nfragmentOutputs.fragData7=fragData[7];\n#endif\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const geometryPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,+CAA+C,CAAC;AACvD,OAAO,4CAA4C,CAAC;AACpD,OAAO,wCAAwC,CAAC;AAChD,OAAO,kCAAkC,CAAC;AAC1C,OAAO,oCAAoC,CAAC;AAC5C,OAAO,+BAA+B,CAAC;;;;;;;;AAEvC,MAAM,IAAI,GAAG,qBAAqB,CAAC;AACnC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0Kd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,uBAAuB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 7319, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/geometry.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/geometry.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/sceneUboDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal\";\nimport \"./ShadersInclude/morphTargetsVertex\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/bumpVertex\";\n\nconst name = \"geometryVertexShader\";\nconst shader = `#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<instancesDeclaration>\n#include<sceneUboDeclaration>\n#include<clipPlaneVertexDeclaration>\nattribute position: vec3f;\n#ifdef HAS_NORMAL_ATTRIBUTE\nattribute normal: vec3f;\n#endif\n#ifdef NEED_UV\nvarying vUV: vec2f;\n#ifdef ALPHATEST\nuniform diffuseMatrix: mat4x4f;\n#endif\n#ifdef BUMP\nuniform bumpMatrix: mat4x4f;varying vBumpUV: vec2f;\n#endif\n#ifdef REFLECTIVITY\nuniform reflectivityMatrix: mat4x4f;uniform albedoMatrix: mat4x4f;varying vReflectivityUV: vec2f;varying vAlbedoUV: vec2f;\n#endif\n#ifdef METALLIC_TEXTURE\nvarying vMetallicUV: vec2f;uniform metallicMatrix: mat4x4f;\n#endif\n#ifdef ROUGHNESS_TEXTURE\nvarying vRoughnessUV: vec2f;uniform roughnessMatrix: mat4x4f;\n#endif\n#ifdef UV1\nattribute uv: vec2f;\n#endif\n#ifdef UV2\nattribute uv2: vec2f;\n#endif\n#endif\n#ifdef BUMP\nvarying vWorldView0: vec4f;varying vWorldView1: vec4f;varying vWorldView2: vec4f;varying vWorldView3: vec4f;\n#endif\n#ifdef BUMP\nvarying vNormalW: vec3f;\n#else\nvarying vNormalV: vec3f;\n#endif\nvarying vViewPos: vec4f;\n#if defined(POSITION) || defined(BUMP)\nvarying vPositionW: vec3f;\n#endif\n#if defined(VELOCITY) || defined(VELOCITY_LINEAR)\nuniform previousViewProjection: mat4x4f;varying vCurrentPosition: vec4f;varying vPreviousPosition: vec4f;\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {var positionUpdated: vec3f=input.position;\n#ifdef HAS_NORMAL_ATTRIBUTE\nvar normalUpdated: vec3f=input.normal;\n#else\nvar normalUpdated: vec3f=vec3f(0.0,0.0,0.0);\n#endif\n#ifdef UV1\nvar uvUpdated: vec2f=input.uv;\n#endif\n#ifdef UV2\nvar uv2Updated: vec2f=input.uv2;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#if (defined(VELOCITY) || defined(VELOCITY_LINEAR)) && !defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=scene.viewProjection*finalWorld*vec4f(positionUpdated,1.0);vPreviousPosition=uniforms.previousViewProjection*finalPreviousWorld* vec4f(positionUpdated,1.0);\n#endif\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvar worldPos: vec4f= vec4f(finalWorld* vec4f(positionUpdated,1.0));\n#ifdef BUMP\nlet vWorldView=scene.view*finalWorld;vertexOutputs.vWorldView0=vWorldView[0];vertexOutputs.vWorldView1=vWorldView[1];vertexOutputs.vWorldView2=vWorldView[2];vertexOutputs.vWorldView3=vWorldView[3];let normalWorld: mat3x3f= mat3x3f(finalWorld[0].xyz,finalWorld[1].xyz,finalWorld[2].xyz);vertexOutputs.vNormalW=normalize(normalWorld*normalUpdated);\n#else\n#ifdef NORMAL_WORLDSPACE\nvertexOutputs.vNormalV=normalize((finalWorld* vec4f(normalUpdated,0.0)).xyz);\n#else\nvertexOutputs.vNormalV=normalize(((scene.view*finalWorld)* vec4f(normalUpdated,0.0)).xyz);\n#endif\n#endif\nvertexOutputs.vViewPos=scene.view*worldPos;\n#if (defined(VELOCITY) || defined(VELOCITY_LINEAR)) && defined(BONES_VELOCITY_ENABLED)\nvertexOutputs.vCurrentPosition=scene.viewProjection*finalWorld* vec4f(positionUpdated,1.0);\n#if NUM_BONE_INFLUENCERS>0\nvar previousInfluence: mat4x4f;previousInfluence=uniforms.mPreviousBones[ i32(vertexInputs.matricesIndices[0])]*vertexInputs.matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\npreviousInfluence+=uniforms.mPreviousBones[ i32(vertexInputs.matricesIndices[1])]*vertexInputs.matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\npreviousInfluence+=uniforms.mPreviousBones[ i32(vertexInputs.matricesIndices[2])]*vertexInputs.matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\npreviousInfluence+=uniforms.mPreviousBones[ i32(vertexInputs.matricesIndices[3])]*vertexInputs.matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\npreviousInfluence+=uniforms.mPreviousBones[ i32(vertexInputs.matricesIndicesExtra[0])]*vertexInputs.matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\npreviousInfluence+=uniforms.mPreviousBones[ i32(vertexInputs.matricesIndicesExtra[1])]*vertexInputs.matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\npreviousInfluence+=uniforms.mPreviousBones[ i32(vertexInputs.matricesIndicesExtra[2])]*vertexInputs.matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\npreviousInfluence+=uniforms.mPreviousBones[ i32(vertexInputs.matricesIndicesExtra[3])]*vertexInputs.matricesWeightsExtra[3];\n#endif\nvertexOutputs.vPreviousPosition=uniforms.previousViewProjection*finalPreviousWorld*previousInfluence* vec4f(positionUpdated,1.0);\n#else\nvertexOutputs.vPreviousPosition=uniforms.previousViewProjection*finalPreviousWorld* vec4f(positionUpdated,1.0);\n#endif\n#endif\n#if defined(POSITION) || defined(BUMP)\nvertexOutputs.vPositionW=worldPos.xyz/worldPos.w;\n#endif\nvertexOutputs.position=scene.viewProjection*finalWorld* vec4f(positionUpdated,1.0);\n#include<clipPlaneVertex>\n#ifdef NEED_UV\n#ifdef UV1\n#if defined(ALPHATEST) && defined(ALPHATEST_UV1)\nvertexOutputs.vUV=(uniforms.diffuseMatrix* vec4f(uvUpdated,1.0,0.0)).xy;\n#else\nvertexOutputs.vUV=uvUpdated;\n#endif\n#ifdef BUMP_UV1\nvertexOutputs.vBumpUV=(uniforms.bumpMatrix* vec4f(uvUpdated,1.0,0.0)).xy;\n#endif\n#ifdef REFLECTIVITY_UV1\nvertexOutputs.vReflectivityUV=(uniforms.reflectivityMatrix* vec4f(uvUpdated,1.0,0.0)).xy;\n#else\n#ifdef METALLIC_UV1\nvertexOutputs.vMetallicUV=(uniforms.metallicMatrix* vec4f(uvUpdated,1.0,0.0)).xy;\n#endif\n#ifdef ROUGHNESS_UV1\nvertexOutputs.vRoughnessUV=(uniforms.roughnessMatrix* vec4f(uvUpdated,1.0,0.0)).xy;\n#endif\n#endif\n#ifdef ALBEDO_UV1\nvertexOutputs.vAlbedoUV=(uniforms.albedoMatrix* vec4f(uvUpdated,1.0,0.0)).xy;\n#endif\n#endif\n#ifdef UV2\n#if defined(ALPHATEST) && defined(ALPHATEST_UV2)\nvertexOutputs.vUV=(uniforms.diffuseMatrix* vec4f(uv2Updated,1.0,0.0)).xy;\n#else\nvertexOutputs.vUV=uv2Updated;\n#endif\n#ifdef BUMP_UV2\nvertexOutputs.vBumpUV=(uniforms.bumpMatrix* vec4f(uv2Updated,1.0,0.0)).xy;\n#endif\n#ifdef REFLECTIVITY_UV2\nvertexOutputs.vReflectivityUV=(uniforms.reflectivityMatrix* vec4f(uv2Updated,1.0,0.0)).xy;\n#else\n#ifdef METALLIC_UV2\nvertexOutputs.vMetallicUV=(uniforms.metallicMatrix* vec4f(uv2Updated,1.0,0.0)).xy;\n#endif\n#ifdef ROUGHNESS_UV2\nvertexOutputs.vRoughnessUV=(uniforms.roughnessMatrix* vec4f(uv2Updated,1.0,0.0)).xy;\n#endif\n#endif\n#ifdef ALBEDO_UV2\nvertexOutputs.vAlbedoUV=(uniforms.albedoMatrix* vec4f(uv2Updated,1.0,0.0)).xy;\n#endif\n#endif\n#endif\n#include<bumpVertex>\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const geometryVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,mCAAmC,CAAC;AAC3C,OAAO,kDAAkD,CAAC;AAC1D,OAAO,sDAAsD,CAAC;AAC9D,OAAO,gDAAgD,CAAC;AACxD,OAAO,uCAAuC,CAAC;AAC/C,OAAO,sCAAsC,CAAC;AAC9C,OAAO,6CAA6C,CAAC;AACrD,OAAO,2CAA2C,CAAC;AACnD,OAAO,qCAAqC,CAAC;AAC7C,OAAO,kCAAkC,CAAC;AAC1C,OAAO,8BAA8B,CAAC;AACtC,OAAO,uCAAuC,CAAC;AAC/C,OAAO,kCAAkC,CAAC;AAC1C,OAAO,6BAA6B,CAAC;;;;;;;;;;;;;;;;AAErC,MAAM,IAAI,GAAG,sBAAsB,CAAC;AACpC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwKd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,wBAAwB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 7536, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/boundingBoxRenderer.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/boundingBoxRenderer.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"boundingBoxRendererPixelShader\";\nconst shader = `uniform color: vec4f;\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\nfragmentOutputs.color=uniforms.color;\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const boundingBoxRendererPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,gCAAgC,CAAC;AAC9C,MAAM,MAAM,GAAG,CAAA;;;;;;;EAOb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,kCAAkC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 7564, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/boundingBoxRenderer.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/boundingBoxRenderer.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"boundingBoxRendererVertexShader\";\nconst shader = `attribute position: vec3f;uniform world: mat4x4f;uniform viewProjection: mat4x4f;\n#ifdef INSTANCES\nattribute world0 : vec4<f32>;attribute world1 : vec4<f32>;attribute world2 : vec4<f32>;attribute world3 : vec4<f32>;\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#ifdef INSTANCES\nvar finalWorld=mat4x4<f32>(vertexInputs.world0,vertexInputs.world1,vertexInputs.world2,vertexInputs.world3);var worldPos: vec4f=finalWorld* vec4f(input.position,1.0);\n#else\nvar worldPos: vec4f=uniforms.world* vec4f(input.position,1.0);\n#endif\nvertexOutputs.position=uniforms.viewProjection*worldPos;\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const boundingBoxRendererVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,iCAAiC,CAAC;AAC/C,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;CAgBd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,mCAAmC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 7601, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/line.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/line.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/logDepthFragment\";\nimport \"./ShadersInclude/clipPlaneFragment\";\n\nconst name = \"linePixelShader\";\nconst shader = `#include<clipPlaneFragmentDeclaration>\nuniform color: vec4f;\n#include<logDepthDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<logDepthFragment>\n#include<clipPlaneFragment>\nfragmentOutputs.color=uniforms.color;\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const linePixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,+CAA+C,CAAC;AACvD,OAAO,sCAAsC,CAAC;AAC9C,OAAO,mCAAmC,CAAC;AAC3C,OAAO,oCAAoC,CAAC;;;;;;AAE5C,MAAM,IAAI,GAAG,iBAAiB,CAAC;AAC/B,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;EAWb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,mBAAmB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 7641, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/line.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/line.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/sceneUboDeclaration\";\nimport \"./ShadersInclude/meshUboDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/logDepthVertex\";\n\nconst name = \"lineVertexShader\";\nconst shader = `#define ADDITIONAL_VERTEX_DECLARATION\n#include<instancesDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\nattribute position: vec3f;attribute normal: vec4f;uniform width: f32;uniform aspectRatio: f32;\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\nvar worldViewProjection: mat4x4f=scene.viewProjection*finalWorld;var viewPosition: vec4f=worldViewProjection* vec4f(input.position,1.0);var viewPositionNext: vec4f=worldViewProjection* vec4f(input.normal.xyz,1.0);var currentScreen: vec2f=viewPosition.xy/viewPosition.w;var nextScreen: vec2f=viewPositionNext.xy/viewPositionNext.w;currentScreen=vec2f(currentScreen.x*uniforms.aspectRatio,currentScreen.y);nextScreen=vec2f(nextScreen.x*uniforms.aspectRatio,nextScreen.y);var dir: vec2f=normalize(nextScreen-currentScreen);var normalDir: vec2f= vec2f(-dir.y,dir.x);normalDir*=uniforms.width/2.0;normalDir=vec2f(normalDir.x/uniforms.aspectRatio,normalDir.y);var offset: vec4f= vec4f(normalDir*input.normal.w,0.0,0.0);vertexOutputs.position=viewPosition+offset;\n#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nvar worldPos: vec4f=finalWorld*vec4f(input.position,1.0);\n#include<clipPlaneVertex>\n#endif\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const lineVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,uCAAuC,CAAC;AAC/C,OAAO,6CAA6C,CAAC;AACrD,OAAO,sCAAsC,CAAC;AAC9C,OAAO,qCAAqC,CAAC;AAC7C,OAAO,sCAAsC,CAAC;AAC9C,OAAO,kCAAkC,CAAC;AAC1C,OAAO,kCAAkC,CAAC;AAC1C,OAAO,iCAAiC,CAAC;;;;;;;;;;AAEzC,MAAM,IAAI,GAAG,kBAAkB,CAAC;AAChC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;EAmBb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,oBAAoB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 7697, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/outline.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/outline.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nimport \"./ShadersInclude/logDepthFragment\";\n\nconst name = \"outlinePixelShader\";\nconst shader = `uniform color: vec4f;\n#ifdef ALPHATEST\nvarying vUV: vec2f;var diffuseSamplerSampler: sampler;var diffuseSampler: texture_2d<f32>;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\n#ifdef ALPHATEST\nif (textureSample(diffuseSampler,diffuseSamplerSampler,fragmentInputs.vUV).a<0.4) {discard;}\n#endif\n#include<logDepthFragment>\nfragmentOutputs.color=uniforms.color;\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const outlinePixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,+CAA+C,CAAC;AACvD,OAAO,sCAAsC,CAAC;AAC9C,OAAO,oCAAoC,CAAC;AAC5C,OAAO,mCAAmC,CAAC;;;;;;AAE3C,MAAM,IAAI,GAAG,oBAAoB,CAAC;AAClC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;EAiBb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,sBAAsB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 7743, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/outline.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/outline.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal\";\nimport \"./ShadersInclude/morphTargetsVertex\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/logDepthVertex\";\n\nconst name = \"outlineVertexShader\";\nconst shader = `attribute position: vec3f;attribute normal: vec3f;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<clipPlaneVertexDeclaration>\nuniform offset: f32;\n#include<instancesDeclaration>\nuniform viewProjection: mat4x4f;\n#ifdef ALPHATEST\nvarying vUV: vec2f;uniform diffuseMatrix: mat4x4f; \n#ifdef UV1\nattribute uv: vec2f;\n#endif\n#ifdef UV2\nattribute uv2: vec2f;\n#endif\n#endif\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input: VertexInputs)->FragmentInputs {var positionUpdated: vec3f=vertexInputs.position;var normalUpdated: vec3f=vertexInputs.normal;\n#ifdef UV1\nvar uvUpdated: vec2f=vertexInputs.uv;\n#endif\n#ifdef UV2\nvar uv2Updated: vec2f=vertexInputs.uv2;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\nvar offsetPosition: vec3f=positionUpdated+(normalUpdated*uniforms.offset);\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvar worldPos: vec4f=finalWorld*vec4f(offsetPosition,1.0);vertexOutputs.position=uniforms.viewProjection*worldPos;\n#ifdef ALPHATEST\n#ifdef UV1\nvertexOutputs.vUV=(uniforms.diffuseMatrix*vec4f(uvUpdated,1.0,0.0)).xy;\n#endif\n#ifdef UV2\nvertexOutputs.vUV=(uniforms.diffuseMatrix*vec4f(uv2Updated,1.0,0.0)).xy;\n#endif\n#endif\n#include<clipPlaneVertex>\n#include<logDepthVertex>\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const outlineVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,mCAAmC,CAAC;AAC3C,OAAO,kDAAkD,CAAC;AAC1D,OAAO,sDAAsD,CAAC;AAC9D,OAAO,gDAAgD,CAAC;AACxD,OAAO,6CAA6C,CAAC;AACrD,OAAO,uCAAuC,CAAC;AAC/C,OAAO,sCAAsC,CAAC;AAC9C,OAAO,2CAA2C,CAAC;AACnD,OAAO,qCAAqC,CAAC;AAC7C,OAAO,kCAAkC,CAAC;AAC1C,OAAO,8BAA8B,CAAC;AACtC,OAAO,uCAAuC,CAAC;AAC/C,OAAO,kCAAkC,CAAC;AAC1C,OAAO,iCAAiC,CAAC;;;;;;;;;;;;;;;;AAEzC,MAAM,IAAI,GAAG,qBAAqB,CAAC;AACnC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8Cd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,uBAAuB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 7838, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/copyTexture3DLayerToTexture.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/copyTexture3DLayerToTexture.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"copyTexture3DLayerToTexturePixelShader\";\nconst shader = `var textureSampler: texture_3d<f32>;uniform layerNum: i32;varying vUV: vec2f;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {let coord=vec3f(vec2f(input.vUV.x,input.vUV.y)*vec2f(textureDimensions(textureSampler,0).xy),f32(uniforms.layerNum));let color=textureLoad(textureSampler,vec3i(coord),0).rgb;fragmentOutputs.color= vec4f(color,1);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const copyTexture3DLayerToTexturePixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,wCAAwC,CAAC;AACtD,MAAM,MAAM,GAAG,CAAA;uQACwP,CAAC;AACxQ,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,0CAA0C,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 7860, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/iblShadowVoxelTracing.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/iblShadowVoxelTracing.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"iblShadowVoxelTracingPixelShader\";\nconst shader = `#define PI 3.1415927\nvarying vUV: vec2f;\n#define DISABLE_UNIFORMITY_ANALYSIS\nvar depthSampler: texture_2d<f32>;var worldNormalSampler : texture_2d<f32>;var blueNoiseSampler: texture_2d<f32>;var icdfSamplerSampler: sampler;var icdfSampler: texture_2d<f32>;var voxelGridSamplerSampler: sampler;var voxelGridSampler: texture_3d<f32>;\n#ifdef COLOR_SHADOWS\nvar iblSamplerSampler: sampler;var iblSampler: texture_cube<f32>;\n#endif\nuniform shadowParameters: vec4f;\n#define SHADOWdirs uniforms.shadowParameters.x\n#define SHADOWframe uniforms.shadowParameters.y\n#define SHADOWenvRot uniforms.shadowParameters.w\nuniform voxelBiasParameters : vec4f;\n#define highestMipLevel uniforms.voxelBiasParameters.z\nuniform sssParameters: vec4f;\n#define SSSsamples uniforms.sssParameters.x\n#define SSSstride uniforms.sssParameters.y\n#define SSSmaxDistance uniforms.sssParameters.z\n#define SSSthickness uniforms.sssParameters.w\nuniform shadowOpacity: vec4f;uniform projMtx: mat4x4f;uniform viewMtx: mat4x4f;uniform invProjMtx: mat4x4f;uniform invViewMtx: mat4x4f;uniform wsNormalizationMtx: mat4x4f;uniform invVPMtx: mat4x4f;\n#define PI 3.1415927\n#define GOLD 0.618034\nstruct AABB3f {m_min: vec3f,\nm_max: vec3f,};struct Ray {orig: vec3f,\ndir: vec3f,\ndir_rcp: vec3f,\nt_min: f32,\nt_max: f32,};fn make_ray(origin: vec3f,direction: vec3f,tmin: f32,\ntmax: f32)->Ray {var ray: Ray;ray.orig=origin;ray.dir=direction;ray.dir_rcp=1.0f/direction;ray.t_min=tmin;ray.t_max=tmax;return ray;}\nfn ray_box_intersection(aabb: AABB3f,ray: Ray ,\ndistance_near: ptr<function,f32>,distance_far: ptr<function,f32>)->bool{var tbot: vec3f=ray.dir_rcp*(aabb.m_min-ray.orig);var ttop: vec3f=ray.dir_rcp*(aabb.m_max-ray.orig);var tmin: vec3f=min(ttop,tbot);var tmax: vec3f=max(ttop,tbot);*distance_near=max(ray.t_min,max(tmin.x,max(tmin.y,tmin.z)));*distance_far=min(ray.t_max,min(tmax.x,min(tmax.y,tmax.z)));return *distance_near<=*distance_far;}\n#if VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION\nstruct VoxelMarchDiagnosticInfo {heat: f32,\nvoxel_intersect_coords: vec3i,};\n#endif\nfn hash(i: u32)->u32 {var temp=i ^ (i>>16u);temp*=0x7FEB352Du;temp ^= temp>>15u;temp*=0x846CA68Bu;temp ^= temp>>16u;return temp;}\nfn uintBitsToFloat(x: u32)->f32 {return bitcast<f32>(x);}\nfn uint2float(i: u32)->f32 {return uintBitsToFloat(0x3F800000u | (i>>9u))-1.0;}\nfn uv_to_normal(uv: vec2f)->vec3f {var N: vec3f;var uvRange: vec2f=uv;var theta: f32=uvRange.x*2.0*PI;var phi: f32=uvRange.y*PI;N.x=cos(theta)*sin(phi);N.z=sin(theta)*sin(phi);N.y=cos(phi);return N;}\nfn plasticSequence(rstate: u32)->vec2f {return vec2f(uint2float(rstate*3242174889u),\nuint2float(rstate*2447445414u));}\nfn goldenSequence(rstate: u32)->f32 {return uint2float(rstate*2654435769u);}\nfn distanceSquared(a: vec2f,b: vec2f)->f32 {var diff: vec2f=a-b;return dot(diff,diff);}\nfn genTB(N: vec3f,T: ptr<function,vec3f>,B: ptr<function,vec3f>) {var s: f32=select(1.0,-1.0,N.z<0.0);var a: f32=-1.0/(s+N.z);var b: f32=N.x*N.y*a;*T= vec3f(1.0+s*N.x*N.x*a,s*b,-s*N.x);*B= vec3f(b,s+N.y*N.y*a,-N.y);}\nfn lessThan(x: vec3f,y: vec3f)->vec3<bool> {return x<y;}\n#ifdef VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION\nfn anyHitVoxels(ray_vs: Ray,\nvoxel_march_diagnostic_info: ptr<function,VoxelMarchDiagnosticInfo>)->bool {\n#else\nfn anyHitVoxels(ray_vs: Ray)->bool {\n#endif\nvar stack=array<i32,24>(); \nvar invD: vec3f=ray_vs.dir_rcp;var D: vec3f=ray_vs.dir;var O: vec3f=ray_vs.orig;var negD=vec3i(lessThan(D, vec3f(0,0,0)));var voxel0: i32=negD.x | (negD.y<<1) | (negD.z<<2);var t0: vec3f=-O*invD;var t1=(vec3f(1.0)-O)*invD;var maxLod: i32= i32(highestMipLevel);var stackLevel: i32=0;\n#if VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION\nvar steps: u32=0u;\n#endif\nstack[stackLevel]=maxLod<<24;stackLevel++;while (stackLevel>0) {stackLevel=stackLevel-1;var elem: i32=stack[stackLevel];var Coords: vec4i =\nvec4i(elem & 0xFF,(elem>>8) & 0xFF,(elem>>16) & 0xFF,elem>>24);if (Coords.w==0) {\n#if VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION\n*voxel_march_diagnostic_info.heat= f32(steps)/24.0;\n#endif\nreturn true;}\n#if VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION\n++steps;\n#endif\nvar invRes: f32=exp2(f32(Coords.w-maxLod));var bbmin: vec3f=invRes*vec3f(Coords.xyz+negD);var bbmax: vec3f=invRes*vec3f(Coords.xyz-negD+vec3i(1));var mint: vec3f=mix(t0,t1,bbmin);var maxt: vec3f=mix(t0,t1,bbmax);var midt: vec3f=0.5*(mint+maxt);mint.x=max(0.0,mint.x);midt.x=max(0.0,midt.x);var nodeMask: u32= u32(\nround(textureLoad(voxelGridSampler,Coords.xyz,Coords.w).x*255.0));Coords.w--;var voxelBit: u32=u32(voxel0);Coords=vec4i((Coords.xyz<<vec3u(1))+negD,Coords.w);var packedCoords: i32 =\nCoords.x | (Coords.y<<8) | (Coords.z<<16) | (Coords.w<<24);if (max(mint.x,max(mint.y,mint.z))<min(midt.x,min(midt.y,midt.z)) &&\n((1u<<voxelBit) & nodeMask) != 0) {stack[stackLevel]=packedCoords;stackLevel++;}\nvoxelBit ^= 0x1;packedCoords ^= 0x00001;if (max(midt.x,max(mint.y,mint.z))<min(maxt.x,min(midt.y,midt.z)) &&\n((1u<<voxelBit) & nodeMask) != 0) {stack[stackLevel]=packedCoords;stackLevel++;}\nvoxelBit ^= 0x2;packedCoords ^= 0x00100;if (max(midt.x,max(midt.y,mint.z))<min(maxt.x,min(maxt.y,midt.z)) &&\n((1u<<voxelBit) & nodeMask) != 0) {stack[stackLevel]=packedCoords;stackLevel++;}\nvoxelBit ^= 0x1;packedCoords ^= 0x00001;if (max(mint.x,max(midt.y,mint.z))<min(midt.x,min(maxt.y,midt.z)) &&\n((1u<<voxelBit) & nodeMask) != 0) {stack[stackLevel]=packedCoords;stackLevel++;}\nvoxelBit ^= 0x4;packedCoords ^= 0x10000;if (max(mint.x,max(midt.y,midt.z))<min(midt.x,min(maxt.y,maxt.z)) &&\n((1u<<voxelBit) & nodeMask) != 0) {stack[stackLevel]=packedCoords;stackLevel++;}\nvoxelBit ^= 0x1;packedCoords ^= 0x00001;if (max(midt.x,max(midt.y,midt.z))<min(maxt.x,min(maxt.y,maxt.z)) &&\n((1u<<voxelBit) & nodeMask) != 0) {stack[stackLevel]=packedCoords;stackLevel++;}\nvoxelBit ^= 0x2;packedCoords ^= 0x00100;if (max(midt.x,max(mint.y,midt.z))<min(maxt.x,min(midt.y,maxt.z)) &&\n((1u<<voxelBit) & nodeMask) != 0) {stack[stackLevel]=packedCoords;stackLevel++;}\nvoxelBit ^= 0x1;packedCoords ^= 0x00001;if (max(mint.x,max(mint.y,midt.z))<min(midt.x,min(midt.y,maxt.z)) &&\n((1u<<voxelBit) & nodeMask) != 0) {stack[stackLevel]=packedCoords;stackLevel++;}}\n#if VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION\n*voxel_march_diagnostic_info.heat= f32(steps)/24.0;\n#endif\nreturn false;}\nfn linearizeDepth(depth: f32,near: f32,far: f32)->f32 {return (near*far)/(far-depth*(far-near));}\nfn screenSpaceShadow(csOrigin: vec3f,csDirection: vec3f,csZBufferSize: vec2f,\nnearPlaneZ: f32,farPlaneZ: f32,noise: f32)->f32 {\n#ifdef RIGHT_HANDED\nvar csZDir : f32=-1.0;\n#else \nvar csZDir : f32=1.0;\n#endif\nvar ssSamples: f32=SSSsamples;var ssMaxDist: f32=SSSmaxDistance;var ssStride: f32=SSSstride;var ssThickness: f32=SSSthickness;var rayLength: f32 =\nselect(ssMaxDist,(nearPlaneZ-csOrigin.z)/csDirection.z,\ncsZDir*(csOrigin.z+ssMaxDist*csDirection.z)<csZDir*nearPlaneZ);var csEndPoint: vec3f=csOrigin+rayLength*csDirection;var H0: vec4f=uniforms.projMtx*vec4f(csOrigin,1.0);var H1: vec4f=uniforms.projMtx*vec4f(csEndPoint,1.0);var Z0=vec2f(csOrigin.z ,1.0)/H0.w;var Z1=vec2f(csEndPoint.z,1.0)/H1.w;var P0=csZBufferSize*(0.5*H0.xy*Z0.y+0.5);var P1=csZBufferSize*(0.5*H1.xy*Z1.y+0.5);P1+= vec2f(select(0.0,0.01,distanceSquared(P0,P1)<0.0001));var delta: vec2f=P1-P0;var permute: bool=false;if (abs(delta.x)<abs(delta.y)) {permute=true;P0=P0.yx;P1=P1.yx;delta=delta.yx;}\nvar stepDirection: f32=sign(delta.x);var invdx: f32=stepDirection/delta.x;var dP: vec2f=ssStride* vec2f(stepDirection,invdx*delta.y);var dZ: vec2f=ssStride*invdx*(Z1-Z0);var opacity: f32=0.0;var P: vec2f=P0+noise*dP;var Z: vec2f=Z0+noise*dZ;var end: f32=P1.x*stepDirection;var rayZMax=csZDir*Z.x/Z.y;var sceneDepth=rayZMax;Z+=dZ;for (var stepCount: f32=0.0; \nopacity<1.0 && P.x*stepDirection<end && sceneDepth>0.0 && stepCount<ssSamples;stepCount+=1) { \nvar coords=vec2i(select(P,P.yx,permute));sceneDepth=textureLoad(depthSampler,coords,0).x;sceneDepth=linearizeDepth(sceneDepth,nearPlaneZ,farPlaneZ);sceneDepth=csZDir*sceneDepth;if (sceneDepth<=0.0) {break;}\nvar rayZMin: f32=rayZMax;rayZMax=csZDir*Z.x/Z.y;opacity+=max(opacity,step(rayZMax,sceneDepth+ssThickness)*step(sceneDepth,rayZMin));P+=dP;Z+=dZ;}\nreturn opacity;}\n#if VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION\nfn voxelShadow(wsOrigin: vec3f,wsDirection: vec3f,wsNormal: vec3f,\nDitherNoise: vec2f,\nvoxel_march_diagnostic_info: ptr<function,VoxelMarchDiagnosticInfo>)->f32 {\n#else\nfn voxelShadow(wsOrigin: vec3f,wsDirection: vec3f,wsNormal: vec3f,\nDitherNoise: vec2f)->f32 {\n#endif\nvar vxResolution: f32=f32(textureDimensions(voxelGridSampler,0).x);var T: vec3f;var B: vec3f;genTB(wsDirection,&T,&B);var DitherXY: vec2f=sqrt(DitherNoise.x)* vec2f(cos(2.0*PI*DitherNoise.y),\nsin(2.0*PI*DitherNoise.y));var Dithering : vec3f=(uniforms.voxelBiasParameters.x*wsNormal +\nuniforms.voxelBiasParameters.y*wsDirection +\nDitherXY.x*T+DitherXY.y*B) /\nvxResolution;var O: vec3f=0.5*wsOrigin+0.5+Dithering;var ray_vs=make_ray(O,wsDirection,0.0,10.0);var voxel_aabb: AABB3f;voxel_aabb.m_min=vec3f(0);voxel_aabb.m_max=vec3f(1);var near: f32=0;var far: f32=0;if (!ray_box_intersection(voxel_aabb,ray_vs,&near,&far)) {return 0.0;}\nray_vs.t_min=max(ray_vs.t_min,near);ray_vs.t_max=min(ray_vs.t_max,far);\n#if VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION\nreturn select(0.0f,1.0f,anyHitVoxels(ray_vs,voxel_march_diagnostic_info));\n#else\nreturn select(0.0f,1.0f,anyHitVoxels(ray_vs));\n#endif\n}\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var nbDirs=u32(SHADOWdirs);var frameId=u32(SHADOWframe);var envRot: f32=SHADOWenvRot;var Resolution: vec2f= vec2f(textureDimensions(depthSampler,0));var currentPixel=vec2i(fragmentInputs.vUV*Resolution);var GlobalIndex =\n(frameId*u32(Resolution.y)+u32(currentPixel.y))*u32(Resolution.x) +\nu32(currentPixel.x);var N : vec3f=textureLoad(worldNormalSampler,currentPixel,0).xyz;if (length(N)<0.01) {fragmentOutputs.color=vec4f(1.0,1.0,0.0,1.0);return fragmentOutputs;}\nvar normalizedRotation: f32=envRot/(2.0*PI);var depth : f32=textureLoad(depthSampler,currentPixel,0).x;\n#ifndef IS_NDC_HALF_ZRANGE\ndepth=depth*2.0-1.0;\n#endif\nvar temp : vec2f=(vec2f(currentPixel)+vec2f(0.5))*2.0/Resolution -\nvec2f(1.0);var VP : vec4f=uniforms.invProjMtx*vec4f(temp.x,-temp.y,depth,1.0);VP/=VP.w;N=normalize(N);var noise : vec3f=textureLoad(blueNoiseSampler,currentPixel & vec2i(0xFF),0).xyz;noise.z=fract(noise.z+goldenSequence(frameId*nbDirs));\n#ifdef VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION\nvar heat: f32=0.0f;\n#endif\nvar shadowAccum: f32=0.001;var specShadowAccum: f32=0.001;var sampleWeight : f32=0.001;\n#ifdef COLOR_SHADOWS\nvar totalLight: vec3f=vec3f(0.001);var shadowedLight: vec3f=vec3f(0.0);\n#endif\nfor (var i: u32=0; i<nbDirs; i++) {var dirId: u32=nbDirs*GlobalIndex+i;var L: vec4f;var T: vec2f;{var r: vec2f=plasticSequence(frameId*nbDirs+i);r=fract(r+ vec2f(2.0)*abs(noise.xy- vec2f(0.5)));T.x=textureSampleLevel(icdfSampler,icdfSamplerSampler,vec2f(r.x,0.0),0.0).x;T.y=textureSampleLevel(icdfSampler,icdfSamplerSampler,vec2f(T.x,r.y),0.0).y;L= vec4f(uv_to_normal(vec2f(T.x-normalizedRotation,T.y)),0);\n#ifndef RIGHT_HANDED\nL.z*=-1.0;\n#endif\n}\n#ifdef COLOR_SHADOWS\nvar lightDir: vec3f=uv_to_normal(vec2f(1.0-fract(T.x+0.25),T.y));var ibl: vec3f=textureSampleLevel(iblSampler,iblSamplerSampler,lightDir,0.0).xyz;var pdf: f32=textureSampleLevel(icdfSampler,icdfSamplerSampler,T,0.0).z;\n#endif\nvar cosNL: f32=dot(N,L.xyz);var opacity: f32=0.0;if (cosNL>0.0) {var VP2: vec4f=VP;VP2.y*=-1.0;var unormWP : vec4f=uniforms.invViewMtx*VP2;var WP: vec3f=(uniforms.wsNormalizationMtx*unormWP).xyz;var vxNoise: vec2f=vec2f(uint2float(hash(dirId*2)),uint2float(hash(dirId*2+1)));\n#ifdef VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION\nVoxelMarchDiagnosticInfo voxel_march_diagnostic_info;opacity=max(opacity,\nuniforms.shadowOpacity.x*voxelShadow(WP,L.xyz,N,vxNoise,\nvoxel_march_diagnostic_info));heat+=voxel_march_diagnostic_info.heat;\n#else\nopacity =\nmax(opacity,uniforms.shadowOpacity.x*voxelShadow(WP,L.xyz,N,vxNoise));\n#endif\nvar VL : vec3f=(uniforms.viewMtx*L).xyz;\n#ifdef RIGHT_HANDED\nvar nearPlaneZ: f32=-2.0*uniforms.projMtx[3][2]/(uniforms.projMtx[2][2]-1.0); \nvar farPlaneZ: f32=-uniforms.projMtx[3][2]/(uniforms.projMtx[2][2]+1.0);\n#else\nvar nearPlaneZ: f32=-2.0*uniforms.projMtx[3][2]/(uniforms.projMtx[2][2]+1.0); \nvar farPlaneZ: f32=-uniforms.projMtx[3][2]/(uniforms.projMtx[2][2]-1.0);\n#endif\nvar ssShadow: f32=uniforms.shadowOpacity.y *\nscreenSpaceShadow(VP2.xyz,VL,Resolution,nearPlaneZ,farPlaneZ,\nabs(2.0*noise.z-1.0));opacity=max(opacity,ssShadow);\n#ifdef COLOR_SHADOWS\nvar light: vec3f=select(vec3f(0.0),vec3f(cosNL)/vec3f(pdf)*ibl,pdf>1e-6);shadowedLight+=light*opacity;totalLight+=light;\n#else\nvar rcos: f32=1.0-cosNL;shadowAccum+=(1.0-opacity*(1.0-pow(rcos,8.0)));sampleWeight+=1.0;var VR : vec3f=abs((uniforms.viewMtx*vec4f(reflect(-L.xyz,N),0.0)).xyz);specShadowAccum+=max(1.0-(opacity*pow(VR.z,8.0)),0.0);\n#endif\n}\nnoise.z=fract(noise.z+GOLD);}\n#ifdef COLOR_SHADOWS\nvar shadow: vec3f=(totalLight-shadowedLight)/totalLight;var maxShadow: f32=max(max(shadow.x,max(shadow.y,shadow.z)),1.0);fragmentOutputs.color=vec4f(shadow/maxShadow,1.0);\n#else\n#ifdef VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION\nfragmentOutputs.color =\nvec4f(shadowAccum/sampleWeight,specShadowAccum/sampleWeight,heat/sampleWeight,1.0);\n#else\nfragmentOutputs.color=vec4f(shadowAccum/sampleWeight,specShadowAccum/sampleWeight,0.0,1.0);\n#endif\n#endif\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const iblShadowVoxelTracingPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,kCAAkC,CAAC;AAChD,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAwLb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,oCAAoC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 8065, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/iblShadowDebug.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/iblShadowDebug.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"iblShadowDebugPixelShader\";\nconst shader = `varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;var debugSamplerSampler: sampler;var debugSampler: texture_2d<f32>;uniform sizeParams: vec4f;\n#define offsetX uniforms.sizeParams.x\n#define offsetY uniforms.sizeParams.y\n#define widthScale uniforms.sizeParams.z\n#define heightScale uniforms.sizeParams.w\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var uv: vec2f =\nvec2f((offsetX+fragmentInputs.vUV.x)*widthScale,(offsetY+fragmentInputs.vUV.y)*heightScale);var background: vec4f=textureSample(textureSampler,textureSamplerSampler,fragmentInputs.vUV);var debugColour: vec4f=textureSample(debugSampler,debugSamplerSampler,fragmentInputs.vUV);if (uv.x<0.0 || uv.x>1.0 || uv.y<0.0 || uv.y>1.0) {fragmentOutputs.color=background;} else {fragmentOutputs.color=vec4f(mix(debugColour.rgb,background.rgb,0.0),1.0);}}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const iblShadowDebugPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,2BAA2B,CAAC;AACzC,MAAM,MAAM,GAAG,CAAA;;;;;;;2bAO4a,CAAC;AAC5b,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,6BAA6B,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 8093, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/iblShadowSpatialBlur.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/iblShadowSpatialBlur.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"iblShadowSpatialBlurPixelShader\";\nconst shader = `#define PI 3.1415927\nvarying vUV: vec2f;var depthSampler: texture_2d<f32>;var worldNormalSampler: texture_2d<f32>;var voxelTracingSampler : texture_2d<f32>;uniform blurParameters: vec4f;\n#define stridef uniforms.blurParameters.x\n#define worldScale uniforms.blurParameters.y\nconst weights=array<f32,5>(0.0625,0.25,0.375,0.25,0.0625);const nbWeights: i32=5;fn max2(v: vec2f,w: vec2f)->vec2f {return vec2f(max(v.x,w.x),max(v.y,w.y));}\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var gbufferRes=vec2f(textureDimensions(depthSampler,0));var gbufferPixelCoord= vec2i(fragmentInputs.vUV*gbufferRes);var shadowRes=vec2f(textureDimensions(voxelTracingSampler,0));var shadowPixelCoord= vec2i(fragmentInputs.vUV*shadowRes);var N: vec3f=textureLoad(worldNormalSampler,gbufferPixelCoord,0).xyz;if (length(N)<0.01) {fragmentOutputs.color=vec4f(1.0,1.0,0.0,1.0);return fragmentOutputs;}\nvar depth: f32=-textureLoad(depthSampler,gbufferPixelCoord,0).x;var X: vec4f= vec4f(0.0);for(var y: i32=0; y<nbWeights; y++) {for(var x: i32=0; x<nbWeights; x++) {var gBufferCoords: vec2i=gbufferPixelCoord+i32(stridef)*vec2i(x-(nbWeights>>1),y-(nbWeights>>1));var shadowCoords: vec2i=shadowPixelCoord+i32(stridef)*vec2i(x-(nbWeights>>1),y-(nbWeights>>1));var T : vec3f=textureLoad(voxelTracingSampler,shadowCoords,0).xyz;var ddepth: f32=-textureLoad(depthSampler,gBufferCoords,0).x-depth;var dN: vec3f=textureLoad(worldNormalSampler,gBufferCoords,0).xyz-N;var w: f32=weights[x]*weights[y] *\nexp2(max(-1000.0/(worldScale*worldScale),-0.5) *\n(ddepth*ddepth) -\n1e1*dot(dN,dN));X+= vec4f(w*T.x,w*T.y,w*T.z,w);}}\nfragmentOutputs.color= vec4f(X.x/X.w,X.y/X.w,X.z/X.w,1.0);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const iblShadowSpatialBlurPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,iCAAiC,CAAC;AAC/C,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;4DAW6C,CAAC;AAC7D,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,mCAAmC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 8125, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/iblShadowAccumulation.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/iblShadowAccumulation.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"iblShadowAccumulationPixelShader\";\nconst shader = `varying vUV: vec2f;uniform accumulationParameters: vec4f;\n#define remanence uniforms.accumulationParameters.x\n#define resetb uniforms.accumulationParameters.y\n#define sceneSize uniforms.accumulationParameters.z\nvar motionSampler: texture_2d<f32>;var positionSampler: texture_2d<f32>;var spatialBlurSampler : texture_2d<f32>;var oldAccumulationSamplerSampler: sampler;var oldAccumulationSampler: texture_2d<f32>;var prevPositionSamplerSampler: sampler;var prevPositionSampler: texture_2d<f32>;fn max2(v: vec2f,w: vec2f)->vec2f { \nreturn vec2f(max(v.x,w.x),max(v.y,w.y)); }\nfn lessThan(x: vec2f,y: vec2f)->vec2<bool> {return x<y;}\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var reset: bool= bool(resetb);var gbufferRes : vec2f=vec2f(textureDimensions(positionSampler,0));var gbufferPixelCoord: vec2i= vec2i(input.vUV*gbufferRes);var shadowRes : vec2f=vec2f(textureDimensions(spatialBlurSampler,0));var shadowPixelCoord: vec2i= vec2i(input.vUV*shadowRes);var LP: vec4f=textureLoad(positionSampler,gbufferPixelCoord,0);if (0.0==LP.w) {fragmentOutputs.color=vec4f(1.0,0.0,0.0,1.0);return fragmentOutputs;}\nvar velocityColor: vec2f=textureLoad(motionSampler,gbufferPixelCoord,0).xy;var prevCoord: vec2f=input.vUV+velocityColor;var PrevLP: vec3f=textureSampleLevel(prevPositionSampler,prevPositionSamplerSampler,prevCoord,0.0).xyz;var PrevShadows: vec4f=textureSampleLevel(oldAccumulationSampler,oldAccumulationSamplerSampler,prevCoord,0.0);var newShadows : vec3f=textureLoad(spatialBlurSampler,shadowPixelCoord,0).xyz;PrevShadows.a=select(1.0,max(PrevShadows.a/(1.0+PrevShadows.a),1.0-remanence),!reset && all(lessThan(abs(prevCoord- vec2f(0.5)), vec2f(0.5))) &&\ndistance(LP.xyz,PrevLP)<5e-2*sceneSize);PrevShadows=max( vec4f(0.0),PrevShadows);fragmentOutputs.color= vec4f(mix(PrevShadows.x,newShadows.x,PrevShadows.a),\nmix(PrevShadows.y,newShadows.y,PrevShadows.a),\nmix(PrevShadows.z,newShadows.z,PrevShadows.a),PrevShadows.a);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const iblShadowAccumulationPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,kCAAkC,CAAC;AAChD,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;+DAYgD,CAAC;AAChE,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,oCAAoC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 8158, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/iblShadowsCombine.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/iblShadowsCombine.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"iblShadowsCombinePixelShader\";\nconst shader = `varying vUV: vec2f;var shadowSamplerSampler : sampler;var shadowSampler : texture_2d<f32>;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform shadowOpacity: f32;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var shadow\n: vec3f =\ntextureSample(shadowSampler,shadowSamplerSampler,input.vUV).rgb;var color\n: vec3f =\ntextureSample(textureSampler,textureSamplerSampler,input.vUV).rgb;var shadowValue: f32=mix(1.0,shadow.x,uniforms.shadowOpacity);fragmentOutputs.color=vec4f(color*shadowValue,1.0);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const iblShadowsCombinePixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,8BAA8B,CAAC;AAC5C,MAAM,MAAM,GAAG,CAAA;;;;;qLAKsK,CAAC;AACtL,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,gCAAgC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 8184, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/iblCombineVoxelGrids.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/iblCombineVoxelGrids.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"iblCombineVoxelGridsPixelShader\";\nconst shader = `varying vUV: vec2f;var voxelXaxisSamplerSampler: sampler;var voxelXaxisSampler: texture_3d<f32>;var voxelYaxisSamplerSampler: sampler;var voxelYaxisSampler: texture_3d<f32>;var voxelZaxisSamplerSampler: sampler;var voxelZaxisSampler: texture_3d<f32>;uniform layer: f32;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var coordZ: vec3f= vec3f(fragmentInputs.vUV.x,fragmentInputs.vUV.y,uniforms.layer);var voxelZ: f32=textureSample(voxelZaxisSampler,voxelZaxisSamplerSampler,coordZ).r;var coordX: vec3f= vec3f(1.0-uniforms.layer,fragmentInputs.vUV.y,fragmentInputs.vUV.x);var voxelX: f32=textureSample(voxelXaxisSampler,voxelXaxisSamplerSampler,coordX).r;var coordY: vec3f= vec3f(uniforms.layer,fragmentInputs.vUV.x,fragmentInputs.vUV.y);var voxelY: f32=textureSample(voxelYaxisSampler,voxelYaxisSamplerSampler,coordY).r;var voxel=select(0.0,1.0,(voxelX>0.0 || voxelY>0.0 || voxelZ>0.0));fragmentOutputs.color= vec4f( vec3f(voxel),1.0);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const iblCombineVoxelGridsPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,iCAAiC,CAAC;AAC/C,MAAM,MAAM,GAAG,CAAA;4pBAC6oB,CAAC;AAC7pB,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,mCAAmC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 8206, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/iblGenerateVoxelMip.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/iblGenerateVoxelMip.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"iblGenerateVoxelMipPixelShader\";\nconst shader = `varying vUV: vec2f;var srcMip: texture_3d<f32>;uniform layerNum: i32;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var Coords=vec3i(2)*vec3i(vec2i(fragmentInputs.position.xy),uniforms.layerNum);var tex =\n(u32(select(0u,1u,textureLoad(srcMip,Coords+vec3i(0,0,0),0).x>0.0f))\n<< 0u) |\n(u32(select(0u,1u,textureLoad(srcMip,Coords+vec3i(1,0,0),0).x>0.0f))\n<< 1u) |\n(u32(select(0u,1u,textureLoad(srcMip,Coords+vec3i(0,1,0),0).x>0.0f))\n<< 2u) |\n(u32(select(0u,1u,textureLoad(srcMip,Coords+vec3i(1,1,0),0).x>0.0f))\n<< 3u) |\n(u32(select(0u,1u,textureLoad(srcMip,Coords+vec3i(0,0,1),0).x>0.0f))\n<< 4u) |\n(u32(select(0u,1u,textureLoad(srcMip,Coords+vec3i(1,0,1),0).x>0.0f))\n<< 5u) |\n(u32(select(0u,1u,textureLoad(srcMip,Coords+vec3i(0,1,1),0).x>0.0f))\n<< 6u) |\n(u32(select(0u,1u,textureLoad(srcMip,Coords+vec3i(1,1,1),0).x>0.0f))\n<< 7u);fragmentOutputs.color=vec4f( f32(tex)/255.0f,0.0f,0.0f,1.0);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const iblGenerateVoxelMipPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,gCAAgC,CAAC;AAC9C,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;qEAiBsD,CAAC;AACtE,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,kCAAkC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 8244, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/iblShadowGBufferDebug.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/iblShadowGBufferDebug.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"iblShadowGBufferDebugPixelShader\";\nconst shader = `varying vUV : vec2f;var textureSamplerSampler : sampler;var textureSampler : texture_2d<f32>;var depthSamplerSampler : sampler;var depthSampler : texture_2d<f32>;var normalSamplerSampler : sampler;var normalSampler : texture_2d<f32>;var positionSamplerSampler : sampler;var positionSampler : texture_2d<f32>;var velocitySamplerSampler : sampler;var velocitySampler : texture_2d<f32>;uniform sizeParams : vec4f;\n#define offsetX uniforms.sizeParams.x\n#define offsetY uniforms.sizeParams.y\n#define widthScale uniforms.sizeParams.z\n#define heightScale uniforms.sizeParams.w\n@fragment fn main(input : FragmentInputs)->FragmentOutputs {var uv : vec2f=\nvec2f((offsetX+input.vUV.x)*widthScale,(offsetY+input.vUV.y)*heightScale);var backgroundColour: vec4f=textureSample(textureSampler,textureSamplerSampler,input.vUV).rgba;var depth : vec4f=textureSample(depthSampler,depthSamplerSampler,input.vUV);var worldNormal: vec4f=textureSample(normalSampler,normalSamplerSampler,input.vUV);var worldPosition : vec4f=textureSample(positionSampler,positionSamplerSampler,input.vUV);var velocityLinear : vec4f=textureSample(velocitySampler,velocitySamplerSampler,input.vUV);if (uv.x<0.0 || uv.x>1.0 || uv.y<0.0 || uv.y>1.0) {fragmentOutputs.color=backgroundColour;} else {if (uv.x<=0.25) {fragmentOutputs.color=vec4f(depth.rgb,1.0);} else if (uv.x<=0.5) {velocityLinear =\nvec4f(velocityLinear.r*0.5+0.5,velocityLinear.g*0.5+0.5,\nvelocityLinear.b,velocityLinear.a);fragmentOutputs.color=vec4f(velocityLinear.rgb,1.0);} else if (uv.x<=0.75) {fragmentOutputs.color=vec4f(worldPosition.rgb,1.0);} else {fragmentOutputs.color=vec4f(worldNormal.rgb,1.0);}}}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const iblShadowGBufferDebugPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,kCAAkC,CAAC;AAChD,MAAM,MAAM,GAAG,CAAA;;;;;;;;+NAQgN,CAAC;AAChO,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,oCAAoC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 8273, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/iblCdfx.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/iblCdfx.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"iblCdfxPixelShader\";\nconst shader = `#define PI 3.1415927\nvarying vUV: vec2f;var cdfy: texture_2d<f32>;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var cdfyRes=textureDimensions(cdfy,0);var currentPixel=vec2u(fragmentInputs.position.xy);var cdfx: f32=0.0;for (var x: u32=1; x<=currentPixel.x; x++) {cdfx+=textureLoad(cdfy, vec2u(x-1,cdfyRes.y-1),0).x;}\nfragmentOutputs.color= vec4f( vec3f(cdfx),1.0);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const iblCdfxPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,oBAAoB,CAAC;AAClC,MAAM,MAAM,GAAG,CAAA;;;iDAGkC,CAAC;AAClD,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,sBAAsB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 8297, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/iblCdfy.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/iblCdfy.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"iblCdfyPixelShader\";\nconst shader = `varying vUV : vec2f;\n#include <helperFunctions>\n#ifdef IBL_USE_CUBE_MAP\nvar iblSourceSampler: sampler;var iblSource: texture_cube<f32>;\n#else\nvar iblSourceSampler: sampler;var iblSource: texture_2d<f32>;\n#endif\nuniform iblHeight: i32;\n#ifdef IBL_USE_CUBE_MAP\nfn fetchCube(uv: vec2f)->f32 {var direction: vec3f=equirectangularToCubemapDirection(uv);return sin(PI*uv.y) *\ndot(textureSampleLevel(iblSource,iblSourceSampler,direction,0.0)\n.rgb,\nLuminanceEncodeApprox);}\n#else\nfn fetchPanoramic(Coords: vec2i,envmapHeight: f32)->f32 {return sin(PI*(f32(Coords.y)+0.5)/envmapHeight) *\ndot(textureLoad(iblSource,Coords,0).rgb,LuminanceEncodeApprox);}\n#endif\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var coords: vec2i= vec2i(fragmentInputs.position.xy);var cdfy: f32=0.0;for (var y: i32=1; y<=coords.y; y++) {\n#ifdef IBL_USE_CUBE_MAP\nvar uv: vec2f= vec2f(input.vUV.x,( f32(y-1)+0.5)/ f32(uniforms.iblHeight));cdfy+=fetchCube(uv);\n#else\ncdfy+=fetchPanoramic( vec2i(coords.x,y-1), f32(uniforms.iblHeight));\n#endif\n}\nfragmentOutputs.color= vec4f(cdfy,0.0,0.0,1.0);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const iblCdfyPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,oBAAoB,CAAC;AAClC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;iDAyBkC,CAAC;AAClD,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,sBAAsB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 8343, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/iblIcdf.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/iblIcdf.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\n\nconst name = \"iblIcdfPixelShader\";\nconst shader = `#include<helperFunctions>\nvarying vUV: vec2f;\n#ifdef IBL_USE_CUBE_MAP\nvar iblSourceSampler: sampler;var iblSource: texture_cube<f32>;\n#else\nvar iblSourceSampler: sampler;var iblSource: texture_2d<f32>;\n#endif\nvar scaledLuminanceSamplerSampler : sampler;var scaledLuminanceSampler : texture_2d<f32>;var cdfx: texture_2d<f32>;var cdfy: texture_2d<f32>;fn fetchLuminance(coords: vec2f)->f32 {\n#ifdef IBL_USE_CUBE_MAP\nvar direction: vec3f=equirectangularToCubemapDirection(coords);var color: vec3f=textureSampleLevel(iblSource,iblSourceSampler,direction,0.0).rgb;\n#else\nvar color: vec3f=textureSampleLevel(iblSource,iblSourceSampler,coords,0.0).rgb;\n#endif\nreturn dot(color,LuminanceEncodeApprox);}\nfn fetchCDFx(x: u32)->f32 {return textureLoad(cdfx, vec2u(x,0),0).x;}\nfn bisectx(size: u32,targetValue: f32)->f32\n{var a: u32=0;var b=size-1;while (b-a>1) {var c: u32=(a+b)>>1;if (fetchCDFx(c)<targetValue) {a=c;}\nelse {b=c;}}\nreturn mix( f32(a), f32(b),(targetValue-fetchCDFx(a))/(fetchCDFx(b)-fetchCDFx(a)))/ f32(size-1);}\nfn fetchCDFy(y: u32,invocationId: u32)->f32 {return textureLoad(cdfy, vec2u(invocationId,y),0).x;}\nfn bisecty(size: u32,targetValue: f32,invocationId: u32)->f32\n{var a: u32=0;var b=size-1;while (b-a>1) {var c=(a+b)>>1;if (fetchCDFy(c,invocationId)<targetValue) {a=c;}\nelse {b=c;}}\nreturn mix( f32(a), f32(b),(targetValue-fetchCDFy(a,invocationId))/(fetchCDFy(b,invocationId)-fetchCDFy(a,invocationId)))/ f32(size-1);}\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var cdfxSize: vec2u=textureDimensions(cdfx,0);var cdfWidth: u32=cdfxSize.x;var icdfWidth: u32=cdfWidth-1;var currentPixel: vec2u= vec2u(fragmentInputs.position.xy);var outputColor: vec3f=vec3f(1.0);if (currentPixel.x==0)\n{outputColor.x= 0.0;}\nelse if (currentPixel.x==icdfWidth-1) {outputColor.x= 1.0;} else {var targetValue: f32=fetchCDFx(cdfWidth-1)*input.vUV.x;outputColor.x= bisectx(cdfWidth,targetValue);}\nvar cdfySize: vec2u=textureDimensions(cdfy,0);var cdfHeight: u32=cdfySize.y;if (currentPixel.y==0) {outputColor.y= 0.0;}\nelse if (currentPixel.y==cdfHeight-2) {outputColor.y= 1.0;} else {var targetValue: f32=fetchCDFy(cdfHeight-1,currentPixel.x)*input.vUV.y;outputColor.y= max(bisecty(cdfHeight,targetValue,currentPixel.x),0.0);}\nvar size : vec2f=vec2f(textureDimensions(scaledLuminanceSampler,0));var highestMip: f32=floor(log2(size.x));var normalization : f32=textureSampleLevel(scaledLuminanceSampler,\nscaledLuminanceSamplerSampler,\ninput.vUV,highestMip)\n.r;var pixelLuminance: f32=fetchLuminance(input.vUV);outputColor.z=pixelLuminance/(2.0*PI*normalization);fragmentOutputs.color=vec4( outputColor,1.0);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const iblIcdfPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,kCAAkC,CAAC;;;AAE1C,MAAM,IAAI,GAAG,oBAAoB,CAAC;AAClC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wJAiCyI,CAAC;AACzJ,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,sBAAsB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 8399, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/iblCdfDebug.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/iblCdfDebug.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"iblCdfDebugPixelShader\";\nconst shader = `#define PI 3.1415927\nvarying vUV: vec2f;var cdfySampler: sampler;var cdfy: texture_2d<f32>;var cdfxSampler: sampler;var cdfx: texture_2d<f32>;var icdfSampler: sampler;var icdf: texture_2d<f32>;\n#ifdef IBL_USE_CUBE_MAP\nvar iblSourceSampler: sampler;var iblSource: texture_cube<f32>;\n#else\nvar iblSourceSampler: sampler;var iblSource: texture_2d<f32>;\n#endif\nvar textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;\n#define cdfyVSize (0.8/3.0)\n#define cdfxVSize 0.1\n#define cdfyHSize 0.5\nuniform sizeParams: vec4f;\n#ifdef IBL_USE_CUBE_MAP\nfn equirectangularToCubemapDirection(uv: vec2f)->vec3f {var longitude: f32=uv.x*2.0*PI-PI;var latitude: f32=PI*0.5-uv.y*PI;var direction: vec3f;direction.x=cos(latitude)*sin(longitude);direction.y=sin(latitude);direction.z=cos(latitude)*cos(longitude);return direction;}\n#endif\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs { \nvar colour: vec3f= vec3f(0.0);var uv: vec2f =\nvec2f((uniforms.sizeParams.x+input.vUV.x)*uniforms.sizeParams.z,(uniforms.sizeParams.y+input.vUV.y)*uniforms.sizeParams.w);var backgroundColour: vec3f=textureSample(textureSampler,textureSamplerSampler,input.vUV).rgb;var cdfxWidth: u32=textureDimensions(cdfx,0).x;var cdfyHeight: u32=textureDimensions(cdfy,0).y;const iblStart: f32=1.0-cdfyVSize;const pdfStart: f32=1.0-2.0*cdfyVSize;const cdfyStart: f32=1.0-3.0*cdfyVSize;const cdfxStart: f32=1.0-3.0*cdfyVSize-cdfxVSize;const icdfxStart: f32=1.0-3.0*cdfyVSize-2.0*cdfxVSize;\n#ifdef IBL_USE_CUBE_MAP\nvar direction: vec3f=equirectangularToCubemapDirection(\n(uv- vec2f(0.0,iblStart))* vec2f(1.0,1.0/cdfyVSize));var iblColour: vec3f=textureSampleLevel(iblSource,iblSourceSampler,direction,0.0).rgb;\n#else\nvar iblColour: vec3f=textureSample(iblSource,iblSourceSampler,(uv- vec2f(0.0,iblStart)) *\nvec2f(1.0,1.0/cdfyVSize))\n.rgb;\n#endif\nvar pdfColour: vec3f =\ntextureSample(icdf,icdfSampler,(uv- vec2f(0.0,pdfStart))* vec2f(1.0,1.0/cdfyVSize)).zzz;var cdfyColour: f32 =\ntextureSample(cdfy,cdfySampler,(uv- vec2f(0.0,cdfyStart))* vec2f(2.0,1.0/cdfyVSize)).r;var icdfyColour: f32 =\ntextureSample(icdf,icdfSampler,(uv- vec2f(0.5,cdfyStart))* vec2f(2.0,1.0/cdfyVSize)).g;var cdfxColour: f32 =\ntextureSample(cdfx,cdfxSampler,(uv- vec2f(0.0,cdfxStart))* vec2f(1.0,1.0/cdfxVSize)).r;var icdfxColour: f32=textureSample(icdf,icdfSampler,(uv- vec2f(0.0,icdfxStart)) *\nvec2f(1.0,1.0/cdfxVSize)).r;if (uv.x<0.0 || uv.x>1.0 || uv.y<0.0 || uv.y>1.0) {colour=backgroundColour;} else if (uv.y>iblStart) {colour+=iblColour;} else if (uv.y>pdfStart) {colour+=pdfColour;} else if (uv.y>cdfyStart && uv.x<0.5) {colour.r+=cdfyColour/f32(cdfyHeight);} else if (uv.y>cdfyStart && uv.x>0.5) {colour.r+=icdfyColour;} else if (uv.y>cdfxStart) {colour.r+=cdfxColour/f32(cdfxWidth);} else if (uv.y>icdfxStart) {colour.r+=icdfxColour;}\nfragmentOutputs.color =vec4(mix(colour,backgroundColour,0.5),1.0);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const iblCdfDebugPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,wBAAwB,CAAC;AACtC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oEAiCqD,CAAC;AACrE,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,0BAA0B,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 8453, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/iblScaledLuminance.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/iblScaledLuminance.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\n\nconst name = \"iblScaledLuminancePixelShader\";\nconst shader = `#include<helperFunctions>\n#ifdef IBL_USE_CUBE_MAP\nvar iblSourceSampler: sampler;var iblSource: texture_cube<f32>;\n#else\nvar iblSourceSampler: sampler;var iblSource: texture_2d<f32>;\n#endif\nuniform iblHeight: i32;uniform iblWidth: i32;fn fetchLuminance(coords: vec2f)->f32 {\n#ifdef IBL_USE_CUBE_MAP\nvar direction: vec3f=equirectangularToCubemapDirection(coords);var color: vec3f=textureSampleLevel(iblSource,iblSourceSampler,direction,0.0).rgb;\n#else\nvar color: vec3f=textureSampleLevel(iblSource,iblSourceSampler,coords,0.0).rgb;\n#endif\nreturn dot(color,LuminanceEncodeApprox);}\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var deform: f32=sin(input.vUV.y*PI);var luminance: f32=fetchLuminance(input.vUV);fragmentOutputs.color=vec4f(vec3f(deform*luminance),1.0);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const iblScaledLuminancePixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,kCAAkC,CAAC;;;AAE1C,MAAM,IAAI,GAAG,+BAA+B,CAAC;AAC7C,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;6LAc8K,CAAC;AAC9L,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,iCAAiC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 8490, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/iblDominantDirection.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/iblDominantDirection.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/importanceSampling\";\nimport \"./ShadersInclude/pbrBRDFFunctions\";\nimport \"./ShadersInclude/hdrFilteringFunctions\";\n\nconst name = \"iblDominantDirectionPixelShader\";\nconst shader = `#include<helperFunctions>\n#include<importanceSampling>\n#include<pbrBRDFFunctions>\n#include<hdrFilteringFunctions>\nvar icdfSamplerSampler: sampler;var icdfSampler: texture_2d<f32>;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var lightDir: vec3f=vec3f(0.0,0.0,0.0);for(var i: u32=0u; i<NUM_SAMPLES; i++)\n{var Xi: vec2f=hammersley(i,NUM_SAMPLES);var T: vec2f;T.x=textureSampleLevel(icdfSampler,icdfSamplerSampler,vec2(Xi.x,0.0),0.0).x;T.y=textureSampleLevel(icdfSampler,icdfSamplerSampler,vec2(T.x,Xi.y),0.0).y;var Ls: vec3f=uv_to_normal(vec2f(1.0-fract(T.x+0.25),T.y));lightDir+=Ls;}\nlightDir/=vec3f(f32(NUM_SAMPLES));fragmentOutputs.color=vec4f(lightDir,1.0);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const iblDominantDirectionPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,kCAAkC,CAAC;AAC1C,OAAO,qCAAqC,CAAC;AAC7C,OAAO,mCAAmC,CAAC;AAC3C,OAAO,wCAAwC,CAAC;;;;;;AAEhD,MAAM,IAAI,GAAG,iCAAiC,CAAC;AAC/C,MAAM,MAAM,GAAG,CAAA;;;;;;;8EAO+D,CAAC;AAC/E,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,mCAAmC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 8526, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/iblVoxelGrid2dArrayDebug.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/iblVoxelGrid2dArrayDebug.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"iblVoxelGrid2dArrayDebugPixelShader\";\nconst shader = `varying vUV: vec2f;var voxelTextureSampler: sampler;var voxelTexture: texture_3d<f32>;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform slice: i32;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var size: vec3u=textureDimensions(voxelTexture,0);var dimension: f32=sqrt( f32(size.z));var samplePos: vec2f=fract(input.vUV.xy* vec2f(dimension));var sampleIndex: u32= u32(floor(input.vUV.x* f32(dimension))+floor(input.vUV.y* f32(dimension))*dimension);var color=textureSample(voxelTexture,voxelTextureSampler, vec3f(samplePos.xy,sampleIndex)).rrr;color+=textureSample(textureSampler,textureSamplerSampler,input.vUV.xy).rgb;fragmentOutputs.color=vec4f(color,1.0);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const iblVoxelGrid2dArrayDebugPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,qCAAqC,CAAC;AACnD,MAAM,MAAM,GAAG,CAAA;mgBACof,CAAC;AACpgB,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,uCAAuC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 8548, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/iblVoxelGrid.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/iblVoxelGrid.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"iblVoxelGridPixelShader\";\nconst shader = `var voxel_storage: texture_storage_3d<rgba8unorm,write>;varying vNormalizedPosition: vec3f;flat varying f_swizzle: i32;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var size: vec3f=vec3f(textureDimensions(voxel_storage));var normPos: vec3f=input.vNormalizedPosition.xyz;var outputColor: vec4f=vec4f(0.0,0.0,0.0,1.0);switch (input.f_swizzle) {case 0: {normPos=normPos.zxy; \noutputColor=vec4f(1.0,1.0,0.0,1.0);break;}\ncase 1: {normPos=normPos.yzx;outputColor=vec4f(1.0,1.0,1.0,1.0);break;}\ndefault: {normPos=normPos.xyz;outputColor=vec4f(1.0,1.0,0.0,1.0);break;}}\ntextureStore(voxel_storage,vec3<i32>(i32(normPos.x*size.x),i32(normPos.y*size.y),i32(normPos.z*size.z)),outputColor);fragmentOutputs.color=vec4<f32>(vec3<f32>(normPos),1.);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const iblVoxelGridPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,yBAAyB,CAAC;AACvC,MAAM,MAAM,GAAG,CAAA;;;;;8KAK+J,CAAC;AAC/K,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,2BAA2B,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 8574, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/iblVoxelGrid.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/iblVoxelGrid.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\n\nconst name = \"iblVoxelGridVertexShader\";\nconst shader = `#include <bakedVertexAnimationDeclaration>\n#include <bonesDeclaration>\n#include <helperFunctions>\n#include <instancesDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef VERTEX_PULLING_USE_INDEX_BUFFER\nvar<storage,read> indices : array<u32>;\n#endif\nvar<storage,read> position : array<f32>;uniform world : mat4x4f;uniform invWorldScale: mat4x4f;varying vNormalizedPosition : vec3f;flat varying f_swizzle: i32;fn readVertexPosition(index : u32)->vec3f {var pos : vec3f;pos.x=position[index*3];pos.y=position[index*3+1];pos.z=position[index*3+2];return pos;}\nfn readVertexIndex(index : u32)->u32 {\n#ifndef VERTEX_PULLING_USE_INDEX_BUFFER\nreturn index;\n#else\n#ifdef VERTEX_PULLING_INDEX_BUFFER_32BITS\nreturn indices[index];\n#else\nlet u32_index=index/2u;let bit_offset=(index & 1u)*16u;return (indices[u32_index]>>bit_offset) & 0xFFFFu;\n#endif\n#endif\n}\nfn calculateTriangleNormal(v0\n: vec3<f32>,v1\n: vec3<f32>,v2\n: vec3<f32>)\n->vec3<f32> {let edge1=v1-v0;let edge2=v2-v0;let triangleNormal=cross(edge1,edge2);let normalizedTriangleNormal=normalize(triangleNormal);return normalizedTriangleNormal;}\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {var vertIdx=readVertexIndex(input.vertexIndex);var positionUpdated=readVertexPosition(vertIdx);\n#include <morphTargetsVertexGlobal>\nlet inputPosition: vec3f=positionUpdated;\n#include <morphTargetsVertex>(vertexInputs.position\\\\),inputPosition))[0..maxSimultaneousMorphTargets]\n#include <instancesVertex>\n#include <bakedVertexAnimation>\n#include <bonesVertex>\nlet worldPos=finalWorld*vec4f(positionUpdated,1.0);vertexOutputs.position=uniforms.invWorldScale*worldPos;var provokingVertNum : u32=input.vertexIndex/3*3;var pos0=readVertexPosition(readVertexIndex(provokingVertNum));var pos1=readVertexPosition(readVertexIndex(provokingVertNum+1));var pos2=readVertexPosition(readVertexIndex(provokingVertNum+2));var N : vec3<f32>=calculateTriangleNormal(pos0,pos1,pos2);N=abs(N);if (N.x>N.y && N.x>N.z) {vertexOutputs.f_swizzle=0;vertexOutputs.position=vec4f(vertexOutputs.position.yzx,1.0);} else if (N.y>N.z) {vertexOutputs.f_swizzle=1;vertexOutputs.position=vec4f(vertexOutputs.position.zxy,1.0);} else {vertexOutputs.f_swizzle=2;vertexOutputs.position=vec4f(vertexOutputs.position.xyz,1.0);}\nvertexOutputs.vNormalizedPosition=vertexOutputs.position.xyz*0.5+0.5;vertexOutputs.position.z =\nvertexOutputs.vNormalizedPosition.z; }\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const iblVoxelGridVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,sDAAsD,CAAC;AAC9D,OAAO,gDAAgD,CAAC;;;;AAExD,MAAM,IAAI,GAAG,0BAA0B,CAAC;AACxC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqCd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,4BAA4B,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 8636, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/iblVoxelGrid3dDebug.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/iblVoxelGrid3dDebug.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"iblVoxelGrid3dDebugPixelShader\";\nconst shader = `varying vUV: vec2f;var voxelTextureSampler: sampler;var voxelTexture: texture_3d<f32>;var voxelSlabTextureSampler: sampler;var voxelSlabTexture: texture_2d<f32>;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform sizeParams: vec4f;\n#define offsetX uniforms.sizeParams.x\n#define offsetY uniforms.sizeParams.y\n#define widthScale uniforms.sizeParams.z\n#define heightScale uniforms.sizeParams.w\nuniform mipNumber: f32;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var uv: vec2f =\nvec2f((offsetX+input.vUV.x)*widthScale,(offsetY+input.vUV.y)*heightScale);var background: vec4f=textureSample(textureSampler,textureSamplerSampler,input.vUV);var voxelSlab: vec4f=textureSample(voxelSlabTexture,voxelSlabTextureSampler,input.vUV);var size: vec3u=textureDimensions(voxelTexture, i32(uniforms.mipNumber));var dimension: f32=ceil(sqrt( f32(size.z)));var samplePos: vec2f=fract(uv.xy* vec2f(dimension));var sampleIndex: u32= u32(floor(uv.x* f32(dimension)) +\nfloor(uv.y* f32(dimension))*dimension);var mip_separator: f32=0.0;if (samplePos.x<0.01 || samplePos.y<0.01) {mip_separator=1.0;}\nvar outBounds: bool=select(false,true,sampleIndex>size.z-1);sampleIndex=clamp(sampleIndex,0,size.z-1);var samplePosInt: vec2i= vec2i(samplePos.xy* vec2f(size.xy));var voxel: vec3f=textureLoad(voxelTexture,\nvec3i(i32(samplePosInt.x),i32(samplePosInt.y),i32(sampleIndex)),\ni32(uniforms.mipNumber)).rgb;if (uv.x<0.0 || uv.x>1.0 || uv.y<0.0 || uv.y>1.0) {fragmentOutputs.color=background;} else {if (outBounds) {voxel= vec3f(0.15,0.0,0.0);} else {voxel.r+=mip_separator;}\nfragmentOutputs.color=vec4f(mix(background.rgb,voxelSlab.rgb,voxelSlab.a)+voxel,1.0);}}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const iblVoxelGrid3dDebugPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,gCAAgC,CAAC;AAC9C,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;wFAYyE,CAAC;AACzF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,kCAAkC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 8669, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/iblVoxelSlabDebug.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/iblVoxelSlabDebug.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"iblVoxelSlabDebugVertexShader\";\nconst shader = `attribute position: vec3f;varying vNormalizedPosition: vec3f;uniform world: mat4x4f;uniform invWorldScale: mat4x4f;uniform cameraViewMatrix: mat4x4f;uniform projection: mat4x4f;uniform viewMatrix: mat4x4f;@vertex\nfn main(input : VertexInputs)->FragmentInputs {var worldPosition: vec4f=(uniforms.world* vec4f(input.position,1.));vertexOutputs.position=uniforms.projection*uniforms.cameraViewMatrix*worldPosition;vertexOutputs.vNormalizedPosition=(uniforms.viewMatrix*uniforms.invWorldScale*worldPosition).rgb;vertexOutputs.vNormalizedPosition=vertexOutputs.vNormalizedPosition* vec3f(0.5)+ vec3f(0.5);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const iblVoxelSlabDebugVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,+BAA+B,CAAC;AAC7C,MAAM,MAAM,GAAG,CAAA;qYACsX,CAAC;AACtY,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,iCAAiC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 8691, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/iblVoxelSlabDebug.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/iblVoxelSlabDebug.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"iblVoxelSlabDebugPixelShader\";\nconst shader = `varying vNormalizedPosition: vec3f;uniform nearPlane: f32;uniform farPlane: f32;uniform stepSize: f32;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var normPos: vec3f=input.vNormalizedPosition.xyz;var chunkSize: f32=uniforms.stepSize* f32(MAX_DRAW_BUFFERS);var numChunks: f32=1.0/chunkSize;var positionInChunk: f32=fract(normPos.z/chunkSize);var slab: f32=floor(positionInChunk* f32(MAX_DRAW_BUFFERS)) /\nf32(MAX_DRAW_BUFFERS);if (normPos.x<0.0 || normPos.y<0.0 || normPos.z<0.0 ||\nnormPos.x>1.0 || normPos.y>1.0 || normPos.z>1.0) {fragmentOutputs.color= vec4f(0.0,0.0,0.0,0.0);} else {fragmentOutputs.color= vec4f(slab,0.0,0.0,0.75);}}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const iblVoxelSlabDebugPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,8BAA8B,CAAC;AAC5C,MAAM,MAAM,GAAG,CAAA;;;2JAG4I,CAAC;AAC5J,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,gCAAgC,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 8715, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/oitBackBlend.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/oitBackBlend.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"oitBackBlendPixelShader\";\nconst shader = `var uBackColor: texture_2d<f32>;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=textureLoad(uBackColor,vec2i(fragmentInputs.position.xy),0);if (fragmentOutputs.color.a==0.0) {discard;}}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const oitBackBlendPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,yBAAyB,CAAC;AACvC,MAAM,MAAM,GAAG,CAAA;;CAEd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,2BAA2B,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 8738, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/oitFinal.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/oitFinal.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"oitFinalPixelShader\";\nconst shader = `var uFrontColor: texture_2d<f32>;var uBackColor: texture_2d<f32>;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var fragCoord: vec2i=vec2i(fragmentInputs.position.xy);var frontColor: vec4f=textureLoad(uFrontColor,fragCoord,0);var backColor: vec4f=textureLoad(uBackColor,fragCoord,0);var alphaMultiplier: f32=1.0-frontColor.a;fragmentOutputs.color=vec4f(\nfrontColor.rgb+alphaMultiplier*backColor.rgb,\nfrontColor.a+backColor.a\n);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const oitFinalPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;;AAErD,MAAM,IAAI,GAAG,qBAAqB,CAAC;AACnC,MAAM,MAAM,GAAG,CAAA;;;;;CAKd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,uBAAuB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 8764, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/sprites.fragment.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/sprites.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/logDepthFragment\";\nimport \"./ShadersInclude/fogFragment\";\nimport \"./ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"spritesPixelShader\";\nconst shader = `uniform alphaTest: i32;varying vColor: vec4f;varying vUV: vec2f;var diffuseSamplerSampler: sampler;var diffuseSampler: texture_2d<f32>;\n#include<fogFragmentDeclaration>\n#include<logDepthDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\n#ifdef PIXEL_PERFECT\nfn uvPixelPerfect(uv: vec2f)->vec2f {var res: vec2f= vec2f(textureDimensions(diffuseSampler,0));var uvTemp=uv*res;var seam: vec2f=floor(uvTemp+0.5);uvTemp=seam+clamp((uvTemp-seam)/fwidth(uvTemp),vec2f(-0.5),vec2f(0.5));return uvTemp/res;}\n#endif\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#ifdef PIXEL_PERFECT\nvar uv: vec2f=uvPixelPerfect(input.vUV);\n#else\nvar uv: vec2f=input.vUV;\n#endif\nvar color: vec4f=textureSample(diffuseSampler,diffuseSamplerSampler,uv);var fAlphaTest: f32= f32(uniforms.alphaTest);if (fAlphaTest != 0.)\n{if (color.a<0.95) {discard;}}\ncolor*=input.vColor;\n#include<logDepthFragment>\n#include<fogFragment>\nfragmentOutputs.color=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const spritesPixelShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,yCAAyC,CAAC;AACjD,OAAO,sCAAsC,CAAC;AAC9C,OAAO,mCAAmC,CAAC;AAC3C,OAAO,8BAA8B,CAAC;AACtC,OAAO,+CAA+C,CAAC;;;;;;;AAEvD,MAAM,IAAI,GAAG,oBAAoB,CAAC;AAClC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;;EAuBb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,sBAAsB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}},
    {"offset": {"line": 8818, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/sprites.vertex.js","sources":["file:///Users/shayanbozorgmanesh/Developer/kitchen-cpq-platform/node_modules/.pnpm/%40babylonjs%2Bcore%408.39.0/dev/core/src/ShadersWGSL/sprites.vertex.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/fogVertexDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/logDepthVertex\";\n\nconst name = \"spritesVertexShader\";\nconst shader = `attribute position: vec4f;attribute options: vec2f;attribute offsets: vec2f;attribute inverts: vec2f;attribute cellInfo: vec4f;attribute color: vec4f;uniform view: mat4x4f;uniform projection: mat4x4f;varying vUV: vec2f;varying vColor: vec4f;\n#include<fogVertexDeclaration>\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvar viewPos: vec3f=(uniforms.view* vec4f(input.position.xyz,1.0)).xyz; \nvar cornerPos: vec2f;var angle: f32=input.position.w;var size: vec2f= vec2f(input.options.x,input.options.y);var offset: vec2f=input.offsets.xy;cornerPos= vec2f(offset.x-0.5,offset.y -0.5)*size;var rotatedCorner: vec3f;rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.z=0.;viewPos+=rotatedCorner;vertexOutputs.position=uniforms.projection*vec4f(viewPos,1.0); \nvertexOutputs.vColor=input.color;var uvOffset: vec2f= vec2f(abs(offset.x-input.inverts.x),abs(1.0-offset.y-input.inverts.y));var uvPlace: vec2f=input.cellInfo.xy;var uvSize: vec2f=input.cellInfo.zw;vertexOutputs.vUV.x=uvPlace.x+uvSize.x*uvOffset.x;vertexOutputs.vUV.y=uvPlace.y+uvSize.y*uvOffset.y;\n#ifdef FOG\nvertexOutputs.vFogDistance=viewPos;\n#endif\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const spritesVertexShaderWGSL = { name, shader };\n"],"names":[],"mappings":"AAAA,eAAe;;;;;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AACrD,OAAO,uCAAuC,CAAC;AAC/C,OAAO,sCAAsC,CAAC;AAC9C,OAAO,iCAAiC,CAAC;;;;;AAEzC,MAAM,IAAI,GAAG,qBAAqB,CAAC;AACnC,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;;;;;;EAeb,CAAC;AACH,aAAa;AACb,IAAI,CAAC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC;IACtC,gPAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChD,CAAC;AAEM,MAAM,uBAAuB,GAAG;IAAE,IAAI;IAAE,MAAM;AAAA,CAAE,CAAC"}}]
}