(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/WebGL/webGLDataBuffer.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "WebGLDataBuffer",
    ()=>WebGLDataBuffer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$dataBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/dataBuffer.js [app-client] (ecmascript)");
;
class WebGLDataBuffer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$dataBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataBuffer"] {
    constructor(resource){
        super();
        this._buffer = resource;
    }
    get underlyingResource() {
        return this._buffer;
    }
} //# sourceMappingURL=webGLDataBuffer.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/subMesh.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SubMesh",
    ()=>SubMesh
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Collisions$2f$intersectionInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Collisions/intersectionInfo.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Culling$2f$boundingInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Culling/boundingInfo.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.functions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$drawWrapper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/drawWrapper.js [app-client] (ecmascript)");
;
;
;
;
;
class SubMesh {
    /**
     * Gets material defines used by the effect associated to the sub mesh
     */ get materialDefines() {
        return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.defines : this._getDrawWrapper()?.defines;
    }
    /**
     * Sets material defines used by the effect associated to the sub mesh
     */ set materialDefines(defines) {
        const drawWrapper = this._mainDrawWrapperOverride ?? this._getDrawWrapper(undefined, true);
        drawWrapper.defines = defines;
    }
    /**
     * @internal
     */ _getDrawWrapper(passId, createIfNotExisting = false) {
        passId = passId ?? this._engine.currentRenderPassId;
        let drawWrapper = this._drawWrappers[passId];
        if (!drawWrapper && createIfNotExisting) {
            this._drawWrappers[passId] = drawWrapper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$drawWrapper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DrawWrapper"](this._mesh.getScene().getEngine());
        }
        return drawWrapper;
    }
    /**
     * @internal
     */ _removeDrawWrapper(passId, disposeWrapper = true, immediate = false) {
        if (disposeWrapper) {
            this._drawWrappers[passId]?.dispose(immediate);
        }
        this._drawWrappers[passId] = undefined;
    }
    /**
     * Gets associated (main) effect (possibly the effect override if defined)
     */ get effect() {
        return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.effect : this._getDrawWrapper()?.effect ?? null;
    }
    /** @internal */ get _drawWrapper() {
        return this._mainDrawWrapperOverride ?? this._getDrawWrapper(undefined, true);
    }
    /** @internal */ get _drawWrapperOverride() {
        return this._mainDrawWrapperOverride;
    }
    /**
     * @internal
     */ _setMainDrawWrapperOverride(wrapper) {
        this._mainDrawWrapperOverride = wrapper;
    }
    /**
     * Sets associated effect (effect used to render this submesh)
     * @param effect defines the effect to associate with
     * @param defines defines the set of defines used to compile this effect
     * @param materialContext material context associated to the effect
     * @param resetContext true to reset the draw context
     */ setEffect(effect, defines = null, materialContext, resetContext = true) {
        const drawWrapper = this._drawWrapper;
        drawWrapper.setEffect(effect, defines, resetContext);
        if (materialContext !== undefined) {
            drawWrapper.materialContext = materialContext;
        }
        if (!effect) {
            drawWrapper.defines = null;
            drawWrapper.materialContext = undefined;
        }
    }
    /**
     * Resets the draw wrappers cache
     * @param passId If provided, releases only the draw wrapper corresponding to this render pass id
     * @param immediate If true, the draw wrapper will dispose the effect immediately (false by default)
     */ resetDrawCache(passId, immediate = false) {
        if (this._drawWrappers) {
            if (passId !== undefined) {
                this._removeDrawWrapper(passId, true, immediate);
                return;
            } else {
                for (const drawWrapper of this._drawWrappers){
                    drawWrapper?.dispose(immediate);
                }
            }
        }
        this._drawWrappers = [];
    }
    /**
     * Add a new submesh to a mesh
     * @param materialIndex defines the material index to use
     * @param verticesStart defines vertex index start
     * @param verticesCount defines vertices count
     * @param indexStart defines index start
     * @param indexCount defines indices count
     * @param mesh defines the parent mesh
     * @param renderingMesh defines an optional rendering mesh
     * @param createBoundingBox defines if bounding box should be created for this submesh
     * @returns the new submesh
     */ static AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox = true) {
        return new SubMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox);
    }
    /**
     * Creates a new submesh
     * @param materialIndex defines the material index to use
     * @param verticesStart defines vertex index start
     * @param verticesCount defines vertices count
     * @param indexStart defines index start
     * @param indexCount defines indices count
     * @param mesh defines the parent mesh
     * @param renderingMesh defines an optional rendering mesh
     * @param createBoundingBox defines if bounding box should be created for this submesh
     * @param addToMesh defines a boolean indicating that the submesh must be added to the mesh.subMeshes array (true by default)
     */ constructor(/** the material index to use */ materialIndex, /** vertex index start */ verticesStart, /** vertices count */ verticesCount, /** index start */ indexStart, /** indices count */ indexCount, mesh, renderingMesh, createBoundingBox = true, addToMesh = true){
        this.materialIndex = materialIndex;
        this.verticesStart = verticesStart;
        this.verticesCount = verticesCount;
        this.indexStart = indexStart;
        this.indexCount = indexCount;
        this._mainDrawWrapperOverride = null;
        /** @internal */ this._linesIndexCount = 0;
        this._linesIndexBuffer = null;
        /** @internal */ this._lastColliderWorldVertices = null;
        /** @internal */ this._lastColliderTransformMatrix = null;
        /** @internal */ this._wasDispatched = false;
        /** @internal */ this._renderId = 0;
        /** @internal */ this._alphaIndex = 0;
        /** @internal */ this._distanceToCamera = 0;
        this._currentMaterial = null;
        this._mesh = mesh;
        this._renderingMesh = renderingMesh || mesh;
        if (addToMesh) {
            mesh.subMeshes.push(this);
        }
        this._engine = this._mesh.getScene().getEngine();
        this.resetDrawCache();
        this._trianglePlanes = [];
        this._id = mesh.subMeshes.length - 1;
        if (createBoundingBox) {
            this.refreshBoundingInfo();
            mesh.computeWorldMatrix(true);
        }
    }
    /**
     * Returns true if this submesh covers the entire parent mesh
     * @ignorenaming
     */ // eslint-disable-next-line @typescript-eslint/naming-convention
    get IsGlobal() {
        return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices() && this.indexStart === 0 && this.indexCount === this._mesh.getTotalIndices();
    }
    /**
     * Returns the submesh BoundingInfo object
     * @returns current bounding info (or mesh's one if the submesh is global)
     */ getBoundingInfo() {
        if (this.IsGlobal || this._mesh.hasThinInstances) {
            return this._mesh.getBoundingInfo();
        }
        return this._boundingInfo;
    }
    /**
     * Sets the submesh BoundingInfo
     * @param boundingInfo defines the new bounding info to use
     * @returns the SubMesh
     */ setBoundingInfo(boundingInfo) {
        this._boundingInfo = boundingInfo;
        return this;
    }
    /**
     * Returns the mesh of the current submesh
     * @returns the parent mesh
     */ getMesh() {
        return this._mesh;
    }
    /**
     * Returns the rendering mesh of the submesh
     * @returns the rendering mesh (could be different from parent mesh)
     */ getRenderingMesh() {
        return this._renderingMesh;
    }
    /**
     * Returns the replacement mesh of the submesh
     * @returns the replacement mesh (could be different from parent mesh)
     */ getReplacementMesh() {
        return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;
    }
    /**
     * Returns the effective mesh of the submesh
     * @returns the effective mesh (could be different from parent mesh)
     */ getEffectiveMesh() {
        const replacementMesh = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;
        return replacementMesh ? replacementMesh : this._renderingMesh;
    }
    /**
     * Returns the submesh material
     * @param getDefaultMaterial Defines whether or not to get the default material if nothing has been defined.
     * @returns null or the current material
     */ getMaterial(getDefaultMaterial = true) {
        const rootMaterial = this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId) ?? this._renderingMesh.material;
        if (!rootMaterial) {
            return getDefaultMaterial && this._mesh.getScene()._hasDefaultMaterial ? this._mesh.getScene().defaultMaterial : null;
        } else if (this._isMultiMaterial(rootMaterial)) {
            const effectiveMaterial = rootMaterial.getSubMaterial(this.materialIndex);
            if (this._currentMaterial !== effectiveMaterial) {
                this._currentMaterial = effectiveMaterial;
                this.resetDrawCache();
            }
            return effectiveMaterial;
        }
        return rootMaterial;
    }
    _isMultiMaterial(material) {
        return material.getSubMaterial !== undefined;
    }
    // Methods
    /**
     * Sets a new updated BoundingInfo object to the submesh
     * @param data defines an optional position array to use to determine the bounding info
     * @returns the SubMesh
     */ refreshBoundingInfo(data = null) {
        this._lastColliderWorldVertices = null;
        if (this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) {
            return this;
        }
        if (!data) {
            data = this._renderingMesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind);
        }
        if (!data) {
            this._boundingInfo = this._mesh.getBoundingInfo();
            return this;
        }
        const indices = this._renderingMesh.getIndices();
        let extend;
        //is this the only submesh?
        if (this.indexStart === 0 && this.indexCount === indices.length) {
            const boundingInfo = this._renderingMesh.getBoundingInfo();
            //the rendering mesh's bounding info can be used, it is the standard submesh for all indices.
            extend = {
                minimum: boundingInfo.minimum.clone(),
                maximum: boundingInfo.maximum.clone()
            };
        } else {
            extend = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["extractMinAndMaxIndexed"])(data, indices, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);
        }
        if (this._boundingInfo) {
            this._boundingInfo.reConstruct(extend.minimum, extend.maximum);
        } else {
            this._boundingInfo = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Culling$2f$boundingInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BoundingInfo"](extend.minimum, extend.maximum);
        }
        return this;
    }
    /**
     * @internal
     */ _checkCollision(collider) {
        const boundingInfo = this.getBoundingInfo();
        return boundingInfo._checkCollision(collider);
    }
    /**
     * Updates the submesh BoundingInfo
     * @param world defines the world matrix to use to update the bounding info
     * @returns the submesh
     */ updateBoundingInfo(world) {
        let boundingInfo = this.getBoundingInfo();
        if (!boundingInfo) {
            this.refreshBoundingInfo();
            boundingInfo = this.getBoundingInfo();
        }
        if (boundingInfo) {
            boundingInfo.update(world);
        }
        return this;
    }
    /**
     * True is the submesh bounding box intersects the frustum defined by the passed array of planes.
     * @param frustumPlanes defines the frustum planes
     * @returns true if the submesh is intersecting with the frustum
     */ isInFrustum(frustumPlanes) {
        const boundingInfo = this.getBoundingInfo();
        if (!boundingInfo) {
            return false;
        }
        return boundingInfo.isInFrustum(frustumPlanes, this._mesh.cullingStrategy);
    }
    /**
     * True is the submesh bounding box is completely inside the frustum defined by the passed array of planes
     * @param frustumPlanes defines the frustum planes
     * @returns true if the submesh is inside the frustum
     */ isCompletelyInFrustum(frustumPlanes) {
        const boundingInfo = this.getBoundingInfo();
        if (!boundingInfo) {
            return false;
        }
        return boundingInfo.isCompletelyInFrustum(frustumPlanes);
    }
    /**
     * Renders the submesh
     * @param enableAlphaMode defines if alpha needs to be used
     * @returns the submesh
     */ render(enableAlphaMode) {
        this._renderingMesh.render(this, enableAlphaMode, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : undefined);
        return this;
    }
    /**
     * @internal
     */ _getLinesIndexBuffer(indices, engine) {
        if (!this._linesIndexBuffer) {
            const adjustedIndexCount = Math.floor(this.indexCount / 3) * 6;
            const shouldUseUint32 = this.verticesStart + this.verticesCount > 65535;
            const linesIndices = shouldUseUint32 ? new Uint32Array(adjustedIndexCount) : new Uint16Array(adjustedIndexCount);
            let offset = 0;
            if (indices.length === 0) {
                // Unindexed mesh
                for(let index = this.indexStart; index < this.indexStart + this.indexCount; index += 3){
                    linesIndices[offset++] = index;
                    linesIndices[offset++] = index + 1;
                    linesIndices[offset++] = index + 1;
                    linesIndices[offset++] = index + 2;
                    linesIndices[offset++] = index + 2;
                    linesIndices[offset++] = index;
                }
            } else {
                for(let index = this.indexStart; index < this.indexStart + this.indexCount; index += 3){
                    linesIndices[offset++] = indices[index];
                    linesIndices[offset++] = indices[index + 1];
                    linesIndices[offset++] = indices[index + 1];
                    linesIndices[offset++] = indices[index + 2];
                    linesIndices[offset++] = indices[index + 2];
                    linesIndices[offset++] = indices[index];
                }
            }
            this._linesIndexBuffer = engine.createIndexBuffer(linesIndices);
            this._linesIndexCount = linesIndices.length;
        }
        return this._linesIndexBuffer;
    }
    /**
     * Checks if the submesh intersects with a ray
     * @param ray defines the ray to test
     * @returns true is the passed ray intersects the submesh bounding box
     */ canIntersects(ray) {
        const boundingInfo = this.getBoundingInfo();
        if (!boundingInfo) {
            return false;
        }
        return ray.intersectsBox(boundingInfo.boundingBox);
    }
    /**
     * Intersects current submesh with a ray
     * @param ray defines the ray to test
     * @param positions defines mesh's positions array
     * @param indices defines mesh's indices array
     * @param fastCheck defines if the first intersection will be used (and not the closest)
     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
     * @returns intersection info or null if no intersection
     */ intersects(ray, positions, indices, fastCheck, trianglePredicate) {
        const material = this.getMaterial();
        if (!material) {
            return null;
        }
        let step = 3;
        let checkStopper = false;
        switch(material.fillMode){
            case 3:
            case 5:
            case 6:
            case 8:
                return null;
            case 7:
                step = 1;
                checkStopper = true;
                break;
            default:
                break;
        }
        // LineMesh first as it's also a Mesh...
        if (material.fillMode === 4) {
            // Check if mesh is unindexed
            if (!indices.length) {
                return this._intersectUnIndexedLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);
            }
            return this._intersectLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);
        } else {
            // Check if mesh is unindexed
            if (!indices.length && this._mesh._unIndexed) {
                return this._intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate);
            }
            return this._intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate);
        }
    }
    /**
     * @internal
     */ _intersectLines(ray, positions, indices, intersectionThreshold, fastCheck) {
        let intersectInfo = null;
        // Line test
        for(let index = this.indexStart; index < this.indexStart + this.indexCount; index += 2){
            const p0 = positions[indices[index]];
            const p1 = positions[indices[index + 1]];
            const length = ray.intersectionSegment(p0, p1, intersectionThreshold);
            if (length < 0) {
                continue;
            }
            if (fastCheck || !intersectInfo || length < intersectInfo.distance) {
                intersectInfo = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Collisions$2f$intersectionInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IntersectionInfo"](null, null, length);
                intersectInfo.faceId = index / 2;
                if (fastCheck) {
                    break;
                }
            }
        }
        return intersectInfo;
    }
    /**
     * @internal
     */ _intersectUnIndexedLines(ray, positions, indices, intersectionThreshold, fastCheck) {
        let intersectInfo = null;
        // Line test
        for(let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 2){
            const p0 = positions[index];
            const p1 = positions[index + 1];
            const length = ray.intersectionSegment(p0, p1, intersectionThreshold);
            if (length < 0) {
                continue;
            }
            if (fastCheck || !intersectInfo || length < intersectInfo.distance) {
                intersectInfo = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Collisions$2f$intersectionInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IntersectionInfo"](null, null, length);
                intersectInfo.faceId = index / 2;
                if (fastCheck) {
                    break;
                }
            }
        }
        return intersectInfo;
    }
    /**
     * @internal
     */ _intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate) {
        let intersectInfo = null;
        // Triangles test
        let faceId = -1;
        for(let index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step){
            faceId++;
            const indexA = indices[index];
            const indexB = indices[index + 1];
            const indexC = indices[index + 2];
            if (checkStopper && indexC === 0xffffffff) {
                index += 2;
                continue;
            }
            const p0 = positions[indexA];
            const p1 = positions[indexB];
            const p2 = positions[indexC];
            // stay defensive and don't check against undefined positions.
            if (!p0 || !p1 || !p2) {
                continue;
            }
            if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, indexA, indexB, indexC)) {
                continue;
            }
            const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);
            if (currentIntersectInfo) {
                if (currentIntersectInfo.distance < 0) {
                    continue;
                }
                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {
                    intersectInfo = currentIntersectInfo;
                    intersectInfo.faceId = faceId;
                    if (fastCheck) {
                        break;
                    }
                }
            }
        }
        return intersectInfo;
    }
    /**
     * @internal
     */ _intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate) {
        let intersectInfo = null;
        // Triangles test
        for(let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3){
            const p0 = positions[index];
            const p1 = positions[index + 1];
            const p2 = positions[index + 2];
            if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, -1, -1, -1)) {
                continue;
            }
            const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);
            if (currentIntersectInfo) {
                if (currentIntersectInfo.distance < 0) {
                    continue;
                }
                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {
                    intersectInfo = currentIntersectInfo;
                    intersectInfo.faceId = index / 3;
                    if (fastCheck) {
                        break;
                    }
                }
            }
        }
        return intersectInfo;
    }
    /** @internal */ _rebuild() {
        if (this._linesIndexBuffer) {
            this._linesIndexBuffer = null;
        }
    }
    // Clone
    /**
     * Creates a new submesh from the passed mesh
     * @param newMesh defines the new hosting mesh
     * @param newRenderingMesh defines an optional rendering mesh
     * @returns the new submesh
     */ clone(newMesh, newRenderingMesh) {
        const result = new SubMesh(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, newMesh, newRenderingMesh, false);
        if (!this.IsGlobal) {
            const boundingInfo = this.getBoundingInfo();
            if (!boundingInfo) {
                return result;
            }
            result._boundingInfo = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Culling$2f$boundingInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BoundingInfo"](boundingInfo.minimum, boundingInfo.maximum);
        }
        return result;
    }
    // Dispose
    /**
     * Release associated resources
     * @param immediate If true, the effect will be disposed immediately (false by default)
     */ dispose(immediate = false) {
        if (this._linesIndexBuffer) {
            this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer);
            this._linesIndexBuffer = null;
        }
        // Remove from mesh
        const index = this._mesh.subMeshes.indexOf(this);
        this._mesh.subMeshes.splice(index, 1);
        this.resetDrawCache(undefined, immediate);
    }
    /**
     * Gets the class name
     * @returns the string "SubMesh".
     */ getClassName() {
        return "SubMesh";
    }
    // Statics
    /**
     * Creates a new submesh from indices data
     * @param materialIndex the index of the main mesh material
     * @param startIndex the index where to start the copy in the mesh indices array
     * @param indexCount the number of indices to copy then from the startIndex
     * @param mesh the main mesh to create the submesh from
     * @param renderingMesh the optional rendering mesh
     * @param createBoundingBox defines if bounding box should be created for this submesh
     * @returns a new submesh
     */ static CreateFromIndices(materialIndex, startIndex, indexCount, mesh, renderingMesh, createBoundingBox = true) {
        let minVertexIndex = Number.MAX_VALUE;
        let maxVertexIndex = -Number.MAX_VALUE;
        const whatWillRender = renderingMesh || mesh;
        const indices = whatWillRender.getIndices();
        for(let index = startIndex; index < startIndex + indexCount; index++){
            const vertexIndex = indices[index];
            if (vertexIndex < minVertexIndex) {
                minVertexIndex = vertexIndex;
            }
            if (vertexIndex > maxVertexIndex) {
                maxVertexIndex = vertexIndex;
            }
        }
        return new SubMesh(materialIndex, minVertexIndex, maxVertexIndex - minVertexIndex + 1, startIndex, indexCount, mesh, renderingMesh, createBoundingBox);
    }
} //# sourceMappingURL=subMesh.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/geometry.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Geometry",
    ()=>Geometry
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.color.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.vertexData.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$subMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/subMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Loading$2f$sceneLoaderFlags$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Loading/sceneLoaderFlags.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Culling$2f$boundingInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Culling/boundingInfo.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tools.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tags$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tags.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.functions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engineStore$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Engines/engineStore.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Compat$2f$compatibilityOptions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Compat/compatibilityOptions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$bufferUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/bufferUtils.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
class Geometry {
    /**
     *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y
     */ get boundingBias() {
        return this._boundingBias;
    }
    /**
     *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y
     */ set boundingBias(value) {
        if (this._boundingBias) {
            this._boundingBias.copyFrom(value);
        } else {
            this._boundingBias = value.clone();
        }
        this._updateBoundingInfo(true, null);
    }
    /**
     * Static function used to attach a new empty geometry to a mesh
     * @param mesh defines the mesh to attach the geometry to
     * @returns the new Geometry
     */ static CreateGeometryForMesh(mesh) {
        const geometry = new Geometry(Geometry.RandomId(), mesh.getScene());
        geometry.applyToMesh(mesh);
        return geometry;
    }
    /** Get the list of meshes using this geometry */ get meshes() {
        return this._meshes;
    }
    /**
     * Creates a new geometry
     * @param id defines the unique ID
     * @param scene defines the hosting scene
     * @param vertexData defines the VertexData used to get geometry data
     * @param updatable defines if geometry must be updatable (false by default)
     * @param mesh defines the mesh that will be associated with the geometry
     */ constructor(id, scene, vertexData, updatable = false, mesh = null){
        /**
         * Gets the delay loading state of the geometry (none by default which means not delayed)
         */ this.delayLoadState = 0;
        this._totalVertices = 0;
        this._isDisposed = false;
        this._extend = {
            minimum: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE),
            maximum: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)
        };
        this._indexBufferIsUpdatable = false;
        this._positionsCache = [];
        /** @internal */ this._parentContainer = null;
        /**
         * If set to true (false by default), the bounding info applied to the meshes sharing this geometry will be the bounding info defined at the class level
         * and won't be computed based on the vertex positions (which is what we get when useBoundingInfoFromGeometry = false)
         */ this.useBoundingInfoFromGeometry = false;
        this._scene = scene || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engineStore$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EngineStore"].LastCreatedScene;
        if (!this._scene) {
            return;
        }
        this.id = id;
        this.uniqueId = this._scene.getUniqueId();
        this._engine = this._scene.getEngine();
        this._meshes = [];
        //Init vertex buffer cache
        this._vertexBuffers = {};
        this._indices = [];
        this._updatable = updatable;
        // vertexData
        if (vertexData) {
            this.setAllVerticesData(vertexData, updatable);
        } else {
            this._totalVertices = 0;
        }
        if (this._engine.getCaps().vertexArrayObject) {
            this._vertexArrayObjects = {};
        }
        // applyToMesh
        if (mesh) {
            this.applyToMesh(mesh);
            mesh.computeWorldMatrix(true);
        }
    }
    /**
     * Gets the current extend of the geometry
     */ get extend() {
        return this._extend;
    }
    /**
     * Gets the hosting scene
     * @returns the hosting Scene
     */ getScene() {
        return this._scene;
    }
    /**
     * Gets the hosting engine
     * @returns the hosting Engine
     */ getEngine() {
        return this._engine;
    }
    /**
     * Defines if the geometry is ready to use
     * @returns true if the geometry is ready to be used
     */ isReady() {
        return this.delayLoadState === 1 || this.delayLoadState === 0;
    }
    /**
     * Gets a value indicating that the geometry should not be serialized
     */ get doNotSerialize() {
        for(let index = 0; index < this._meshes.length; index++){
            if (!this._meshes[index].doNotSerialize) {
                return false;
            }
        }
        return true;
    }
    /** @internal */ _rebuild() {
        if (this._vertexArrayObjects) {
            this._vertexArrayObjects = {};
        }
        // Index buffer
        if (this._meshes.length !== 0 && this._indices) {
            this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable, "Geometry_" + this.id + "_IndexBuffer");
        }
        // Vertex buffers
        const buffers = new Set();
        for(const key in this._vertexBuffers){
            buffers.add(this._vertexBuffers[key].getWrapperBuffer());
        }
        buffers.forEach((buffer)=>{
            buffer._rebuild();
        });
    }
    /**
     * Affects all geometry data in one call
     * @param vertexData defines the geometry data
     * @param updatable defines if the geometry must be flagged as updatable (false as default)
     */ setAllVerticesData(vertexData, updatable) {
        vertexData.applyToGeometry(this, updatable);
        this._notifyUpdate();
    }
    /**
     * Set specific vertex data
     * @param kind defines the data kind (Position, normal, etc...)
     * @param data defines the vertex data to use
     * @param updatable defines if the vertex must be flagged as updatable (false as default)
     * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified
     */ setVerticesData(kind, data, updatable = false, stride) {
        if (updatable && Array.isArray(data)) {
            // to avoid converting to Float32Array at each draw call in engine.updateDynamicVertexBuffer, we make the conversion a single time here
            data = new Float32Array(data);
        }
        const buffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"](this._engine, data, kind, {
            updatable,
            postponeInternalCreation: this._meshes.length === 0,
            stride,
            label: "Geometry_" + this.id + "_" + kind
        });
        this.setVerticesBuffer(buffer);
    }
    /**
     * Removes a specific vertex data
     * @param kind defines the data kind (Position, normal, etc...)
     */ removeVerticesData(kind) {
        if (this._vertexBuffers[kind]) {
            this._vertexBuffers[kind].dispose();
            delete this._vertexBuffers[kind];
        }
        if (this._vertexArrayObjects) {
            this._disposeVertexArrayObjects();
        }
    }
    /**
     * Affect a vertex buffer to the geometry. the vertexBuffer.getKind() function is used to determine where to store the data
     * @param buffer defines the vertex buffer to use
     * @param totalVertices defines the total number of vertices for position kind (could be null)
     * @param disposeExistingBuffer disposes the existing buffer, if any (default: true)
     */ setVerticesBuffer(buffer, totalVertices = null, disposeExistingBuffer = true) {
        const kind = buffer.getKind();
        if (this._vertexBuffers[kind] && disposeExistingBuffer) {
            this._vertexBuffers[kind].dispose();
        }
        if (buffer._buffer && buffer._ownsBuffer) {
            buffer._buffer._increaseReferences();
        }
        this._vertexBuffers[kind] = buffer;
        const meshes = this._meshes;
        const numOfMeshes = meshes.length;
        if (kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind) {
            this._totalVertices = totalVertices ?? buffer._maxVerticesCount;
            this._updateExtend(this.useBoundingInfoFromGeometry && this._boundingInfo ? null : buffer.getFloatData(this._totalVertices));
            this._resetPointsArrayCache();
            // this._extend can be empty if buffer.getFloatData(this._totalVertices) returned null
            const minimum = this._extend && this._extend.minimum || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            const maximum = this._extend && this._extend.maximum || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
            for(let index = 0; index < numOfMeshes; index++){
                const mesh = meshes[index];
                mesh.buildBoundingInfo(minimum, maximum);
                mesh._createGlobalSubMesh(mesh.isUnIndexed);
                mesh.computeWorldMatrix(true);
                mesh.synchronizeInstances();
            }
        }
        this._notifyUpdate(kind);
    }
    /**
     * Update a specific vertex buffer
     * This function will directly update the underlying DataBuffer according to the passed numeric array or Float32Array
     * It will do nothing if the buffer is not updatable
     * @param kind defines the data kind (Position, normal, etc...)
     * @param data defines the data to use
     * @param offset defines the offset in the target buffer where to store the data
     * @param useBytes set to true if the offset is in bytes
     */ updateVerticesDataDirectly(kind, data, offset, useBytes = false) {
        const vertexBuffer = this.getVertexBuffer(kind);
        if (!vertexBuffer) {
            return;
        }
        vertexBuffer.updateDirectly(data, offset, useBytes);
        this._notifyUpdate(kind);
    }
    /**
     * Update a specific vertex buffer
     * This function will create a new buffer if the current one is not updatable
     * @param kind defines the data kind (Position, normal, etc...)
     * @param data defines the data to use
     * @param updateExtends defines if the geometry extends must be recomputed (false by default)
     */ updateVerticesData(kind, data, updateExtends = false) {
        const vertexBuffer = this.getVertexBuffer(kind);
        if (!vertexBuffer) {
            return;
        }
        vertexBuffer.update(data);
        if (kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind) {
            this._updateBoundingInfo(updateExtends, data);
        }
        this._notifyUpdate(kind);
    }
    _updateBoundingInfo(updateExtends, data) {
        if (updateExtends) {
            this._updateExtend(data);
        }
        this._resetPointsArrayCache();
        if (updateExtends) {
            const meshes = this._meshes;
            for (const mesh of meshes){
                if (mesh.hasBoundingInfo) {
                    mesh.getBoundingInfo().reConstruct(this._extend.minimum, this._extend.maximum);
                } else {
                    mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);
                }
                const subMeshes = mesh.subMeshes;
                for (const subMesh of subMeshes){
                    subMesh.refreshBoundingInfo();
                }
            }
        }
    }
    /**
     * @internal
     */ _bind(effect, indexToBind, overrideVertexBuffers, overrideVertexArrayObjects) {
        if (!effect) {
            return;
        }
        if (indexToBind === undefined) {
            indexToBind = this._indexBuffer;
        }
        const vbs = this.getVertexBuffers();
        if (!vbs) {
            return;
        }
        if (indexToBind != this._indexBuffer || !this._vertexArrayObjects && !overrideVertexArrayObjects) {
            this._engine.bindBuffers(vbs, indexToBind, effect, overrideVertexBuffers);
            return;
        }
        const vaos = overrideVertexArrayObjects ? overrideVertexArrayObjects : this._vertexArrayObjects;
        const engine = this._engine;
        // Using VAO
        if (!vaos[effect.key]) {
            vaos[effect.key] = engine.recordVertexArrayObject(vbs, indexToBind, effect, overrideVertexBuffers);
        }
        engine.bindVertexArrayObject(vaos[effect.key], indexToBind);
    }
    /**
     * Gets total number of vertices
     * @returns the total number of vertices
     */ getTotalVertices() {
        if (!this.isReady()) {
            return 0;
        }
        return this._totalVertices;
    }
    /**
     * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.
     * @param kind defines the data kind (Position, normal, etc...)
     * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes
     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it
     * @returns a float array containing vertex data
     */ getVerticesData(kind, copyWhenShared, forceCopy) {
        const vertexBuffer = this.getVertexBuffer(kind);
        if (!vertexBuffer) {
            return null;
        }
        return vertexBuffer.getFloatData(this._totalVertices, forceCopy || copyWhenShared && this._meshes.length !== 1);
    }
    /**
     * Copies the requested vertex data kind into the given vertex data map. Float data is constructed if the map doesn't have the data.
     * @param kind defines the data kind (Position, normal, etc...)
     * @param vertexData defines the map that stores the resulting data
     */ copyVerticesData(kind, vertexData) {
        const vertexBuffer = this.getVertexBuffer(kind);
        if (!vertexBuffer) {
            return;
        }
        vertexData[kind] || (vertexData[kind] = new Float32Array(this._totalVertices * vertexBuffer.getSize()));
        const data = vertexBuffer.getData();
        if (data) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$bufferUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CopyFloatData"])(data, vertexBuffer.getSize(), vertexBuffer.type, vertexBuffer.byteOffset, vertexBuffer.byteStride, vertexBuffer.normalized, this._totalVertices, vertexData[kind]);
        }
    }
    /**
     * Returns a boolean defining if the vertex data for the requested `kind` is updatable
     * @param kind defines the data kind (Position, normal, etc...)
     * @returns true if the vertex buffer with the specified kind is updatable
     */ isVertexBufferUpdatable(kind) {
        const vb = this._vertexBuffers[kind];
        if (!vb) {
            return false;
        }
        return vb.isUpdatable();
    }
    /**
     * Gets a specific vertex buffer
     * @param kind defines the data kind (Position, normal, etc...)
     * @returns a VertexBuffer
     */ getVertexBuffer(kind) {
        if (!this.isReady()) {
            return null;
        }
        return this._vertexBuffers[kind];
    }
    /**
     * Returns all vertex buffers
     * @returns an object holding all vertex buffers indexed by kind
     */ getVertexBuffers() {
        if (!this.isReady()) {
            return null;
        }
        return this._vertexBuffers;
    }
    /**
     * Gets a boolean indicating if specific vertex buffer is present
     * @param kind defines the data kind (Position, normal, etc...)
     * @returns true if data is present
     */ isVerticesDataPresent(kind) {
        if (!this._vertexBuffers) {
            if (this._delayInfo) {
                return this._delayInfo.indexOf(kind) !== -1;
            }
            return false;
        }
        return this._vertexBuffers[kind] !== undefined;
    }
    /**
     * Gets a list of all attached data kinds (Position, normal, etc...)
     * @returns a list of string containing all kinds
     */ getVerticesDataKinds() {
        const result = [];
        let kind;
        if (!this._vertexBuffers && this._delayInfo) {
            for(kind in this._delayInfo){
                result.push(kind);
            }
        } else {
            for(kind in this._vertexBuffers){
                result.push(kind);
            }
        }
        return result;
    }
    /**
     * Update index buffer
     * @param indices defines the indices to store in the index buffer
     * @param offset defines the offset in the target buffer where to store the data
     * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)
     */ updateIndices(indices, offset, gpuMemoryOnly = false) {
        if (!this._indexBuffer) {
            return;
        }
        if (!this._indexBufferIsUpdatable) {
            this.setIndices(indices, null, true);
        } else {
            const needToUpdateSubMeshes = indices.length !== this._indices.length;
            if (!gpuMemoryOnly) {
                this._indices = indices.slice();
            }
            this._engine.updateDynamicIndexBuffer(this._indexBuffer, indices, offset);
            if (needToUpdateSubMeshes) {
                for (const mesh of this._meshes){
                    mesh._createGlobalSubMesh(true);
                }
            }
        }
    }
    /**
     * Sets the index buffer for this geometry.
     * @param indexBuffer Defines the index buffer to use for this geometry
     * @param totalVertices Defines the total number of vertices used by the buffer
     * @param totalIndices Defines the total number of indices in the index buffer
     * @param is32Bits Defines if the indices are 32 bits. If null (default), the value is guessed from the number of vertices
     */ setIndexBuffer(indexBuffer, totalVertices, totalIndices, is32Bits = null) {
        this._indices = [];
        this._indexBufferIsUpdatable = false;
        this._indexBuffer = indexBuffer;
        this._totalVertices = totalVertices;
        this._totalIndices = totalIndices;
        if (is32Bits === null) {
            indexBuffer.is32Bits = totalVertices > 65535;
        } else {
            indexBuffer.is32Bits = is32Bits;
        }
        for (const mesh of this._meshes){
            mesh._createGlobalSubMesh(true);
            mesh.synchronizeInstances();
        }
        this._notifyUpdate();
    }
    /**
     * Creates a new index buffer
     * @param indices defines the indices to store in the index buffer
     * @param totalVertices defines the total number of vertices (could be null)
     * @param updatable defines if the index buffer must be flagged as updatable (false by default)
     * @param dontForceSubMeshRecreation defines a boolean indicating that we don't want to force the recreation of sub-meshes if we don't have to (false by default)
     */ setIndices(indices, totalVertices = null, updatable = false, dontForceSubMeshRecreation = false) {
        if (this._indexBuffer) {
            this._engine._releaseBuffer(this._indexBuffer);
        }
        this._indices = indices;
        this._indexBufferIsUpdatable = updatable;
        if (this._meshes.length !== 0 && this._indices) {
            this._indexBuffer = this._engine.createIndexBuffer(this._indices, updatable, "Geometry_" + this.id + "_IndexBuffer");
        }
        if (totalVertices != undefined) {
            // including null and undefined
            this._totalVertices = totalVertices;
        }
        for (const mesh of this._meshes){
            mesh._createGlobalSubMesh(!dontForceSubMeshRecreation);
            mesh.synchronizeInstances();
        }
        this._notifyUpdate();
    }
    /**
     * Return the total number of indices
     * @returns the total number of indices
     */ getTotalIndices() {
        if (!this.isReady()) {
            return 0;
        }
        return this._totalIndices !== undefined ? this._totalIndices : this._indices.length;
    }
    /**
     * Gets the index buffer array
     * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes
     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it
     * @returns the index buffer array
     */ getIndices(copyWhenShared, forceCopy) {
        if (!this.isReady()) {
            return null;
        }
        const orig = this._indices;
        if (!forceCopy && (!copyWhenShared || this._meshes.length === 1)) {
            return orig;
        } else {
            return orig.slice();
        }
    }
    /**
     * Gets the index buffer
     * @returns the index buffer
     */ getIndexBuffer() {
        if (!this.isReady()) {
            return null;
        }
        return this._indexBuffer;
    }
    /**
     * @internal
     */ _releaseVertexArrayObject(effect = null) {
        if (!effect || !this._vertexArrayObjects) {
            return;
        }
        if (this._vertexArrayObjects[effect.key]) {
            this._engine.releaseVertexArrayObject(this._vertexArrayObjects[effect.key]);
            delete this._vertexArrayObjects[effect.key];
        }
    }
    /**
     * Release the associated resources for a specific mesh
     * @param mesh defines the source mesh
     * @param shouldDispose defines if the geometry must be disposed if there is no more mesh pointing to it
     */ releaseForMesh(mesh, shouldDispose) {
        const meshes = this._meshes;
        const index = meshes.indexOf(mesh);
        if (index === -1) {
            return;
        }
        meshes.splice(index, 1);
        if (this._vertexArrayObjects) {
            mesh._invalidateInstanceVertexArrayObject();
        }
        mesh._geometry = null;
        if (meshes.length === 0 && shouldDispose) {
            this.dispose();
        }
    }
    /**
     * Apply current geometry to a given mesh
     * @param mesh defines the mesh to apply geometry to
     */ applyToMesh(mesh) {
        if (mesh._geometry === this) {
            return;
        }
        const previousGeometry = mesh._geometry;
        if (previousGeometry) {
            previousGeometry.releaseForMesh(mesh);
        }
        if (this._vertexArrayObjects) {
            mesh._invalidateInstanceVertexArrayObject();
        }
        const meshes = this._meshes;
        // must be done before setting vertexBuffers because of mesh._createGlobalSubMesh()
        mesh._geometry = this;
        mesh._internalAbstractMeshDataInfo._positions = null;
        this._scene.pushGeometry(this);
        meshes.push(mesh);
        if (this.isReady()) {
            this._applyToMesh(mesh);
        } else if (this._boundingInfo) {
            mesh.setBoundingInfo(this._boundingInfo);
        }
    }
    _updateExtend(data = null) {
        if (this.useBoundingInfoFromGeometry && this._boundingInfo) {
            this._extend = {
                minimum: this._boundingInfo.minimum.clone(),
                maximum: this._boundingInfo.maximum.clone()
            };
        } else {
            if (!data) {
                data = this.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind);
                // This can happen if the buffer comes from a Hardware Buffer where
                // The data have not been uploaded by Babylon. (ex: Compute Shaders and Storage Buffers)
                if (!data) {
                    return;
                }
            }
            this._extend = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["extractMinAndMax"])(data, 0, this._totalVertices, this.boundingBias, 3);
        }
    }
    _applyToMesh(mesh) {
        // vertexBuffers
        for(const kind in this._vertexBuffers){
            const vertexBuffer = this._vertexBuffers[kind];
            if (!vertexBuffer._buffer.getBuffer()) {
                vertexBuffer.create();
            }
            if (kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind) {
                if (!this._extend) {
                    this._updateExtend();
                }
                mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);
                mesh._createGlobalSubMesh(mesh.isUnIndexed);
                //bounding info was just created again, world matrix should be applied again.
                mesh._updateBoundingInfo();
            }
        }
        // indexBuffer
        if (!this._indexBuffer && this._indices && this._indices.length > 0) {
            this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable, "Geometry_" + this.id + "_IndexBuffer");
        }
        // morphTargets
        mesh._syncGeometryWithMorphTargetManager();
        // instances
        mesh.synchronizeInstances();
    }
    _notifyUpdate(kind) {
        if (this.onGeometryUpdated) {
            this.onGeometryUpdated(this, kind);
        }
        if (this._vertexArrayObjects) {
            this._disposeVertexArrayObjects();
        }
        for (const mesh of this._meshes){
            mesh._markSubMeshesAsAttributesDirty();
        }
    }
    /**
     * Load the geometry if it was flagged as delay loaded
     * @param scene defines the hosting scene
     * @param onLoaded defines a callback called when the geometry is loaded
     */ load(scene, onLoaded) {
        if (this.delayLoadState === 2) {
            return;
        }
        if (this.isReady()) {
            if (onLoaded) {
                onLoaded();
            }
            return;
        }
        this.delayLoadState = 2;
        this._queueLoad(scene, onLoaded);
    }
    _queueLoad(scene, onLoaded) {
        if (!this.delayLoadingFile) {
            return;
        }
        scene.addPendingData(this);
        scene._loadFile(this.delayLoadingFile, (data)=>{
            if (!this._delayLoadingFunction) {
                return;
            }
            this._delayLoadingFunction(JSON.parse(data), this);
            this.delayLoadState = 1;
            this._delayInfo = [];
            scene.removePendingData(this);
            const meshes = this._meshes;
            const numOfMeshes = meshes.length;
            for(let index = 0; index < numOfMeshes; index++){
                this._applyToMesh(meshes[index]);
            }
            if (onLoaded) {
                onLoaded();
            }
        }, undefined, true);
    }
    /**
     * Invert the geometry to move from a right handed system to a left handed one.
     */ toLeftHanded() {
        // Flip faces
        const tIndices = this.getIndices(false);
        if (tIndices != null && tIndices.length > 0) {
            for(let i = 0; i < tIndices.length; i += 3){
                const tTemp = tIndices[i + 0];
                tIndices[i + 0] = tIndices[i + 2];
                tIndices[i + 2] = tTemp;
            }
            this.setIndices(tIndices);
        }
        // Negate position.z
        const tPositions = this.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind, false);
        if (tPositions != null && tPositions.length > 0) {
            for(let i = 0; i < tPositions.length; i += 3){
                tPositions[i + 2] = -tPositions[i + 2];
            }
            this.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind, tPositions, false);
        }
        // Negate normal.z
        const tNormals = this.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].NormalKind, false);
        if (tNormals != null && tNormals.length > 0) {
            for(let i = 0; i < tNormals.length; i += 3){
                tNormals[i + 2] = -tNormals[i + 2];
            }
            this.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].NormalKind, tNormals, false);
        }
    }
    // Cache
    /** @internal */ _resetPointsArrayCache() {
        this._positions = null;
    }
    /** @internal */ _generatePointsArray() {
        if (this._positions) {
            return true;
        }
        const data = this.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind);
        if (!data || data.length === 0) {
            return false;
        }
        for(let index = this._positionsCache.length * 3, arrayIdx = this._positionsCache.length; index < data.length; index += 3, ++arrayIdx){
            this._positionsCache[arrayIdx] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].FromArray(data, index);
        }
        for(let index = 0, arrayIdx = 0; index < data.length; index += 3, ++arrayIdx){
            this._positionsCache[arrayIdx].set(data[0 + index], data[1 + index], data[2 + index]);
        }
        // just in case the number of positions was reduced, splice the array
        this._positionsCache.length = data.length / 3;
        this._positions = this._positionsCache;
        return true;
    }
    /**
     * Gets a value indicating if the geometry is disposed
     * @returns true if the geometry was disposed
     */ isDisposed() {
        return this._isDisposed;
    }
    _disposeVertexArrayObjects() {
        if (this._vertexArrayObjects) {
            for(const kind in this._vertexArrayObjects){
                this._engine.releaseVertexArrayObject(this._vertexArrayObjects[kind]);
            }
            this._vertexArrayObjects = {}; // Will trigger a rebuild of the VAO if supported
            const meshes = this._meshes;
            const numOfMeshes = meshes.length;
            for(let index = 0; index < numOfMeshes; index++){
                meshes[index]._invalidateInstanceVertexArrayObject();
            }
        }
    }
    /**
     * Free all associated resources
     */ dispose() {
        const meshes = this._meshes;
        const numOfMeshes = meshes.length;
        let index;
        for(index = 0; index < numOfMeshes; index++){
            this.releaseForMesh(meshes[index]);
        }
        this._meshes.length = 0;
        this._disposeVertexArrayObjects();
        for(const kind in this._vertexBuffers){
            this._vertexBuffers[kind].dispose();
        }
        this._vertexBuffers = {};
        this._totalVertices = 0;
        if (this._indexBuffer) {
            this._engine._releaseBuffer(this._indexBuffer);
        }
        this._indexBuffer = null;
        this._indices = [];
        this.delayLoadState = 0;
        this.delayLoadingFile = null;
        this._delayLoadingFunction = null;
        this._delayInfo = [];
        this._boundingInfo = null;
        this._scene.removeGeometry(this);
        if (this._parentContainer) {
            const index = this._parentContainer.geometries.indexOf(this);
            if (index > -1) {
                this._parentContainer.geometries.splice(index, 1);
            }
            this._parentContainer = null;
        }
        this._isDisposed = true;
    }
    /**
     * Clone the current geometry into a new geometry
     * @param id defines the unique ID of the new geometry
     * @returns a new geometry object
     */ copy(id) {
        const geometry = new Geometry(id, this._scene);
        const indices = this.getIndices(undefined, true);
        if (indices) {
            geometry.setIndices(indices);
        }
        let updatable = false;
        let kind;
        for(kind in this._vertexBuffers){
            const vb = this.getVertexBuffer(kind);
            const bufferData = vb.getData();
            if (!bufferData) {
                continue;
            }
            const isUpdatable = vb.isUpdatable();
            const size = vb.getSize();
            const { type, byteOffset, byteStride, normalized } = vb;
            updatable = updatable || isUpdatable;
            const copy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$bufferUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GetTypedArrayData"])(bufferData, size, type, byteOffset, byteStride, this._totalVertices, true);
            const newVb = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"](this._engine, copy, kind, {
                updatable: isUpdatable,
                useBytes: false,
                stride: size,
                size: size,
                offset: 0,
                type: type,
                normalized: normalized,
                takeBufferOwnership: true
            });
            geometry.setVerticesBuffer(newVb, this._totalVertices);
        }
        geometry._updatable = updatable;
        geometry.delayLoadState = this.delayLoadState;
        geometry.delayLoadingFile = this.delayLoadingFile;
        geometry._delayLoadingFunction = this._delayLoadingFunction;
        for(kind in this._delayInfo){
            geometry._delayInfo = geometry._delayInfo || [];
            geometry._delayInfo.push(kind);
        }
        // Bounding info
        geometry._boundingInfo = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Culling$2f$boundingInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BoundingInfo"](this._extend.minimum, this._extend.maximum);
        return geometry;
    }
    /**
     * Serialize the current geometry info (and not the vertices data) into a JSON object
     * @returns a JSON representation of the current geometry data (without the vertices data)
     */ serialize() {
        const serializationObject = {};
        serializationObject.id = this.id;
        serializationObject.uniqueId = this.uniqueId;
        serializationObject.updatable = this._updatable;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tags$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tags"] && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tags$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tags"].HasTags(this)) {
            serializationObject.tags = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tags$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tags"].GetTags(this);
        }
        return serializationObject;
    }
    _toNumberArray(origin) {
        if (Array.isArray(origin)) {
            return origin;
        } else {
            return Array.prototype.slice.call(origin);
        }
    }
    /**
     * Release any memory retained by the cached data on the Geometry.
     *
     * Call this function to reduce memory footprint of the mesh.
     * Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)
     */ clearCachedData() {
        this._indices = [];
        this._resetPointsArrayCache();
        for(const vbName in this._vertexBuffers){
            if (!Object.prototype.hasOwnProperty.call(this._vertexBuffers, vbName)) {
                continue;
            }
            this._vertexBuffers[vbName]._buffer._data = null;
        }
    }
    /**
     * Serialize all vertices data into a JSON object
     * @returns a JSON representation of the current geometry data
     */ serializeVerticeData() {
        const serializationObject = this.serialize();
        if (this.isVerticesDataPresent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind)) {
            serializationObject.positions = this._toNumberArray(this.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind));
            if (this.isVertexBufferUpdatable(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind)) {
                serializationObject.positionsUpdatable = true;
            }
        }
        if (this.isVerticesDataPresent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].NormalKind)) {
            serializationObject.normals = this._toNumberArray(this.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].NormalKind));
            if (this.isVertexBufferUpdatable(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].NormalKind)) {
                serializationObject.normalsUpdatable = true;
            }
        }
        if (this.isVerticesDataPresent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].TangentKind)) {
            serializationObject.tangents = this._toNumberArray(this.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].TangentKind));
            if (this.isVertexBufferUpdatable(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].TangentKind)) {
                serializationObject.tangentsUpdatable = true;
            }
        }
        if (this.isVerticesDataPresent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UVKind)) {
            serializationObject.uvs = this._toNumberArray(this.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UVKind));
            if (this.isVertexBufferUpdatable(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UVKind)) {
                serializationObject.uvsUpdatable = true;
            }
        }
        if (this.isVerticesDataPresent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV2Kind)) {
            serializationObject.uvs2 = this._toNumberArray(this.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV2Kind));
            if (this.isVertexBufferUpdatable(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV2Kind)) {
                serializationObject.uvs2Updatable = true;
            }
        }
        if (this.isVerticesDataPresent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV3Kind)) {
            serializationObject.uvs3 = this._toNumberArray(this.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV3Kind));
            if (this.isVertexBufferUpdatable(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV3Kind)) {
                serializationObject.uvs3Updatable = true;
            }
        }
        if (this.isVerticesDataPresent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV4Kind)) {
            serializationObject.uvs4 = this._toNumberArray(this.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV4Kind));
            if (this.isVertexBufferUpdatable(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV4Kind)) {
                serializationObject.uvs4Updatable = true;
            }
        }
        if (this.isVerticesDataPresent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV5Kind)) {
            serializationObject.uvs5 = this._toNumberArray(this.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV5Kind));
            if (this.isVertexBufferUpdatable(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV5Kind)) {
                serializationObject.uvs5Updatable = true;
            }
        }
        if (this.isVerticesDataPresent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV6Kind)) {
            serializationObject.uvs6 = this._toNumberArray(this.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV6Kind));
            if (this.isVertexBufferUpdatable(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV6Kind)) {
                serializationObject.uvs6Updatable = true;
            }
        }
        if (this.isVerticesDataPresent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorKind)) {
            serializationObject.colors = this._toNumberArray(this.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorKind));
            if (this.isVertexBufferUpdatable(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorKind)) {
                serializationObject.colorsUpdatable = true;
            }
        }
        if (this.isVerticesDataPresent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesIndicesKind)) {
            serializationObject.matricesIndices = this._toNumberArray(this.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesIndicesKind));
            serializationObject.matricesIndicesExpanded = true;
            if (this.isVertexBufferUpdatable(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesIndicesKind)) {
                serializationObject.matricesIndicesUpdatable = true;
            }
        }
        if (this.isVerticesDataPresent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesWeightsKind)) {
            serializationObject.matricesWeights = this._toNumberArray(this.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesWeightsKind));
            if (this.isVertexBufferUpdatable(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesWeightsKind)) {
                serializationObject.matricesWeightsUpdatable = true;
            }
        }
        serializationObject.indices = this._toNumberArray(this.getIndices());
        return serializationObject;
    }
    // Statics
    /**
     * Extracts a clone of a mesh geometry
     * @param mesh defines the source mesh
     * @param id defines the unique ID of the new geometry object
     * @returns the new geometry object
     */ static ExtractFromMesh(mesh, id) {
        const geometry = mesh._geometry;
        if (!geometry) {
            return null;
        }
        return geometry.copy(id);
    }
    /**
     * You should now use Tools.RandomId(), this method is still here for legacy reasons.
     * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523
     * Be aware Math.random() could cause collisions, but:
     * "All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide"
     * @returns a string containing a new GUID
     */ static RandomId() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tools"].RandomId();
    }
    static _GetGeometryByLoadedUniqueId(uniqueId, scene) {
        for(let index = 0; index < scene.geometries.length; index++){
            if (scene.geometries[index]._loadedUniqueId === uniqueId) {
                return scene.geometries[index];
            }
        }
        return null;
    }
    /**
     * @internal
     */ static _ImportGeometry(parsedGeometry, mesh) {
        const scene = mesh.getScene();
        // Geometry
        const geometryUniqueId = parsedGeometry.geometryUniqueId;
        const geometryId = parsedGeometry.geometryId;
        if (geometryUniqueId || geometryId) {
            const geometry = geometryUniqueId ? this._GetGeometryByLoadedUniqueId(geometryUniqueId, scene) : scene.getGeometryById(geometryId);
            if (geometry) {
                geometry.applyToMesh(mesh);
            }
        } else if (parsedGeometry instanceof ArrayBuffer) {
            const binaryInfo = mesh._binaryInfo;
            if (binaryInfo.positionsAttrDesc && binaryInfo.positionsAttrDesc.count > 0) {
                const positionsData = new Float32Array(parsedGeometry, binaryInfo.positionsAttrDesc.offset, binaryInfo.positionsAttrDesc.count);
                mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind, positionsData, false);
            }
            if (binaryInfo.normalsAttrDesc && binaryInfo.normalsAttrDesc.count > 0) {
                const normalsData = new Float32Array(parsedGeometry, binaryInfo.normalsAttrDesc.offset, binaryInfo.normalsAttrDesc.count);
                mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].NormalKind, normalsData, false);
            }
            if (binaryInfo.tangetsAttrDesc && binaryInfo.tangetsAttrDesc.count > 0) {
                const tangentsData = new Float32Array(parsedGeometry, binaryInfo.tangetsAttrDesc.offset, binaryInfo.tangetsAttrDesc.count);
                mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].TangentKind, tangentsData, false);
            }
            if (binaryInfo.uvsAttrDesc && binaryInfo.uvsAttrDesc.count > 0) {
                const uvsData = new Float32Array(parsedGeometry, binaryInfo.uvsAttrDesc.offset, binaryInfo.uvsAttrDesc.count);
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Compat$2f$compatibilityOptions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useOpenGLOrientationForUV"]) {
                    for(let index = 1; index < uvsData.length; index += 2){
                        uvsData[index] = 1 - uvsData[index];
                    }
                }
                mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UVKind, uvsData, false);
            }
            if (binaryInfo.uvs2AttrDesc && binaryInfo.uvs2AttrDesc.count > 0) {
                const uvs2Data = new Float32Array(parsedGeometry, binaryInfo.uvs2AttrDesc.offset, binaryInfo.uvs2AttrDesc.count);
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Compat$2f$compatibilityOptions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useOpenGLOrientationForUV"]) {
                    for(let index = 1; index < uvs2Data.length; index += 2){
                        uvs2Data[index] = 1 - uvs2Data[index];
                    }
                }
                mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV2Kind, uvs2Data, false);
            }
            if (binaryInfo.uvs3AttrDesc && binaryInfo.uvs3AttrDesc.count > 0) {
                const uvs3Data = new Float32Array(parsedGeometry, binaryInfo.uvs3AttrDesc.offset, binaryInfo.uvs3AttrDesc.count);
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Compat$2f$compatibilityOptions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useOpenGLOrientationForUV"]) {
                    for(let index = 1; index < uvs3Data.length; index += 2){
                        uvs3Data[index] = 1 - uvs3Data[index];
                    }
                }
                mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV3Kind, uvs3Data, false);
            }
            if (binaryInfo.uvs4AttrDesc && binaryInfo.uvs4AttrDesc.count > 0) {
                const uvs4Data = new Float32Array(parsedGeometry, binaryInfo.uvs4AttrDesc.offset, binaryInfo.uvs4AttrDesc.count);
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Compat$2f$compatibilityOptions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useOpenGLOrientationForUV"]) {
                    for(let index = 1; index < uvs4Data.length; index += 2){
                        uvs4Data[index] = 1 - uvs4Data[index];
                    }
                }
                mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV4Kind, uvs4Data, false);
            }
            if (binaryInfo.uvs5AttrDesc && binaryInfo.uvs5AttrDesc.count > 0) {
                const uvs5Data = new Float32Array(parsedGeometry, binaryInfo.uvs5AttrDesc.offset, binaryInfo.uvs5AttrDesc.count);
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Compat$2f$compatibilityOptions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useOpenGLOrientationForUV"]) {
                    for(let index = 1; index < uvs5Data.length; index += 2){
                        uvs5Data[index] = 1 - uvs5Data[index];
                    }
                }
                mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV5Kind, uvs5Data, false);
            }
            if (binaryInfo.uvs6AttrDesc && binaryInfo.uvs6AttrDesc.count > 0) {
                const uvs6Data = new Float32Array(parsedGeometry, binaryInfo.uvs6AttrDesc.offset, binaryInfo.uvs6AttrDesc.count);
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Compat$2f$compatibilityOptions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useOpenGLOrientationForUV"]) {
                    for(let index = 1; index < uvs6Data.length; index += 2){
                        uvs6Data[index] = 1 - uvs6Data[index];
                    }
                }
                mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV6Kind, uvs6Data, false);
            }
            if (binaryInfo.colorsAttrDesc && binaryInfo.colorsAttrDesc.count > 0) {
                const colorsData = new Float32Array(parsedGeometry, binaryInfo.colorsAttrDesc.offset, binaryInfo.colorsAttrDesc.count);
                mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorKind, colorsData, false, binaryInfo.colorsAttrDesc.stride);
            }
            if (binaryInfo.matricesIndicesAttrDesc && binaryInfo.matricesIndicesAttrDesc.count > 0) {
                const matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesAttrDesc.offset, binaryInfo.matricesIndicesAttrDesc.count);
                const floatIndices = [];
                for(let i = 0; i < matricesIndicesData.length; i++){
                    const index = matricesIndicesData[i];
                    floatIndices.push(index & 0x000000ff);
                    floatIndices.push((index & 0x0000ff00) >> 8);
                    floatIndices.push((index & 0x00ff0000) >> 16);
                    floatIndices.push(index >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0
                }
                mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesIndicesKind, floatIndices, false);
            }
            if (binaryInfo.matricesIndicesExtraAttrDesc && binaryInfo.matricesIndicesExtraAttrDesc.count > 0) {
                const matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesExtraAttrDesc.offset, binaryInfo.matricesIndicesExtraAttrDesc.count);
                const floatIndices = [];
                for(let i = 0; i < matricesIndicesData.length; i++){
                    const index = matricesIndicesData[i];
                    floatIndices.push(index & 0x000000ff);
                    floatIndices.push((index & 0x0000ff00) >> 8);
                    floatIndices.push((index & 0x00ff0000) >> 16);
                    floatIndices.push(index >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0
                }
                mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesIndicesExtraKind, floatIndices, false);
            }
            if (binaryInfo.matricesWeightsAttrDesc && binaryInfo.matricesWeightsAttrDesc.count > 0) {
                const matricesWeightsData = new Float32Array(parsedGeometry, binaryInfo.matricesWeightsAttrDesc.offset, binaryInfo.matricesWeightsAttrDesc.count);
                mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesWeightsKind, matricesWeightsData, false);
            }
            if (binaryInfo.indicesAttrDesc && binaryInfo.indicesAttrDesc.count > 0) {
                const indicesData = new Int32Array(parsedGeometry, binaryInfo.indicesAttrDesc.offset, binaryInfo.indicesAttrDesc.count);
                mesh.setIndices(indicesData, null);
            }
            if (binaryInfo.subMeshesAttrDesc && binaryInfo.subMeshesAttrDesc.count > 0) {
                const subMeshesData = new Int32Array(parsedGeometry, binaryInfo.subMeshesAttrDesc.offset, binaryInfo.subMeshesAttrDesc.count * 5);
                mesh.subMeshes = [];
                for(let i = 0; i < binaryInfo.subMeshesAttrDesc.count; i++){
                    const materialIndex = subMeshesData[i * 5 + 0];
                    const verticesStart = subMeshesData[i * 5 + 1];
                    const verticesCount = subMeshesData[i * 5 + 2];
                    const indexStart = subMeshesData[i * 5 + 3];
                    const indexCount = subMeshesData[i * 5 + 4];
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$subMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SubMesh"].AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh);
                }
            }
        } else if (parsedGeometry.positions && parsedGeometry.normals && parsedGeometry.indices) {
            mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind, parsedGeometry.positions, parsedGeometry.positions._updatable || parsedGeometry.positionsUpdatable);
            mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].NormalKind, parsedGeometry.normals, parsedGeometry.normals._updatable || parsedGeometry.normalsUpdatable);
            if (parsedGeometry.tangents) {
                mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].TangentKind, parsedGeometry.tangents, parsedGeometry.tangents._updatable || parsedGeometry.tangentsUpdatable);
            }
            if (parsedGeometry.uvs) {
                mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UVKind, parsedGeometry.uvs, parsedGeometry.uvs._updatable || parsedGeometry.uvsUpdatable);
            }
            if (parsedGeometry.uvs2) {
                mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV2Kind, parsedGeometry.uvs2, parsedGeometry.uvs2._updatable || parsedGeometry.uvs2Updatable);
            }
            if (parsedGeometry.uvs3) {
                mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV3Kind, parsedGeometry.uvs3, parsedGeometry.uvs3._updatable || parsedGeometry.uvs3Updatable);
            }
            if (parsedGeometry.uvs4) {
                mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV4Kind, parsedGeometry.uvs4, parsedGeometry.uvs4._updatable || parsedGeometry.uvs4Updatable);
            }
            if (parsedGeometry.uvs5) {
                mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV5Kind, parsedGeometry.uvs5, parsedGeometry.uvs5._updatable || parsedGeometry.uvs5Updatable);
            }
            if (parsedGeometry.uvs6) {
                mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV6Kind, parsedGeometry.uvs6, parsedGeometry.uvs6._updatable || parsedGeometry.uvs6Updatable);
            }
            if (parsedGeometry.colors) {
                mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorKind, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color4"].CheckColors4(parsedGeometry.colors, parsedGeometry.positions.length / 3), parsedGeometry.colors._updatable);
            }
            if (parsedGeometry.matricesIndices) {
                if (!parsedGeometry.matricesIndices._isExpanded && !parsedGeometry.matricesIndicesExpanded) {
                    const floatIndices = [];
                    for(let i = 0; i < parsedGeometry.matricesIndices.length; i++){
                        const matricesIndex = parsedGeometry.matricesIndices[i];
                        floatIndices.push(matricesIndex & 0x000000ff);
                        floatIndices.push((matricesIndex & 0x0000ff00) >> 8);
                        floatIndices.push((matricesIndex & 0x00ff0000) >> 16);
                        floatIndices.push(matricesIndex >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0
                    }
                    mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesIndicesKind, floatIndices, parsedGeometry.matricesIndices._updatable || parsedGeometry.matricesIndicesUpdatable);
                } else {
                    delete parsedGeometry.matricesIndices._isExpanded;
                    delete parsedGeometry.matricesIndicesExpanded;
                    mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesIndicesKind, parsedGeometry.matricesIndices, parsedGeometry.matricesIndices._updatable || parsedGeometry.matricesIndicesUpdatable);
                }
            }
            if (parsedGeometry.matricesIndicesExtra) {
                if (!(parsedGeometry.matricesIndicesExtraExpanded || parsedGeometry.matricesIndicesExtra._isExpanded)) {
                    const floatIndices = [];
                    for(let i = 0; i < parsedGeometry.matricesIndicesExtra.length; i++){
                        const matricesIndex = parsedGeometry.matricesIndicesExtra[i];
                        floatIndices.push(matricesIndex & 0x000000ff);
                        floatIndices.push((matricesIndex & 0x0000ff00) >> 8);
                        floatIndices.push((matricesIndex & 0x00ff0000) >> 16);
                        floatIndices.push(matricesIndex >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0
                    }
                    mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesIndicesExtraKind, floatIndices, parsedGeometry.matricesIndicesExtra._updatable || parsedGeometry.matricesIndicesExtraUpdatable);
                } else {
                    delete parsedGeometry.matricesIndices._isExpanded;
                    delete parsedGeometry.matricesIndicesExtraExpanded;
                    mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesIndicesExtraKind, parsedGeometry.matricesIndicesExtra, parsedGeometry.matricesIndicesExtra._updatable || parsedGeometry.matricesIndicesExtraUpdatable);
                }
            }
            if (parsedGeometry.matricesWeights) {
                Geometry._CleanMatricesWeights(parsedGeometry, mesh);
                mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesWeightsKind, parsedGeometry.matricesWeights, parsedGeometry.matricesWeights._updatable);
            }
            if (parsedGeometry.matricesWeightsExtra) {
                mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesWeightsExtraKind, parsedGeometry.matricesWeightsExtra, parsedGeometry.matricesWeights._updatable);
            }
            mesh.setIndices(parsedGeometry.indices, null);
        }
        // SubMeshes
        if (parsedGeometry.subMeshes) {
            mesh.subMeshes = [];
            for(let subIndex = 0; subIndex < parsedGeometry.subMeshes.length; subIndex++){
                const parsedSubMesh = parsedGeometry.subMeshes[subIndex];
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$subMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SubMesh"].AddToMesh(parsedSubMesh.materialIndex, parsedSubMesh.verticesStart, parsedSubMesh.verticesCount, parsedSubMesh.indexStart, parsedSubMesh.indexCount, mesh);
            }
        }
        // Flat shading
        if (mesh._shouldGenerateFlatShading) {
            mesh.convertToFlatShadedMesh();
            mesh._shouldGenerateFlatShading = false;
        }
        // Update
        mesh.computeWorldMatrix(true);
        scene.onMeshImportedObservable.notifyObservers(mesh);
    }
    static _CleanMatricesWeights(parsedGeometry, mesh) {
        const epsilon = 1e-3;
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Loading$2f$sceneLoaderFlags$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SceneLoaderFlags"].CleanBoneMatrixWeights) {
            return;
        }
        let noInfluenceBoneIndex = 0.0;
        if (parsedGeometry.skeletonId > -1) {
            const skeleton = mesh.getScene().getLastSkeletonById(parsedGeometry.skeletonId);
            if (!skeleton) {
                return;
            }
            noInfluenceBoneIndex = skeleton.bones.length;
        } else {
            return;
        }
        const matricesIndices = mesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesIndicesKind);
        const matricesIndicesExtra = mesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesIndicesExtraKind);
        const matricesWeights = parsedGeometry.matricesWeights;
        const matricesWeightsExtra = parsedGeometry.matricesWeightsExtra;
        const influencers = parsedGeometry.numBoneInfluencer;
        const size = matricesWeights.length;
        for(let i = 0; i < size; i += 4){
            let weight = 0.0;
            let firstZeroWeight = -1;
            for(let j = 0; j < 4; j++){
                const w = matricesWeights[i + j];
                weight += w;
                if (w < epsilon && firstZeroWeight < 0) {
                    firstZeroWeight = j;
                }
            }
            if (matricesWeightsExtra) {
                for(let j = 0; j < 4; j++){
                    const w = matricesWeightsExtra[i + j];
                    weight += w;
                    if (w < epsilon && firstZeroWeight < 0) {
                        firstZeroWeight = j + 4;
                    }
                }
            }
            if (firstZeroWeight < 0 || firstZeroWeight > influencers - 1) {
                firstZeroWeight = influencers - 1;
            }
            if (weight > epsilon) {
                const mweight = 1.0 / weight;
                for(let j = 0; j < 4; j++){
                    matricesWeights[i + j] *= mweight;
                }
                if (matricesWeightsExtra) {
                    for(let j = 0; j < 4; j++){
                        matricesWeightsExtra[i + j] *= mweight;
                    }
                }
            } else {
                if (firstZeroWeight >= 4) {
                    matricesWeightsExtra[i + firstZeroWeight - 4] = 1.0 - weight;
                    matricesIndicesExtra[i + firstZeroWeight - 4] = noInfluenceBoneIndex;
                } else {
                    matricesWeights[i + firstZeroWeight] = 1.0 - weight;
                    matricesIndices[i + firstZeroWeight] = noInfluenceBoneIndex;
                }
            }
        }
        mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesIndicesKind, matricesIndices);
        if (parsedGeometry.matricesWeightsExtra) {
            mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesIndicesExtraKind, matricesIndicesExtra);
        }
    }
    /**
     * Create a new geometry from persisted data (Using .babylon file format)
     * @param parsedVertexData defines the persisted data
     * @param scene defines the hosting scene
     * @param rootUrl defines the root url to use to load assets (like delayed data)
     * @returns the new geometry object
     */ static Parse(parsedVertexData, scene, rootUrl) {
        const geometry = new Geometry(parsedVertexData.id, scene, undefined, parsedVertexData.updatable);
        geometry._loadedUniqueId = parsedVertexData.uniqueId;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tags$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tags"]) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tags$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tags"].AddTagsTo(geometry, parsedVertexData.tags);
        }
        if (parsedVertexData.delayLoadingFile) {
            geometry.delayLoadState = 4;
            geometry.delayLoadingFile = rootUrl + parsedVertexData.delayLoadingFile;
            geometry._boundingInfo = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Culling$2f$boundingInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BoundingInfo"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].FromArray(parsedVertexData.boundingBoxMinimum), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].FromArray(parsedVertexData.boundingBoxMaximum));
            geometry._delayInfo = [];
            if (parsedVertexData.hasUVs) {
                geometry._delayInfo.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UVKind);
            }
            if (parsedVertexData.hasUVs2) {
                geometry._delayInfo.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV2Kind);
            }
            if (parsedVertexData.hasUVs3) {
                geometry._delayInfo.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV3Kind);
            }
            if (parsedVertexData.hasUVs4) {
                geometry._delayInfo.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV4Kind);
            }
            if (parsedVertexData.hasUVs5) {
                geometry._delayInfo.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV5Kind);
            }
            if (parsedVertexData.hasUVs6) {
                geometry._delayInfo.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV6Kind);
            }
            if (parsedVertexData.hasColors) {
                geometry._delayInfo.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorKind);
            }
            if (parsedVertexData.hasMatricesIndices) {
                geometry._delayInfo.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesIndicesKind);
            }
            if (parsedVertexData.hasMatricesWeights) {
                geometry._delayInfo.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesWeightsKind);
            }
            geometry._delayLoadingFunction = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexData"].ImportVertexData;
        } else {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexData"].ImportVertexData(parsedVertexData, geometry);
        }
        scene.pushGeometry(geometry, true);
        return geometry;
    }
} //# sourceMappingURL=geometry.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/transformNode.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TransformNode",
    ()=>TransformNode
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$tslib$2e$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/tslib.es6.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/decorators.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$serialization$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/decorators.serialization.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/observable.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/node.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$typeStore$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/typeStore.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
class TransformNode extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"] {
    /**
     * Gets or sets the billboard mode. Default is 0.
     *
     * | Value | Type | Description |
     * | --- | --- | --- |
     * | 0 | BILLBOARDMODE_NONE |  |
     * | 1 | BILLBOARDMODE_X |  |
     * | 2 | BILLBOARDMODE_Y |  |
     * | 4 | BILLBOARDMODE_Z |  |
     * | 7 | BILLBOARDMODE_ALL |  |
     *
     */ get billboardMode() {
        return this._billboardMode;
    }
    set billboardMode(value) {
        if (this._billboardMode === value) {
            return;
        }
        this._billboardMode = value;
        this._cache.useBillboardPosition = (this._billboardMode & TransformNode.BILLBOARDMODE_USE_POSITION) !== 0;
    }
    /**
     * Gets or sets the distance of the object to max, often used by skybox
     */ get infiniteDistance() {
        return this._infiniteDistance;
    }
    set infiniteDistance(value) {
        if (this._infiniteDistance === value) {
            return;
        }
        this._infiniteDistance = value;
    }
    constructor(name, scene = null, isPure = true){
        super(name, scene, false);
        this._forward = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 0, 1);
        this._up = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 1, 0);
        this._right = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](1, 0, 0);
        // Properties
        this._position = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Zero();
        this._rotation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Zero();
        this._rotationQuaternion = null;
        this._scaling = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].One();
        this._transformToBoneReferal = null;
        this._isAbsoluteSynced = false;
        this._billboardMode = TransformNode.BILLBOARDMODE_NONE;
        /**
         * Multiplication factor on scale x/y/z when computing the world matrix. Eg. for a 1x1x1 cube setting this to 2 will make it a 2x2x2 cube
         */ this.scalingDeterminant = 1;
        this._infiniteDistance = false;
        /**
         * Gets or sets a boolean indicating that non uniform scaling (when at least one component is different from others) should be ignored.
         * By default the system will update normals to compensate
         */ this.ignoreNonUniformScaling = false;
        /**
         * Gets or sets a boolean indicating that even if rotationQuaternion is defined, you can keep updating rotation property and Babylon.js will just mix both
         */ this.reIntegrateRotationIntoRotationQuaternion = false;
        // Cache
        /** @internal */ this._poseMatrix = null;
        /** @internal */ this._localMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].Zero();
        this._usePivotMatrix = false;
        this._absolutePosition = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Zero();
        this._absoluteScaling = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Zero();
        this._absoluteRotationQuaternion = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"].Identity();
        this._pivotMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].Identity();
        /** @internal */ this._postMultiplyPivotMatrix = false;
        this._isWorldMatrixFrozen = false;
        /** @internal */ this._indexInSceneTransformNodesArray = -1;
        /**
         * An event triggered after the world matrix is updated
         */ this.onAfterWorldMatrixUpdateObservable = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Observable"]();
        this._nonUniformScaling = false;
        if (isPure) {
            this.getScene().addTransformNode(this);
        }
    }
    /**
     * Gets a string identifying the name of the class
     * @returns "TransformNode" string
     */ getClassName() {
        return "TransformNode";
    }
    /**
     * Gets or set the node position (default is (0.0, 0.0, 0.0))
     */ get position() {
        return this._position;
    }
    set position(newPosition) {
        this._position = newPosition;
        this._markAsDirtyInternal();
    }
    /**
     * return true if a pivot has been set
     * @returns true if a pivot matrix is used
     */ isUsingPivotMatrix() {
        return this._usePivotMatrix;
    }
    /**
     * @returns true if pivot matrix must be cancelled in the world matrix. When this parameter is set to true (default), the inverse of the pivot matrix is also applied at the end to cancel the transformation effect.
     */ isUsingPostMultiplyPivotMatrix() {
        return this._postMultiplyPivotMatrix;
    }
    /**
     * Gets or sets the rotation property : a Vector3 defining the rotation value in radians around each local axis X, Y, Z  (default is (0.0, 0.0, 0.0)).
     * If rotation quaternion is set, this Vector3 will be ignored and copy from the quaternion
     */ get rotation() {
        return this._rotation;
    }
    set rotation(newRotation) {
        this._rotation = newRotation;
        this._rotationQuaternion = null;
        this._markAsDirtyInternal();
    }
    /**
     * Gets or sets the scaling property : a Vector3 defining the node scaling along each local axis X, Y, Z (default is (1.0, 1.0, 1.0)).
     */ get scaling() {
        return this._scaling;
    }
    set scaling(newScaling) {
        this._scaling = newScaling;
        this._markAsDirtyInternal();
    }
    /**
     * Gets or sets the rotation Quaternion property : this a Quaternion object defining the node rotation by using a unit quaternion (undefined by default, but can be null).
     * If set, only the rotationQuaternion is then used to compute the node rotation (ie. node.rotation will be ignored)
     */ get rotationQuaternion() {
        return this._rotationQuaternion;
    }
    set rotationQuaternion(quaternion) {
        this._rotationQuaternion = quaternion;
        //reset the rotation vector.
        if (quaternion) {
            this._rotation.setAll(0.0);
        }
        this._markAsDirtyInternal();
    }
    _markAsDirtyInternal() {
        if (this._isDirty) {
            return;
        }
        this._isDirty = true;
        if (this.customMarkAsDirty) {
            this.customMarkAsDirty();
        }
    }
    /**
     * The forward direction of that transform in world space.
     */ get forward() {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformNormalFromFloatsToRef(0, 0, this.getScene().useRightHandedSystem ? -1.0 : 1.0, this.getWorldMatrix(), this._forward);
        return this._forward.normalize();
    }
    /**
     * The up direction of that transform in world space.
     */ get up() {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformNormalFromFloatsToRef(0, 1, 0, this.getWorldMatrix(), this._up);
        return this._up.normalize();
    }
    /**
     * The right direction of that transform in world space.
     */ get right() {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformNormalFromFloatsToRef(this.getScene().useRightHandedSystem ? -1.0 : 1.0, 0, 0, this.getWorldMatrix(), this._right);
        return this._right.normalize();
    }
    /**
     * Copies the parameter passed Matrix into the mesh Pose matrix.
     * @param matrix the matrix to copy the pose from
     * @returns this TransformNode.
     */ updatePoseMatrix(matrix) {
        if (!this._poseMatrix) {
            this._poseMatrix = matrix.clone();
            return this;
        }
        this._poseMatrix.copyFrom(matrix);
        return this;
    }
    /**
     * Returns the mesh Pose matrix.
     * @returns the pose matrix
     */ getPoseMatrix() {
        if (!this._poseMatrix) {
            this._poseMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].Identity();
        }
        return this._poseMatrix;
    }
    /** @internal */ _isSynchronized() {
        const cache = this._cache;
        if (this._billboardMode !== cache.billboardMode || this._billboardMode !== TransformNode.BILLBOARDMODE_NONE) {
            return false;
        }
        if (cache.pivotMatrixUpdated) {
            return false;
        }
        if (this._infiniteDistance) {
            return false;
        }
        if (this._position._isDirty) {
            return false;
        }
        if (this._scaling._isDirty) {
            return false;
        }
        if (this._rotationQuaternion && this._rotationQuaternion._isDirty || this._rotation._isDirty) {
            return false;
        }
        return true;
    }
    /** @internal */ _initCache() {
        super._initCache();
        const cache = this._cache;
        cache.localMatrixUpdated = false;
        cache.billboardMode = -1;
        cache.infiniteDistance = false;
        cache.useBillboardPosition = false;
    }
    /**
     * Returns the current mesh absolute position.
     * Returns a Vector3.
     */ get absolutePosition() {
        return this.getAbsolutePosition();
    }
    /**
     * Returns the current mesh absolute scaling.
     * Returns a Vector3.
     */ get absoluteScaling() {
        this._syncAbsoluteScalingAndRotation();
        return this._absoluteScaling;
    }
    /**
     * Returns the current mesh absolute rotation.
     * Returns a Quaternion.
     */ get absoluteRotationQuaternion() {
        this._syncAbsoluteScalingAndRotation();
        return this._absoluteRotationQuaternion;
    }
    /**
     * Sets a new matrix to apply before all other transformation
     * @param matrix defines the transform matrix
     * @returns the current TransformNode
     */ setPreTransformMatrix(matrix) {
        return this.setPivotMatrix(matrix, false);
    }
    /**
     * Sets a new pivot matrix to the current node
     * @param matrix defines the new pivot matrix to use
     * @param postMultiplyPivotMatrix defines if the pivot matrix must be cancelled in the world matrix. When this parameter is set to true (default), the inverse of the pivot matrix is also applied at the end to cancel the transformation effect
     * @returns the current TransformNode
     */ setPivotMatrix(matrix, postMultiplyPivotMatrix = true) {
        this._pivotMatrix.copyFrom(matrix);
        this._usePivotMatrix = !this._pivotMatrix.isIdentity();
        this._cache.pivotMatrixUpdated = true;
        this._postMultiplyPivotMatrix = postMultiplyPivotMatrix;
        if (this._postMultiplyPivotMatrix) {
            if (!this._pivotMatrixInverse) {
                this._pivotMatrixInverse = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].Invert(this._pivotMatrix);
            } else {
                this._pivotMatrix.invertToRef(this._pivotMatrixInverse);
            }
        }
        return this;
    }
    /**
     * Returns the mesh pivot matrix.
     * Default : Identity.
     * @returns the matrix
     */ getPivotMatrix() {
        return this._pivotMatrix;
    }
    /**
     * Instantiate (when possible) or clone that node with its hierarchy
     * @param newParent defines the new parent to use for the instance (or clone)
     * @param options defines options to configure how copy is done
     * @param options.doNotInstantiate defines if the model must be instantiated or just cloned
     * @param onNewNodeCreated defines an option callback to call when a clone or an instance is created
     * @returns an instance (or a clone) of the current node with its hierarchy
     */ instantiateHierarchy(newParent = null, options, onNewNodeCreated) {
        const clone = this.clone("Clone of " + (this.name || this.id), newParent || this.parent, true);
        if (clone) {
            if (onNewNodeCreated) {
                onNewNodeCreated(this, clone);
            }
        }
        for (const child of this.getChildTransformNodes(true)){
            child.instantiateHierarchy(clone, options, onNewNodeCreated);
        }
        return clone;
    }
    /**
     * Prevents the World matrix to be computed any longer.
     * Please note that the "moral" contract is that the world matrix is not going to be updated anymore. It is up to the developer to force updates.
     * You trade flexibility for performance. If you want to update it, you have to unfreeze it first.
     * @param newWorldMatrix defines an optional matrix to use as world matrix
     * @param decompose defines whether to decompose the given newWorldMatrix or directly assign
     * @returns the TransformNode.
     */ freezeWorldMatrix(newWorldMatrix = null, decompose = false) {
        if (newWorldMatrix) {
            if (decompose) {
                this._rotation.setAll(0);
                this._rotationQuaternion = this._rotationQuaternion || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"].Identity();
                newWorldMatrix.decompose(this._scaling, this._rotationQuaternion, this._position);
                this.computeWorldMatrix(true);
            } else {
                this._worldMatrix = newWorldMatrix;
                this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);
                this._afterComputeWorldMatrix();
            }
        } else {
            this._isWorldMatrixFrozen = false; // no guarantee world is not already frozen, switch off temporarily
            this.computeWorldMatrix(true);
        }
        this._isDirty = false;
        this._isWorldMatrixFrozen = true;
        return this;
    }
    /**
     * Allows back the World matrix computation.
     * @returns the TransformNode.
     */ unfreezeWorldMatrix() {
        this._isWorldMatrixFrozen = false;
        this.computeWorldMatrix(true);
        return this;
    }
    /**
     * True if the World matrix has been frozen.
     */ get isWorldMatrixFrozen() {
        return this._isWorldMatrixFrozen;
    }
    /**
     * Returns the mesh absolute position in the World.
     * @returns a Vector3.
     */ getAbsolutePosition() {
        this.computeWorldMatrix();
        return this._absolutePosition;
    }
    /**
     * Sets the mesh absolute position in the World from a Vector3 or an Array(3).
     * @param absolutePosition the absolute position to set
     * @returns the TransformNode.
     */ setAbsolutePosition(absolutePosition) {
        if (!absolutePosition) {
            return this;
        }
        let absolutePositionX;
        let absolutePositionY;
        let absolutePositionZ;
        if (absolutePosition.x === undefined) {
            if (arguments.length < 3) {
                return this;
            }
            absolutePositionX = arguments[0];
            absolutePositionY = arguments[1];
            absolutePositionZ = arguments[2];
        } else {
            absolutePositionX = absolutePosition.x;
            absolutePositionY = absolutePosition.y;
            absolutePositionZ = absolutePosition.z;
        }
        if (this.parent) {
            const invertParentWorldMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[0];
            this.parent.getWorldMatrix().invertToRef(invertParentWorldMatrix);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformCoordinatesFromFloatsToRef(absolutePositionX, absolutePositionY, absolutePositionZ, invertParentWorldMatrix, this.position);
        } else {
            this.position.x = absolutePositionX;
            this.position.y = absolutePositionY;
            this.position.z = absolutePositionZ;
        }
        this._absolutePosition.copyFrom(absolutePosition);
        return this;
    }
    /**
     * Sets the mesh position in its local space.
     * @param vector3 the position to set in localspace
     * @returns the TransformNode.
     */ setPositionWithLocalVector(vector3) {
        this.computeWorldMatrix();
        this.position = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformNormal(vector3, this._localMatrix);
        return this;
    }
    /**
     * Returns the mesh position in the local space from the current World matrix values.
     * @returns a new Vector3.
     */ getPositionExpressedInLocalSpace() {
        this.computeWorldMatrix();
        const invLocalWorldMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[0];
        this._localMatrix.invertToRef(invLocalWorldMatrix);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformNormal(this.position, invLocalWorldMatrix);
    }
    /**
     * Translates the mesh along the passed Vector3 in its local space.
     * @param vector3 the distance to translate in localspace
     * @returns the TransformNode.
     */ locallyTranslate(vector3) {
        this.computeWorldMatrix(true);
        this.position = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformCoordinates(vector3, this._localMatrix);
        return this;
    }
    /**
     * Orients a mesh towards a target point. Mesh must be drawn facing user.
     * @param targetPoint the position (must be in same space as current mesh) to look at
     * @param yawCor optional yaw (y-axis) correction in radians
     * @param pitchCor optional pitch (x-axis) correction in radians
     * @param rollCor optional roll (z-axis) correction in radians
     * @param space the chosen space of the target
     * @returns the TransformNode.
     */ lookAt(targetPoint, yawCor = 0, pitchCor = 0, rollCor = 0, space = 0 /* Space.LOCAL */ ) {
        const dv = TransformNode._LookAtVectorCache;
        const pos = space === 0 /* Space.LOCAL */  ? this.position : this.getAbsolutePosition();
        targetPoint.subtractToRef(pos, dv);
        this.setDirection(dv, yawCor, pitchCor, rollCor);
        // Correct for parent's rotation offset
        if (space === 1 /* Space.WORLD */  && this.parent) {
            if (this.rotationQuaternion) {
                // Get local rotation matrix of the looking object
                const rotationMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[0];
                this.rotationQuaternion.toRotationMatrix(rotationMatrix);
                // Offset rotation by parent's inverted rotation matrix to correct in world space
                const parentRotationMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[1];
                this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);
                parentRotationMatrix.invert();
                rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);
                this.rotationQuaternion.fromRotationMatrix(rotationMatrix);
            } else {
                // Get local rotation matrix of the looking object
                const quaternionRotation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Quaternion[0];
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"].FromEulerVectorToRef(this.rotation, quaternionRotation);
                const rotationMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[0];
                quaternionRotation.toRotationMatrix(rotationMatrix);
                // Offset rotation by parent's inverted rotation matrix to correct in world space
                const parentRotationMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[1];
                this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);
                parentRotationMatrix.invert();
                rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);
                quaternionRotation.fromRotationMatrix(rotationMatrix);
                quaternionRotation.toEulerAnglesToRef(this.rotation);
            }
        }
        return this;
    }
    /**
     * Returns a new Vector3 that is the localAxis, expressed in the mesh local space, rotated like the mesh.
     * This Vector3 is expressed in the World space.
     * @param localAxis axis to rotate
     * @returns a new Vector3 that is the localAxis, expressed in the mesh local space, rotated like the mesh.
     */ getDirection(localAxis) {
        const result = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Zero();
        this.getDirectionToRef(localAxis, result);
        return result;
    }
    /**
     * Sets the Vector3 "result" as the rotated Vector3 "localAxis" in the same rotation than the mesh.
     * localAxis is expressed in the mesh local space.
     * result is computed in the World space from the mesh World matrix.
     * @param localAxis axis to rotate
     * @param result the resulting transformnode
     * @returns this TransformNode.
     */ getDirectionToRef(localAxis, result) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformNormalToRef(localAxis, this.getWorldMatrix(), result);
        return this;
    }
    /**
     * Sets this transform node rotation to the given local axis.
     * @param localAxis the axis in local space
     * @param yawCor optional yaw (y-axis) correction in radians
     * @param pitchCor optional pitch (x-axis) correction in radians
     * @param rollCor optional roll (z-axis) correction in radians
     * @returns this TransformNode
     */ setDirection(localAxis, yawCor = 0, pitchCor = 0, rollCor = 0) {
        const yaw = -Math.atan2(localAxis.z, localAxis.x) + Math.PI / 2;
        const len = Math.sqrt(localAxis.x * localAxis.x + localAxis.z * localAxis.z);
        const pitch = -Math.atan2(localAxis.y, len);
        if (this.rotationQuaternion) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"].RotationYawPitchRollToRef(yaw + yawCor, pitch + pitchCor, rollCor, this.rotationQuaternion);
        } else {
            this.rotation.x = pitch + pitchCor;
            this.rotation.y = yaw + yawCor;
            this.rotation.z = rollCor;
        }
        return this;
    }
    /**
     * Sets a new pivot point to the current node
     * @param point defines the new pivot point to use
     * @param space defines if the point is in world or local space (local by default)
     * @returns the current TransformNode
     */ setPivotPoint(point, space = 0 /* Space.LOCAL */ ) {
        if (this.getScene().getRenderId() == 0) {
            this.computeWorldMatrix(true);
        }
        const wm = this.getWorldMatrix();
        if (space == 1 /* Space.WORLD */ ) {
            const tmat = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[0];
            wm.invertToRef(tmat);
            point = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformCoordinates(point, tmat);
        }
        return this.setPivotMatrix(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].Translation(-point.x, -point.y, -point.z), true);
    }
    /**
     * Returns a new Vector3 set with the mesh pivot point coordinates in the local space.
     * @returns the pivot point
     */ getPivotPoint() {
        const point = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Zero();
        this.getPivotPointToRef(point);
        return point;
    }
    /**
     * Sets the passed Vector3 "result" with the coordinates of the mesh pivot point in the local space.
     * @param result the vector3 to store the result
     * @returns this TransformNode.
     */ getPivotPointToRef(result) {
        result.x = -this._pivotMatrix.m[12];
        result.y = -this._pivotMatrix.m[13];
        result.z = -this._pivotMatrix.m[14];
        return this;
    }
    /**
     * Returns a new Vector3 set with the mesh pivot point World coordinates.
     * @returns a new Vector3 set with the mesh pivot point World coordinates.
     */ getAbsolutePivotPoint() {
        const point = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Zero();
        this.getAbsolutePivotPointToRef(point);
        return point;
    }
    /**
     * Sets the Vector3 "result" coordinates with the mesh pivot point World coordinates.
     * @param result vector3 to store the result
     * @returns this TransformNode.
     */ getAbsolutePivotPointToRef(result) {
        this.getPivotPointToRef(result);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformCoordinatesToRef(result, this.getWorldMatrix(), result);
        return this;
    }
    /**
     * Flag the transform node as dirty (Forcing it to update everything)
     * @param property if set to "rotation" the objects rotationQuaternion will be set to null
     * @returns this  node
     */ markAsDirty(property) {
        if (this._isDirty) {
            return this;
        }
        // We need to explicitly update the children
        // as the scene.evaluateActiveMeshes will not poll the transform nodes
        if (this._children) {
            for (const child of this._children){
                child.markAsDirty(property);
            }
        }
        return super.markAsDirty(property);
    }
    /**
     * Defines the passed node as the parent of the current node.
     * The node will remain exactly where it is and its position / rotation will be updated accordingly.
     * If you don't want to preserve the current rotation / position, assign the parent through parent accessor.
     * Note that if the mesh has a pivot matrix / point defined it will be applied after the parent was updated.
     * In that case the node will not remain in the same space as it is, as the pivot will be applied.
     * To avoid this, you can set updatePivot to true and the pivot will be updated to identity
     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/parent_pivot/parent
     * @param node the node ot set as the parent
     * @param preserveScalingSign if true, keep scaling sign of child. Otherwise, scaling sign might change.
     * @param updatePivot if true, update the pivot matrix to keep the node in the same space as before
     * @returns this TransformNode.
     */ setParent(node, preserveScalingSign = false, updatePivot = false) {
        if (!node && !this.parent) {
            return this;
        }
        const quatRotation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Quaternion[0];
        const position = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[0];
        const scale = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[1];
        const invParentMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[1];
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].IdentityToRef(invParentMatrix);
        const composedMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[0];
        this.computeWorldMatrix(true);
        let currentRotation = this.rotationQuaternion;
        if (!currentRotation) {
            currentRotation = TransformNode._TmpRotation;
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"].RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, currentRotation);
        }
        // current global transformation without pivot
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].ComposeToRef(this.scaling, currentRotation, this.position, composedMatrix);
        if (this.parent) {
            composedMatrix.multiplyToRef(this.parent.computeWorldMatrix(true), composedMatrix);
        }
        // is a node was set, calculate the difference between this and the node
        if (node) {
            node.computeWorldMatrix(true).invertToRef(invParentMatrix);
            composedMatrix.multiplyToRef(invParentMatrix, composedMatrix);
        }
        composedMatrix.decompose(scale, quatRotation, position, preserveScalingSign ? this : undefined);
        if (this.rotationQuaternion) {
            this.rotationQuaternion.copyFrom(quatRotation);
        } else {
            quatRotation.toEulerAnglesToRef(this.rotation);
        }
        this.scaling.copyFrom(scale);
        this.position.copyFrom(position);
        this.parent = node;
        if (updatePivot) {
            this.setPivotMatrix(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].Identity());
        }
        return this;
    }
    /**
     * Adds the passed mesh as a child to the current mesh.
     * The node will remain exactly where it is and its position / rotation will be updated accordingly.
     * This method is equivalent to calling setParent().
     * @param mesh defines the child mesh
     * @param preserveScalingSign if true, keep scaling sign of child. Otherwise, scaling sign might change.
     * @returns the current mesh
     */ addChild(mesh, preserveScalingSign = false) {
        mesh.setParent(this, preserveScalingSign);
        return this;
    }
    /**
     * Removes the passed mesh from the current mesh children list
     * @param mesh defines the child mesh
     * @param preserveScalingSign if true, keep scaling sign of child. Otherwise, scaling sign might change.
     * @returns the current mesh
     */ removeChild(mesh, preserveScalingSign = false) {
        if (mesh.parent !== this) {
            return this;
        }
        mesh.setParent(null, preserveScalingSign);
        return this;
    }
    /**
     * True if the scaling property of this object is non uniform eg. (1,2,1)
     */ get nonUniformScaling() {
        return this._nonUniformScaling;
    }
    /**
     * @internal
     */ _updateNonUniformScalingState(value) {
        if (this._nonUniformScaling === value) {
            return false;
        }
        this._nonUniformScaling = value;
        return true;
    }
    /**
     * Attach the current TransformNode to another TransformNode associated with a bone
     * @param bone Bone affecting the TransformNode
     * @param affectedTransformNode TransformNode associated with the bone
     * @returns this object
     */ attachToBone(bone, affectedTransformNode) {
        this._currentParentWhenAttachingToBone = this.parent;
        this._transformToBoneReferal = affectedTransformNode;
        this.parent = bone;
        bone.getSkeleton().prepare(true); // make sure bone.getFinalMatrix() is up to date
        if (bone.getFinalMatrix().determinant() < 0) {
            this.scalingDeterminant *= -1;
        }
        return this;
    }
    /**
     * Detach the transform node if its associated with a bone
     * @param resetToPreviousParent Indicates if the parent that was in effect when attachToBone was called should be set back or if we should set parent to null instead (defaults to the latter)
     * @returns this object
     */ detachFromBone(resetToPreviousParent = false) {
        if (!this.parent) {
            if (resetToPreviousParent) {
                this.parent = this._currentParentWhenAttachingToBone;
            }
            return this;
        }
        if (this.parent.getWorldMatrix().determinant() < 0) {
            this.scalingDeterminant *= -1;
        }
        this._transformToBoneReferal = null;
        if (resetToPreviousParent) {
            this.parent = this._currentParentWhenAttachingToBone;
        } else {
            this.parent = null;
        }
        return this;
    }
    /**
     * Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in the given space.
     * space (default LOCAL) can be either Space.LOCAL, either Space.WORLD.
     * Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.
     * The passed axis is also normalized.
     * @param axis the axis to rotate around
     * @param amount the amount to rotate in radians
     * @param space Space to rotate in (Default: local)
     * @returns the TransformNode.
     */ rotate(axis, amount, space) {
        axis.normalize();
        if (!this.rotationQuaternion) {
            this.rotationQuaternion = this.rotation.toQuaternion();
            this.rotation.setAll(0);
        }
        let rotationQuaternion;
        if (!space || space === 0 /* Space.LOCAL */ ) {
            rotationQuaternion = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"].RotationAxisToRef(axis, amount, TransformNode._RotationAxisCache);
            this.rotationQuaternion.multiplyToRef(rotationQuaternion, this.rotationQuaternion);
        } else {
            if (this.parent) {
                const parentWorldMatrix = this.parent.getWorldMatrix();
                const invertParentWorldMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[0];
                parentWorldMatrix.invertToRef(invertParentWorldMatrix);
                axis = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformNormal(axis, invertParentWorldMatrix);
                if (parentWorldMatrix.determinant() < 0) {
                    amount *= -1;
                }
            }
            rotationQuaternion = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"].RotationAxisToRef(axis, amount, TransformNode._RotationAxisCache);
            rotationQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);
        }
        return this;
    }
    /**
     * Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in world space.
     * Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.
     * The passed axis is also normalized. .
     * Method is based on http://www.euclideanspace.com/maths/geometry/affine/aroundPoint/index.htm
     * @param point the point to rotate around
     * @param axis the axis to rotate around
     * @param amount the amount to rotate in radians
     * @returns the TransformNode
     */ rotateAround(point, axis, amount) {
        axis.normalize();
        if (!this.rotationQuaternion) {
            this.rotationQuaternion = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"].RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);
            this.rotation.setAll(0);
        }
        const tmpVector = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[0];
        const finalScale = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[1];
        const finalTranslation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[2];
        const finalRotation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Quaternion[0];
        const translationMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[0]; // T
        const translationMatrixInv = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[1]; // T'
        const rotationMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[2]; // R
        const finalMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[3]; // T' x R x T
        point.subtractToRef(this.position, tmpVector);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].TranslationToRef(tmpVector.x, tmpVector.y, tmpVector.z, translationMatrix); // T
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].TranslationToRef(-tmpVector.x, -tmpVector.y, -tmpVector.z, translationMatrixInv); // T'
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].RotationAxisToRef(axis, amount, rotationMatrix); // R
        translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix); // T' x R
        finalMatrix.multiplyToRef(translationMatrix, finalMatrix); // T' x R x T
        finalMatrix.decompose(finalScale, finalRotation, finalTranslation);
        this.position.addInPlace(finalTranslation);
        finalRotation.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);
        return this;
    }
    /**
     * Translates the mesh along the axis vector for the passed distance in the given space.
     * space (default LOCAL) can be either Space.LOCAL, either Space.WORLD.
     * @param axis the axis to translate in
     * @param distance the distance to translate
     * @param space Space to rotate in (Default: local)
     * @returns the TransformNode.
     */ translate(axis, distance, space) {
        const displacementVector = axis.scale(distance);
        if (!space || space === 0 /* Space.LOCAL */ ) {
            const tempV3 = this.getPositionExpressedInLocalSpace().add(displacementVector);
            this.setPositionWithLocalVector(tempV3);
        } else {
            this.setAbsolutePosition(this.getAbsolutePosition().add(displacementVector));
        }
        return this;
    }
    /**
     * Adds a rotation step to the mesh current rotation.
     * x, y, z are Euler angles expressed in radians.
     * This methods updates the current mesh rotation, either mesh.rotation, either mesh.rotationQuaternion if it's set.
     * This means this rotation is made in the mesh local space only.
     * It's useful to set a custom rotation order different from the BJS standard one YXZ.
     * Example : this rotates the mesh first around its local X axis, then around its local Z axis, finally around its local Y axis.
     * ```javascript
     * mesh.addRotation(x1, 0, 0).addRotation(0, 0, z2).addRotation(0, 0, y3);
     * ```
     * Note that `addRotation()` accumulates the passed rotation values to the current ones and computes the .rotation or .rotationQuaternion updated values.
     * Under the hood, only quaternions are used. So it's a little faster is you use .rotationQuaternion because it doesn't need to translate them back to Euler angles.
     * @param x Rotation to add
     * @param y Rotation to add
     * @param z Rotation to add
     * @returns the TransformNode.
     */ addRotation(x, y, z) {
        let rotationQuaternion;
        if (this.rotationQuaternion) {
            rotationQuaternion = this.rotationQuaternion;
        } else {
            rotationQuaternion = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Quaternion[1];
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"].RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, rotationQuaternion);
        }
        const accumulation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Quaternion[0];
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"].RotationYawPitchRollToRef(y, x, z, accumulation);
        rotationQuaternion.multiplyInPlace(accumulation);
        if (!this.rotationQuaternion) {
            rotationQuaternion.toEulerAnglesToRef(this.rotation);
        }
        return this;
    }
    /**
     * @internal
     */ _getEffectiveParent() {
        return this.parent;
    }
    /**
     * Returns whether the transform node world matrix computation needs the camera information to be computed.
     * This is the case when the node is a billboard or has an infinite distance for instance.
     * @returns true if the world matrix computation needs the camera information to be computed
     */ isWorldMatrixCameraDependent() {
        return this._infiniteDistance && !this.parent || this._billboardMode !== TransformNode.BILLBOARDMODE_NONE;
    }
    /**
     * Computes the world matrix of the node
     * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch
     * @param camera defines the camera used if different from the scene active camera (This is used with modes like Billboard or infinite distance)
     * @returns the world matrix
     */ computeWorldMatrix(force = false, camera = null) {
        if (this._isWorldMatrixFrozen && !this._isDirty) {
            return this._worldMatrix;
        }
        const currentRenderId = this.getScene().getRenderId();
        if (!this._isDirty && !force && (this._currentRenderId === currentRenderId || this.isSynchronized())) {
            this._currentRenderId = currentRenderId;
            return this._worldMatrix;
        }
        camera = camera || this.getScene().activeCamera;
        this._updateCache();
        const cache = this._cache;
        cache.pivotMatrixUpdated = false;
        cache.billboardMode = this.billboardMode;
        cache.infiniteDistance = this.infiniteDistance;
        cache.parent = this._parentNode;
        this._currentRenderId = currentRenderId;
        this._childUpdateId += 1;
        this._isDirty = false;
        this._position._isDirty = false;
        this._rotation._isDirty = false;
        this._scaling._isDirty = false;
        const parent = this._getEffectiveParent();
        // Scaling
        const scaling = TransformNode._TmpScaling;
        let translation = this._position;
        // Translation
        if (this._infiniteDistance) {
            if (!this.parent && camera) {
                const cameraWorldMatrix = camera.getWorldMatrix();
                const cameraGlobalPosition = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](cameraWorldMatrix.m[12], cameraWorldMatrix.m[13], cameraWorldMatrix.m[14]);
                translation = TransformNode._TmpTranslation;
                translation.copyFromFloats(this._position.x + cameraGlobalPosition.x, this._position.y + cameraGlobalPosition.y, this._position.z + cameraGlobalPosition.z);
            }
        }
        // Scaling
        scaling.copyFromFloats(this._scaling.x * this.scalingDeterminant, this._scaling.y * this.scalingDeterminant, this._scaling.z * this.scalingDeterminant);
        // Rotation
        let rotation;
        if (this._rotationQuaternion) {
            this._rotationQuaternion._isDirty = false;
            rotation = this._rotationQuaternion;
            if (this.reIntegrateRotationIntoRotationQuaternion) {
                const len = this.rotation.lengthSquared();
                if (len) {
                    this._rotationQuaternion.multiplyInPlace(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"].RotationYawPitchRoll(this._rotation.y, this._rotation.x, this._rotation.z));
                    this._rotation.copyFromFloats(0, 0, 0);
                }
            }
        } else {
            rotation = TransformNode._TmpRotation;
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"].RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, rotation);
        }
        // Compose
        if (this._usePivotMatrix) {
            const scaleMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[1];
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].ScalingToRef(scaling.x, scaling.y, scaling.z, scaleMatrix);
            // Rotation
            const rotationMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[0];
            rotation.toRotationMatrix(rotationMatrix);
            // Composing transformations
            this._pivotMatrix.multiplyToRef(scaleMatrix, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[4]);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[4].multiplyToRef(rotationMatrix, this._localMatrix);
            // Post multiply inverse of pivotMatrix
            if (this._postMultiplyPivotMatrix) {
                this._localMatrix.multiplyToRef(this._pivotMatrixInverse, this._localMatrix);
            }
            this._localMatrix.addTranslationFromFloats(translation.x, translation.y, translation.z);
        } else {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].ComposeToRef(scaling, rotation, translation, this._localMatrix);
        }
        // Parent
        if (parent && parent.getWorldMatrix) {
            if (force) {
                parent.computeWorldMatrix(force);
            }
            if (this.billboardMode) {
                if (this._transformToBoneReferal) {
                    const bone = this.parent;
                    bone.getSkeleton().prepare();
                    bone.getFinalMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[7]);
                } else {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[7].copyFrom(parent.getWorldMatrix());
                }
                // Extract scaling and translation from parent
                const translation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[5];
                const scale = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[6];
                const orientation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Quaternion[0];
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[7].decompose(scale, orientation, translation);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].ScalingToRef(scale.x, scale.y, scale.z, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[7]);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[7].setTranslation(translation);
                if (TransformNode.BillboardUseParentOrientation) {
                    // set localMatrix translation to be transformed against parent's orientation.
                    this._position.applyRotationQuaternionToRef(orientation, translation);
                    this._localMatrix.setTranslation(translation);
                }
                this._localMatrix.multiplyToRef(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[7], this._worldMatrix);
            } else {
                if (this._transformToBoneReferal) {
                    const bone = this.parent;
                    bone.getSkeleton().prepare();
                    this._localMatrix.multiplyToRef(bone.getFinalMatrix(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[6]);
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[6].multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), this._worldMatrix);
                } else {
                    this._localMatrix.multiplyToRef(parent.getWorldMatrix(), this._worldMatrix);
                }
            }
            this._markSyncedWithParent();
        } else {
            this._worldMatrix.copyFrom(this._localMatrix);
        }
        if (camera && this.billboardMode) {
            // Billboarding based on camera orientation (testing PG:http://www.babylonjs-playground.com/#UJEIL#13)
            if (!cache.useBillboardPosition) {
                const storedTranslation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[0];
                this._worldMatrix.getTranslationToRef(storedTranslation); // Save translation
                // Get camera view matrix
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[1].copyFrom(camera.getViewMatrix());
                const isRH = this.getScene().useRightHandedSystem;
                if (isRH) {
                    // This operation is necessary to cancel out the scaling component of the matrix without decomposing it.
                    // It's a trick to extract only the rotation part.
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[1].multiplyToRef(TransformNode._TmpRHRestore, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[1]);
                }
                // This will cancel the camera rotation
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[1].setTranslationFromFloats(0, 0, 0);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[1].invertToRef(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[0]);
                if ((this.billboardMode & TransformNode.BILLBOARDMODE_ALL) !== TransformNode.BILLBOARDMODE_ALL) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[0].decompose(undefined, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Quaternion[0], undefined);
                    const eulerAngles = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[1];
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Quaternion[0].toEulerAnglesToRef(eulerAngles);
                    if ((this.billboardMode & TransformNode.BILLBOARDMODE_X) !== TransformNode.BILLBOARDMODE_X) {
                        eulerAngles.x = 0;
                    }
                    if ((this.billboardMode & TransformNode.BILLBOARDMODE_Y) !== TransformNode.BILLBOARDMODE_Y) {
                        eulerAngles.y = 0;
                    }
                    if ((this.billboardMode & TransformNode.BILLBOARDMODE_Z) !== TransformNode.BILLBOARDMODE_Z) {
                        eulerAngles.z = 0;
                    }
                    if (isRH) {
                        eulerAngles.y += Math.PI; // Yaw correction
                    }
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].RotationYawPitchRollToRef(eulerAngles.y, eulerAngles.x, eulerAngles.z, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[0]);
                }
                this._worldMatrix.setTranslationFromFloats(0, 0, 0);
                this._worldMatrix.multiplyToRef(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[0], this._worldMatrix);
                // Restore translation
                this._worldMatrix.setTranslation(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[0]);
            } else {
                const storedTranslation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[0];
                // Save translation
                this._worldMatrix.getTranslationToRef(storedTranslation);
                // Compute camera position in local space
                const cameraPosition = camera.globalPosition;
                this._worldMatrix.invertToRef(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[1]);
                const camInObjSpace = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[1];
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformCoordinatesToRef(cameraPosition, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[1], camInObjSpace);
                camInObjSpace.normalize();
                // Find the lookAt info in local space
                const yaw = -Math.atan2(camInObjSpace.z, camInObjSpace.x) + Math.PI / 2;
                const len = Math.sqrt(camInObjSpace.x * camInObjSpace.x + camInObjSpace.z * camInObjSpace.z);
                const pitch = -Math.atan2(camInObjSpace.y, len);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"].RotationYawPitchRollToRef(yaw, pitch, 0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Quaternion[0]);
                if ((this.billboardMode & TransformNode.BILLBOARDMODE_ALL) !== TransformNode.BILLBOARDMODE_ALL) {
                    const eulerAngles = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[1];
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Quaternion[0].toEulerAnglesToRef(eulerAngles);
                    if ((this.billboardMode & TransformNode.BILLBOARDMODE_X) !== TransformNode.BILLBOARDMODE_X) {
                        eulerAngles.x = 0;
                    }
                    if ((this.billboardMode & TransformNode.BILLBOARDMODE_Y) !== TransformNode.BILLBOARDMODE_Y) {
                        eulerAngles.y = 0;
                    }
                    if ((this.billboardMode & TransformNode.BILLBOARDMODE_Z) !== TransformNode.BILLBOARDMODE_Z) {
                        eulerAngles.z = 0;
                    }
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].RotationYawPitchRollToRef(eulerAngles.y, eulerAngles.x, eulerAngles.z, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[0]);
                } else {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].FromQuaternionToRef(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Quaternion[0], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[0]);
                }
                // Cancel translation
                this._worldMatrix.setTranslationFromFloats(0, 0, 0);
                // Rotate according to lookat (diff from local to lookat)
                this._worldMatrix.multiplyToRef(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[0], this._worldMatrix);
                // Restore translation
                this._worldMatrix.setTranslation(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[0]);
            }
        }
        // Normal matrix
        if (!this.ignoreNonUniformScaling) {
            if (this._scaling.isNonUniformWithinEpsilon(0.000001)) {
                this._updateNonUniformScalingState(true);
            } else if (parent && parent._nonUniformScaling) {
                this._updateNonUniformScalingState(parent._nonUniformScaling);
            } else {
                this._updateNonUniformScalingState(false);
            }
        } else {
            this._updateNonUniformScalingState(false);
        }
        this._afterComputeWorldMatrix();
        // Absolute position
        this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);
        this._isAbsoluteSynced = false;
        // Callbacks
        this.onAfterWorldMatrixUpdateObservable.notifyObservers(this);
        if (!this._poseMatrix) {
            this._poseMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].Invert(this._worldMatrix);
        }
        // Cache the determinant
        this._worldMatrixDeterminantIsDirty = true;
        return this._worldMatrix;
    }
    /**
     * Resets this nodeTransform's local matrix to Matrix.Identity().
     * @param independentOfChildren indicates if all child nodeTransform's world-space transform should be preserved.
     */ resetLocalMatrix(independentOfChildren = true) {
        this.computeWorldMatrix();
        if (independentOfChildren) {
            const children = this.getChildren();
            for(let i = 0; i < children.length; ++i){
                const child = children[i];
                if (child) {
                    child.computeWorldMatrix();
                    const bakedMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[0];
                    child._localMatrix.multiplyToRef(this._localMatrix, bakedMatrix);
                    const tmpRotationQuaternion = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Quaternion[0];
                    bakedMatrix.decompose(child.scaling, tmpRotationQuaternion, child.position);
                    if (child.rotationQuaternion) {
                        child.rotationQuaternion.copyFrom(tmpRotationQuaternion);
                    } else {
                        tmpRotationQuaternion.toEulerAnglesToRef(child.rotation);
                    }
                }
            }
        }
        this.scaling.copyFromFloats(1, 1, 1);
        this.position.copyFromFloats(0, 0, 0);
        this.rotation.copyFromFloats(0, 0, 0);
        //only if quaternion is already set
        if (this.rotationQuaternion) {
            this.rotationQuaternion = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"].Identity();
        }
        this._worldMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].Identity();
    }
    _afterComputeWorldMatrix() {}
    /**
     * If you'd like to be called back after the mesh position, rotation or scaling has been updated.
     * @param func callback function to add
     *
     * @returns the TransformNode.
     */ registerAfterWorldMatrixUpdate(func) {
        this.onAfterWorldMatrixUpdateObservable.add(func);
        return this;
    }
    /**
     * Removes a registered callback function.
     * @param func callback function to remove
     * @returns the TransformNode.
     */ unregisterAfterWorldMatrixUpdate(func) {
        this.onAfterWorldMatrixUpdateObservable.removeCallback(func);
        return this;
    }
    /**
     * Gets the position of the current mesh in camera space
     * @param camera defines the camera to use
     * @returns a position
     */ getPositionInCameraSpace(camera = null) {
        if (!camera) {
            camera = this.getScene().activeCamera;
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformCoordinates(this.getAbsolutePosition(), camera.getViewMatrix());
    }
    /**
     * Returns the distance from the mesh to the active camera
     * @param camera defines the camera to use
     * @returns the distance
     */ getDistanceToCamera(camera = null) {
        if (!camera) {
            camera = this.getScene().activeCamera;
        }
        return this.getAbsolutePosition().subtract(camera.globalPosition).length();
    }
    /**
     * Clone the current transform node
     * @param name Name of the new clone
     * @param newParent New parent for the clone
     * @param doNotCloneChildren Do not clone children hierarchy
     * @returns the new transform node
     */ clone(name, newParent, doNotCloneChildren) {
        const result = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$serialization$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SerializationHelper"].Clone(()=>new TransformNode(name, this.getScene()), this);
        result.name = name;
        result.id = name;
        if (newParent) {
            result.parent = newParent;
        }
        if (!doNotCloneChildren) {
            // Children
            const directDescendants = this.getDescendants(true);
            for(let index = 0; index < directDescendants.length; index++){
                const child = directDescendants[index];
                if (child.clone) {
                    child.clone(name + "." + child.name, result);
                }
            }
        }
        return result;
    }
    /**
     * Serializes the objects information.
     * @param currentSerializationObject defines the object to serialize in
     * @returns the serialized object
     */ serialize(currentSerializationObject) {
        const serializationObject = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$serialization$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SerializationHelper"].Serialize(this, currentSerializationObject);
        serializationObject.type = this.getClassName();
        serializationObject.uniqueId = this.uniqueId;
        // Parent
        if (this.parent) {
            this.parent._serializeAsParent(serializationObject);
        }
        serializationObject.localMatrix = this.getPivotMatrix().asArray();
        serializationObject.isEnabled = this.isEnabled();
        // Animations
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$serialization$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SerializationHelper"].AppendSerializedAnimations(this, serializationObject);
        serializationObject.ranges = this.serializeAnimationRanges();
        return serializationObject;
    }
    // Statics
    /**
     * Returns a new TransformNode object parsed from the source provided.
     * @param parsedTransformNode is the source.
     * @param scene the scene the object belongs to
     * @param rootUrl is a string, it's the root URL to prefix the `delayLoadingFile` property with
     * @returns a new TransformNode object parsed from the source provided.
     */ static Parse(parsedTransformNode, scene, rootUrl) {
        const transformNode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$serialization$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SerializationHelper"].Parse(()=>new TransformNode(parsedTransformNode.name, scene), parsedTransformNode, scene, rootUrl);
        if (parsedTransformNode.localMatrix) {
            transformNode.setPreTransformMatrix(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].FromArray(parsedTransformNode.localMatrix));
        } else if (parsedTransformNode.pivotMatrix) {
            transformNode.setPivotMatrix(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].FromArray(parsedTransformNode.pivotMatrix));
        }
        transformNode.setEnabled(parsedTransformNode.isEnabled);
        transformNode._waitingParsedUniqueId = parsedTransformNode.uniqueId;
        // Parent
        if (parsedTransformNode.parentId !== undefined) {
            transformNode._waitingParentId = parsedTransformNode.parentId;
        }
        if (parsedTransformNode.parentInstanceIndex !== undefined) {
            transformNode._waitingParentInstanceIndex = parsedTransformNode.parentInstanceIndex;
        }
        // Animations
        if (parsedTransformNode.animations) {
            for(let animationIndex = 0; animationIndex < parsedTransformNode.animations.length; animationIndex++){
                const parsedAnimation = parsedTransformNode.animations[animationIndex];
                const internalClass = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$typeStore$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GetClass"])("BABYLON.Animation");
                if (internalClass) {
                    transformNode.animations.push(internalClass.Parse(parsedAnimation));
                }
            }
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].ParseAnimationRanges(transformNode, parsedTransformNode, scene);
        }
        if (parsedTransformNode.autoAnimate) {
            scene.beginAnimation(transformNode, parsedTransformNode.autoAnimateFrom, parsedTransformNode.autoAnimateTo, parsedTransformNode.autoAnimateLoop, parsedTransformNode.autoAnimateSpeed || 1.0);
        }
        return transformNode;
    }
    /**
     * Get all child-transformNodes of this node
     * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered
     * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored
     * @returns an array of TransformNode
     */ getChildTransformNodes(directDescendantsOnly, predicate) {
        const results = [];
        this._getDescendants(results, directDescendantsOnly, (node)=>{
            return (!predicate || predicate(node)) && node instanceof TransformNode;
        });
        return results;
    }
    /**
     * Releases resources associated with this transform node.
     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
     */ dispose(doNotRecurse, disposeMaterialAndTextures = false) {
        // Animations
        this.getScene().stopAnimation(this);
        // Remove from scene
        this.getScene().removeTransformNode(this);
        if (this._parentContainer) {
            const index = this._parentContainer.transformNodes.indexOf(this);
            if (index > -1) {
                this._parentContainer.transformNodes.splice(index, 1);
            }
            this._parentContainer = null;
        }
        this.onAfterWorldMatrixUpdateObservable.clear();
        if (doNotRecurse) {
            const transformNodes = this.getChildTransformNodes(true);
            for (const transformNode of transformNodes){
                transformNode.parent = null;
                transformNode.computeWorldMatrix(true);
            }
        }
        super.dispose(doNotRecurse, disposeMaterialAndTextures);
    }
    /**
     * Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units)
     * @param includeDescendants Use the hierarchy's bounding box instead of the mesh's bounding box. Default is false
     * @param ignoreRotation ignore rotation when computing the scale (ie. object will be axis aligned). Default is false
     * @param predicate predicate that is passed in to getHierarchyBoundingVectors when selecting which object should be included when scaling
     * @returns the current mesh
     */ normalizeToUnitCube(includeDescendants = true, ignoreRotation = false, predicate) {
        let storedRotation = null;
        let storedRotationQuaternion = null;
        if (ignoreRotation) {
            if (this.rotationQuaternion) {
                storedRotationQuaternion = this.rotationQuaternion.clone();
                this.rotationQuaternion.copyFromFloats(0, 0, 0, 1);
            } else if (this.rotation) {
                storedRotation = this.rotation.clone();
                this.rotation.copyFromFloats(0, 0, 0);
            }
        }
        const boundingVectors = this.getHierarchyBoundingVectors(includeDescendants, predicate);
        const sizeVec = boundingVectors.max.subtract(boundingVectors.min);
        const maxDimension = Math.max(sizeVec.x, sizeVec.y, sizeVec.z);
        if (maxDimension === 0) {
            return this;
        }
        const scale = 1 / maxDimension;
        this.scaling.scaleInPlace(scale);
        if (ignoreRotation) {
            if (this.rotationQuaternion && storedRotationQuaternion) {
                this.rotationQuaternion.copyFrom(storedRotationQuaternion);
            } else if (this.rotation && storedRotation) {
                this.rotation.copyFrom(storedRotation);
            }
        }
        return this;
    }
    _syncAbsoluteScalingAndRotation() {
        if (!this._isAbsoluteSynced) {
            this._worldMatrix.decompose(this._absoluteScaling, this._absoluteRotationQuaternion);
            this._isAbsoluteSynced = true;
        }
    }
}
// Statics
/**
 * Object will not rotate to face the camera
 */ TransformNode.BILLBOARDMODE_NONE = 0;
/**
 * Object will rotate to face the camera but only on the x axis
 */ TransformNode.BILLBOARDMODE_X = 1;
/**
 * Object will rotate to face the camera but only on the y axis
 */ TransformNode.BILLBOARDMODE_Y = 2;
/**
 * Object will rotate to face the camera but only on the z axis
 */ TransformNode.BILLBOARDMODE_Z = 4;
/**
 * Object will rotate to face the camera
 */ TransformNode.BILLBOARDMODE_ALL = 7;
/**
 * Object will rotate to face the camera's position instead of orientation
 */ TransformNode.BILLBOARDMODE_USE_POSITION = 128;
/**
 * Child transform with Billboard flags should or should not apply parent rotation (default if off)
 */ TransformNode.BillboardUseParentOrientation = false;
TransformNode._TmpRotation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"].Zero();
TransformNode._TmpScaling = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Zero();
TransformNode._TmpTranslation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Zero();
// eslint-disable-next-line @typescript-eslint/naming-convention
TransformNode._TmpRHRestore = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].Scaling(1, 1, -1);
TransformNode._LookAtVectorCache = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 0, 0);
TransformNode._RotationAxisCache = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"]();
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$tslib$2e$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__decorate"])([
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["serializeAsVector3"])("position")
], TransformNode.prototype, "_position", void 0);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$tslib$2e$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__decorate"])([
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["serializeAsVector3"])("rotation")
], TransformNode.prototype, "_rotation", void 0);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$tslib$2e$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__decorate"])([
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["serializeAsQuaternion"])("rotationQuaternion")
], TransformNode.prototype, "_rotationQuaternion", void 0);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$tslib$2e$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__decorate"])([
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["serializeAsVector3"])("scaling")
], TransformNode.prototype, "_scaling", void 0);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$tslib$2e$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__decorate"])([
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["serialize"])("billboardMode")
], TransformNode.prototype, "_billboardMode", void 0);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$tslib$2e$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__decorate"])([
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["serialize"])()
], TransformNode.prototype, "scalingDeterminant", void 0);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$tslib$2e$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__decorate"])([
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["serialize"])("infiniteDistance")
], TransformNode.prototype, "_infiniteDistance", void 0);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$tslib$2e$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__decorate"])([
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["serialize"])()
], TransformNode.prototype, "ignoreNonUniformScaling", void 0);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$tslib$2e$es6$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__decorate"])([
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["serialize"])()
], TransformNode.prototype, "reIntegrateRotationIntoRotationQuaternion", void 0); //# sourceMappingURL=transformNode.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/meshLODLevel.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Class used to represent a specific level of detail of a mesh
 * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/LOD
 */ __turbopack_context__.s([
    "MeshLODLevel",
    ()=>MeshLODLevel
]);
class MeshLODLevel {
    /**
     * Creates a new LOD level
     * @param distanceOrScreenCoverage defines either the distance or the screen coverage where this level should start being displayed
     * @param mesh defines the mesh to use to render this level
     */ constructor(/** Either distance from the center of the object to show this level or the screen coverage if `useLODScreenCoverage` is set to `true` on the mesh*/ distanceOrScreenCoverage, /** Defines the mesh to use to render this level */ mesh){
        this.distanceOrScreenCoverage = distanceOrScreenCoverage;
        this.mesh = mesh;
    }
} //# sourceMappingURL=meshLODLevel.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/instancedMesh.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "InstancedMesh",
    ()=>InstancedMesh
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/logger.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$abstractMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/abstractMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$deepCopier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/deepCopier.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$transformNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/transformNode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tools.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$typeStore$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/typeStore.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"]._instancedMeshFactory = (name, mesh)=>{
    const instance = new InstancedMesh(name, mesh);
    if (mesh.instancedBuffers) {
        instance.instancedBuffers = {};
        for(const key in mesh.instancedBuffers){
            instance.instancedBuffers[key] = mesh.instancedBuffers[key];
        }
    }
    return instance;
};
class InstancedMesh extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$abstractMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AbstractMesh"] {
    /**
     * Creates a new InstancedMesh object from the mesh source.
     * @param name defines the name of the instance
     * @param source the mesh to create the instance from
     */ constructor(name, source){
        super(name, source.getScene());
        /** @internal */ this._indexInSourceMeshInstanceArray = -1;
        /** @internal */ this._distanceToCamera = 0;
        source.addInstance(this);
        this._sourceMesh = source;
        this._unIndexed = source._unIndexed;
        this.position.copyFrom(source.position);
        this.rotation.copyFrom(source.rotation);
        this.scaling.copyFrom(source.scaling);
        if (source.rotationQuaternion) {
            this.rotationQuaternion = source.rotationQuaternion.clone();
        }
        this.animations = source.animations.slice();
        for (const range of source.getAnimationRanges()){
            if (range != null) {
                this.createAnimationRange(range.name, range.from, range.to);
            }
        }
        this.infiniteDistance = source.infiniteDistance;
        this.setPivotMatrix(source.getPivotMatrix());
        if (!source.skeleton && !source.morphTargetManager && source.hasBoundingInfo) {
            // without skeleton or morphTargetManager, use bounding info of source mesh directly
            const boundingInfo = source.getBoundingInfo();
            this.buildBoundingInfo(boundingInfo.minimum, boundingInfo.maximum);
        } else {
            this.refreshBoundingInfo(true, true);
        }
        this._syncSubMeshes();
    }
    /**
     * @returns the string "InstancedMesh".
     */ getClassName() {
        return "InstancedMesh";
    }
    /** Gets the list of lights affecting that mesh */ get lightSources() {
        return this._sourceMesh._lightSources;
    }
    _resyncLightSources() {
    // Do nothing as all the work will be done by source mesh
    }
    _resyncLightSource() {
    // Do nothing as all the work will be done by source mesh
    }
    _removeLightSource() {
    // Do nothing as all the work will be done by source mesh
    }
    // Methods
    /**
     * If the source mesh receives shadows
     */ get receiveShadows() {
        return this._sourceMesh.receiveShadows;
    }
    set receiveShadows(_value) {
        if (this._sourceMesh?.receiveShadows !== _value) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tools"].Warn("Setting receiveShadows on an instanced mesh has no effect");
        }
    }
    /**
     * The material of the source mesh
     */ get material() {
        return this._sourceMesh.material;
    }
    set material(_value) {
        if (this._sourceMesh?.material !== _value) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tools"].Warn("Setting material on an instanced mesh has no effect");
        }
    }
    /**
     * Visibility of the source mesh
     */ get visibility() {
        return this._sourceMesh.visibility;
    }
    set visibility(_value) {
        if (this._sourceMesh?.visibility !== _value) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tools"].Warn("Setting visibility on an instanced mesh has no effect");
        }
    }
    /**
     * Skeleton of the source mesh
     */ get skeleton() {
        return this._sourceMesh.skeleton;
    }
    set skeleton(_value) {
        if (this._sourceMesh?.skeleton !== _value) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tools"].Warn("Setting skeleton on an instanced mesh has no effect");
        }
    }
    /**
     * Rendering ground id of the source mesh
     */ get renderingGroupId() {
        return this._sourceMesh.renderingGroupId;
    }
    set renderingGroupId(value) {
        if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {
            return;
        }
        //no-op with warning
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].Warn("Note - setting renderingGroupId of an instanced mesh has no effect on the scene");
    }
    /**
     * @returns the total number of vertices (integer).
     */ getTotalVertices() {
        return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;
    }
    /**
     * Returns a positive integer : the total number of indices in this mesh geometry.
     * @returns the number of indices or zero if the mesh has no geometry.
     */ getTotalIndices() {
        return this._sourceMesh.getTotalIndices();
    }
    /**
     * The source mesh of the instance
     */ get sourceMesh() {
        return this._sourceMesh;
    }
    /**
     * Gets the mesh internal Geometry object
     */ get geometry() {
        return this._sourceMesh._geometry;
    }
    /**
     * Creates a new InstancedMesh object from the mesh model.
     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances
     * @param name defines the name of the new instance
     * @returns a new InstancedMesh
     */ createInstance(name) {
        return this._sourceMesh.createInstance(name);
    }
    /**
     * Is this node ready to be used/rendered
     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)
     * @returns {boolean} is it ready
     */ isReady(completeCheck = false) {
        return this._sourceMesh.isReady(completeCheck, true);
    }
    /**
     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.
     * @param kind kind of verticies to retrieve (eg. positions, normals, uvs, etc.)
     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.
     * @param forceCopy defines a boolean forcing the copy of the buffer no matter what the value of copyWhenShared is
     * @returns a float array or a Float32Array of the requested kind of data : positions, normals, uvs, etc.
     */ getVerticesData(kind, copyWhenShared, forceCopy) {
        return this._sourceMesh.getVerticesData(kind, copyWhenShared, forceCopy);
    }
    copyVerticesData(kind, vertexData) {
        this._sourceMesh.copyVerticesData(kind, vertexData);
    }
    getVertexBuffer(kind, bypassInstanceData) {
        return this._sourceMesh.getVertexBuffer(kind, bypassInstanceData);
    }
    /**
     * Sets the vertex data of the mesh geometry for the requested `kind`.
     * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.
     * The `data` are either a numeric array either a Float32Array.
     * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initially none) or updater.
     * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).
     * Note that a new underlying VertexBuffer object is created each call.
     * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
     *
     * Possible `kind` values :
     * - VertexBuffer.PositionKind
     * - VertexBuffer.UVKind
     * - VertexBuffer.UV2Kind
     * - VertexBuffer.UV3Kind
     * - VertexBuffer.UV4Kind
     * - VertexBuffer.UV5Kind
     * - VertexBuffer.UV6Kind
     * - VertexBuffer.ColorKind
     * - VertexBuffer.MatricesIndicesKind
     * - VertexBuffer.MatricesIndicesExtraKind
     * - VertexBuffer.MatricesWeightsKind
     * - VertexBuffer.MatricesWeightsExtraKind
     *
     * Returns the Mesh.
     * @param kind defines vertex data kind
     * @param data defines the data source
     * @param updatable defines if the data must be flagged as updatable (false as default)
     * @param stride defines the vertex stride (optional)
     * @returns the current mesh
     */ setVerticesData(kind, data, updatable, stride) {
        if (this.sourceMesh) {
            this.sourceMesh.setVerticesData(kind, data, updatable, stride);
        }
        return this.sourceMesh;
    }
    /**
     * Updates the existing vertex data of the mesh geometry for the requested `kind`.
     * If the mesh has no geometry, it is simply returned as it is.
     * The `data` are either a numeric array either a Float32Array.
     * No new underlying VertexBuffer object is created.
     * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
     * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.
     *
     * Possible `kind` values :
     * - VertexBuffer.PositionKind
     * - VertexBuffer.UVKind
     * - VertexBuffer.UV2Kind
     * - VertexBuffer.UV3Kind
     * - VertexBuffer.UV4Kind
     * - VertexBuffer.UV5Kind
     * - VertexBuffer.UV6Kind
     * - VertexBuffer.ColorKind
     * - VertexBuffer.MatricesIndicesKind
     * - VertexBuffer.MatricesIndicesExtraKind
     * - VertexBuffer.MatricesWeightsKind
     * - VertexBuffer.MatricesWeightsExtraKind
     *
     * Returns the Mesh.
     * @param kind defines vertex data kind
     * @param data defines the data source
     * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for "position" kind
     * @param makeItUnique defines it the updated vertex buffer must be flagged as unique (false by default)
     * @returns the source mesh
     */ updateVerticesData(kind, data, updateExtends, makeItUnique) {
        if (this.sourceMesh) {
            this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);
        }
        return this.sourceMesh;
    }
    /**
     * Sets the mesh indices.
     * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).
     * If the mesh has no geometry, a new Geometry object is created and set to the mesh.
     * This method creates a new index buffer each call.
     * Returns the Mesh.
     * @param indices the source data
     * @param totalVertices defines the total number of vertices referenced by indices (could be null)
     * @returns source mesh
     */ setIndices(indices, totalVertices = null) {
        if (this.sourceMesh) {
            this.sourceMesh.setIndices(indices, totalVertices);
        }
        return this.sourceMesh;
    }
    /**
     * Boolean : True if the mesh owns the requested kind of data.
     * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :
     * - VertexBuffer.PositionKind
     * - VertexBuffer.UVKind
     * - VertexBuffer.UV2Kind
     * - VertexBuffer.UV3Kind
     * - VertexBuffer.UV4Kind
     * - VertexBuffer.UV5Kind
     * - VertexBuffer.UV6Kind
     * - VertexBuffer.ColorKind
     * - VertexBuffer.MatricesIndicesKind
     * - VertexBuffer.MatricesIndicesExtraKind
     * - VertexBuffer.MatricesWeightsKind
     * - VertexBuffer.MatricesWeightsExtraKind
     * @returns true if data kind is present
     */ isVerticesDataPresent(kind) {
        return this._sourceMesh.isVerticesDataPresent(kind);
    }
    /**
     * @returns an array of indices (IndicesArray).
     */ getIndices() {
        return this._sourceMesh.getIndices();
    }
    get _positions() {
        return this._sourceMesh._positions;
    }
    refreshBoundingInfo(applySkeletonOrOptions = false, applyMorph = false) {
        if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {
            return this;
        }
        let options;
        if (typeof applySkeletonOrOptions === "object") {
            options = applySkeletonOrOptions;
        } else {
            options = {
                applySkeleton: applySkeletonOrOptions,
                applyMorph: applyMorph
            };
        }
        const bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;
        this._refreshBoundingInfo(this._sourceMesh._getData(options, null, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind), bias);
        return this;
    }
    /** @internal */ _preActivate() {
        if (this._currentLOD) {
            this._currentLOD._preActivate();
        }
        return this;
    }
    /**
     * @internal
     */ _activate(renderId, intermediateRendering) {
        super._activate(renderId, intermediateRendering);
        if (!this._sourceMesh.subMeshes) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].Warn("Instances should only be created for meshes with geometry.");
        }
        if (this._currentLOD) {
            const differentSign = this._currentLOD._getWorldMatrixDeterminant() >= 0 !== this._getWorldMatrixDeterminant() >= 0;
            if (differentSign) {
                this._internalAbstractMeshDataInfo._actAsRegularMesh = true;
                return true;
            }
            this._internalAbstractMeshDataInfo._actAsRegularMesh = false;
            this._currentLOD._registerInstanceForRenderId(this, renderId);
            if (intermediateRendering) {
                if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {
                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;
                    return true;
                }
            } else {
                if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {
                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;
                    return true;
                }
            }
        }
        return false;
    }
    /** @internal */ _postActivate() {
        if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {
            // we are using the edge renderer of the source mesh
            this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);
            this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());
        } else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {
            // we are using the edge renderer defined for this instance
            this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);
        }
    }
    getWorldMatrix() {
        if (this._currentLOD && this._currentLOD !== this._sourceMesh && this._currentLOD.billboardMode !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$transformNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransformNode"].BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {
            if (!this._billboardWorldMatrix) {
                this._billboardWorldMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"]();
            }
            const tempMaster = this._currentLOD._masterMesh;
            this._currentLOD._masterMesh = this;
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[7].copyFrom(this._currentLOD.position);
            this._currentLOD.position.set(0, 0, 0);
            this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(true));
            this._currentLOD.position.copyFrom(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[7]);
            this._currentLOD._masterMesh = tempMaster;
            return this._billboardWorldMatrix;
        }
        return super.getWorldMatrix();
    }
    get isAnInstance() {
        return true;
    }
    /**
     * Returns the current associated LOD AbstractMesh.
     * @param camera defines the camera to use to pick the LOD level
     * @returns a Mesh or `null` if no LOD is associated with the AbstractMesh
     */ getLOD(camera) {
        if (!camera) {
            return this;
        }
        const sourceMeshLODLevels = this.sourceMesh.getLODLevels();
        if (!sourceMeshLODLevels || sourceMeshLODLevels.length === 0) {
            this._currentLOD = this.sourceMesh;
        } else {
            const boundingInfo = this.getBoundingInfo();
            this._currentLOD = this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);
        }
        return this._currentLOD;
    }
    /**
     * @internal
     */ _preActivateForIntermediateRendering(renderId) {
        return this.sourceMesh._preActivateForIntermediateRendering(renderId);
    }
    /** @internal */ _syncSubMeshes() {
        this.releaseSubMeshes();
        if (this._sourceMesh.subMeshes) {
            for(let index = 0; index < this._sourceMesh.subMeshes.length; index++){
                this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);
            }
        }
        return this;
    }
    /** @internal */ _generatePointsArray() {
        return this._sourceMesh._generatePointsArray();
    }
    /** @internal */ _updateBoundingInfo() {
        if (this.hasBoundingInfo) {
            this.getBoundingInfo().update(this.worldMatrixFromCache);
        } else {
            this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache);
        }
        this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);
        return this;
    }
    /**
     * Creates a new InstancedMesh from the current mesh.
     *
     * Returns the clone.
     * @param name the cloned mesh name
     * @param newParent the optional Node to parent the clone to.
     * @param doNotCloneChildren if `true` the model children aren't cloned.
     * @param newSourceMesh if set this mesh will be used as the source mesh instead of ths instance's one
     * @returns the clone
     */ clone(name, newParent = null, doNotCloneChildren, newSourceMesh) {
        const result = (newSourceMesh || this._sourceMesh).createInstance(name);
        // Deep copy
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$deepCopier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DeepCopier"].DeepCopy(this, result, [
            "name",
            "subMeshes",
            "uniqueId",
            "parent",
            "lightSources",
            "receiveShadows",
            "material",
            "visibility",
            "skeleton",
            "sourceMesh",
            "isAnInstance",
            "facetNb",
            "isFacetDataEnabled",
            "isBlocked",
            "useBones",
            "hasInstances",
            "collider",
            "edgesRenderer",
            "forward",
            "up",
            "right",
            "absolutePosition",
            "absoluteScaling",
            "absoluteRotationQuaternion",
            "isWorldMatrixFrozen",
            "nonUniformScaling",
            "behaviors",
            "worldMatrixFromCache",
            "hasThinInstances",
            "hasBoundingInfo",
            "geometry"
        ], []);
        // Parent
        if (newParent) {
            result.parent = newParent;
        }
        if (!doNotCloneChildren) {
            // Children
            for(let index = 0; index < this.getScene().meshes.length; index++){
                const mesh = this.getScene().meshes[index];
                if (mesh.parent === this) {
                    mesh.clone(mesh.name, result);
                }
            }
        }
        result.computeWorldMatrix(true);
        this.onClonedObservable.notifyObservers(result);
        return result;
    }
    /**
     * Disposes the InstancedMesh.
     * Returns nothing.
     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
     */ dispose(doNotRecurse, disposeMaterialAndTextures = false) {
        // Remove from mesh
        this._sourceMesh.removeInstance(this);
        super.dispose(doNotRecurse, disposeMaterialAndTextures);
    }
    /**
     * @internal
     */ _serializeAsParent(serializationObject) {
        super._serializeAsParent(serializationObject);
        serializationObject.parentId = this._sourceMesh.uniqueId;
        serializationObject.parentInstanceIndex = this._indexInSourceMeshInstanceArray;
    }
    /**
     * Instantiate (when possible) or clone that node with its hierarchy
     * @param newParent defines the new parent to use for the instance (or clone)
     * @param options defines options to configure how copy is done
     * @param options.doNotInstantiate defines if the model must be instantiated or just cloned
     * @param options.newSourcedMesh newSourcedMesh the new source mesh for the instance (or clone)
     * @param onNewNodeCreated defines an option callback to call when a clone or an instance is created
     * @returns an instance (or a clone) of the current node with its hierarchy
     */ instantiateHierarchy(newParent = null, options, onNewNodeCreated) {
        const clone = this.clone("Clone of " + (this.name || this.id), newParent || this.parent, true, options && options.newSourcedMesh);
        if (clone) {
            if (onNewNodeCreated) {
                onNewNodeCreated(this, clone);
            }
        }
        for (const child of this.getChildTransformNodes(true)){
            child.instantiateHierarchy(clone, options, onNewNodeCreated);
        }
        return clone;
    }
}
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"].prototype.registerInstancedBuffer = function(kind, stride) {
    // Remove existing one
    this._userInstancedBuffersStorage?.vertexBuffers[kind]?.dispose();
    // Creates the instancedBuffer field if not present
    if (!this.instancedBuffers) {
        this.instancedBuffers = {};
        for (const instance of this.instances){
            instance.instancedBuffers = {};
        }
    }
    if (!this._userInstancedBuffersStorage) {
        this._userInstancedBuffersStorage = {
            data: {},
            vertexBuffers: {},
            strides: {},
            sizes: {},
            vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : undefined
        };
    }
    // Creates an empty property for this kind
    this.instancedBuffers[kind] = null;
    this._userInstancedBuffersStorage.strides[kind] = stride;
    this._userInstancedBuffersStorage.sizes[kind] = stride * 32; // Initial size
    this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);
    this._userInstancedBuffersStorage.vertexBuffers[kind] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"](this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);
    for (const instance of this.instances){
        instance.instancedBuffers[kind] = null;
    }
    this._invalidateInstanceVertexArrayObject();
    this._markSubMeshesAsAttributesDirty();
};
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"].prototype._processInstancedBuffers = function(visibleInstances, renderSelf) {
    const instanceCount = visibleInstances ? visibleInstances.length : 0;
    for(const kind in this.instancedBuffers){
        let size = this._userInstancedBuffersStorage.sizes[kind];
        const stride = this._userInstancedBuffersStorage.strides[kind];
        // Resize if required
        const expectedSize = (instanceCount + 1) * stride;
        while(size < expectedSize){
            size *= 2;
        }
        if (this._userInstancedBuffersStorage.data[kind].length != size) {
            this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);
            this._userInstancedBuffersStorage.sizes[kind] = size;
            if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {
                this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();
                this._userInstancedBuffersStorage.vertexBuffers[kind] = null;
            }
        }
        const data = this._userInstancedBuffersStorage.data[kind];
        // Update data buffer
        let offset = 0;
        if (renderSelf) {
            const value = this.instancedBuffers[kind];
            if (value.toArray) {
                value.toArray(data, offset);
            } else if (value.copyToArray) {
                value.copyToArray(data, offset);
            } else {
                data[offset] = value;
            }
            offset += stride;
        }
        for(let instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++){
            const instance = visibleInstances[instanceIndex];
            const value = instance.instancedBuffers[kind];
            if (value.toArray) {
                value.toArray(data, offset);
            } else if (value.copyToArray) {
                value.copyToArray(data, offset);
            } else {
                data[offset] = value;
            }
            offset += stride;
        }
        // Update vertex buffer
        if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {
            this._userInstancedBuffersStorage.vertexBuffers[kind] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"](this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);
            this._invalidateInstanceVertexArrayObject();
        } else {
            this._userInstancedBuffersStorage.vertexBuffers[kind].updateDirectly(data, 0);
        }
    }
};
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"].prototype._invalidateInstanceVertexArrayObject = function() {
    if (!this._userInstancedBuffersStorage || this._userInstancedBuffersStorage.vertexArrayObjects === undefined) {
        return;
    }
    for(const kind in this._userInstancedBuffersStorage.vertexArrayObjects){
        this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[kind]);
    }
    this._userInstancedBuffersStorage.vertexArrayObjects = {};
};
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"].prototype._disposeInstanceSpecificData = function() {
    for(const renderPassId in this._instanceDataStorage.renderPasses){
        this._instanceDataStorage.renderPasses[renderPassId].instancesBuffer?.dispose();
    }
    this._instanceDataStorage.renderPasses = {};
    while(this.instances.length){
        this.instances[0].dispose();
    }
    for(const kind in this.instancedBuffers){
        if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {
            this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();
        }
    }
    this._invalidateInstanceVertexArrayObject();
    this.instancedBuffers = {};
};
// Register Class Name
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$typeStore$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RegisterClass"])("BABYLON.InstancedMesh", InstancedMesh); //# sourceMappingURL=instancedMesh.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/groundMesh.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GroundMesh",
    ()=>GroundMesh
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.js [app-client] (ecmascript)");
;
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"]._GroundMeshParser = (parsedMesh, scene)=>{
    return GroundMesh.Parse(parsedMesh, scene);
};
class GroundMesh extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"] {
    constructor(name, scene){
        super(name, scene);
        /** If octree should be generated */ this.generateOctree = false;
    }
    /**
     * "GroundMesh"
     * @returns "GroundMesh"
     */ getClassName() {
        return "GroundMesh";
    }
    /**
     * The minimum of x and y subdivisions
     */ get subdivisions() {
        return Math.min(this._subdivisionsX, this._subdivisionsY);
    }
    /**
     * X subdivisions
     */ get subdivisionsX() {
        return this._subdivisionsX;
    }
    /**
     * Y subdivisions
     */ get subdivisionsY() {
        return this._subdivisionsY;
    }
    /**
     * This function will divide the mesh into submeshes and update an octree to help to select the right submeshes
     * for rendering, picking and collision computations. Please note that you must have a decent number of submeshes
     * to get performance improvements when using an octree.
     * @param chunksCount the number of submeshes the mesh will be divided into
     * @param octreeBlocksSize the maximum size of the octree blocks (Default: 32)
     */ optimize(chunksCount, octreeBlocksSize = 32) {
        this._subdivisionsX = chunksCount;
        this._subdivisionsY = chunksCount;
        this.subdivide(chunksCount);
        // Call the octree system optimization if it is defined.
        const thisAsAny = this;
        if (thisAsAny.createOrUpdateSubmeshesOctree) {
            thisAsAny.createOrUpdateSubmeshesOctree(octreeBlocksSize);
        }
    }
    /**
     * Returns a height (y) value in the World system :
     * the ground altitude at the coordinates (x, z) expressed in the World system.
     * @param x x coordinate
     * @param z z coordinate
     * @returns the ground y position if (x, z) are outside the ground surface.
     */ getHeightAtCoordinates(x, z) {
        const world = this.getWorldMatrix();
        const invMat = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[5];
        world.invertToRef(invMat);
        const tmpVect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[8];
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformCoordinatesFromFloatsToRef(x, 0.0, z, invMat, tmpVect); // transform x,z in the mesh local space
        x = tmpVect.x;
        z = tmpVect.z;
        if (x < this._minX || x >= this._maxX || z <= this._minZ || z > this._maxZ) {
            return this.position.y;
        }
        if (!this._heightQuads || this._heightQuads.length == 0) {
            this._initHeightQuads();
            this._computeHeightQuads();
        }
        const facet = this._getFacetAt(x, z);
        const y = -(facet.x * x + facet.z * z + facet.w) / facet.y;
        // return y in the World system
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformCoordinatesFromFloatsToRef(0.0, y, 0.0, world, tmpVect);
        return tmpVect.y;
    }
    /**
     * Returns a normalized vector (Vector3) orthogonal to the ground
     * at the ground coordinates (x, z) expressed in the World system.
     * @param x x coordinate
     * @param z z coordinate
     * @returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.
     */ getNormalAtCoordinates(x, z) {
        const normal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0.0, 1.0, 0.0);
        this.getNormalAtCoordinatesToRef(x, z, normal);
        return normal;
    }
    /**
     * Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground
     * at the ground coordinates (x, z) expressed in the World system.
     * Doesn't update the reference Vector3 if (x, z) are outside the ground surface.
     * @param x x coordinate
     * @param z z coordinate
     * @param ref vector to store the result
     * @returns the GroundMesh.
     */ getNormalAtCoordinatesToRef(x, z, ref) {
        const world = this.getWorldMatrix();
        const tmpMat = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[5];
        world.invertToRef(tmpMat);
        const tmpVect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[8];
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformCoordinatesFromFloatsToRef(x, 0.0, z, tmpMat, tmpVect); // transform x,z in the mesh local space
        x = tmpVect.x;
        z = tmpVect.z;
        if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {
            return this;
        }
        if (!this._heightQuads || this._heightQuads.length == 0) {
            this._initHeightQuads();
            this._computeHeightQuads();
        }
        const facet = this._getFacetAt(x, z);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformNormalFromFloatsToRef(facet.x, facet.y, facet.z, world, ref);
        return this;
    }
    /**
     * Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()
     * if the ground has been updated.
     * This can be used in the render loop.
     * @returns the GroundMesh.
     */ updateCoordinateHeights() {
        if (!this._heightQuads || this._heightQuads.length == 0) {
            this._initHeightQuads();
        }
        this._computeHeightQuads();
        return this;
    }
    // Returns the element "facet" from the heightQuads array relative to (x, z) local coordinates
    _getFacetAt(x, z) {
        // retrieve col and row from x, z coordinates in the ground local system
        const col = Math.floor((x + this._maxX) * this._subdivisionsX / this._width);
        const row = Math.floor(-(z + this._maxZ) * this._subdivisionsY / this._height + this._subdivisionsY);
        const quad = this._heightQuads[row * this._subdivisionsX + col];
        let facet;
        if (z < quad.slope.x * x + quad.slope.y) {
            facet = quad.facet1;
        } else {
            facet = quad.facet2;
        }
        return facet;
    }
    //  Creates and populates the heightMap array with "facet" elements :
    // a quad is two triangular facets separated by a slope, so a "facet" element is 1 slope + 2 facets
    // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h
    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0
    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0
    // Returns the GroundMesh.
    _initHeightQuads() {
        const subdivisionsX = this._subdivisionsX;
        const subdivisionsY = this._subdivisionsY;
        this._heightQuads = [];
        for(let row = 0; row < subdivisionsY; row++){
            for(let col = 0; col < subdivisionsX; col++){
                const quad = {
                    slope: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"].Zero(),
                    facet1: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector4"](0.0, 0.0, 0.0, 0.0),
                    facet2: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector4"](0.0, 0.0, 0.0, 0.0)
                };
                this._heightQuads[row * subdivisionsX + col] = quad;
            }
        }
        return this;
    }
    // Compute each quad element values and update the heightMap array :
    // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h
    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0
    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0
    // Returns the GroundMesh.
    _computeHeightQuads() {
        const positions = this.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind);
        if (!positions) {
            return this;
        }
        const v1 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[3];
        const v2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[2];
        const v3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[1];
        const v4 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[0];
        const v1v2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[4];
        const v1v3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[5];
        const v1v4 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[6];
        const norm1 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[7];
        const norm2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[8];
        let i = 0;
        let j = 0;
        let k = 0;
        let cd = 0; // 2D slope coefficient : z = cd * x + h
        let h = 0;
        let d1 = 0; // facet plane equation : ax + by + cz + d = 0
        let d2 = 0;
        const subdivisionsX = this._subdivisionsX;
        const subdivisionsY = this._subdivisionsY;
        for(let row = 0; row < subdivisionsY; row++){
            for(let col = 0; col < subdivisionsX; col++){
                i = col * 3;
                j = row * (subdivisionsX + 1) * 3;
                k = (row + 1) * (subdivisionsX + 1) * 3;
                v1.x = positions[j + i];
                v1.y = positions[j + i + 1];
                v1.z = positions[j + i + 2];
                v2.x = positions[j + i + 3];
                v2.y = positions[j + i + 4];
                v2.z = positions[j + i + 5];
                v3.x = positions[k + i];
                v3.y = positions[k + i + 1];
                v3.z = positions[k + i + 2];
                v4.x = positions[k + i + 3];
                v4.y = positions[k + i + 4];
                v4.z = positions[k + i + 5];
                // 2D slope V1V4
                cd = (v4.z - v1.z) / (v4.x - v1.x);
                h = v1.z - cd * v1.x; // v1 belongs to the slope
                // facet equations :
                // we compute each facet normal vector
                // the equation of the facet plane is : norm.x * x + norm.y * y + norm.z * z + d = 0
                // we compute the value d by applying the equation to v1 which belongs to the plane
                // then we store the facet equation in a Vector4
                v2.subtractToRef(v1, v1v2);
                v3.subtractToRef(v1, v1v3);
                v4.subtractToRef(v1, v1v4);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].CrossToRef(v1v4, v1v3, norm1); // caution : CrossToRef uses the Tmp class
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].CrossToRef(v1v2, v1v4, norm2);
                norm1.normalize();
                norm2.normalize();
                d1 = -(norm1.x * v1.x + norm1.y * v1.y + norm1.z * v1.z);
                d2 = -(norm2.x * v2.x + norm2.y * v2.y + norm2.z * v2.z);
                const quad = this._heightQuads[row * subdivisionsX + col];
                quad.slope.copyFromFloats(cd, h);
                quad.facet1.copyFromFloats(norm1.x, norm1.y, norm1.z, d1);
                quad.facet2.copyFromFloats(norm2.x, norm2.y, norm2.z, d2);
            }
        }
        return this;
    }
    /**
     * Serializes this ground mesh
     * @param serializationObject object to write serialization to
     */ serialize(serializationObject) {
        super.serialize(serializationObject);
        serializationObject.subdivisionsX = this._subdivisionsX;
        serializationObject.subdivisionsY = this._subdivisionsY;
        serializationObject.minX = this._minX;
        serializationObject.maxX = this._maxX;
        serializationObject.minZ = this._minZ;
        serializationObject.maxZ = this._maxZ;
        serializationObject.width = this._width;
        serializationObject.height = this._height;
    }
    /**
     * Parses a serialized ground mesh
     * @param parsedMesh the serialized mesh
     * @param scene the scene to create the ground mesh in
     * @returns the created ground mesh
     */ static Parse(parsedMesh, scene) {
        const result = new GroundMesh(parsedMesh.name, scene);
        result._subdivisionsX = parsedMesh.subdivisionsX || 1;
        result._subdivisionsY = parsedMesh.subdivisionsY || 1;
        result._minX = parsedMesh.minX;
        result._maxX = parsedMesh.maxX;
        result._minZ = parsedMesh.minZ;
        result._maxZ = parsedMesh.maxZ;
        result._width = parsedMesh.width;
        result._height = parsedMesh.height;
        return result;
    }
} //# sourceMappingURL=groundMesh.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/buffer.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

/**
 * This is here for backwards compatibility with 4.2
 * @internal
 */ __turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/buffer.js [app-client] (ecmascript)"); //# sourceMappingURL=buffer.js.map
;
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/linesMesh.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "InstancedLinesMesh",
    ()=>InstancedLinesMesh,
    "LinesMesh",
    ()=>LinesMesh
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.color.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$instancedMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/instancedMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/material.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$shaderMaterial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/shaderMaterial.js [app-client] (ecmascript)");
;
;
;
;
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"]._LinesMeshParser = (parsedMesh, scene)=>{
    return LinesMesh.Parse(parsedMesh, scene);
};
class LinesMesh extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"] {
    _isShaderMaterial(shader) {
        if (!shader) {
            return false;
        }
        return shader.getClassName() === "ShaderMaterial";
    }
    /**
     * Creates a new LinesMesh
     * @param name defines the name
     * @param scene defines the hosting scene
     * @param parent defines the parent mesh if any
     * @param source defines the optional source LinesMesh used to clone data from
     * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.
     * When false, achieved by calling a clone(), also passing False.
     * This will make creation of children, recursive.
     * @param useVertexColor defines if this LinesMesh supports vertex color
     * @param useVertexAlpha defines if this LinesMesh supports vertex alpha
     * @param material material to use to draw the line. If not provided, will create a new one
     */ constructor(name, scene = null, parent = null, source = null, doNotCloneChildren, /**
     * If vertex color should be applied to the mesh
     */ useVertexColor, /**
     * If vertex alpha should be applied to the mesh
     */ useVertexAlpha, material){
        super(name, scene, parent, source, doNotCloneChildren);
        this.useVertexColor = useVertexColor;
        this.useVertexAlpha = useVertexAlpha;
        /**
         * Color of the line (Default: White)
         */ this.color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color3"](1, 1, 1);
        /**
         * Alpha of the line (Default: 1)
         */ this.alpha = 1;
        /** Shader language used by the material */ this._shaderLanguage = 0 /* ShaderLanguage.GLSL */ ;
        this._ownsMaterial = false;
        if (source) {
            this.color = source.color.clone();
            this.alpha = source.alpha;
            this.useVertexColor = source.useVertexColor;
            this.useVertexAlpha = source.useVertexAlpha;
        }
        this.intersectionThreshold = 0.1;
        const defines = [];
        const options = {
            attributes: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind
            ],
            uniforms: [
                "world",
                "viewProjection"
            ],
            needAlphaBlending: true,
            defines: defines,
            useClipPlane: null,
            shaderLanguage: 0 /* ShaderLanguage.GLSL */ 
        };
        if (!this.useVertexAlpha) {
            options.needAlphaBlending = false;
        } else {
            options.defines.push("#define VERTEXALPHA");
        }
        if (!this.useVertexColor) {
            options.uniforms.push("color");
            this._color4 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color4"]();
        } else {
            options.defines.push("#define VERTEXCOLOR");
            options.attributes.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorKind);
        }
        if (material) {
            this.material = material;
        } else {
            const engine = this.getScene().getEngine();
            if (engine.isWebGPU && !LinesMesh.ForceGLSL) {
                this._shaderLanguage = 1 /* ShaderLanguage.WGSL */ ;
            }
            options.shaderLanguage = this._shaderLanguage;
            options.extraInitializationsAsync = async ()=>{
                if (this._shaderLanguage === 1 /* ShaderLanguage.WGSL */ ) {
                    await Promise.all([
                        __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/color.vertex.js [app-client] (ecmascript, async loader)"),
                        __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/color.fragment.js [app-client] (ecmascript, async loader)")
                    ]);
                } else {
                    await Promise.all([
                        __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/color.vertex.js [app-client] (ecmascript, async loader)"),
                        __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/color.fragment.js [app-client] (ecmascript, async loader)")
                    ]);
                }
            };
            const material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$shaderMaterial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"]("colorShader", this.getScene(), "color", options, false);
            material.doNotSerialize = true;
            this._ownsMaterial = true;
            this._setInternalMaterial(material);
        }
    }
    /**
     * @returns the string "LineMesh"
     */ getClassName() {
        return "LinesMesh";
    }
    /**
     * @internal
     */ get material() {
        return this._internalAbstractMeshDataInfo._material;
    }
    /**
     * @internal
     */ set material(value) {
        const currentMaterial = this.material;
        if (currentMaterial === value) {
            return;
        }
        const shouldDispose = currentMaterial && this._ownsMaterial;
        this._ownsMaterial = false;
        this._setInternalMaterial(value);
        if (shouldDispose) {
            currentMaterial?.dispose();
        }
    }
    _setInternalMaterial(material) {
        this._setMaterial(material);
        if (this.material) {
            this.material.fillMode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Material"].LineListDrawMode;
            this.material.disableLighting = true;
        }
    }
    /**
     * @internal
     */ get checkCollisions() {
        return false;
    }
    set checkCollisions(value) {
    // Just ignore it
    }
    /**
     * @internal
     */ _bind(_subMesh, colorEffect) {
        if (!this._geometry) {
            return this;
        }
        // VBOs
        const indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();
        if (!this._userInstancedBuffersStorage || this.hasThinInstances) {
            this._geometry._bind(colorEffect, indexToBind);
        } else {
            this._geometry._bind(colorEffect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);
        }
        // Color
        if (!this.useVertexColor && this._isShaderMaterial(this.material)) {
            const { r, g, b } = this.color;
            this._color4.set(r, g, b, this.alpha);
            this.material.setColor4("color", this._color4);
        }
        return this;
    }
    /**
     * @internal
     */ _draw(subMesh, fillMode, instancesCount) {
        if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {
            return this;
        }
        const engine = this.getScene().getEngine();
        // Draw order
        if (this._unIndexed) {
            engine.drawArraysType(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Material"].LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);
        } else {
            engine.drawElementsType(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Material"].LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);
        }
        return this;
    }
    /**
     * Disposes of the line mesh (this disposes of the automatically created material if not instructed otherwise).
     * @param doNotRecurse If children should be disposed
     * @param disposeMaterialAndTextures This parameter is used to force disposing the material in case it is not the default one
     * @param doNotDisposeMaterial If the material should not be disposed (default: false, meaning the material might be disposed)
     */ dispose(doNotRecurse, disposeMaterialAndTextures = false, doNotDisposeMaterial) {
        if (!doNotDisposeMaterial) {
            if (this._ownsMaterial) {
                this.material?.dispose(false, false, true);
            } else if (disposeMaterialAndTextures) {
                this.material?.dispose(false, false, true);
            }
        }
        super.dispose(doNotRecurse);
    }
    /**
     * Returns a new LineMesh object cloned from the current one.
     * @param name defines the cloned mesh name
     * @param newParent defines the new mesh parent
     * @param doNotCloneChildren if set to true, none of the mesh children are cloned (false by default)
     * @returns the new mesh
     */ clone(name, newParent = null, doNotCloneChildren) {
        if (newParent && newParent._addToSceneRootNodes === undefined) {
            const createOptions = newParent;
            createOptions.source = this;
            return new LinesMesh(name, this.getScene(), createOptions.parent, createOptions.source, createOptions.doNotCloneChildren);
        }
        return new LinesMesh(name, this.getScene(), newParent, this, doNotCloneChildren);
    }
    /**
     * Creates a new InstancedLinesMesh object from the mesh model.
     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances
     * @param name defines the name of the new instance
     * @returns a new InstancedLinesMesh
     */ createInstance(name) {
        const instance = new InstancedLinesMesh(name, this);
        if (this.instancedBuffers) {
            instance.instancedBuffers = {};
            for(const key in this.instancedBuffers){
                instance.instancedBuffers[key] = this.instancedBuffers[key];
            }
        }
        return instance;
    }
    /**
     * Serializes this ground mesh
     * @param serializationObject object to write serialization to
     */ serialize(serializationObject) {
        super.serialize(serializationObject);
        serializationObject.color = this.color.asArray();
        serializationObject.alpha = this.alpha;
    }
    /**
     * Parses a serialized ground mesh
     * @param parsedMesh the serialized mesh
     * @param scene the scene to create the ground mesh in
     * @returns the created ground mesh
     */ static Parse(parsedMesh, scene) {
        const result = new LinesMesh(parsedMesh.name, scene);
        result.color = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color3"].FromArray(parsedMesh.color);
        result.alpha = parsedMesh.alpha;
        return result;
    }
}
/**
 * Force all the LineMeshes to compile their default color material to glsl even on WebGPU engines.
 * False by default. This is mostly meant for backward compatibility.
 */ LinesMesh.ForceGLSL = false;
class InstancedLinesMesh extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$instancedMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstancedMesh"] {
    constructor(name, source){
        super(name, source);
        this.intersectionThreshold = source.intersectionThreshold;
    }
    /**
     * @returns the string "InstancedLinesMesh".
     */ getClassName() {
        return "InstancedLinesMesh";
    }
} //# sourceMappingURL=linesMesh.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/polygonMesh.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Polygon",
    ()=>Polygon,
    "PolygonMeshBuilder",
    ()=>PolygonMeshBuilder
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/logger.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.vertexData.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$path$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.path.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engineStore$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Engines/engineStore.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
/**
 * Vector2 wth index property
 */ class IndexedVector2 extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"] {
    constructor(original, /** Index of the vector2 */ index){
        super(original.x, original.y);
        this.index = index;
    }
}
/**
 * Defines points to create a polygon
 */ class PolygonPoints {
    constructor(){
        this.elements = [];
    }
    add(originalPoints) {
        const result = [];
        for (const point of originalPoints){
            const newPoint = new IndexedVector2(point, this.elements.length);
            result.push(newPoint);
            this.elements.push(newPoint);
        }
        return result;
    }
    computeBounds() {
        const lmin = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](this.elements[0].x, this.elements[0].y);
        const lmax = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](this.elements[0].x, this.elements[0].y);
        for (const point of this.elements){
            // x
            if (point.x < lmin.x) {
                lmin.x = point.x;
            } else if (point.x > lmax.x) {
                lmax.x = point.x;
            }
            // y
            if (point.y < lmin.y) {
                lmin.y = point.y;
            } else if (point.y > lmax.y) {
                lmax.y = point.y;
            }
        }
        return {
            min: lmin,
            max: lmax,
            width: lmax.x - lmin.x,
            height: lmax.y - lmin.y
        };
    }
}
class Polygon {
    /**
     * Creates a rectangle
     * @param xmin bottom X coord
     * @param ymin bottom Y coord
     * @param xmax top X coord
     * @param ymax top Y coord
     * @returns points that make the resulting rectangle
     */ static Rectangle(xmin, ymin, xmax, ymax) {
        return [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](xmin, ymin),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](xmax, ymin),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](xmax, ymax),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](xmin, ymax)
        ];
    }
    /**
     * Creates a circle
     * @param radius radius of circle
     * @param cx scale in x
     * @param cy scale in y
     * @param numberOfSides number of sides that make up the circle
     * @returns points that make the resulting circle
     */ static Circle(radius, cx = 0, cy = 0, numberOfSides = 32) {
        const result = [];
        let angle = 0;
        const increment = Math.PI * 2 / numberOfSides;
        for(let i = 0; i < numberOfSides; i++){
            result.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius));
            angle -= increment;
        }
        return result;
    }
    /**
     * Creates a polygon from input string
     * @param input Input polygon data
     * @returns the parsed points
     */ static Parse(input) {
        const floats = input.split(/[^-+eE.\d]+/).map(parseFloat).filter((val)=>!isNaN(val));
        let i;
        const result = [];
        for(i = 0; i < (floats.length & 0x7ffffffe); i += 2){
            result.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](floats[i], floats[i + 1]));
        }
        return result;
    }
    /**
     * Starts building a polygon from x and y coordinates
     * @param x x coordinate
     * @param y y coordinate
     * @returns the started path2
     */ static StartingAt(x, y) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$path$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path2"].StartingAt(x, y);
    }
}
class PolygonMeshBuilder {
    _addToepoint(points) {
        for (const p of points){
            this._epoints.push(p.x, p.y);
        }
    }
    /**
     * Creates a PolygonMeshBuilder
     * @param name name of the builder
     * @param contours Path of the polygon
     * @param scene scene to add to when creating the mesh
     * @param earcutInjection can be used to inject your own earcut reference
     */ constructor(name, contours, scene, earcutInjection = earcut){
        this._points = new PolygonPoints();
        this._outlinepoints = new PolygonPoints();
        this._holes = new Array();
        this._epoints = new Array();
        this._eholes = new Array();
        this.bjsEarcut = earcutInjection;
        this._name = name;
        this._scene = scene || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engineStore$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EngineStore"].LastCreatedScene;
        let points;
        if (contours instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$path$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path2"]) {
            points = contours.getPoints();
        } else {
            points = contours;
        }
        this._addToepoint(points);
        this._points.add(points);
        this._outlinepoints.add(points);
        if (typeof this.bjsEarcut === "undefined") {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].Warn("Earcut was not found, the polygon will not be built.");
        }
    }
    /**
     * Adds a hole within the polygon
     * @param hole Array of points defining the hole
     * @returns this
     */ addHole(hole) {
        this._points.add(hole);
        const holepoints = new PolygonPoints();
        holepoints.add(hole);
        this._holes.push(holepoints);
        this._eholes.push(this._epoints.length / 2);
        this._addToepoint(hole);
        return this;
    }
    /**
     * Creates the polygon
     * @param updatable If the mesh should be updatable
     * @param depth The depth of the mesh created
     * @param smoothingThreshold Dot product threshold for smoothed normals
     * @returns the created mesh
     */ build(updatable = false, depth = 0, smoothingThreshold = 2) {
        const result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](this._name, this._scene);
        const vertexData = this.buildVertexData(depth, smoothingThreshold);
        result.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind, vertexData.positions, updatable);
        result.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].NormalKind, vertexData.normals, updatable);
        result.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UVKind, vertexData.uvs, updatable);
        result.setIndices(vertexData.indices);
        return result;
    }
    /**
     * Creates the polygon
     * @param depth The depth of the mesh created
     * @param smoothingThreshold Dot product threshold for smoothed normals
     * @returns the created VertexData
     */ buildVertexData(depth = 0, smoothingThreshold = 2) {
        const result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexData"]();
        const normals = [];
        const positions = [];
        const uvs = [];
        const bounds = this._points.computeBounds();
        for (const p of this._points.elements){
            normals.push(0, 1.0, 0);
            positions.push(p.x, 0, p.y);
            uvs.push((p.x - bounds.min.x) / bounds.width, (p.y - bounds.min.y) / bounds.height);
        }
        const indices = [];
        const res = this.bjsEarcut(this._epoints, this._eholes, 2);
        for(let i = 0; i < res.length; i++){
            indices.push(res[i]);
        }
        if (depth > 0) {
            const positionscount = positions.length / 3; //get the current pointcount
            for (const p of this._points.elements){
                //add the elements at the depth
                normals.push(0, -1.0, 0);
                positions.push(p.x, -depth, p.y);
                uvs.push(1 - (p.x - bounds.min.x) / bounds.width, 1 - (p.y - bounds.min.y) / bounds.height);
            }
            const totalCount = indices.length;
            for(let i = 0; i < totalCount; i += 3){
                const i0 = indices[i + 0];
                const i1 = indices[i + 1];
                const i2 = indices[i + 2];
                indices.push(i2 + positionscount);
                indices.push(i1 + positionscount);
                indices.push(i0 + positionscount);
            }
            //Add the sides
            this._addSide(positions, normals, uvs, indices, bounds, this._outlinepoints, depth, false, smoothingThreshold);
            for (const hole of this._holes){
                this._addSide(positions, normals, uvs, indices, bounds, hole, depth, true, smoothingThreshold);
            }
        }
        result.indices = indices;
        result.positions = positions;
        result.normals = normals;
        result.uvs = uvs;
        return result;
    }
    /**
     * Adds a side to the polygon
     * @param positions points that make the polygon
     * @param normals normals of the polygon
     * @param uvs uvs of the polygon
     * @param indices indices of the polygon
     * @param bounds bounds of the polygon
     * @param points points of the polygon
     * @param depth depth of the polygon
     * @param flip flip of the polygon
     * @param smoothingThreshold
     */ _addSide(positions, normals, uvs, indices, bounds, points, depth, flip, smoothingThreshold) {
        let startIndex = positions.length / 3;
        let ulength = 0;
        for(let i = 0; i < points.elements.length; i++){
            const p = points.elements[i];
            const p1 = points.elements[(i + 1) % points.elements.length];
            positions.push(p.x, 0, p.y);
            positions.push(p.x, -depth, p.y);
            positions.push(p1.x, 0, p1.y);
            positions.push(p1.x, -depth, p1.y);
            const p0 = points.elements[(i + points.elements.length - 1) % points.elements.length];
            const p2 = points.elements[(i + 2) % points.elements.length];
            let vc = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](-(p1.y - p.y), 0, p1.x - p.x);
            let vp = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](-(p.y - p0.y), 0, p.x - p0.x);
            let vn = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](-(p2.y - p1.y), 0, p2.x - p1.x);
            if (!flip) {
                vc = vc.scale(-1);
                vp = vp.scale(-1);
                vn = vn.scale(-1);
            }
            const vcNorm = vc.normalizeToNew();
            let vpNorm = vp.normalizeToNew();
            let vnNorm = vn.normalizeToNew();
            const dotp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Dot(vpNorm, vcNorm);
            if (dotp > smoothingThreshold) {
                if (dotp < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Epsilon"] - 1) {
                    vpNorm = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](p.x, 0, p.y).subtract(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](p1.x, 0, p1.y)).normalize();
                } else {
                    // cheap average weighed by side length
                    vpNorm = vp.add(vc).normalize();
                }
            } else {
                vpNorm = vcNorm;
            }
            const dotn = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Dot(vn, vc);
            if (dotn > smoothingThreshold) {
                if (dotn < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Epsilon"] - 1) {
                    // back to back
                    vnNorm = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](p1.x, 0, p1.y).subtract(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](p.x, 0, p.y)).normalize();
                } else {
                    // cheap average weighed by side length
                    vnNorm = vn.add(vc).normalize();
                }
            } else {
                vnNorm = vcNorm;
            }
            uvs.push(ulength / bounds.width, 0);
            uvs.push(ulength / bounds.width, 1);
            ulength += vc.length();
            uvs.push(ulength / bounds.width, 0);
            uvs.push(ulength / bounds.width, 1);
            normals.push(vpNorm.x, vpNorm.y, vpNorm.z);
            normals.push(vpNorm.x, vpNorm.y, vpNorm.z);
            normals.push(vnNorm.x, vnNorm.y, vnNorm.z);
            normals.push(vnNorm.x, vnNorm.y, vnNorm.z);
            if (!flip) {
                indices.push(startIndex);
                indices.push(startIndex + 1);
                indices.push(startIndex + 2);
                indices.push(startIndex + 1);
                indices.push(startIndex + 3);
                indices.push(startIndex + 2);
            } else {
                indices.push(startIndex);
                indices.push(startIndex + 2);
                indices.push(startIndex + 1);
                indices.push(startIndex + 1);
                indices.push(startIndex + 2);
                indices.push(startIndex + 3);
            }
            startIndex += 4;
        }
    }
} //# sourceMappingURL=polygonMesh.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/geodesicMesh.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint-disable @typescript-eslint/naming-convention */ __turbopack_context__.s([
    "GeodesicData",
    ()=>GeodesicData,
    "PolyhedronData",
    ()=>PolyhedronData,
    "_PrimaryIsoTriangle",
    ()=>_PrimaryIsoTriangle
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.scalar.functions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$isovector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.isovector.js [app-client] (ecmascript)");
;
;
;
;
class _PrimaryIsoTriangle {
    constructor(){
        this.cartesian = [];
        this.vertices = [];
        this.max = [];
        this.min = [];
        this.closestTo = [];
        this.innerFacets = [];
        this.isoVecsABOB = [];
        this.isoVecsOBOA = [];
        this.isoVecsBAOA = [];
        this.vertexTypes = [];
        // eslint-disable-next-line @typescript-eslint/naming-convention
        this.IDATA = new PolyhedronData("icosahedron", "Regular", [
            [
                0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHI"],
                -1
            ],
            [
                -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHI"],
                1,
                0
            ],
            [
                -1,
                0,
                -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHI"]
            ],
            [
                1,
                0,
                -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHI"]
            ],
            [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHI"],
                1,
                0
            ],
            [
                0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHI"],
                1
            ],
            [
                -1,
                0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHI"]
            ],
            [
                -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHI"],
                -1,
                0
            ],
            [
                0,
                -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHI"],
                -1
            ],
            [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHI"],
                -1,
                0
            ],
            [
                1,
                0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHI"]
            ],
            [
                0,
                -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHI"],
                1
            ]
        ], [
            [
                0,
                2,
                1
            ],
            [
                0,
                3,
                2
            ],
            [
                0,
                4,
                3
            ],
            [
                0,
                5,
                4
            ],
            [
                0,
                1,
                5
            ],
            [
                7,
                6,
                1
            ],
            [
                8,
                7,
                2
            ],
            [
                9,
                8,
                3
            ],
            [
                10,
                9,
                4
            ],
            [
                6,
                10,
                5
            ],
            [
                2,
                7,
                1
            ],
            [
                3,
                8,
                2
            ],
            [
                4,
                9,
                3
            ],
            [
                5,
                10,
                4
            ],
            [
                1,
                6,
                5
            ],
            [
                11,
                6,
                7
            ],
            [
                11,
                7,
                8
            ],
            [
                11,
                8,
                9
            ],
            [
                11,
                9,
                10
            ],
            [
                11,
                10,
                6
            ]
        ]);
    }
    /**
     * Creates the PrimaryIsoTriangle Triangle OAB
     * @param m an integer
     * @param n an integer
     */ //operators
    setIndices() {
        let indexCount = 12; // 12 vertices already assigned
        const vecToidx = {}; //maps iso-vectors to indexCount;
        const m = this.m;
        const n = this.n;
        let g = m; // hcf of m, n when n != 0
        let m1 = 1;
        let n1 = 0;
        if (n !== 0) {
            g = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HighestCommonFactor"])(m, n);
        }
        m1 = m / g;
        n1 = n / g;
        let fr; //face to the right of current face
        let rot; //rotation about which vertex for fr
        let O;
        let A;
        let B;
        const oVec = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$isovector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsoVector"].Zero();
        const aVec = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$isovector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsoVector"](m, n);
        const bVec = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$isovector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsoVector"](-n, m + n);
        const oaVec = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$isovector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsoVector"].Zero();
        const abVec = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$isovector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsoVector"].Zero();
        const obVec = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$isovector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsoVector"].Zero();
        let verts = [];
        let idx;
        let idxR;
        let isoId;
        let isoIdR;
        const closestTo = [];
        const vDist = this.vertByDist;
        const matchIdx = (f, fr, isoId, isoIdR)=>{
            idx = f + "|" + isoId;
            idxR = fr + "|" + isoIdR;
            if (!(idx in vecToidx || idxR in vecToidx)) {
                vecToidx[idx] = indexCount;
                vecToidx[idxR] = indexCount;
                indexCount++;
            } else if (idx in vecToidx && !(idxR in vecToidx)) {
                vecToidx[idxR] = vecToidx[idx];
            } else if (idxR in vecToidx && !(idx in vecToidx)) {
                vecToidx[idx] = vecToidx[idxR];
            }
            if (vDist[isoId][0] > 2) {
                closestTo[vecToidx[idx]] = [
                    -vDist[isoId][0],
                    vDist[isoId][1],
                    vecToidx[idx]
                ];
            } else {
                closestTo[vecToidx[idx]] = [
                    verts[vDist[isoId][0]],
                    vDist[isoId][1],
                    vecToidx[idx]
                ];
            }
        };
        this.IDATA.edgematch = [
            [
                1,
                "B"
            ],
            [
                2,
                "B"
            ],
            [
                3,
                "B"
            ],
            [
                4,
                "B"
            ],
            [
                0,
                "B"
            ],
            [
                10,
                "O",
                14,
                "A"
            ],
            [
                11,
                "O",
                10,
                "A"
            ],
            [
                12,
                "O",
                11,
                "A"
            ],
            [
                13,
                "O",
                12,
                "A"
            ],
            [
                14,
                "O",
                13,
                "A"
            ],
            [
                0,
                "O"
            ],
            [
                1,
                "O"
            ],
            [
                2,
                "O"
            ],
            [
                3,
                "O"
            ],
            [
                4,
                "O"
            ],
            [
                19,
                "B",
                5,
                "A"
            ],
            [
                15,
                "B",
                6,
                "A"
            ],
            [
                16,
                "B",
                7,
                "A"
            ],
            [
                17,
                "B",
                8,
                "A"
            ],
            [
                18,
                "B",
                9,
                "A"
            ]
        ];
        /***edges AB to OB***** rotation about B*/ for(let f = 0; f < 20; f++){
            //f current face
            verts = this.IDATA.face[f];
            O = verts[2];
            A = verts[1];
            B = verts[0];
            isoId = oVec.x + "|" + oVec.y;
            idx = f + "|" + isoId;
            if (!(idx in vecToidx)) {
                vecToidx[idx] = O;
                closestTo[O] = [
                    verts[vDist[isoId][0]],
                    vDist[isoId][1]
                ];
            }
            isoId = aVec.x + "|" + aVec.y;
            idx = f + "|" + isoId;
            if (!(idx in vecToidx)) {
                vecToidx[idx] = A;
                closestTo[A] = [
                    verts[vDist[isoId][0]],
                    vDist[isoId][1]
                ];
            }
            isoId = bVec.x + "|" + bVec.y;
            idx = f + "|" + isoId;
            if (!(idx in vecToidx)) {
                vecToidx[idx] = B;
                closestTo[B] = [
                    verts[vDist[isoId][0]],
                    vDist[isoId][1]
                ];
            }
            //for edge vertices
            fr = this.IDATA.edgematch[f][0];
            rot = this.IDATA.edgematch[f][1];
            if (rot === "B") {
                for(let i = 1; i < g; i++){
                    abVec.x = m - i * (m1 + n1);
                    abVec.y = n + i * m1;
                    obVec.x = -i * n1;
                    obVec.y = i * (m1 + n1);
                    isoId = abVec.x + "|" + abVec.y;
                    isoIdR = obVec.x + "|" + obVec.y;
                    matchIdx(f, fr, isoId, isoIdR);
                }
            }
            if (rot === "O") {
                for(let i = 1; i < g; i++){
                    obVec.x = -i * n1;
                    obVec.y = i * (m1 + n1);
                    oaVec.x = i * m1;
                    oaVec.y = i * n1;
                    isoId = obVec.x + "|" + obVec.y;
                    isoIdR = oaVec.x + "|" + oaVec.y;
                    matchIdx(f, fr, isoId, isoIdR);
                }
            }
            fr = this.IDATA.edgematch[f][2];
            rot = this.IDATA.edgematch[f][3];
            if (rot && rot === "A") {
                for(let i = 1; i < g; i++){
                    oaVec.x = i * m1;
                    oaVec.y = i * n1;
                    abVec.x = m - (g - i) * (m1 + n1); //reversed for BA
                    abVec.y = n + (g - i) * m1; //reversed for BA
                    isoId = oaVec.x + "|" + oaVec.y;
                    isoIdR = abVec.x + "|" + abVec.y;
                    matchIdx(f, fr, isoId, isoIdR);
                }
            }
            for(let i = 0; i < this.vertices.length; i++){
                isoId = this.vertices[i].x + "|" + this.vertices[i].y;
                idx = f + "|" + isoId;
                if (!(idx in vecToidx)) {
                    vecToidx[idx] = indexCount++;
                    if (vDist[isoId][0] > 2) {
                        closestTo[vecToidx[idx]] = [
                            -vDist[isoId][0],
                            vDist[isoId][1],
                            vecToidx[idx]
                        ];
                    } else {
                        closestTo[vecToidx[idx]] = [
                            verts[vDist[isoId][0]],
                            vDist[isoId][1],
                            vecToidx[idx]
                        ];
                    }
                }
            }
        }
        this.closestTo = closestTo;
        this.vecToidx = vecToidx;
    }
    calcCoeffs() {
        const m = this.m;
        const n = this.n;
        const thirdR3 = Math.sqrt(3) / 3;
        const LSQD = m * m + n * n + m * n;
        this.coau = (m + n) / LSQD;
        this.cobu = -n / LSQD;
        this.coav = -thirdR3 * (m - n) / LSQD;
        this.cobv = thirdR3 * (2 * m + n) / LSQD;
    }
    createInnerFacets() {
        const m = this.m;
        const n = this.n;
        for(let y = 0; y < n + m + 1; y++){
            for(let x = this.min[y]; x < this.max[y] + 1; x++){
                if (x < this.max[y] && x < this.max[y + 1] + 1) {
                    this.innerFacets.push([
                        "|" + x + "|" + y,
                        "|" + x + "|" + (y + 1),
                        "|" + (x + 1) + "|" + y
                    ]);
                }
                if (y > 0 && x < this.max[y - 1] && x + 1 < this.max[y] + 1) {
                    this.innerFacets.push([
                        "|" + x + "|" + y,
                        "|" + (x + 1) + "|" + y,
                        "|" + (x + 1) + "|" + (y - 1)
                    ]);
                }
            }
        }
    }
    edgeVecsABOB() {
        const m = this.m;
        const n = this.n;
        const B = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$isovector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsoVector"](-n, m + n);
        for(let y = 1; y < m + n; y++){
            const point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$isovector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsoVector"](this.min[y], y);
            const prev = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$isovector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsoVector"](this.min[y - 1], y - 1);
            const next = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$isovector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsoVector"](this.min[y + 1], y + 1);
            const pointR = point.clone();
            const prevR = prev.clone();
            const nextR = next.clone();
            pointR.rotate60About(B);
            prevR.rotate60About(B);
            nextR.rotate60About(B);
            const maxPoint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$isovector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsoVector"](this.max[pointR.y], pointR.y);
            const maxPrev = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$isovector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsoVector"](this.max[pointR.y - 1], pointR.y - 1);
            const maxLeftPrev = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$isovector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsoVector"](this.max[pointR.y - 1] - 1, pointR.y - 1);
            if (pointR.x !== maxPoint.x || pointR.y !== maxPoint.y) {
                if (pointR.x !== maxPrev.x) {
                    // type2
                    //up
                    this.vertexTypes.push([
                        1,
                        0,
                        0
                    ]);
                    this.isoVecsABOB.push([
                        point,
                        maxPrev,
                        maxLeftPrev
                    ]);
                    //down
                    this.vertexTypes.push([
                        1,
                        0,
                        0
                    ]);
                    this.isoVecsABOB.push([
                        point,
                        maxLeftPrev,
                        maxPoint
                    ]);
                } else if (pointR.y === nextR.y) {
                    // type1
                    //up
                    this.vertexTypes.push([
                        1,
                        1,
                        0
                    ]);
                    this.isoVecsABOB.push([
                        point,
                        prev,
                        maxPrev
                    ]);
                    //down
                    this.vertexTypes.push([
                        1,
                        0,
                        1
                    ]);
                    this.isoVecsABOB.push([
                        point,
                        maxPrev,
                        next
                    ]);
                } else {
                    // type 0
                    //up
                    this.vertexTypes.push([
                        1,
                        1,
                        0
                    ]);
                    this.isoVecsABOB.push([
                        point,
                        prev,
                        maxPrev
                    ]);
                    //down
                    this.vertexTypes.push([
                        1,
                        0,
                        0
                    ]);
                    this.isoVecsABOB.push([
                        point,
                        maxPrev,
                        maxPoint
                    ]);
                }
            }
        }
    }
    mapABOBtoOBOA() {
        const point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$isovector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsoVector"](0, 0);
        for(let i = 0; i < this.isoVecsABOB.length; i++){
            const temp = [];
            for(let j = 0; j < 3; j++){
                point.x = this.isoVecsABOB[i][j].x;
                point.y = this.isoVecsABOB[i][j].y;
                if (this.vertexTypes[i][j] === 0) {
                    point.rotateNeg120(this.m, this.n);
                }
                temp.push(point.clone());
            }
            this.isoVecsOBOA.push(temp);
        }
    }
    mapABOBtoBAOA() {
        const point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$isovector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsoVector"](0, 0);
        for(let i = 0; i < this.isoVecsABOB.length; i++){
            const temp = [];
            for(let j = 0; j < 3; j++){
                point.x = this.isoVecsABOB[i][j].x;
                point.y = this.isoVecsABOB[i][j].y;
                if (this.vertexTypes[i][j] === 1) {
                    point.rotate120(this.m, this.n);
                }
                temp.push(point.clone());
            }
            this.isoVecsBAOA.push(temp);
        }
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    MapToFace(faceNb, geodesicData) {
        const F = this.IDATA.face[faceNb];
        const oidx = F[2];
        const aidx = F[1];
        const bidx = F[0];
        const O = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].FromArray(this.IDATA.vertex[oidx]);
        const A = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].FromArray(this.IDATA.vertex[aidx]);
        const B = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].FromArray(this.IDATA.vertex[bidx]);
        const OA = A.subtract(O);
        const OB = B.subtract(O);
        const x = OA.scale(this.coau).add(OB.scale(this.cobu));
        const y = OA.scale(this.coav).add(OB.scale(this.cobv));
        const mapped = [];
        let idx;
        let tempVec = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[0];
        for(let i = 0; i < this.cartesian.length; i++){
            tempVec = x.scale(this.cartesian[i].x).add(y.scale(this.cartesian[i].y)).add(O);
            mapped[i] = [
                tempVec.x,
                tempVec.y,
                tempVec.z
            ];
            idx = faceNb + "|" + this.vertices[i].x + "|" + this.vertices[i].y;
            geodesicData.vertex[this.vecToidx[idx]] = [
                tempVec.x,
                tempVec.y,
                tempVec.z
            ];
        }
    }
    //statics
    /**Creates a primary triangle
     * @internal
     */ build(m, n) {
        const vertices = [];
        const O = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$isovector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsoVector"].Zero();
        const A = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$isovector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsoVector"](m, n);
        const B = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$isovector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsoVector"](-n, m + n);
        vertices.push(O, A, B);
        //max internal isoceles triangle vertices
        for(let y = n; y < m + 1; y++){
            for(let x = 0; x < m + 1 - y; x++){
                vertices.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$isovector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsoVector"](x, y));
            }
        }
        //shared vertices along edges when needed
        if (n > 0) {
            const g = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HighestCommonFactor"])(m, n);
            const m1 = m / g;
            const n1 = n / g;
            for(let i = 1; i < g; i++){
                vertices.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$isovector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsoVector"](i * m1, i * n1)); //OA
                vertices.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$isovector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsoVector"](-i * n1, i * (m1 + n1))); //OB
                vertices.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$isovector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsoVector"](m - i * (m1 + n1), n + i * m1)); // AB
            }
            //lower rows vertices and their rotations
            const ratio = m / n;
            for(let y = 1; y < n; y++){
                for(let x = 0; x < y * ratio; x++){
                    vertices.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$isovector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsoVector"](x, y));
                    vertices.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$isovector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsoVector"](x, y).rotate120(m, n));
                    vertices.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$isovector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsoVector"](x, y).rotateNeg120(m, n));
                }
            }
        }
        //order vertices by x and then y
        vertices.sort((a, b)=>{
            return a.x - b.x;
        });
        vertices.sort((a, b)=>{
            return a.y - b.y;
        });
        const min = new Array(m + n + 1);
        const max = new Array(m + n + 1);
        for(let i = 0; i < min.length; i++){
            min[i] = Infinity;
            max[i] = -Infinity;
        }
        let y = 0;
        let x = 0;
        const len = vertices.length;
        for(let i = 0; i < len; i++){
            x = vertices[i].x;
            y = vertices[i].y;
            min[y] = Math.min(x, min[y]);
            max[y] = Math.max(x, max[y]);
        }
        //calculates the distance of a vertex from a given primary vertex
        const distFrom = (vert, primVert)=>{
            const v = vert.clone();
            if (primVert === "A") {
                v.rotateNeg120(m, n);
            }
            if (primVert === "B") {
                v.rotate120(m, n);
            }
            if (v.x < 0) {
                return v.y;
            }
            return v.x + v.y;
        };
        const cartesian = [];
        const distFromO = [];
        const distFromA = [];
        const distFromB = [];
        const vertByDist = {};
        const vertData = [];
        let closest = -1;
        let dist = -1;
        for(let i = 0; i < len; i++){
            cartesian[i] = vertices[i].toCartesianOrigin(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$isovector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsoVector"](0, 0), 0.5);
            distFromO[i] = distFrom(vertices[i], "O");
            distFromA[i] = distFrom(vertices[i], "A");
            distFromB[i] = distFrom(vertices[i], "B");
            if (distFromO[i] === distFromA[i] && distFromA[i] === distFromB[i]) {
                closest = 3;
                dist = distFromO[i];
            } else if (distFromO[i] === distFromA[i]) {
                closest = 4;
                dist = distFromO[i];
            } else if (distFromA[i] === distFromB[i]) {
                closest = 5;
                dist = distFromA[i];
            } else if (distFromB[i] === distFromO[i]) {
                closest = 6;
                dist = distFromO[i];
            }
            if (distFromO[i] < distFromA[i] && distFromO[i] < distFromB[i]) {
                closest = 2;
                dist = distFromO[i];
            }
            if (distFromA[i] < distFromO[i] && distFromA[i] < distFromB[i]) {
                closest = 1;
                dist = distFromA[i];
            }
            if (distFromB[i] < distFromA[i] && distFromB[i] < distFromO[i]) {
                closest = 0;
                dist = distFromB[i];
            }
            vertData.push([
                closest,
                dist,
                vertices[i].x,
                vertices[i].y
            ]);
        }
        vertData.sort((a, b)=>{
            return a[2] - b[2];
        });
        vertData.sort((a, b)=>{
            return a[3] - b[3];
        });
        vertData.sort((a, b)=>{
            return a[1] - b[1];
        });
        vertData.sort((a, b)=>{
            return a[0] - b[0];
        });
        for(let v = 0; v < vertData.length; v++){
            vertByDist[vertData[v][2] + "|" + vertData[v][3]] = [
                vertData[v][0],
                vertData[v][1],
                v
            ];
        }
        this.m = m;
        this.n = n;
        this.vertices = vertices;
        this.vertByDist = vertByDist;
        this.cartesian = cartesian;
        this.min = min;
        this.max = max;
        return this;
    }
}
class PolyhedronData {
    constructor(/**
     * The name of the polyhedron
     */ name, /**
     * The category of the polyhedron
     */ category, /**
     * vertex data
     */ vertex, /**
     * face data
     */ face){
        this.name = name;
        this.category = category;
        this.vertex = vertex;
        this.face = face;
    }
}
class GeodesicData extends PolyhedronData {
    /**
     * @internal
     */ innerToData(face, primTri) {
        for(let i = 0; i < primTri.innerFacets.length; i++){
            this.face.push(primTri.innerFacets[i].map((el)=>primTri.vecToidx[face + el]));
        }
    }
    /**
     * @internal
     */ mapABOBtoDATA(faceNb, primTri) {
        const fr = primTri.IDATA.edgematch[faceNb][0];
        for(let i = 0; i < primTri.isoVecsABOB.length; i++){
            const temp = [];
            for(let j = 0; j < 3; j++){
                if (primTri.vertexTypes[i][j] === 0) {
                    temp.push(faceNb + "|" + primTri.isoVecsABOB[i][j].x + "|" + primTri.isoVecsABOB[i][j].y);
                } else {
                    temp.push(fr + "|" + primTri.isoVecsABOB[i][j].x + "|" + primTri.isoVecsABOB[i][j].y);
                }
            }
            this.face.push([
                primTri.vecToidx[temp[0]],
                primTri.vecToidx[temp[1]],
                primTri.vecToidx[temp[2]]
            ]);
        }
    }
    /**
     * @internal
     */ mapOBOAtoDATA(faceNb, primTri) {
        const fr = primTri.IDATA.edgematch[faceNb][0];
        for(let i = 0; i < primTri.isoVecsOBOA.length; i++){
            const temp = [];
            for(let j = 0; j < 3; j++){
                if (primTri.vertexTypes[i][j] === 1) {
                    temp.push(faceNb + "|" + primTri.isoVecsOBOA[i][j].x + "|" + primTri.isoVecsOBOA[i][j].y);
                } else {
                    temp.push(fr + "|" + primTri.isoVecsOBOA[i][j].x + "|" + primTri.isoVecsOBOA[i][j].y);
                }
            }
            this.face.push([
                primTri.vecToidx[temp[0]],
                primTri.vecToidx[temp[1]],
                primTri.vecToidx[temp[2]]
            ]);
        }
    }
    /**
     * @internal
     */ mapBAOAtoDATA(faceNb, primTri) {
        const fr = primTri.IDATA.edgematch[faceNb][2];
        for(let i = 0; i < primTri.isoVecsBAOA.length; i++){
            const temp = [];
            for(let j = 0; j < 3; j++){
                if (primTri.vertexTypes[i][j] === 1) {
                    temp.push(faceNb + "|" + primTri.isoVecsBAOA[i][j].x + "|" + primTri.isoVecsBAOA[i][j].y);
                } else {
                    temp.push(fr + "|" + primTri.isoVecsBAOA[i][j].x + "|" + primTri.isoVecsBAOA[i][j].y);
                }
            }
            this.face.push([
                primTri.vecToidx[temp[0]],
                primTri.vecToidx[temp[1]],
                primTri.vecToidx[temp[2]]
            ]);
        }
    }
    /**
     * @internal
     */ orderData(primTri) {
        const nearTo = [];
        for(let i = 0; i < 13; i++){
            nearTo[i] = [];
        }
        const close = primTri.closestTo;
        for(let i = 0; i < close.length; i++){
            if (close[i][0] > -1) {
                if (close[i][1] > 0) {
                    nearTo[close[i][0]].push([
                        i,
                        close[i][1]
                    ]);
                }
            } else {
                nearTo[12].push([
                    i,
                    close[i][0]
                ]);
            }
        }
        const near = [];
        for(let i = 0; i < 12; i++){
            near[i] = i;
        }
        let nearIndex = 12;
        for(let i = 0; i < 12; i++){
            nearTo[i].sort((a, b)=>{
                return a[1] - b[1];
            });
            for(let j = 0; j < nearTo[i].length; j++){
                near[nearTo[i][j][0]] = nearIndex++;
            }
        }
        for(let j = 0; j < nearTo[12].length; j++){
            near[nearTo[12][j][0]] = nearIndex++;
        }
        for(let i = 0; i < this.vertex.length; i++){
            this.vertex[i].push(near[i]);
        }
        this.vertex.sort((a, b)=>{
            return a[3] - b[3];
        });
        for(let i = 0; i < this.vertex.length; i++){
            this.vertex[i].pop();
        }
        for(let i = 0; i < this.face.length; i++){
            for(let j = 0; j < this.face[i].length; j++){
                this.face[i][j] = near[this.face[i][j]];
            }
        }
        this.sharedNodes = nearTo[12].length;
        this.poleNodes = this.vertex.length - this.sharedNodes;
    }
    /**
     * @internal
     */ setOrder(m, faces) {
        const adjVerts = [];
        const dualFaces = [];
        let face = faces.pop();
        dualFaces.push(face);
        let index = this.face[face].indexOf(m);
        index = (index + 2) % 3;
        let v = this.face[face][index];
        adjVerts.push(v);
        let f = 0;
        while(faces.length > 0){
            face = faces[f];
            if (this.face[face].indexOf(v) > -1) {
                // v is a vertex of face f
                index = (this.face[face].indexOf(v) + 1) % 3;
                v = this.face[face][index];
                adjVerts.push(v);
                dualFaces.push(face);
                faces.splice(f, 1);
                f = 0;
            } else {
                f++;
            }
        }
        this.adjacentFaces.push(adjVerts);
        return dualFaces;
    }
    /**
     * @internal
     */ toGoldbergPolyhedronData() {
        const goldbergPolyhedronData = new PolyhedronData("GeoDual", "Goldberg", [], []);
        goldbergPolyhedronData.name = "GD dual";
        const verticesNb = this.vertex.length;
        const map = new Array(verticesNb);
        for(let v = 0; v < verticesNb; v++){
            map[v] = [];
        }
        for(let f = 0; f < this.face.length; f++){
            for(let i = 0; i < 3; i++){
                map[this.face[f][i]].push(f);
            }
        }
        let cx = 0;
        let cy = 0;
        let cz = 0;
        let face = [];
        let vertex = [];
        this.adjacentFaces = [];
        for(let m = 0; m < map.length; m++){
            goldbergPolyhedronData.face[m] = this.setOrder(m, map[m].concat([]));
            for (const el of map[m]){
                cx = 0;
                cy = 0;
                cz = 0;
                face = this.face[el];
                for(let i = 0; i < 3; i++){
                    vertex = this.vertex[face[i]];
                    cx += vertex[0];
                    cy += vertex[1];
                    cz += vertex[2];
                }
                goldbergPolyhedronData.vertex[el] = [
                    cx / 3,
                    cy / 3,
                    cz / 3
                ];
            }
        }
        return goldbergPolyhedronData;
    }
    //statics
    /**Builds the data for a Geodesic Polyhedron from a primary triangle
     * @param primTri the primary triangle
     * @internal
     */ static BuildGeodesicData(primTri) {
        const geodesicData = new GeodesicData("Geodesic-m-n", "Geodesic", [
            [
                0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHI"],
                -1
            ],
            [
                -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHI"],
                1,
                0
            ],
            [
                -1,
                0,
                -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHI"]
            ],
            [
                1,
                0,
                -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHI"]
            ],
            [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHI"],
                1,
                0
            ],
            [
                0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHI"],
                1
            ],
            [
                -1,
                0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHI"]
            ],
            [
                -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHI"],
                -1,
                0
            ],
            [
                0,
                -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHI"],
                -1
            ],
            [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHI"],
                -1,
                0
            ],
            [
                1,
                0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHI"]
            ],
            [
                0,
                -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PHI"],
                1
            ]
        ], []);
        primTri.setIndices();
        primTri.calcCoeffs();
        primTri.createInnerFacets();
        primTri.edgeVecsABOB();
        primTri.mapABOBtoOBOA();
        primTri.mapABOBtoBAOA();
        for(let f = 0; f < primTri.IDATA.face.length; f++){
            primTri.MapToFace(f, geodesicData);
            geodesicData.innerToData(f, primTri);
            if (primTri.IDATA.edgematch[f][1] === "B") {
                geodesicData.mapABOBtoDATA(f, primTri);
            }
            if (primTri.IDATA.edgematch[f][1] === "O") {
                geodesicData.mapOBOAtoDATA(f, primTri);
            }
            if (primTri.IDATA.edgematch[f][3] === "A") {
                geodesicData.mapBAOAtoDATA(f, primTri);
            }
        }
        geodesicData.orderData(primTri);
        const radius = 1;
        geodesicData.vertex = geodesicData.vertex.map(function(el) {
            const a = el[0];
            const b = el[1];
            const c = el[2];
            const d = Math.sqrt(a * a + b * b + c * c);
            el[0] *= radius / d;
            el[1] *= radius / d;
            el[2] *= radius / d;
            return el;
        });
        return geodesicData;
    }
} //# sourceMappingURL=geodesicMesh.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/goldbergMesh.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GoldbergMesh",
    ()=>GoldbergMesh
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.color.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/logger.js [app-client] (ecmascript)");
;
;
;
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"]._GoldbergMeshParser = (parsedMesh, scene)=>{
    return GoldbergMesh.Parse(parsedMesh, scene);
};
class GoldbergMesh extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"] {
    constructor(){
        super(...arguments);
        /**
         * Defines the specific Goldberg data used in this mesh construction.
         */ this.goldbergData = {
            faceColors: [],
            faceCenters: [],
            faceZaxis: [],
            faceXaxis: [],
            faceYaxis: [],
            nbSharedFaces: 0,
            nbUnsharedFaces: 0,
            nbFaces: 0,
            nbFacesAtPole: 0,
            adjacentFaces: []
        };
    }
    /**
     * Gets the related Goldberg face from pole infos
     * @param poleOrShared Defines the pole index or the shared face index if the fromPole parameter is passed in
     * @param fromPole Defines an optional pole index to find the related info from
     * @returns the goldberg face number
     */ relatedGoldbergFace(poleOrShared, fromPole) {
        if (fromPole === void 0) {
            if (poleOrShared > this.goldbergData.nbUnsharedFaces - 1) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].Warn("Maximum number of unshared faces used");
                poleOrShared = this.goldbergData.nbUnsharedFaces - 1;
            }
            return this.goldbergData.nbUnsharedFaces + poleOrShared;
        }
        if (poleOrShared > 11) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].Warn("Last pole used");
            poleOrShared = 11;
        }
        if (fromPole > this.goldbergData.nbFacesAtPole - 1) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].Warn("Maximum number of faces at a pole used");
            fromPole = this.goldbergData.nbFacesAtPole - 1;
        }
        return 12 + poleOrShared * this.goldbergData.nbFacesAtPole + fromPole;
    }
    _changeGoldbergFaceColors(colorRange) {
        for(let i = 0; i < colorRange.length; i++){
            const min = colorRange[i][0];
            const max = colorRange[i][1];
            const col = colorRange[i][2];
            for(let f = min; f < max + 1; f++){
                this.goldbergData.faceColors[f] = col;
            }
        }
        const newCols = [];
        for(let f = 0; f < 12; f++){
            for(let i = 0; i < 5; i++){
                newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);
            }
        }
        for(let f = 12; f < this.goldbergData.faceColors.length; f++){
            for(let i = 0; i < 6; i++){
                newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);
            }
        }
        return newCols;
    }
    /**
     * Set new goldberg face colors
     * @param colorRange the new color to apply to the mesh
     */ setGoldbergFaceColors(colorRange) {
        const newCols = this._changeGoldbergFaceColors(colorRange);
        this.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorKind, newCols);
    }
    /**
     * Updates new goldberg face colors
     * @param colorRange the new color to apply to the mesh
     */ updateGoldbergFaceColors(colorRange) {
        const newCols = this._changeGoldbergFaceColors(colorRange);
        this.updateVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorKind, newCols);
    }
    _changeGoldbergFaceUVs(uvRange) {
        const uvs = this.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UVKind);
        for(let i = 0; i < uvRange.length; i++){
            const min = uvRange[i][0];
            const max = uvRange[i][1];
            const center = uvRange[i][2];
            const radius = uvRange[i][3];
            const angle = uvRange[i][4];
            const points5 = [];
            const points6 = [];
            let u;
            let v;
            for(let p = 0; p < 5; p++){
                u = center.x + radius * Math.cos(angle + p * Math.PI / 2.5);
                v = center.y + radius * Math.sin(angle + p * Math.PI / 2.5);
                if (u < 0) {
                    u = 0;
                }
                if (u > 1) {
                    u = 1;
                }
                points5.push(u, v);
            }
            for(let p = 0; p < 6; p++){
                u = center.x + radius * Math.cos(angle + p * Math.PI / 3);
                v = center.y + radius * Math.sin(angle + p * Math.PI / 3);
                if (u < 0) {
                    u = 0;
                }
                if (u > 1) {
                    u = 1;
                }
                points6.push(u, v);
            }
            for(let f = min; f < Math.min(12, max + 1); f++){
                for(let p = 0; p < 5; p++){
                    uvs[10 * f + 2 * p] = points5[2 * p];
                    uvs[10 * f + 2 * p + 1] = points5[2 * p + 1];
                }
            }
            for(let f = Math.max(12, min); f < max + 1; f++){
                for(let p = 0; p < 6; p++){
                    //120 + 12 * (f - 12) = 12 * f - 24
                    uvs[12 * f - 24 + 2 * p] = points6[2 * p];
                    uvs[12 * f - 23 + 2 * p] = points6[2 * p + 1];
                }
            }
        }
        return uvs;
    }
    /**
     * set new goldberg face UVs
     * @param uvRange the new UVs to apply to the mesh
     */ setGoldbergFaceUVs(uvRange) {
        const newUVs = this._changeGoldbergFaceUVs(uvRange);
        this.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UVKind, newUVs);
    }
    /**
     * Updates new goldberg face UVs
     * @param uvRange the new UVs to apply to the mesh
     */ updateGoldbergFaceUVs(uvRange) {
        const newUVs = this._changeGoldbergFaceUVs(uvRange);
        this.updateVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UVKind, newUVs);
    }
    /**
     * Places a mesh on a particular face of the goldberg polygon
     * @param mesh Defines the mesh to position
     * @param face Defines the face to position onto
     * @param position Defines the position relative to the face we are positioning the mesh onto
     */ placeOnGoldbergFaceAt(mesh, face, position) {
        const orientation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].RotationFromAxis(this.goldbergData.faceXaxis[face], this.goldbergData.faceYaxis[face], this.goldbergData.faceZaxis[face]);
        mesh.rotation = orientation;
        mesh.position = this.goldbergData.faceCenters[face].add(this.goldbergData.faceXaxis[face].scale(position.x)).add(this.goldbergData.faceYaxis[face].scale(position.y)).add(this.goldbergData.faceZaxis[face].scale(position.z));
    }
    /**
     * Serialize current mesh
     * @param serializationObject defines the object which will receive the serialization data
     */ serialize(serializationObject) {
        super.serialize(serializationObject);
        serializationObject.type = "GoldbergMesh";
        const goldbergData = {};
        goldbergData.adjacentFaces = this.goldbergData.adjacentFaces;
        goldbergData.nbSharedFaces = this.goldbergData.nbSharedFaces;
        goldbergData.nbUnsharedFaces = this.goldbergData.nbUnsharedFaces;
        goldbergData.nbFaces = this.goldbergData.nbFaces;
        goldbergData.nbFacesAtPole = this.goldbergData.nbFacesAtPole;
        if (this.goldbergData.faceColors) {
            goldbergData.faceColors = [];
            for (const color of this.goldbergData.faceColors){
                goldbergData.faceColors.push(color.asArray());
            }
        }
        if (this.goldbergData.faceCenters) {
            goldbergData.faceCenters = [];
            for (const vector of this.goldbergData.faceCenters){
                goldbergData.faceCenters.push(vector.asArray());
            }
        }
        if (this.goldbergData.faceZaxis) {
            goldbergData.faceZaxis = [];
            for (const vector of this.goldbergData.faceZaxis){
                goldbergData.faceZaxis.push(vector.asArray());
            }
        }
        if (this.goldbergData.faceYaxis) {
            goldbergData.faceYaxis = [];
            for (const vector of this.goldbergData.faceYaxis){
                goldbergData.faceYaxis.push(vector.asArray());
            }
        }
        if (this.goldbergData.faceXaxis) {
            goldbergData.faceXaxis = [];
            for (const vector of this.goldbergData.faceXaxis){
                goldbergData.faceXaxis.push(vector.asArray());
            }
        }
        serializationObject.goldbergData = goldbergData;
    }
    /**
     * Parses a serialized goldberg mesh
     * @param parsedMesh the serialized mesh
     * @param scene the scene to create the goldberg mesh in
     * @returns the created goldberg mesh
     */ static Parse(parsedMesh, scene) {
        const goldbergData = parsedMesh.goldbergData;
        goldbergData.faceColors = goldbergData.faceColors.map((el)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color4"].FromArray(el));
        goldbergData.faceCenters = goldbergData.faceCenters.map((el)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].FromArray(el));
        goldbergData.faceZaxis = goldbergData.faceZaxis.map((el)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].FromArray(el));
        goldbergData.faceXaxis = goldbergData.faceXaxis.map((el)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].FromArray(el));
        goldbergData.faceYaxis = goldbergData.faceYaxis.map((el)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].FromArray(el));
        const goldberg = new GoldbergMesh(parsedMesh.name, scene);
        goldberg.goldbergData = goldbergData;
        return goldberg;
    }
} //# sourceMappingURL=goldbergMesh.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/meshBuilder.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint-disable @typescript-eslint/naming-convention */ __turbopack_context__.s([
    "MeshBuilder",
    ()=>MeshBuilder
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$ribbonBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Builders/ribbonBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$discBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Builders/discBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$boxBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Builders/boxBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$tiledBoxBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Builders/tiledBoxBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$sphereBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Builders/sphereBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$cylinderBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Builders/cylinderBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$torusBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Builders/torusBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$torusKnotBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Builders/torusKnotBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$linesBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Builders/linesBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$polygonBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Builders/polygonBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$shapeBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Builders/shapeBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$latheBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Builders/latheBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$planeBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Builders/planeBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$tiledPlaneBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Builders/tiledPlaneBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$groundBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Builders/groundBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$tubeBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Builders/tubeBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$polyhedronBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Builders/polyhedronBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$icoSphereBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Builders/icoSphereBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$decalBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Builders/decalBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$capsuleBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Builders/capsuleBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$geodesicBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Builders/geodesicBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$goldbergBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Builders/goldbergBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$textBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Builders/textBuilder.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const MeshBuilder = {
    CreateBox: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$boxBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateBox"],
    CreateTiledBox: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$tiledBoxBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateTiledBox"],
    CreateSphere: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$sphereBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateSphere"],
    CreateDisc: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$discBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateDisc"],
    CreateIcoSphere: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$icoSphereBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateIcoSphere"],
    CreateRibbon: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$ribbonBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateRibbon"],
    CreateCylinder: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$cylinderBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateCylinder"],
    CreateTorus: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$torusBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateTorus"],
    CreateTorusKnot: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$torusKnotBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateTorusKnot"],
    CreateLineSystem: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$linesBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateLineSystem"],
    CreateLines: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$linesBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateLines"],
    CreateDashedLines: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$linesBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateDashedLines"],
    ExtrudeShape: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$shapeBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtrudeShape"],
    ExtrudeShapeCustom: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$shapeBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtrudeShapeCustom"],
    CreateLathe: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$latheBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateLathe"],
    CreateTiledPlane: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$tiledPlaneBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateTiledPlane"],
    CreatePlane: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$planeBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreatePlane"],
    CreateGround: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$groundBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateGround"],
    CreateTiledGround: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$groundBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateTiledGround"],
    CreateGroundFromHeightMap: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$groundBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateGroundFromHeightMap"],
    CreatePolygon: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$polygonBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreatePolygon"],
    ExtrudePolygon: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$polygonBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtrudePolygon"],
    CreateTube: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$tubeBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateTube"],
    CreatePolyhedron: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$polyhedronBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreatePolyhedron"],
    CreateGeodesic: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$geodesicBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateGeodesic"],
    CreateGoldberg: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$goldbergBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateGoldberg"],
    CreateDecal: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$decalBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateDecal"],
    CreateCapsule: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$capsuleBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateCapsule"],
    CreateText: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$textBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateText"]
}; //# sourceMappingURL=meshBuilder.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/WebGPU/webgpuDataBuffer.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "WebGPUDataBuffer",
    ()=>WebGPUDataBuffer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$dataBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/dataBuffer.js [app-client] (ecmascript)");
;
class WebGPUDataBuffer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$dataBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataBuffer"] {
    set buffer(buffer) {
        this._buffer = buffer;
    }
    constructor(resource, capacity = 0){
        super();
        // Used to make sure the buffer is not recreated twice after a context loss/restoration
        this.engineId = -1;
        this.capacity = capacity;
        if (resource) {
            this._buffer = resource;
        }
    }
    get underlyingResource() {
        return this._buffer;
    }
} //# sourceMappingURL=webgpuDataBuffer.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/subMesh.project.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$subMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/subMesh.js [app-client] (ecmascript)");
;
;
/**
 * @internal
 */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$subMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SubMesh"].prototype._projectOnTrianglesToRef = function(vector, positions, indices, step, checkStopper, ref) {
    // Triangles test
    const proj = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[0];
    const tmp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[1];
    let distance = +Infinity;
    for(let index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step){
        const indexA = indices[index];
        const indexB = indices[index + 1];
        const indexC = indices[index + 2];
        if (checkStopper && indexC === 0xffffffff) {
            index += 2;
            continue;
        }
        const p0 = positions[indexA];
        const p1 = positions[indexB];
        const p2 = positions[indexC];
        // stay defensive and don't check against undefined positions.
        if (!p0 || !p1 || !p2) {
            continue;
        }
        const tmpDist = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].ProjectOnTriangleToRef(vector, p0, p1, p2, tmp);
        if (tmpDist < distance) {
            proj.copyFrom(tmp);
            distance = tmpDist;
        }
    }
    ref.copyFrom(proj);
    return distance;
};
/**
 * @internal
 */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$subMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SubMesh"].prototype._projectOnUnIndexedTrianglesToRef = function(vector, positions, indices, ref) {
    // Triangles test
    const proj = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[0];
    const tmp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[1];
    let distance = +Infinity;
    for(let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3){
        const p0 = positions[index];
        const p1 = positions[index + 1];
        const p2 = positions[index + 2];
        const tmpDist = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].ProjectOnTriangleToRef(vector, p0, p1, p2, tmp);
        if (tmpDist < distance) {
            proj.copyFrom(tmp);
            distance = tmpDist;
        }
    }
    ref.copyFrom(proj);
    return distance;
};
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$subMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SubMesh"].prototype.projectToRef = function(vector, positions, indices, ref) {
    const material = this.getMaterial();
    if (!material) {
        return -1;
    }
    let step = 3;
    let checkStopper = false;
    switch(material.fillMode){
        case 3:
        case 5:
        case 6:
        case 8:
            return -1;
        case 7:
            step = 1;
            checkStopper = true;
            break;
        default:
            break;
    }
    // LineMesh first as it's also a Mesh...
    if (material.fillMode === 4) {
        return -1;
    } else {
        // Check if mesh is unindexed
        if (!indices.length && this._mesh._unIndexed) {
            return this._projectOnUnIndexedTrianglesToRef(vector, positions, indices, ref);
        }
        return this._projectOnTrianglesToRef(vector, positions, indices, step, checkStopper, ref);
    }
}; //# sourceMappingURL=subMesh.project.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/thinInstanceMesh.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/logger.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Culling$2f$boundingInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Culling/boundingInfo.js [app-client] (ecmascript)");
;
;
;
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"].prototype.thinInstanceAdd = function(matrix, refresh = true) {
    if (!this.getScene().getEngine().getCaps().instancedArrays) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].Error("Thin Instances are not supported on this device as Instanced Array extension not supported");
        return -1;
    }
    this._thinInstanceUpdateBufferSize("matrix", Array.isArray(matrix) ? matrix.length : 1);
    const index = this._thinInstanceDataStorage.instancesCount;
    if (Array.isArray(matrix)) {
        for(let i = 0; i < matrix.length; ++i){
            this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix[i], i === matrix.length - 1 && refresh);
        }
    } else {
        this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix, refresh);
    }
    return index;
};
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"].prototype.thinInstanceAddSelf = function(refresh = true) {
    return this.thinInstanceAdd(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].IdentityReadOnly, refresh);
};
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"].prototype.thinInstanceRegisterAttribute = function(kind, stride) {
    // preserve backward compatibility
    if (kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorKind) {
        kind = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorInstanceKind;
    }
    this.removeVerticesData(kind);
    this._thinInstanceInitializeUserStorage();
    this._userThinInstanceBuffersStorage.strides[kind] = stride;
    this._userThinInstanceBuffersStorage.sizes[kind] = stride * Math.max(32, this._thinInstanceDataStorage.instancesCount); // Initial size
    this._userThinInstanceBuffersStorage.data[kind] = new Float32Array(this._userThinInstanceBuffersStorage.sizes[kind]);
    this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"](this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, true, false, stride, true);
    this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
};
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"].prototype.thinInstanceSetMatrixAt = function(index, matrix, refresh = true) {
    if (!this._thinInstanceDataStorage.matrixData || index >= this._thinInstanceDataStorage.instancesCount) {
        return false;
    }
    const matrixData = this._thinInstanceDataStorage.matrixData;
    matrix.copyToArray(matrixData, index * 16);
    if (this._thinInstanceDataStorage.worldMatrices) {
        this._thinInstanceDataStorage.worldMatrices[index] = matrix;
    }
    if (refresh) {
        this.thinInstanceBufferUpdated("matrix");
        if (!this.doNotSyncBoundingInfo) {
            this.thinInstanceRefreshBoundingInfo(false);
        }
    }
    return true;
};
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"].prototype.thinInstanceSetAttributeAt = function(kind, index, value, refresh = true) {
    // preserve backward compatibility
    if (kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorKind) {
        kind = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorInstanceKind;
    }
    if (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.data[kind] || index >= this._thinInstanceDataStorage.instancesCount) {
        return false;
    }
    this._thinInstanceUpdateBufferSize(kind, 0); // make sur the buffer for the kind attribute is big enough
    this._userThinInstanceBuffersStorage.data[kind].set(value, index * this._userThinInstanceBuffersStorage.strides[kind]);
    if (refresh) {
        this.thinInstanceBufferUpdated(kind);
    }
    return true;
};
Object.defineProperty(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"].prototype, "thinInstanceCount", {
    get: function() {
        return this._thinInstanceDataStorage.instancesCount;
    },
    set: function(value) {
        const matrixData = this._thinInstanceDataStorage.matrixData ?? this.source?._thinInstanceDataStorage.matrixData;
        const numMaxInstances = matrixData ? matrixData.length / 16 : 0;
        if (value <= numMaxInstances) {
            this._thinInstanceDataStorage.instancesCount = value;
        }
    },
    enumerable: true,
    configurable: true
});
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"].prototype._thinInstanceCreateMatrixBuffer = function(kind, buffer, staticBuffer = true) {
    const matrixBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"](this.getEngine(), buffer, !staticBuffer, 16, false, true);
    for(let i = 0; i < 4; i++){
        this.setVerticesBuffer(matrixBuffer.createVertexBuffer(kind + i, i * 4, 4));
    }
    return matrixBuffer;
};
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"].prototype.thinInstanceSetBuffer = function(kind, buffer, stride = 0, staticBuffer = true) {
    stride = stride || 16;
    if (kind === "matrix") {
        this._thinInstanceDataStorage.matrixBuffer?.dispose();
        this._thinInstanceDataStorage.matrixBuffer = null;
        this._thinInstanceDataStorage.matrixBufferSize = buffer ? buffer.length : 32 * stride;
        this._thinInstanceDataStorage.matrixData = buffer;
        this._thinInstanceDataStorage.worldMatrices = null;
        if (buffer !== null) {
            this._thinInstanceDataStorage.instancesCount = buffer.length / stride;
            this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer("world", buffer, staticBuffer);
            if (!this.doNotSyncBoundingInfo) {
                this.thinInstanceRefreshBoundingInfo(false);
            }
        } else {
            this._thinInstanceDataStorage.instancesCount = 0;
            if (!this.doNotSyncBoundingInfo) {
                // mesh has no more thin instances, so need to recompute the bounding box because it's the regular mesh that will now be displayed
                this.refreshBoundingInfo();
            }
        }
    } else if (kind === "previousMatrix") {
        this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();
        this._thinInstanceDataStorage.previousMatrixBuffer = null;
        this._thinInstanceDataStorage.previousMatrixData = buffer;
        if (buffer !== null) {
            this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", buffer, staticBuffer);
        }
    } else if (kind === "splatIndex" && buffer) {
        this._thinInstanceInitializeUserStorage();
        this._thinInstanceDataStorage.instancesCount = buffer.length / stride;
        this._userThinInstanceBuffersStorage.data[kind] = buffer;
        this._userThinInstanceBuffersStorage.strides[kind] = stride;
        this._userThinInstanceBuffersStorage.sizes[kind] = buffer.length;
        const splatInstancesBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"](this.getEngine(), buffer, true, 16, false, true);
        this._thinInstanceDataStorage.matrixBuffer = splatInstancesBuffer;
        for(let i = 0; i < 4; i++){
            this.setVerticesBuffer(splatInstancesBuffer.createVertexBuffer(kind + i, i * 4, 4));
        }
    } else {
        // color for instanced mesh is ColorInstanceKind and not ColorKind because of native that needs to do the differenciation
        // hot switching kind here to preserve backward compatibility
        if (kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorKind) {
            kind = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorInstanceKind;
        }
        if (buffer === null) {
            if (this._userThinInstanceBuffersStorage?.data[kind]) {
                this.removeVerticesData(kind);
                delete this._userThinInstanceBuffersStorage.data[kind];
                delete this._userThinInstanceBuffersStorage.strides[kind];
                delete this._userThinInstanceBuffersStorage.sizes[kind];
                delete this._userThinInstanceBuffersStorage.vertexBuffers[kind];
            }
        } else {
            this._thinInstanceInitializeUserStorage();
            this._userThinInstanceBuffersStorage.data[kind] = buffer;
            this._userThinInstanceBuffersStorage.strides[kind] = stride;
            this._userThinInstanceBuffersStorage.sizes[kind] = buffer.length;
            this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"](this.getEngine(), buffer, kind, !staticBuffer, false, stride, true);
            this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
        }
    }
};
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"].prototype.thinInstanceBufferUpdated = function(kind) {
    if (kind === "matrix") {
        if (this.thinInstanceAllowAutomaticStaticBufferRecreation && this._thinInstanceDataStorage.matrixBuffer && !this._thinInstanceDataStorage.matrixBuffer.isUpdatable()) {
            this._thinInstanceRecreateBuffer(kind);
        }
        this._thinInstanceDataStorage.matrixBuffer?.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, this._thinInstanceDataStorage.instancesCount);
    } else if (kind === "previousMatrix") {
        if (this.thinInstanceAllowAutomaticStaticBufferRecreation && this._thinInstanceDataStorage.previousMatrixBuffer && !this._thinInstanceDataStorage.previousMatrixBuffer.isUpdatable()) {
            this._thinInstanceRecreateBuffer(kind);
        }
        this._thinInstanceDataStorage.previousMatrixBuffer?.updateDirectly(this._thinInstanceDataStorage.previousMatrixData, 0, this._thinInstanceDataStorage.instancesCount);
    } else if (kind === "splatIndex") {
        this._thinInstanceDataStorage.matrixBuffer?.updateDirectly(this._userThinInstanceBuffersStorage.data[kind], 0, this._thinInstanceDataStorage.instancesCount);
    } else {
        // preserve backward compatibility
        if (kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorKind) {
            kind = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorInstanceKind;
        }
        if (this._userThinInstanceBuffersStorage?.vertexBuffers[kind]) {
            if (this.thinInstanceAllowAutomaticStaticBufferRecreation && !this._userThinInstanceBuffersStorage.vertexBuffers[kind].isUpdatable()) {
                this._thinInstanceRecreateBuffer(kind);
            }
            this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(this._userThinInstanceBuffersStorage.data[kind], 0);
        }
    }
};
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"].prototype.thinInstancePartialBufferUpdate = function(kind, data, offset) {
    if (kind === "matrix") {
        if (this._thinInstanceDataStorage.matrixBuffer) {
            this._thinInstanceDataStorage.matrixBuffer.updateDirectly(data, offset);
        }
    } else {
        // preserve backward compatibility
        if (kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorKind) {
            kind = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorInstanceKind;
        }
        if (this._userThinInstanceBuffersStorage?.vertexBuffers[kind]) {
            this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(data, offset);
        }
    }
};
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"].prototype.thinInstanceGetWorldMatrices = function() {
    if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {
        return [];
    }
    const matrixData = this._thinInstanceDataStorage.matrixData;
    if (!this._thinInstanceDataStorage.worldMatrices) {
        this._thinInstanceDataStorage.worldMatrices = [];
        for(let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i){
            this._thinInstanceDataStorage.worldMatrices[i] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].FromArray(matrixData, i * 16);
        }
    }
    return this._thinInstanceDataStorage.worldMatrices;
};
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"].prototype.thinInstanceRefreshBoundingInfo = function(forceRefreshParentInfo = false, applySkeleton = false, applyMorph = false) {
    if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {
        return;
    }
    const vectors = this._thinInstanceDataStorage.boundingVectors;
    if (forceRefreshParentInfo || !this.rawBoundingInfo) {
        vectors.length = 0;
        this.refreshBoundingInfo(applySkeleton, applyMorph);
        const boundingInfo = this.getBoundingInfo();
        this.rawBoundingInfo = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Culling$2f$boundingInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BoundingInfo"](boundingInfo.minimum, boundingInfo.maximum);
    }
    const boundingInfo = this.getBoundingInfo();
    const matrixData = this._thinInstanceDataStorage.matrixData;
    if (vectors.length === 0) {
        for(let v = 0; v < boundingInfo.boundingBox.vectors.length; ++v){
            vectors.push(boundingInfo.boundingBox.vectors[v].clone());
        }
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[0].setAll(Number.POSITIVE_INFINITY); // min
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[1].setAll(Number.NEGATIVE_INFINITY); // max
    for(let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i){
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].FromArrayToRef(matrixData, i * 16, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[0]);
        for(let v = 0; v < vectors.length; ++v){
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformCoordinatesToRef(vectors[v], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[0], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[2]);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[0].minimizeInPlace(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[2]);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[1].maximizeInPlace(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[2]);
        }
    }
    boundingInfo.reConstruct(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[0], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[1]);
    this._updateBoundingInfo();
};
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"].prototype._thinInstanceRecreateBuffer = function(kind, staticBuffer = true) {
    if (kind === "matrix") {
        this._thinInstanceDataStorage.matrixBuffer?.dispose();
        this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer("world", this._thinInstanceDataStorage.matrixData, staticBuffer);
    } else if (kind === "previousMatrix") {
        if (this._scene.needsPreviousWorldMatrices) {
            this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();
            this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", this._thinInstanceDataStorage.previousMatrixData ?? this._thinInstanceDataStorage.matrixData, staticBuffer);
        }
    } else {
        if (kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorKind) {
            kind = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorInstanceKind;
        }
        this._userThinInstanceBuffersStorage.vertexBuffers[kind]?.dispose();
        this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"](this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, !staticBuffer, false, this._userThinInstanceBuffersStorage.strides[kind], true);
        this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
    }
};
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"].prototype._thinInstanceUpdateBufferSize = function(kind, numInstances = 1) {
    // preserve backward compatibility
    if (kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorKind) {
        kind = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorInstanceKind;
    }
    const kindIsMatrix = kind === "matrix";
    if (!kindIsMatrix && (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.strides[kind])) {
        return;
    }
    const stride = kindIsMatrix ? 16 : this._userThinInstanceBuffersStorage.strides[kind];
    const currentSize = kindIsMatrix ? this._thinInstanceDataStorage.matrixBufferSize : this._userThinInstanceBuffersStorage.sizes[kind];
    let data = kindIsMatrix ? this._thinInstanceDataStorage.matrixData : this._userThinInstanceBuffersStorage.data[kind];
    const bufferSize = (this._thinInstanceDataStorage.instancesCount + numInstances) * stride;
    let newSize = currentSize;
    while(newSize < bufferSize){
        newSize *= 2;
    }
    if (!data || currentSize != newSize) {
        if (!data) {
            data = new Float32Array(newSize);
        } else {
            const newData = new Float32Array(newSize);
            newData.set(data, 0);
            data = newData;
        }
        if (kindIsMatrix) {
            this._thinInstanceDataStorage.matrixBuffer?.dispose();
            this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer("world", data, false);
            this._thinInstanceDataStorage.matrixData = data;
            this._thinInstanceDataStorage.matrixBufferSize = newSize;
            if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData) {
                this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();
                this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", data, false);
            }
        } else {
            this._userThinInstanceBuffersStorage.vertexBuffers[kind]?.dispose();
            this._userThinInstanceBuffersStorage.data[kind] = data;
            this._userThinInstanceBuffersStorage.sizes[kind] = newSize;
            this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"](this.getEngine(), data, kind, true, false, stride, true);
            this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
        }
    }
};
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"].prototype._thinInstanceInitializeUserStorage = function() {
    if (!this._userThinInstanceBuffersStorage) {
        this._userThinInstanceBuffersStorage = {
            data: {},
            sizes: {},
            vertexBuffers: {},
            strides: {}
        };
    }
};
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"].prototype._disposeThinInstanceSpecificData = function() {
    if (this._thinInstanceDataStorage?.matrixBuffer) {
        this._thinInstanceDataStorage.matrixBuffer.dispose();
        this._thinInstanceDataStorage.matrixBuffer = null;
    }
    if (this._thinInstanceDataStorage?.previousMatrixBuffer) {
        this._thinInstanceDataStorage.previousMatrixBuffer.dispose();
        this._thinInstanceDataStorage.previousMatrixBuffer = null;
    }
}; //# sourceMappingURL=thinInstanceMesh.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/abstractMesh.decalMap.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$abstractMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/abstractMesh.js [app-client] (ecmascript)");
;
Object.defineProperty(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$abstractMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AbstractMesh"].prototype, "decalMap", {
    get: function() {
        return this._decalMap;
    },
    set: function(decalMap) {
        this._decalMap = decalMap;
    },
    enumerable: true,
    configurable: true
}); //# sourceMappingURL=abstractMesh.decalMap.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/abstractMesh.hotSpot.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CreateHotSpotQueryForPickingInfo",
    ()=>CreateHotSpotQueryForPickingInfo,
    "GetHotSpotToRef",
    ()=>GetHotSpotToRef,
    "GetTransformedPosition",
    ()=>GetTransformedPosition
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$bufferUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/bufferUtils.js [app-client] (ecmascript)");
;
;
;
function CreateHotSpotQueryForPickingInfo(pickingInfo) {
    const indices = pickingInfo.pickedMesh?.getIndices();
    const base = pickingInfo.faceId * 3;
    return {
        pointIndex: indices ? [
            indices[base],
            indices[base + 1],
            indices[base + 2]
        ] : [
            base,
            base + 1,
            base + 2
        ],
        barycentric: [
            pickingInfo.bu,
            pickingInfo.bv,
            1 - pickingInfo.bu - pickingInfo.bv
        ]
    };
}
function GetVertexElementData(mesh, index, kind) {
    const vertexBuffer = mesh.getVertexBuffer(kind);
    if (!vertexBuffer) {
        return null;
    }
    const bufferData = vertexBuffer.getData();
    if (!bufferData) {
        return null;
    }
    // EnumerateFloatValues synchronously calls the callback, hence the non-null assertion.
    let values;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$bufferUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EnumerateFloatValues"])(bufferData, vertexBuffer.byteStride * index, vertexBuffer.byteStride, vertexBuffer.getSize(), vertexBuffer.type, 1, vertexBuffer.normalized, (v)=>values = v);
    return values;
}
function GetTransformedPosition(mesh, index, res) {
    const positions = GetVertexElementData(mesh, index, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind);
    if (!positions) {
        return false;
    }
    if (positions.some((value)=>isNaN(value ?? Number.NaN))) {
        return false;
    }
    if (mesh.morphTargetManager) {
        const base = index * 3;
        for(let i = 0; i < positions.length; i++){
            let value = positions[i];
            for(let targetCount = 0; targetCount < mesh.morphTargetManager.numTargets; targetCount++){
                const target = mesh.morphTargetManager.getTarget(targetCount);
                const influence = target.influence;
                if (influence !== 0) {
                    const targetData = target.getPositions();
                    if (targetData) {
                        value += (targetData[base + i] - positions[i]) * influence;
                    }
                }
            }
            positions[i] = value;
        }
    }
    res.fromArray(positions);
    if (mesh.skeleton) {
        const matricesIndicesData = GetVertexElementData(mesh, index, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesIndicesKind);
        const matricesWeightsData = GetVertexElementData(mesh, index, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesWeightsKind);
        if (matricesIndicesData && matricesWeightsData) {
            const needExtras = mesh.numBoneInfluencers > 4;
            const matricesIndicesExtraData = needExtras ? GetVertexElementData(mesh, index, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesIndicesExtraKind) : null;
            const matricesWeightsExtraData = needExtras ? GetVertexElementData(mesh, index, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesWeightsExtraKind) : null;
            const skeletonMatrices = mesh.skeleton.getTransformMatrices(mesh);
            const finalMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[0];
            const tempMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[1];
            finalMatrix.reset();
            for(let i = 0; i < matricesWeightsData.length; i++){
                const weight = matricesWeightsData[i];
                if (weight > 0) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[i] * 16), weight, tempMatrix);
                    finalMatrix.addToSelf(tempMatrix);
                }
            }
            if (matricesIndicesExtraData && matricesWeightsExtraData) {
                for(let i = 0; i < matricesWeightsExtraData.length; i++){
                    const weight = matricesWeightsExtraData[i];
                    if (weight > 0) {
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[i] * 16), weight, tempMatrix);
                        finalMatrix.addToSelf(tempMatrix);
                    }
                }
            }
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformCoordinatesFromFloatsToRef(positions[0], positions[1], positions[2], finalMatrix, res);
        }
    }
    return true;
}
function GetHotSpotToRef(mesh, hotSpotQuery, resPosition, resNormal) {
    resPosition.set(0, 0, 0);
    for(let i = 0; i < 3; i++){
        const index = hotSpotQuery.pointIndex[i];
        if (!GetTransformedPosition(mesh, index, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[i])) {
            return false;
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[i].scaleAndAddToRef(hotSpotQuery.barycentric[i], resPosition);
    }
    // Convert the result to world space
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformCoordinatesToRef(resPosition, mesh.getWorldMatrix(), resPosition);
    // compute normal in world space
    if (resNormal) {
        const pointA = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[0];
        const pointB = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[1];
        const pointC = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[2];
        const segmentA = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[3];
        const segmentB = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[4];
        segmentA.copyFrom(pointB);
        segmentA.subtractInPlace(pointA);
        segmentB.copyFrom(pointC);
        segmentB.subtractInPlace(pointA);
        segmentA.normalize();
        segmentB.normalize();
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].CrossToRef(segmentA, segmentB, resNormal);
        // flip normal when face culling is changed
        const flipNormal = mesh.material && mesh.material.sideOrientation === (mesh.getScene().useRightHandedSystem ? 0 : 1);
        if (flipNormal) {
            resNormal.scaleInPlace(-1);
        }
        // Convert the result to world space
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformNormalToRef(resNormal, mesh.getWorldMatrix(), resNormal);
        resNormal.normalize();
    }
    return true;
} //# sourceMappingURL=abstractMesh.hotSpot.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Compression/dracoCompressionWorker.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @internal
 */ __turbopack_context__.s([
    "DecodeMesh",
    ()=>DecodeMesh,
    "DecoderWorkerFunction",
    ()=>DecoderWorkerFunction,
    "EncodeMesh",
    ()=>EncodeMesh,
    "EncoderWorkerFunction",
    ()=>EncoderWorkerFunction,
    "initializeWebWorker",
    ()=>initializeWebWorker,
    "workerFunction",
    ()=>DecoderWorkerFunction
]);
function EncodeMesh(module /** EncoderModule */ , attributes, indices, options) {
    const encoderModule = module;
    let encoder = null;
    let meshBuilder = null;
    let mesh = null;
    let encodedNativeBuffer = null;
    const attributeIDs = {}; // Babylon kind -> Draco unique id
    // Double-check that at least a position attribute is provided
    const positionAttribute = attributes.find((a)=>a.dracoName === "POSITION");
    if (!positionAttribute) {
        throw new Error("Position attribute is required for Draco encoding");
    }
    // If no indices are provided, assume mesh is unindexed. Let's generate them, since Draco meshes require them.
    // TODO: This may be the POINT_CLOUD case, but need to investigate. Should work for now-- just less efficient.
    if (!indices) {
        // Assume position attribute is the largest attribute.
        const positionVerticesCount = positionAttribute.data.length / positionAttribute.size;
        indices = new (positionVerticesCount > 65535 ? Uint32Array : Uint16Array)(positionVerticesCount);
        for(let i = 0; i < positionVerticesCount; i++){
            indices[i] = i;
        }
    }
    try {
        encoder = new encoderModule.Encoder();
        meshBuilder = new encoderModule.MeshBuilder();
        mesh = new encoderModule.Mesh();
        // Add the faces
        meshBuilder.AddFacesToMesh(mesh, indices.length / 3, indices);
        const addAttributeMap = new Map([
            [
                Float32Array,
                (mb, m, a, c, s, d)=>mb.AddFloatAttribute(m, a, c, s, d)
            ],
            [
                Uint32Array,
                (mb, m, a, c, s, d)=>mb.AddUInt32Attribute(m, a, c, s, d)
            ],
            [
                Uint16Array,
                (mb, m, a, c, s, d)=>mb.AddUInt16Attribute(m, a, c, s, d)
            ],
            [
                Uint8Array,
                (mb, m, a, c, s, d)=>mb.AddUInt8Attribute(m, a, c, s, d)
            ],
            [
                Int32Array,
                (mb, m, a, c, s, d)=>mb.AddInt32Attribute(m, a, c, s, d)
            ],
            [
                Int16Array,
                (mb, m, a, c, s, d)=>mb.AddInt16Attribute(m, a, c, s, d)
            ],
            [
                Int8Array,
                (mb, m, a, c, s, d)=>mb.AddInt8Attribute(m, a, c, s, d)
            ]
        ]);
        // Add the attributes
        for (const attribute of attributes){
            if (attribute.data instanceof Uint8ClampedArray) {
                attribute.data = new Uint8Array(attribute.data); // Draco does not support Uint8ClampedArray
            }
            const addAttribute = addAttributeMap.get(attribute.data.constructor);
            const verticesCount = attribute.data.length / attribute.size;
            attributeIDs[attribute.kind] = addAttribute(meshBuilder, mesh, encoderModule[attribute.dracoName], verticesCount, attribute.size, attribute.data);
            if (options.quantizationBits && options.quantizationBits[attribute.dracoName]) {
                encoder.SetAttributeQuantization(encoderModule[attribute.dracoName], options.quantizationBits[attribute.dracoName]);
            }
        }
        // Set the options
        if (options.method) {
            encoder.SetEncodingMethod(encoderModule[options.method]);
        }
        if (options.encodeSpeed !== undefined && options.decodeSpeed !== undefined) {
            encoder.SetSpeedOptions(options.encodeSpeed, options.decodeSpeed);
        }
        // Encode to native buffer
        encodedNativeBuffer = new encoderModule.DracoInt8Array();
        const encodedLength = encoder.EncodeMeshToDracoBuffer(mesh, encodedNativeBuffer);
        if (encodedLength <= 0) {
            throw new Error("Draco encoding failed.");
        }
        // Copy the native buffer data to worker heap
        const encodedData = new Int8Array(encodedLength);
        for(let i = 0; i < encodedLength; i++){
            encodedData[i] = encodedNativeBuffer.GetValue(i);
        }
        return {
            data: encodedData,
            attributeIds: attributeIDs
        };
    } finally{
        if (mesh) {
            encoderModule.destroy(mesh);
        }
        if (meshBuilder) {
            encoderModule.destroy(meshBuilder);
        }
        if (encoder) {
            encoderModule.destroy(encoder);
        }
        if (encodedNativeBuffer) {
            encoderModule.destroy(encodedNativeBuffer);
        }
    }
}
function EncoderWorkerFunction() {
    let encoderPromise;
    onmessage = (event)=>{
        const message = event.data;
        switch(message.id){
            case "init":
                {
                    // if URL is provided then load the script. Otherwise expect the script to be loaded already
                    if (message.url) {
                        importScripts(message.url);
                    }
                    const initEncoderObject = message.wasmBinary ? {
                        wasmBinary: message.wasmBinary
                    } : {};
                    encoderPromise = DracoEncoderModule(initEncoderObject);
                    postMessage({
                        id: "initDone"
                    });
                    break;
                }
            case "encodeMesh":
                {
                    if (!encoderPromise) {
                        throw new Error("Draco encoder module is not available");
                    }
                    // eslint-disable-next-line github/no-then
                    encoderPromise.then((encoder)=>{
                        const result = EncodeMesh(encoder, message.attributes, message.indices, message.options);
                        postMessage({
                            id: "encodeMeshDone",
                            encodedMeshData: result
                        }, result ? [
                            result.data.buffer
                        ] : undefined);
                    });
                    break;
                }
        }
    };
}
function DecodeMesh(module /** DecoderModule */ , data, attributeIDs, onIndicesData, onAttributeData) {
    const decoderModule = module;
    let decoder = null;
    let buffer = null;
    let geometry = null;
    try {
        decoder = new decoderModule.Decoder();
        buffer = new decoderModule.DecoderBuffer();
        buffer.Init(data, data.byteLength);
        let status;
        const type = decoder.GetEncodedGeometryType(buffer);
        switch(type){
            case decoderModule.TRIANGULAR_MESH:
                {
                    const mesh = new decoderModule.Mesh();
                    status = decoder.DecodeBufferToMesh(buffer, mesh);
                    if (!status.ok() || mesh.ptr === 0) {
                        throw new Error(status.error_msg());
                    }
                    const numFaces = mesh.num_faces();
                    const numIndices = numFaces * 3;
                    const byteLength = numIndices * 4;
                    const ptr = decoderModule._malloc(byteLength);
                    try {
                        decoder.GetTrianglesUInt32Array(mesh, byteLength, ptr);
                        const indices = new Uint32Array(numIndices);
                        indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));
                        onIndicesData(indices);
                    } finally{
                        decoderModule._free(ptr);
                    }
                    geometry = mesh;
                    break;
                }
            case decoderModule.POINT_CLOUD:
                {
                    const pointCloud = new decoderModule.PointCloud();
                    status = decoder.DecodeBufferToPointCloud(buffer, pointCloud);
                    if (!status.ok() || !pointCloud.ptr) {
                        throw new Error(status.error_msg());
                    }
                    geometry = pointCloud;
                    break;
                }
            default:
                {
                    throw new Error(`Invalid geometry type ${type}`);
                }
        }
        const numPoints = geometry.num_points();
        const processAttribute = (decoder, geometry, kind, attribute /** Attribute */ )=>{
            const dataType = attribute.data_type();
            const numComponents = attribute.num_components();
            const normalized = attribute.normalized();
            const byteStride = attribute.byte_stride();
            const byteOffset = attribute.byte_offset();
            const dataTypeInfo = {
                [decoderModule.DT_FLOAT32]: {
                    typedArrayConstructor: Float32Array,
                    heap: decoderModule.HEAPF32
                },
                [decoderModule.DT_INT8]: {
                    typedArrayConstructor: Int8Array,
                    heap: decoderModule.HEAP8
                },
                [decoderModule.DT_INT16]: {
                    typedArrayConstructor: Int16Array,
                    heap: decoderModule.HEAP16
                },
                [decoderModule.DT_INT32]: {
                    typedArrayConstructor: Int32Array,
                    heap: decoderModule.HEAP32
                },
                [decoderModule.DT_UINT8]: {
                    typedArrayConstructor: Uint8Array,
                    heap: decoderModule.HEAPU8
                },
                [decoderModule.DT_UINT16]: {
                    typedArrayConstructor: Uint16Array,
                    heap: decoderModule.HEAPU16
                },
                [decoderModule.DT_UINT32]: {
                    typedArrayConstructor: Uint32Array,
                    heap: decoderModule.HEAPU32
                }
            };
            const info = dataTypeInfo[dataType];
            if (!info) {
                throw new Error(`Invalid data type ${dataType}`);
            }
            const numValues = numPoints * numComponents;
            const byteLength = numValues * info.typedArrayConstructor.BYTES_PER_ELEMENT;
            const ptr = decoderModule._malloc(byteLength);
            try {
                decoder.GetAttributeDataArrayForAllPoints(geometry, attribute, dataType, byteLength, ptr);
                const data = new info.typedArrayConstructor(info.heap.buffer, ptr, numValues);
                onAttributeData(kind, data.slice(), numComponents, byteOffset, byteStride, normalized);
            } finally{
                decoderModule._free(ptr);
            }
        };
        if (attributeIDs) {
            for(const kind in attributeIDs){
                const id = attributeIDs[kind];
                const attribute = decoder.GetAttributeByUniqueId(geometry, id);
                processAttribute(decoder, geometry, kind, attribute);
            }
        } else {
            const dracoAttributeTypes = {
                position: decoderModule.POSITION,
                normal: decoderModule.NORMAL,
                color: decoderModule.COLOR,
                uv: decoderModule.TEX_COORD
            };
            for(const kind in dracoAttributeTypes){
                const id = decoder.GetAttributeId(geometry, dracoAttributeTypes[kind]);
                if (id !== -1) {
                    const attribute = decoder.GetAttribute(geometry, id);
                    processAttribute(decoder, geometry, kind, attribute);
                }
            }
        }
        return numPoints;
    } finally{
        if (geometry) {
            decoderModule.destroy(geometry);
        }
        if (buffer) {
            decoderModule.destroy(buffer);
        }
        if (decoder) {
            decoderModule.destroy(decoder);
        }
    }
}
function DecoderWorkerFunction() {
    let decoderPromise;
    onmessage = (event)=>{
        const message = event.data;
        switch(message.id){
            case "init":
                {
                    // if URL is provided then load the script. Otherwise expect the script to be loaded already
                    if (message.url) {
                        importScripts(message.url);
                    }
                    const initDecoderObject = message.wasmBinary ? {
                        wasmBinary: message.wasmBinary
                    } : {};
                    decoderPromise = DracoDecoderModule(initDecoderObject);
                    postMessage({
                        id: "initDone"
                    });
                    break;
                }
            case "decodeMesh":
                {
                    if (!decoderPromise) {
                        throw new Error("Draco decoder module is not available");
                    }
                    // eslint-disable-next-line github/no-then
                    decoderPromise.then((decoder)=>{
                        const numPoints = DecodeMesh(decoder, message.dataView, message.attributes, (indices)=>{
                            postMessage({
                                id: "indices",
                                data: indices
                            }, [
                                indices.buffer
                            ]);
                        }, (kind, data, size, offset, stride, normalized)=>{
                            postMessage({
                                id: "attribute",
                                kind,
                                data,
                                size,
                                byteOffset: offset,
                                byteStride: stride,
                                normalized
                            }, [
                                data.buffer
                            ]);
                        });
                        postMessage({
                            id: "decodeMeshDone",
                            totalVertices: numPoints
                        });
                    });
                    break;
                }
        }
    };
}
;
async function initializeWebWorker(worker, wasmBinary, moduleUrl) {
    return await new Promise((resolve, reject)=>{
        const onError = (error)=>{
            worker.removeEventListener("error", onError);
            worker.removeEventListener("message", onMessage);
            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
            reject(error);
        };
        const onMessage = (event)=>{
            if (event.data.id === "initDone") {
                worker.removeEventListener("error", onError);
                worker.removeEventListener("message", onMessage);
                resolve(worker);
            }
        };
        worker.addEventListener("error", onError);
        worker.addEventListener("message", onMessage);
        // Load with either JS-only or WASM version
        if (!wasmBinary) {
            worker.postMessage({
                id: "init",
                url: moduleUrl
            });
        } else {
            // clone the array buffer to make it transferable
            const clone = wasmBinary.slice(0);
            worker.postMessage({
                id: "init",
                url: moduleUrl,
                wasmBinary: clone
            }, [
                clone
            ]);
        }
    // note: no transfer list as the ArrayBuffer is shared across main thread and pool workers
    });
} //# sourceMappingURL=dracoCompressionWorker.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Compression/dracoCodec.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DracoCodec",
    ()=>DracoCodec,
    "_GetDefaultNumWorkers",
    ()=>_GetDefaultNumWorkers,
    "_IsConfigurationAvailable",
    ()=>_IsConfigurationAvailable
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tools.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$workerPool$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/workerPool.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoCompressionWorker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Compression/dracoCompressionWorker.js [app-client] (ecmascript)");
;
;
;
function _GetDefaultNumWorkers() {
    if (typeof navigator !== "object" || !navigator.hardwareConcurrency) {
        return 1;
    }
    // Use 50% of the available logical processors but capped at 4.
    return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);
}
function _IsConfigurationAvailable(config) {
    return !!(config.wasmUrl && (config.wasmBinary || config.wasmBinaryUrl) && typeof WebAssembly === "object" || config.fallbackUrl);
// TODO: Account for jsModule
}
class DracoCodec {
    /**
     * Constructor
     * @param configuration The configuration for the DracoCodec instance.
     */ constructor(configuration){
        // check if the codec binary and worker pool was injected
        // Note - it is expected that the developer checked if WebWorker, WebAssembly and the URL object are available
        if (configuration.workerPool) {
            // Set the promise accordingly
            this._workerPoolPromise = Promise.resolve(configuration.workerPool);
            return;
        }
        // to avoid making big changes to the code here, if wasmBinary is provided use it in the wasmBinaryPromise
        const wasmBinaryProvided = configuration.wasmBinary;
        const numberOfWorkers = configuration.numWorkers ?? _GetDefaultNumWorkers();
        const useWorkers = numberOfWorkers && typeof Worker === "function" && typeof URL === "function";
        const urlNeeded = useWorkers || !configuration.jsModule;
        // code maintained here for back-compat with no changes
        const codecInfo = configuration.wasmUrl && configuration.wasmBinaryUrl && typeof WebAssembly === "object" ? {
            url: urlNeeded ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tools"].GetBabylonScriptURL(configuration.wasmUrl, true) : "",
            wasmBinaryPromise: wasmBinaryProvided ? Promise.resolve(wasmBinaryProvided) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tools"].LoadFileAsync(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tools"].GetBabylonScriptURL(configuration.wasmBinaryUrl, true))
        } : {
            url: urlNeeded ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tools"].GetBabylonScriptURL(configuration.fallbackUrl) : "",
            wasmBinaryPromise: Promise.resolve(undefined)
        };
        // If using workers, initialize a worker pool with either the wasm or url?
        if (useWorkers) {
            // eslint-disable-next-line github/no-then
            this._workerPoolPromise = codecInfo.wasmBinaryPromise.then((wasmBinary)=>{
                const workerContent = this._getWorkerContent();
                const workerBlobUrl = URL.createObjectURL(new Blob([
                    workerContent
                ], {
                    type: "application/javascript"
                }));
                // eslint-disable-next-line @typescript-eslint/promise-function-async
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$workerPool$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AutoReleaseWorkerPool"](numberOfWorkers, ()=>{
                    const worker = new Worker(workerBlobUrl);
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoCompressionWorker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["initializeWebWorker"])(worker, wasmBinary, codecInfo.url);
                });
            });
        } else {
            // eslint-disable-next-line github/no-then
            this._modulePromise = codecInfo.wasmBinaryPromise.then(async (wasmBinary)=>{
                if (!this._isModuleAvailable()) {
                    if (!configuration.jsModule) {
                        if (!codecInfo.url) {
                            throw new Error("Draco codec module is not available");
                        }
                        await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tools"].LoadBabylonScriptAsync(codecInfo.url);
                    }
                }
                return await this._createModuleAsync(wasmBinary, configuration.jsModule);
            });
        }
    }
    /**
     * Returns a promise that resolves when ready. Call this manually to ensure the draco codec is ready before use.
     * @returns a promise that resolves when ready
     */ async whenReadyAsync() {
        if (this._workerPoolPromise) {
            await this._workerPoolPromise;
            return;
        }
        if (this._modulePromise) {
            await this._modulePromise;
            return;
        }
    }
    /**
     * Stop all async operations and release resources.
     */ dispose() {
        if (this._workerPoolPromise) {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then
            this._workerPoolPromise.then((workerPool)=>{
                workerPool.dispose();
            });
        }
        delete this._workerPoolPromise;
        delete this._modulePromise;
    }
} //# sourceMappingURL=dracoCodec.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Compression/dracoDecoder.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DracoDecoder",
    ()=>DracoDecoder
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoCodec$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Compression/dracoCodec.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tools.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/buffer.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/logger.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoCompressionWorker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Compression/dracoCompressionWorker.js [app-client] (ecmascript)");
;
;
;
;
;
;
class DracoDecoder extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoCodec$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DracoCodec"] {
    /**
     * Returns true if the decoder's `DefaultConfiguration` is available.
     */ static get DefaultAvailable() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoCodec$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsConfigurationAvailable"])(DracoDecoder.DefaultConfiguration);
    }
    /**
     * Default instance for the DracoDecoder.
     */ static get Default() {
        DracoDecoder._Default ?? (DracoDecoder._Default = new DracoDecoder());
        return DracoDecoder._Default;
    }
    /**
     * Reset the default DracoDecoder object to null and disposing the removed default instance.
     * Note that if the workerPool is a member of the static DefaultConfiguration object it is recommended not to run dispose,
     * unless the static worker pool is no longer needed.
     * @param skipDispose set to true to not dispose the removed default instance
     */ static ResetDefault(skipDispose) {
        if (DracoDecoder._Default) {
            if (!skipDispose) {
                DracoDecoder._Default.dispose();
            }
            DracoDecoder._Default = null;
        }
    }
    _isModuleAvailable() {
        return typeof DracoDecoderModule !== "undefined";
    }
    async _createModuleAsync(wasmBinary, jsModule /** DracoDecoderModule */ ) {
        const module = await (jsModule || DracoDecoderModule)({
            wasmBinary
        });
        return {
            module
        };
    }
    _getWorkerContent() {
        return `${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoCompressionWorker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DecodeMesh"]}(${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoCompressionWorker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DecoderWorkerFunction"]})()`;
    }
    /**
     * Creates a new Draco decoder.
     * @param configuration Optional override of the configuration for the DracoDecoder. If not provided, defaults to {@link DracoDecoder.DefaultConfiguration}.
     */ constructor(configuration = DracoDecoder.DefaultConfiguration){
        super(configuration);
    }
    /**
     * Decode Draco compressed mesh data to mesh data.
     * @param data The ArrayBuffer or ArrayBufferView of the compressed Draco data
     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids
     * @param gltfNormalizedOverride A map of attributes from vertex buffer kinds to normalized flags to override the Draco normalization
     * @returns A promise that resolves with the decoded mesh data
     */ // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    decodeMeshToMeshDataAsync(data, attributes, gltfNormalizedOverride) {
        const dataView = data instanceof ArrayBuffer ? new Int8Array(data) : new Int8Array(data.buffer, data.byteOffset, data.byteLength);
        const applyGltfNormalizedOverride = (kind, normalized)=>{
            if (gltfNormalizedOverride && gltfNormalizedOverride[kind] !== undefined) {
                if (normalized !== gltfNormalizedOverride[kind]) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].Warn(`Normalized flag from Draco data (${normalized}) does not match normalized flag from glTF accessor (${gltfNormalizedOverride[kind]}). Using flag from glTF accessor.`);
                }
                return gltfNormalizedOverride[kind];
            } else {
                return normalized;
            }
        };
        if (this._workerPoolPromise) {
            // eslint-disable-next-line github/no-then
            return this._workerPoolPromise.then(async (workerPool)=>{
                return await new Promise((resolve, reject)=>{
                    workerPool.push((worker, onComplete)=>{
                        let resultIndices = null;
                        const resultAttributes = [];
                        const onError = (error)=>{
                            worker.removeEventListener("error", onError);
                            worker.removeEventListener("message", onMessage);
                            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
                            reject(error);
                            onComplete();
                        };
                        const onMessage = (event)=>{
                            const message = event.data;
                            switch(message.id){
                                case "indices":
                                    {
                                        resultIndices = message.data;
                                        break;
                                    }
                                case "attribute":
                                    {
                                        resultAttributes.push({
                                            kind: message.kind,
                                            data: message.data,
                                            size: message.size,
                                            byteOffset: message.byteOffset,
                                            byteStride: message.byteStride,
                                            normalized: applyGltfNormalizedOverride(message.kind, message.normalized)
                                        });
                                        break;
                                    }
                                case "decodeMeshDone":
                                    {
                                        worker.removeEventListener("error", onError);
                                        worker.removeEventListener("message", onMessage);
                                        resolve({
                                            indices: resultIndices,
                                            attributes: resultAttributes,
                                            totalVertices: message.totalVertices
                                        });
                                        onComplete();
                                        break;
                                    }
                            }
                        };
                        worker.addEventListener("error", onError);
                        worker.addEventListener("message", onMessage);
                        const dataViewCopy = dataView.slice();
                        worker.postMessage({
                            id: "decodeMesh",
                            dataView: dataViewCopy,
                            attributes: attributes
                        }, [
                            dataViewCopy.buffer
                        ]);
                    });
                });
            });
        }
        if (this._modulePromise) {
            // eslint-disable-next-line github/no-then
            return this._modulePromise.then((decoder)=>{
                let resultIndices = null;
                const resultAttributes = [];
                const numPoints = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoCompressionWorker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DecodeMesh"])(decoder.module, dataView, attributes, (indices)=>{
                    resultIndices = indices;
                }, (kind, data, size, byteOffset, byteStride, normalized)=>{
                    resultAttributes.push({
                        kind,
                        data,
                        size,
                        byteOffset,
                        byteStride,
                        normalized
                    });
                });
                return {
                    indices: resultIndices,
                    attributes: resultAttributes,
                    totalVertices: numPoints
                };
            });
        }
        throw new Error("Draco decoder module is not available");
    }
    /**
     * Decode Draco compressed mesh data to Babylon geometry.
     * @param name The name to use when creating the geometry
     * @param scene The scene to use when creating the geometry
     * @param data The ArrayBuffer or ArrayBufferView of the Draco compressed data
     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids
     * @returns A promise that resolves with the decoded geometry
     */ async decodeMeshToGeometryAsync(name, scene, data, attributes) {
        const meshData = await this.decodeMeshToMeshDataAsync(data, attributes);
        const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Geometry"](name, scene);
        if (meshData.indices) {
            geometry.setIndices(meshData.indices);
        }
        for (const attribute of meshData.attributes){
            geometry.setVerticesBuffer(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"](scene.getEngine(), attribute.data, attribute.kind, false, undefined, attribute.byteStride, undefined, attribute.byteOffset, attribute.size, undefined, attribute.normalized, true), meshData.totalVertices);
        }
        return geometry;
    }
    /** @internal */ async _decodeMeshToGeometryForGltfAsync(name, scene, data, attributes, gltfNormalizedOverride, boundingInfo) {
        const meshData = await this.decodeMeshToMeshDataAsync(data, attributes, gltfNormalizedOverride);
        const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Geometry"](name, scene);
        if (boundingInfo) {
            geometry._boundingInfo = boundingInfo;
            geometry.useBoundingInfoFromGeometry = true;
        }
        if (meshData.indices) {
            geometry.setIndices(meshData.indices);
        }
        for (const attribute of meshData.attributes){
            geometry.setVerticesBuffer(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"](scene.getEngine(), attribute.data, attribute.kind, false, undefined, attribute.byteStride, undefined, attribute.byteOffset, attribute.size, undefined, attribute.normalized, true), meshData.totalVertices);
        }
        return geometry;
    }
}
/**
 * Default configuration for the DracoDecoder. Defaults to the following:
 * - numWorkers: 50% of the available logical processors, capped to 4. If no logical processors are available, defaults to 1.
 * - wasmUrl: `"https://cdn.babylonjs.com/draco_wasm_wrapper_gltf.js"`
 * - wasmBinaryUrl: `"https://cdn.babylonjs.com/draco_decoder_gltf.wasm"`
 * - fallbackUrl: `"https://cdn.babylonjs.com/draco_decoder_gltf.js"`
 */ DracoDecoder.DefaultConfiguration = {
    wasmUrl: `${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tools"]._DefaultCdnUrl}/draco_wasm_wrapper_gltf.js`,
    wasmBinaryUrl: `${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tools"]._DefaultCdnUrl}/draco_decoder_gltf.wasm`,
    fallbackUrl: `${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tools"]._DefaultCdnUrl}/draco_decoder_gltf.js`
};
DracoDecoder._Default = null; //# sourceMappingURL=dracoDecoder.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Compression/dracoCompression.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DracoCompression",
    ()=>DracoCompression
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoCodec$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Compression/dracoCodec.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoDecoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Compression/dracoDecoder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/buffer.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.vertexData.js [app-client] (ecmascript)");
;
;
;
;
class DracoCompression {
    /**
     * The configuration. Defaults to the following urls:
     * - wasmUrl: "https://cdn.babylonjs.com/draco_wasm_wrapper_gltf.js"
     * - wasmBinaryUrl: "https://cdn.babylonjs.com/draco_decoder_gltf.wasm"
     * - fallbackUrl: "https://cdn.babylonjs.com/draco_decoder_gltf.js"
     */ static get Configuration() {
        return {
            get decoder () {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoDecoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DracoDecoder"].DefaultConfiguration;
            },
            set decoder (value){
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoDecoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DracoDecoder"].DefaultConfiguration = value;
            }
        };
    }
    static set Configuration(value1) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoDecoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DracoDecoder"].DefaultConfiguration = value1.decoder;
    }
    /**
     * Returns true if the decoder configuration is available.
     */ static get DecoderAvailable() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoCodec$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsConfigurationAvailable"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoDecoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DracoDecoder"].DefaultConfiguration);
    }
    /**
     * Default instance for the DracoCompression.
     */ static get Default() {
        DracoCompression._Default ?? (DracoCompression._Default = new DracoCompression());
        return DracoCompression._Default;
    }
    /**
     * Reset the default draco compression object to null and disposing the removed default instance.
     * Note that if the workerPool is a member of the static Configuration object it is recommended not to run dispose,
     * unless the static worker pool is no longer needed.
     * @param skipDispose set to true to not dispose the removed default instance
     */ static ResetDefault(skipDispose) {
        if (DracoCompression._Default) {
            if (!skipDispose) {
                DracoCompression._Default.dispose();
            }
            DracoCompression._Default = null;
        }
    }
    /**
     * Creates a new DracoCompression object.
     * @param numWorkersOrOptions Overrides for the Configuration. Either:
     * - The number of workers for async operations or a config object. Specify `0` to disable web workers and run synchronously in the current context.
     * - An options object
     */ constructor(numWorkersOrOptions = DracoCompression.DefaultNumWorkers){
        const configuration = typeof numWorkersOrOptions === "number" ? {
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoDecoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DracoDecoder"].DefaultConfiguration,
            numWorkers: numWorkersOrOptions
        } : {
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoDecoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DracoDecoder"].DefaultConfiguration,
            ...numWorkersOrOptions
        };
        this._decoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoDecoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DracoDecoder"](configuration);
    }
    /**
     * Stop all async operations and release resources.
     */ dispose() {
        this._decoder.dispose();
    }
    /**
     * Returns a promise that resolves when ready. Call this manually to ensure draco compression is ready before use.
     * @returns a promise that resolves when ready
     */ async whenReadyAsync() {
        return await this._decoder.whenReadyAsync();
    }
    /**
     * Decode Draco compressed mesh data to mesh data.
     * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data
     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids
     * @param gltfNormalizedOverride A map of attributes from vertex buffer kinds to normalized flags to override the Draco normalization
     * @returns A promise that resolves with the decoded mesh data
     */ // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    decodeMeshToMeshDataAsync(data, attributes, gltfNormalizedOverride) {
        return this._decoder.decodeMeshToMeshDataAsync(data, attributes, gltfNormalizedOverride);
    }
    /**
     * Decode Draco compressed mesh data to Babylon geometry.
     * @param name The name to use when creating the geometry
     * @param scene The scene to use when creating the geometry
     * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data
     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids
     * @returns A promise that resolves with the decoded geometry
     */ async decodeMeshToGeometryAsync(name, scene, data, attributes) {
        return await this._decoder.decodeMeshToGeometryAsync(name, scene, data, attributes);
    }
    /** @internal */ async _decodeMeshToGeometryForGltfAsync(name, scene, data, attributes, gltfNormalizedOverride, boundingInfo) {
        return await this._decoder._decodeMeshToGeometryForGltfAsync(name, scene, data, attributes, gltfNormalizedOverride, boundingInfo);
    }
    /**
     * Decode Draco compressed mesh data to Babylon vertex data.
     * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data
     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids
     * @returns A promise that resolves with the decoded vertex data
     * @deprecated Use {@link decodeMeshToGeometryAsync} for better performance in some cases
     */ async decodeMeshAsync(data, attributes) {
        const meshData = await this._decoder.decodeMeshToMeshDataAsync(data, attributes);
        const vertexData = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexData"]();
        if (meshData.indices) {
            vertexData.indices = meshData.indices;
        }
        for (const attribute of meshData.attributes){
            const floatData = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].GetFloatData(attribute.data, attribute.size, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].GetDataType(attribute.data), attribute.byteOffset, attribute.byteStride, attribute.normalized, meshData.totalVertices);
            vertexData.set(floatData, attribute.kind);
        }
        return vertexData;
    }
}
/**
 * Default number of workers to create when creating the draco compression object.
 */ DracoCompression.DefaultNumWorkers = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoCodec$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_GetDefaultNumWorkers"])();
DracoCompression._Default = null; //# sourceMappingURL=dracoCompression.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Compression/meshoptCompression.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MeshoptCompression",
    ()=>MeshoptCompression
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tools.js [app-client] (ecmascript)");
;
// eslint-disable-next-line @typescript-eslint/naming-convention
let NumberOfWorkers = 0;
// eslint-disable-next-line @typescript-eslint/naming-convention
let WorkerTimeout = null;
class MeshoptCompression {
    /**
     * Default instance for the meshoptimizer object.
     */ static get Default() {
        if (!MeshoptCompression._Default) {
            MeshoptCompression._Default = new MeshoptCompression();
        }
        return MeshoptCompression._Default;
    }
    /**
     * Constructor
     */ constructor(){
        const decoder = MeshoptCompression.Configuration.decoder;
        // eslint-disable-next-line github/no-then
        this._decoderModulePromise = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tools"].LoadBabylonScriptAsync(decoder.url).then(()=>{
            // Wait for WebAssembly compilation before resolving promise
            return MeshoptDecoder.ready;
        });
    }
    /**
     * Stop all async operations and release resources.
     */ dispose() {
        delete this._decoderModulePromise;
    }
    /**
     * Decode meshopt data.
     * @see https://github.com/zeux/meshoptimizer/tree/master/js#decoder
     * @param source The input data.
     * @param count The number of elements.
     * @param stride The stride in bytes.
     * @param mode The compression mode.
     * @param filter The compression filter.
     * @returns a Promise<Uint8Array> that resolves to the decoded data
     */ async decodeGltfBufferAsync(source, count, stride, mode, filter) {
        await this._decoderModulePromise;
        if (NumberOfWorkers === 0) {
            MeshoptDecoder.useWorkers(1);
            NumberOfWorkers = 1;
        }
        const result = await MeshoptDecoder.decodeGltfBufferAsync(count, stride, source, mode, filter);
        // a simple debounce to avoid switching back and forth between workers and no workers while decoding
        if (WorkerTimeout !== null) {
            clearTimeout(WorkerTimeout);
        }
        WorkerTimeout = setTimeout(()=>{
            MeshoptDecoder.useWorkers(0);
            NumberOfWorkers = 0;
            WorkerTimeout = null;
        }, 1000);
        return result;
    }
}
/**
 * The configuration. Defaults to the following:
 * ```javascript
 * decoder: {
 *   url: "https://cdn.babylonjs.com/meshopt_decoder.js"
 * }
 * ```
 */ MeshoptCompression.Configuration = {
    decoder: {
        url: `${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tools"]._DefaultCdnUrl}/meshopt_decoder.js`
    }
};
MeshoptCompression._Default = null; //# sourceMappingURL=meshoptCompression.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Compression/dracoEncoder.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DracoEncoder",
    ()=>DracoEncoder
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoCodec$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Compression/dracoCodec.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoCompressionWorker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Compression/dracoCompressionWorker.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tools.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/buffer.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/logger.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$deepMerger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/deepMerger.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$bufferUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/bufferUtils.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
/**
 * Map the Babylon.js attribute kind to the Draco attribute kind, defined by the `GeometryAttributeType` enum.
 * @internal
 */ function GetDracoAttributeName(kind) {
    if (kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind) {
        return "POSITION";
    } else if (kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].NormalKind) {
        return "NORMAL";
    } else if (kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorKind) {
        return "COLOR";
    } else if (kind.startsWith(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UVKind)) {
        return "TEX_COORD";
    }
    return "GENERIC";
}
/**
 * Get the indices for the geometry, if present. Eventually used as
 * `AddFacesToMesh(mesh: Mesh, numFaces: number, faces: Uint16Array | Uint32Array)`;
 * where `numFaces = indices.length / 3` and `faces = indices`.
 * @internal
 */ function PrepareIndicesForDraco(input) {
    let indices = input.getIndices(undefined, true);
    // Convert number[] and Int32Array types, if needed
    if (indices && !(indices instanceof Uint32Array) && !(indices instanceof Uint16Array)) {
        indices = ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$bufferUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AreIndices32Bits"])(indices, indices.length) ? Uint32Array : Uint16Array).from(indices);
    }
    return indices;
}
/**
 * Get relevant information about the geometry's vertex attributes for Draco encoding. Eventually used for each attribute as
 * `AddFloatAttribute(mesh: Mesh, attribute: number, count: number, itemSize: number, array: TypedArray)`
 * where `attribute = EncoderModule[<dracoAttribute>]`, `itemSize = <size>`, `array = <data>`, and count is the number of position vertices.
 * @internal
 */ function PrepareAttributesForDraco(input, excludedAttributes) {
    const attributes = [];
    for (const kind of input.getVerticesDataKinds()){
        if (excludedAttributes?.includes(kind)) {
            if (kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind) {
                throw new Error("Cannot exclude position attribute from Draco encoding.");
            }
            continue;
        }
        // Convert number[] to typed array, if needed.
        const vertexBuffer = input.getVertexBuffer(kind);
        const size = vertexBuffer.getSize();
        const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$bufferUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GetTypedArrayData"])(vertexBuffer.getData(), size, vertexBuffer.type, vertexBuffer.byteOffset, vertexBuffer.byteStride, input.getTotalVertices(), true);
        attributes.push({
            kind: kind,
            dracoName: GetDracoAttributeName(kind),
            size: size,
            data: data
        });
    }
    return attributes;
}
const DefaultEncoderOptions = {
    decodeSpeed: 5,
    encodeSpeed: 5,
    method: "MESH_EDGEBREAKER_ENCODING",
    quantizationBits: {
        POSITION: 14,
        NORMAL: 10,
        COLOR: 8,
        TEX_COORD: 12,
        GENERIC: 12
    }
};
class DracoEncoder extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoCodec$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DracoCodec"] {
    /**
     * Returns true if the encoder's `DefaultConfiguration` is available.
     */ static get DefaultAvailable() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoCodec$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_IsConfigurationAvailable"])(DracoEncoder.DefaultConfiguration);
    }
    /**
     * Default instance for the DracoEncoder.
     */ static get Default() {
        DracoEncoder._Default ?? (DracoEncoder._Default = new DracoEncoder());
        return DracoEncoder._Default;
    }
    /**
     * Reset the default DracoEncoder object to null and disposing the removed default instance.
     * Note that if the workerPool is a member of the static DefaultConfiguration object it is recommended not to run dispose,
     * unless the static worker pool is no longer needed.
     * @param skipDispose set to true to not dispose the removed default instance
     */ static ResetDefault(skipDispose) {
        if (DracoEncoder._Default) {
            if (!skipDispose) {
                DracoEncoder._Default.dispose();
            }
            DracoEncoder._Default = null;
        }
    }
    _isModuleAvailable() {
        return typeof DracoEncoderModule !== "undefined";
    }
    async _createModuleAsync(wasmBinary, jsModule /** DracoEncoderModule */ ) {
        const module = await (jsModule || DracoEncoderModule)({
            wasmBinary
        });
        return {
            module
        };
    }
    _getWorkerContent() {
        return `${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoCompressionWorker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EncodeMesh"]}(${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoCompressionWorker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EncoderWorkerFunction"]})()`;
    }
    /**
     * Creates a new Draco encoder.
     * @param configuration Optional override of the configuration for the DracoEncoder. If not provided, defaults to {@link DracoEncoder.DefaultConfiguration}.
     */ constructor(configuration = DracoEncoder.DefaultConfiguration){
        super(configuration);
    }
    /**
     * @internal
     */ async _encodeAsync(attributes, indices, options) {
        const mergedOptions = options ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$deepMerger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deepMerge"])(DefaultEncoderOptions, options) : DefaultEncoderOptions;
        if (this._workerPoolPromise) {
            const workerPool = await this._workerPoolPromise;
            return await new Promise((resolve, reject)=>{
                workerPool.push((worker, onComplete)=>{
                    const onError = (error)=>{
                        worker.removeEventListener("error", onError);
                        worker.removeEventListener("message", onMessage);
                        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
                        reject(error);
                        onComplete();
                    };
                    const onMessage = (message)=>{
                        if (message.data.id === "encodeMeshDone") {
                            worker.removeEventListener("error", onError);
                            worker.removeEventListener("message", onMessage);
                            resolve(message.data.encodedMeshData);
                            onComplete();
                        }
                    };
                    worker.addEventListener("error", onError);
                    worker.addEventListener("message", onMessage);
                    // Build the transfer list. No need to copy, as the data was copied in previous steps.
                    const transferList = [];
                    for (const attribute of attributes){
                        transferList.push(attribute.data.buffer);
                    }
                    if (indices) {
                        transferList.push(indices.buffer);
                    }
                    worker.postMessage({
                        id: "encodeMesh",
                        attributes: attributes,
                        indices: indices,
                        options: mergedOptions
                    }, transferList);
                });
            });
        }
        if (this._modulePromise) {
            const encoder = await this._modulePromise;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoCompressionWorker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EncodeMesh"])(encoder.module, attributes, indices, mergedOptions);
        }
        throw new Error("Draco encoder module is not available");
    }
    /**
     * Encodes a mesh or geometry into a Draco-encoded mesh data.
     * @param input the mesh or geometry to encode
     * @param options options for the encoding
     * @returns a promise that resolves to the newly-encoded data
     */ async encodeMeshAsync(input, options) {
        const verticesCount = input.getTotalVertices();
        if (verticesCount == 0) {
            throw new Error("Cannot compress geometry with Draco. There are no vertices.");
        }
        // Prepare parameters for encoding
        if (input instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"] && input.morphTargetManager && options?.method === "MESH_EDGEBREAKER_ENCODING") {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method.");
            options.method = "MESH_SEQUENTIAL_ENCODING";
        }
        const indices = PrepareIndicesForDraco(input);
        const attributes = PrepareAttributesForDraco(input, options?.excludedAttributes);
        return await this._encodeAsync(attributes, indices, options);
    }
}
/**
 * Default configuration for the DracoEncoder. Defaults to the following:
 * - numWorkers: 50% of the available logical processors, capped to 4. If no logical processors are available, defaults to 1.
 * - wasmUrl: `"https://cdn.babylonjs.com/draco_encoder_wasm_wrapper.js"`
 * - wasmBinaryUrl: `"https://cdn.babylonjs.com/draco_encoder.wasm"`
 * - fallbackUrl: `"https://cdn.babylonjs.com/draco_encoder.js"`
 */ DracoEncoder.DefaultConfiguration = {
    wasmUrl: `${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tools"]._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,
    wasmBinaryUrl: `${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tools"]._DefaultCdnUrl}/draco_encoder.wasm`,
    fallbackUrl: `${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tools"]._DefaultCdnUrl}/draco_encoder.js`
};
DracoEncoder._Default = null; //# sourceMappingURL=dracoEncoder.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Compression/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoCompression$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Compression/dracoCompression.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$meshoptCompression$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Compression/meshoptCompression.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoDecoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Compression/dracoDecoder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoEncoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Compression/dracoEncoder.js [app-client] (ecmascript)"); //# sourceMappingURL=index.js.map
;
;
;
;
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Compression/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DracoCompression",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoCompression$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DracoCompression"],
    "DracoDecoder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoDecoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DracoDecoder"],
    "DracoEncoder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoEncoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DracoEncoder"],
    "MeshoptCompression",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$meshoptCompression$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshoptCompression"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Compression/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoCompression$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Compression/dracoCompression.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$meshoptCompression$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Compression/meshoptCompression.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoDecoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Compression/dracoDecoder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$dracoEncoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Compression/dracoEncoder.js [app-client] (ecmascript)");
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/csg.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CSG",
    ()=>CSG
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$subMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/subMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.color.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.vertexData.js [app-client] (ecmascript)");
;
;
;
;
;
;
/**
 * Unique ID when we import meshes from Babylon to CSG
 */ let CurrentCSGMeshId = 0;
/**
 * Represents a vertex of a polygon. Use your own vertex class instead of this
 * one to provide additional features like texture coordinates and vertex
 * colors. Custom vertex classes need to provide a `pos` property and `clone()`,
 * `flip()`, and `interpolate()` methods that behave analogous to the ones
 * defined by `BABYLON.CSG.Vertex`. This class provides `normal` so convenience
 * functions like `BABYLON.CSG.sphere()` can return a smooth vertex normal, but `normal`
 * is not used anywhere else.
 * Same goes for uv, it allows to keep the original vertex uv coordinates of the 2 meshes
 */ class Vertex {
    /**
     * Initializes the vertex
     * @param pos The position of the vertex
     * @param normal The normal of the vertex
     * @param uv The texture coordinate of the vertex
     * @param vertColor The RGBA color of the vertex
     */ constructor(/**
     * The position of the vertex
     */ pos, /**
     * The normal of the vertex
     */ normal, /**
     * The texture coordinate of the vertex
     */ uv, /**
     * The texture coordinate of the vertex
     */ vertColor){
        this.pos = pos;
        this.normal = normal;
        this.uv = uv;
        this.vertColor = vertColor;
    }
    /**
     * Make a clone, or deep copy, of the vertex
     * @returns A new Vertex
     */ clone() {
        return new Vertex(this.pos.clone(), this.normal.clone(), this.uv?.clone(), this.vertColor?.clone());
    }
    /**
     * Invert all orientation-specific data (e.g. vertex normal). Called when the
     * orientation of a polygon is flipped.
     */ flip() {
        this.normal = this.normal.scale(-1);
    }
    /**
     * Create a new vertex between this vertex and `other` by linearly
     * interpolating all properties using a parameter of `t`. Subclasses should
     * override this to interpolate additional properties.
     * @param other the vertex to interpolate against
     * @param t The factor used to linearly interpolate between the vertices
     * @returns The new interpolated vertex
     */ interpolate(other, t) {
        return new Vertex(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Lerp(this.pos, other.pos, t), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Lerp(this.normal, other.normal, t), this.uv && other.uv ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"].Lerp(this.uv, other.uv, t) : undefined, this.vertColor && other.vertColor ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color4"].Lerp(this.vertColor, other.vertColor, t) : undefined);
    }
}
/**
 * Represents a plane in 3D space.
 */ class CSGPlane {
    /**
     * Initializes the plane
     * @param normal The normal for the plane
     * @param w
     */ constructor(normal, w){
        this.normal = normal;
        this.w = w;
    }
    /**
     * Construct a plane from three points
     * @param a Point a
     * @param b Point b
     * @param c Point c
     * @returns A new plane
     */ static FromPoints(a, b, c) {
        const v0 = c.subtract(a);
        const v1 = b.subtract(a);
        if (v0.lengthSquared() === 0 || v1.lengthSquared() === 0) {
            return null;
        }
        const n = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Normalize(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Cross(v0, v1));
        return new CSGPlane(n, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Dot(n, a));
    }
    /**
     * Clone, or make a deep copy of the plane
     * @returns a new Plane
     */ clone() {
        return new CSGPlane(this.normal.clone(), this.w);
    }
    /**
     * Flip the face of the plane
     */ flip() {
        this.normal.scaleInPlace(-1);
        this.w = -this.w;
    }
    /**
     * Split `polygon` by this plane if needed, then put the polygon or polygon
     * fragments in the appropriate lists. Coplanar polygons go into either
    `* coplanarFront` or `coplanarBack` depending on their orientation with
     * respect to this plane. Polygons in front or in back of this plane go into
     * either `front` or `back`
     * @param polygon The polygon to be split
     * @param coplanarFront Will contain polygons coplanar with the plane that are oriented to the front of the plane
     * @param coplanarBack Will contain polygons coplanar with the plane that are oriented to the back of the plane
     * @param front Will contain the polygons in front of the plane
     * @param back Will contain the polygons begind the plane
     */ splitPolygon(polygon, coplanarFront, coplanarBack, front, back) {
        const coplanarConst = 0;
        const frontConst = 1;
        const backConst = 2;
        const spanningConst = 3;
        // Classify each point as well as the entire polygon into one of the above
        // four classes.
        let polygonType = 0;
        const types = [];
        let i;
        let t;
        for(i = 0; i < polygon.vertices.length; i++){
            t = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Dot(this.normal, polygon.vertices[i].pos) - this.w;
            const type = t < -CSGPlane.EPSILON ? backConst : t > CSGPlane.EPSILON ? frontConst : coplanarConst;
            polygonType |= type;
            types.push(type);
        }
        // Put the polygon in the correct list, splitting it when necessary
        switch(polygonType){
            case coplanarConst:
                (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Dot(this.normal, polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);
                break;
            case frontConst:
                front.push(polygon);
                break;
            case backConst:
                back.push(polygon);
                break;
            case spanningConst:
                {
                    const f = [], b = [];
                    for(i = 0; i < polygon.vertices.length; i++){
                        const j = (i + 1) % polygon.vertices.length;
                        const ti = types[i], tj = types[j];
                        const vi = polygon.vertices[i], vj = polygon.vertices[j];
                        if (ti !== backConst) {
                            f.push(vi);
                        }
                        if (ti !== frontConst) {
                            b.push(ti !== backConst ? vi.clone() : vi);
                        }
                        if ((ti | tj) === spanningConst) {
                            t = (this.w - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Dot(this.normal, vi.pos)) / __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Dot(this.normal, vj.pos.subtract(vi.pos));
                            const v = vi.interpolate(vj, t);
                            f.push(v);
                            b.push(v.clone());
                        }
                    }
                    let poly;
                    if (f.length >= 3) {
                        poly = new CSGPolygon(f, polygon.shared);
                        if (poly.plane) {
                            front.push(poly);
                        }
                    }
                    if (b.length >= 3) {
                        poly = new CSGPolygon(b, polygon.shared);
                        if (poly.plane) {
                            back.push(poly);
                        }
                    }
                    break;
                }
        }
    }
}
/**
 * `CSG.Plane.EPSILON` is the tolerance used by `splitPolygon()` to decide if a
 * point is on the plane
 */ CSGPlane.EPSILON = 1e-5;
/**
 * Represents a convex polygon. The vertices used to initialize a polygon must
 * be coplanar and form a convex loop.
 *
 * Each convex polygon has a `shared` property, which is shared between all
 * polygons that are clones of each other or were split from the same polygon.
 * This can be used to define per-polygon properties (such as surface color)
 */ class CSGPolygon {
    /**
     * Initializes the polygon
     * @param vertices The vertices of the polygon
     * @param shared The properties shared across all polygons
     */ constructor(vertices, shared){
        this.vertices = vertices;
        this.shared = shared;
        this.plane = CSGPlane.FromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);
    }
    /**
     * Clones, or makes a deep copy, or the polygon
     * @returns A new CSGPolygon
     */ clone() {
        const vertices = this.vertices.map((v)=>v.clone());
        return new CSGPolygon(vertices, this.shared);
    }
    /**
     * Flips the faces of the polygon
     */ flip() {
        this.vertices.reverse().map((v)=>{
            v.flip();
        });
        this.plane.flip();
    }
}
/**
 * Holds a node in a BSP tree. A BSP tree is built from a collection of polygons
 * by picking a polygon to split along. That polygon (and all other coplanar
 * polygons) are added directly to that node and the other polygons are added to
 * the front and/or back subtrees. This is not a leafy BSP tree since there is
 * no distinction between internal and leaf nodes
 */ class Node {
    /**
     * Initializes the node
     * @param polygons A collection of polygons held in the node
     */ constructor(polygons){
        this._plane = null;
        this._front = null;
        this._back = null;
        this._polygons = new Array();
        if (polygons) {
            this.build(polygons);
        }
    }
    /**
     * Clones, or makes a deep copy, of the node
     * @returns The cloned node
     */ clone() {
        const node = new Node();
        node._plane = this._plane && this._plane.clone();
        node._front = this._front && this._front.clone();
        node._back = this._back && this._back.clone();
        node._polygons = this._polygons.map((p)=>p.clone());
        return node;
    }
    /**
     * Convert solid space to empty space and empty space to solid space
     */ invert() {
        for(let i = 0; i < this._polygons.length; i++){
            this._polygons[i].flip();
        }
        if (this._plane) {
            this._plane.flip();
        }
        if (this._front) {
            this._front.invert();
        }
        if (this._back) {
            this._back.invert();
        }
        const temp = this._front;
        this._front = this._back;
        this._back = temp;
    }
    /**
     * Recursively remove all polygons in `polygons` that are inside this BSP
     * tree.
     * @param polygons Polygons to remove from the BSP
     * @returns Polygons clipped from the BSP
     */ clipPolygons(polygons) {
        if (!this._plane) {
            return polygons.slice();
        }
        let front = [], back = [];
        for(let i = 0; i < polygons.length; i++){
            this._plane.splitPolygon(polygons[i], front, back, front, back);
        }
        if (this._front) {
            front = this._front.clipPolygons(front);
        }
        if (this._back) {
            back = this._back.clipPolygons(back);
        } else {
            back = [];
        }
        return front.concat(back);
    }
    /**
     * Remove all polygons in this BSP tree that are inside the other BSP tree
     * `bsp`.
     * @param bsp BSP containing polygons to remove from this BSP
     */ clipTo(bsp) {
        this._polygons = bsp.clipPolygons(this._polygons);
        if (this._front) {
            this._front.clipTo(bsp);
        }
        if (this._back) {
            this._back.clipTo(bsp);
        }
    }
    /**
     * Return a list of all polygons in this BSP tree
     * @returns List of all polygons in this BSP tree
     */ allPolygons() {
        let polygons = this._polygons.slice();
        if (this._front) {
            polygons = polygons.concat(this._front.allPolygons());
        }
        if (this._back) {
            polygons = polygons.concat(this._back.allPolygons());
        }
        return polygons;
    }
    /**
     * Build a BSP tree out of `polygons`. When called on an existing tree, the
     * new polygons are filtered down to the bottom of the tree and become new
     * nodes there. Each set of polygons is partitioned using the first polygon
     * (no heuristic is used to pick a good split)
     * @param polygons Polygons used to construct the BSP tree
     */ build(polygons) {
        if (!polygons.length) {
            return;
        }
        if (!this._plane) {
            this._plane = polygons[0].plane.clone();
        }
        const front = [], back = [];
        for(let i = 0; i < polygons.length; i++){
            this._plane.splitPolygon(polygons[i], this._polygons, this._polygons, front, back);
        }
        if (front.length) {
            if (!this._front) {
                this._front = new Node();
            }
            this._front.build(front);
        }
        if (back.length) {
            if (!this._back) {
                this._back = new Node();
            }
            this._back.build(back);
        }
    }
}
class CSG {
    constructor(){
        this._polygons = new Array();
    }
    /**
     * Convert a VertexData to CSG
     * @param data defines the VertexData to convert to CSG
     * @returns the new CSG
     */ static FromVertexData(data) {
        let vertex, polygon, vertices;
        const polygons = [];
        const indices = data.indices;
        const positions = data.positions;
        const normals = data.normals;
        const uvs = data.uvs;
        const vertColors = data.colors;
        if (!indices || !positions) {
            // eslint-disable-next-line no-throw-literal
            throw "BABYLON.CSG: VertexData must at least contain positions and indices";
        }
        for(let i = 0; i < indices.length; i += 3){
            vertices = [];
            for(let j = 0; j < 3; j++){
                const indexIndices = i + j;
                const offset = indices[indexIndices];
                const normal = normals ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].FromArray(normals, offset * 3) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Zero();
                const uv = uvs ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"].FromArray(uvs, offset * 2) : undefined;
                const vertColor = vertColors ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color4"].FromArray(vertColors, offset * 4) : undefined;
                const position = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].FromArray(positions, offset * 3);
                vertex = new Vertex(position, normal, uv, vertColor);
                vertices.push(vertex);
            }
            polygon = new CSGPolygon(vertices, {
                subMeshId: 0,
                meshId: CurrentCSGMeshId,
                materialIndex: 0
            });
            // To handle the case of degenerated triangle
            // polygon.plane == null <=> the polygon does not represent 1 single plane <=> the triangle is degenerated
            if (polygon.plane) {
                polygons.push(polygon);
            }
        }
        const csg = CSG._FromPolygons(polygons);
        csg.matrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].Identity();
        csg.position = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Zero();
        csg.rotation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Zero();
        csg.scaling = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].One();
        csg.rotationQuaternion = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"].Identity();
        CurrentCSGMeshId++;
        return csg;
    }
    /**
     * Convert the Mesh to CSG
     * @param mesh The Mesh to convert to CSG
     * @param absolute If true, the final (local) matrix transformation is set to the identity and not to that of `mesh`. It can help when dealing with right-handed meshes (default: false)
     * @returns A new CSG from the Mesh
     */ static FromMesh(mesh, absolute = false) {
        let vertex, normal, uv = undefined, position, vertColor = undefined, polygon, vertices;
        const polygons = [];
        let matrix, meshPosition, meshRotation, meshRotationQuaternion = null, meshScaling;
        let invertWinding = false;
        if (mesh instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"]) {
            mesh.computeWorldMatrix(true);
            matrix = mesh.getWorldMatrix();
            meshPosition = mesh.position.clone();
            meshRotation = mesh.rotation.clone();
            if (mesh.rotationQuaternion) {
                meshRotationQuaternion = mesh.rotationQuaternion.clone();
            }
            meshScaling = mesh.scaling.clone();
            if (mesh.material && absolute) {
                invertWinding = mesh.material.sideOrientation === 0;
            }
        } else {
            // eslint-disable-next-line no-throw-literal
            throw "BABYLON.CSG: Wrong Mesh type, must be BABYLON.Mesh";
        }
        const indices = mesh.getIndices(), positions = mesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind), normals = mesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].NormalKind), uvs = mesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UVKind), vertColors = mesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorKind);
        if (indices === null) {
            // eslint-disable-next-line no-throw-literal
            throw "BABYLON.CSG: Mesh has no indices";
        }
        if (positions === null) {
            // eslint-disable-next-line no-throw-literal
            throw "BABYLON.CSG: Mesh has no positions";
        }
        if (normals === null) {
            // eslint-disable-next-line no-throw-literal
            throw "BABYLON.CSG: Mesh has no normals";
        }
        const subMeshes = mesh.subMeshes;
        if (!subMeshes) {
            // eslint-disable-next-line no-throw-literal
            throw "BABYLON.CSG: Mesh has no submeshes";
        }
        for(let sm = 0, sml = subMeshes.length; sm < sml; sm++){
            for(let i = subMeshes[sm].indexStart, il = subMeshes[sm].indexCount + subMeshes[sm].indexStart; i < il; i += 3){
                vertices = [];
                for(let j = 0; j < 3; j++){
                    const indexIndices = j === 0 ? i + j : invertWinding ? i + 3 - j : i + j;
                    const sourceNormal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](normals[indices[indexIndices] * 3], normals[indices[indexIndices] * 3 + 1], normals[indices[indexIndices] * 3 + 2]);
                    if (uvs) {
                        uv = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](uvs[indices[indexIndices] * 2], uvs[indices[indexIndices] * 2 + 1]);
                    }
                    if (vertColors) {
                        vertColor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color4"](vertColors[indices[indexIndices] * 4], vertColors[indices[indexIndices] * 4 + 1], vertColors[indices[indexIndices] * 4 + 2], vertColors[indices[indexIndices] * 4 + 3]);
                    }
                    const sourcePosition = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](positions[indices[indexIndices] * 3], positions[indices[indexIndices] * 3 + 1], positions[indices[indexIndices] * 3 + 2]);
                    position = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformCoordinates(sourcePosition, matrix);
                    normal = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformNormal(sourceNormal, matrix);
                    vertex = new Vertex(position, normal, uv, vertColor);
                    vertices.push(vertex);
                }
                polygon = new CSGPolygon(vertices, {
                    subMeshId: sm,
                    meshId: CurrentCSGMeshId,
                    materialIndex: subMeshes[sm].materialIndex
                });
                // To handle the case of degenerated triangle
                // polygon.plane == null <=> the polygon does not represent 1 single plane <=> the triangle is degenerated
                if (polygon.plane) {
                    polygons.push(polygon);
                }
            }
        }
        const csg = CSG._FromPolygons(polygons);
        csg.matrix = absolute ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].Identity() : matrix;
        csg.position = absolute ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Zero() : meshPosition;
        csg.rotation = absolute ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Zero() : meshRotation;
        csg.scaling = absolute ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].One() : meshScaling;
        csg.rotationQuaternion = absolute && meshRotationQuaternion ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"].Identity() : meshRotationQuaternion;
        CurrentCSGMeshId++;
        return csg;
    }
    /**
     * Construct a CSG solid from a list of `CSG.Polygon` instances.
     * @param polygons Polygons used to construct a CSG solid
     * @returns A new CSG solid
     */ static _FromPolygons(polygons) {
        const csg = new CSG();
        csg._polygons = polygons;
        return csg;
    }
    /**
     * Clones, or makes a deep copy, of the CSG
     * @returns A new CSG
     */ clone() {
        const csg = new CSG();
        csg._polygons = this._polygons.map((p)=>p.clone());
        csg.copyTransformAttributes(this);
        return csg;
    }
    /**
     * Unions this CSG with another CSG
     * @param csg The CSG to union against this CSG
     * @returns The unioned CSG
     */ union(csg) {
        const a = new Node(this.clone()._polygons);
        const b = new Node(csg.clone()._polygons);
        a.clipTo(b);
        b.clipTo(a);
        b.invert();
        b.clipTo(a);
        b.invert();
        a.build(b.allPolygons());
        return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);
    }
    /**
     * Unions this CSG with another CSG in place
     * @param csg The CSG to union against this CSG
     */ unionInPlace(csg) {
        const a = new Node(this._polygons);
        const b = new Node(csg._polygons);
        a.clipTo(b);
        b.clipTo(a);
        b.invert();
        b.clipTo(a);
        b.invert();
        a.build(b.allPolygons());
        this._polygons = a.allPolygons();
    }
    /**
     * Subtracts this CSG with another CSG
     * @param csg The CSG to subtract against this CSG
     * @returns A new CSG
     */ subtract(csg) {
        const a = new Node(this.clone()._polygons);
        const b = new Node(csg.clone()._polygons);
        a.invert();
        a.clipTo(b);
        b.clipTo(a);
        b.invert();
        b.clipTo(a);
        b.invert();
        a.build(b.allPolygons());
        a.invert();
        return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);
    }
    /**
     * Subtracts this CSG with another CSG in place
     * @param csg The CSG to subtract against this CSG
     */ subtractInPlace(csg) {
        const a = new Node(this._polygons);
        const b = new Node(csg._polygons);
        a.invert();
        a.clipTo(b);
        b.clipTo(a);
        b.invert();
        b.clipTo(a);
        b.invert();
        a.build(b.allPolygons());
        a.invert();
        this._polygons = a.allPolygons();
    }
    /**
     * Intersect this CSG with another CSG
     * @param csg The CSG to intersect against this CSG
     * @returns A new CSG
     */ intersect(csg) {
        const a = new Node(this.clone()._polygons);
        const b = new Node(csg.clone()._polygons);
        a.invert();
        b.clipTo(a);
        b.invert();
        a.clipTo(b);
        b.clipTo(a);
        a.build(b.allPolygons());
        a.invert();
        return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);
    }
    /**
     * Intersects this CSG with another CSG in place
     * @param csg The CSG to intersect against this CSG
     */ intersectInPlace(csg) {
        const a = new Node(this._polygons);
        const b = new Node(csg._polygons);
        a.invert();
        b.clipTo(a);
        b.invert();
        a.clipTo(b);
        b.clipTo(a);
        a.build(b.allPolygons());
        a.invert();
        this._polygons = a.allPolygons();
    }
    /**
     * Return a new CSG solid with solid and empty space switched. This solid is
     * not modified.
     * @returns A new CSG solid with solid and empty space switched
     */ inverse() {
        const csg = this.clone();
        csg.inverseInPlace();
        return csg;
    }
    /**
     * Inverses the CSG in place
     */ inverseInPlace() {
        this._polygons.map((p)=>{
            p.flip();
        });
    }
    /**
     * This is used to keep meshes transformations so they can be restored
     * when we build back a Babylon Mesh
     * NB : All CSG operations are performed in world coordinates
     * @param csg The CSG to copy the transform attributes from
     * @returns This CSG
     */ copyTransformAttributes(csg) {
        this.matrix = csg.matrix;
        this.position = csg.position;
        this.rotation = csg.rotation;
        this.scaling = csg.scaling;
        this.rotationQuaternion = csg.rotationQuaternion;
        return this;
    }
    /**
     * Build vertex data from CSG
     * Coordinates here are in world space
     * @param onBeforePolygonProcessing called before each polygon is being processed
     * @param onAfterPolygonProcessing called after each polygon has been processed
     * @returns the final vertex data
     */ toVertexData(onBeforePolygonProcessing = null, onAfterPolygonProcessing = null) {
        const matrix = this.matrix.clone();
        matrix.invert();
        const polygons = this._polygons;
        const vertices = [];
        const indices = [];
        const normals = [];
        let uvs = null;
        let vertColors = null;
        const vertex = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Zero();
        const normal = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Zero();
        const uv = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"].Zero();
        const vertColor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color4"](0, 0, 0, 0);
        const polygonIndices = [
            0,
            0,
            0
        ];
        const verticeDict = {};
        let vertexIdx;
        for(let i = 0, il = polygons.length; i < il; i++){
            const polygon = polygons[i];
            if (onBeforePolygonProcessing) {
                onBeforePolygonProcessing(polygon);
            }
            for(let j = 2, jl = polygon.vertices.length; j < jl; j++){
                polygonIndices[0] = 0;
                polygonIndices[1] = j - 1;
                polygonIndices[2] = j;
                for(let k = 0; k < 3; k++){
                    vertex.copyFrom(polygon.vertices[polygonIndices[k]].pos);
                    normal.copyFrom(polygon.vertices[polygonIndices[k]].normal);
                    if (polygon.vertices[polygonIndices[k]].uv) {
                        if (!uvs) {
                            uvs = [];
                        }
                        uv.copyFrom(polygon.vertices[polygonIndices[k]].uv);
                    }
                    if (polygon.vertices[polygonIndices[k]].vertColor) {
                        if (!vertColors) {
                            vertColors = [];
                        }
                        vertColor.copyFrom(polygon.vertices[polygonIndices[k]].vertColor);
                    }
                    const localVertex = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformCoordinates(vertex, matrix);
                    const localNormal = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformNormal(normal, matrix);
                    vertexIdx = verticeDict[localVertex.x + "," + localVertex.y + "," + localVertex.z];
                    let areUvsDifferent = false;
                    if (uvs && !(uvs[vertexIdx * 2] === uv.x || uvs[vertexIdx * 2 + 1] === uv.y)) {
                        areUvsDifferent = true;
                    }
                    let areColorsDifferent = false;
                    if (vertColors && !(vertColors[vertexIdx * 4] === vertColor.r || vertColors[vertexIdx * 4 + 1] === vertColor.g || vertColors[vertexIdx * 4 + 2] === vertColor.b || vertColors[vertexIdx * 4 + 3] === vertColor.a)) {
                        areColorsDifferent = true;
                    }
                    // Check if 2 points can be merged
                    if (!(typeof vertexIdx !== "undefined" && normals[vertexIdx * 3] === localNormal.x && normals[vertexIdx * 3 + 1] === localNormal.y && normals[vertexIdx * 3 + 2] === localNormal.z) || areUvsDifferent || areColorsDifferent) {
                        vertices.push(localVertex.x, localVertex.y, localVertex.z);
                        if (uvs) {
                            uvs.push(uv.x, uv.y);
                        }
                        normals.push(normal.x, normal.y, normal.z);
                        if (vertColors) {
                            vertColors.push(vertColor.r, vertColor.g, vertColor.b, vertColor.a);
                        }
                        vertexIdx = verticeDict[localVertex.x + "," + localVertex.y + "," + localVertex.z] = vertices.length / 3 - 1;
                    }
                    indices.push(vertexIdx);
                    if (onAfterPolygonProcessing) {
                        onAfterPolygonProcessing();
                    }
                }
            }
        }
        const result = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexData"]();
        result.positions = vertices;
        result.normals = normals;
        if (uvs) {
            result.uvs = uvs;
        }
        if (vertColors) {
            result.colors = vertColors;
        }
        result.indices = indices;
        return result;
    }
    /**
     * Build Raw mesh from CSG
     * Coordinates here are in world space
     * @param name The name of the mesh geometry
     * @param scene The Scene
     * @param keepSubMeshes Specifies if the submeshes should be kept
     * @returns A new Mesh
     */ buildMeshGeometry(name, scene, keepSubMeshes) {
        const mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](name, scene);
        const polygons = this._polygons;
        let currentIndex = 0;
        const subMeshDict = {};
        let subMeshObj;
        if (keepSubMeshes) {
            // Sort Polygons, since subMeshes are indices range
            polygons.sort((a, b)=>{
                if (a.shared.meshId === b.shared.meshId) {
                    return a.shared.subMeshId - b.shared.subMeshId;
                } else {
                    return a.shared.meshId - b.shared.meshId;
                }
            });
        }
        const vertexData = this.toVertexData((polygon)=>{
            // Building SubMeshes
            if (!subMeshDict[polygon.shared.meshId]) {
                subMeshDict[polygon.shared.meshId] = {};
            }
            if (!subMeshDict[polygon.shared.meshId][polygon.shared.subMeshId]) {
                subMeshDict[polygon.shared.meshId][polygon.shared.subMeshId] = {
                    indexStart: +Infinity,
                    indexEnd: -Infinity,
                    materialIndex: polygon.shared.materialIndex
                };
            }
            subMeshObj = subMeshDict[polygon.shared.meshId][polygon.shared.subMeshId];
        }, ()=>{
            subMeshObj.indexStart = Math.min(currentIndex, subMeshObj.indexStart);
            subMeshObj.indexEnd = Math.max(currentIndex, subMeshObj.indexEnd);
            currentIndex++;
        });
        vertexData.applyToMesh(mesh);
        if (keepSubMeshes) {
            // We offset the materialIndex by the previous number of materials in the CSG mixed meshes
            let materialIndexOffset = 0, materialMaxIndex;
            mesh.subMeshes = [];
            for(const m in subMeshDict){
                materialMaxIndex = -1;
                for(const sm in subMeshDict[m]){
                    subMeshObj = subMeshDict[m][sm];
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$subMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SubMesh"].CreateFromIndices(subMeshObj.materialIndex + materialIndexOffset, subMeshObj.indexStart, subMeshObj.indexEnd - subMeshObj.indexStart + 1, mesh);
                    materialMaxIndex = Math.max(subMeshObj.materialIndex, materialMaxIndex);
                }
                materialIndexOffset += ++materialMaxIndex;
            }
        }
        return mesh;
    }
    /**
     * Build Mesh from CSG taking material and transforms into account
     * @param name The name of the Mesh
     * @param material The material of the Mesh
     * @param scene The Scene
     * @param keepSubMeshes Specifies if submeshes should be kept
     * @returns The new Mesh
     */ toMesh(name, material = null, scene, keepSubMeshes) {
        const mesh = this.buildMeshGeometry(name, scene, keepSubMeshes);
        mesh.material = material;
        mesh.position.copyFrom(this.position);
        mesh.rotation.copyFrom(this.rotation);
        if (this.rotationQuaternion) {
            mesh.rotationQuaternion = this.rotationQuaternion.clone();
        }
        mesh.scaling.copyFrom(this.scaling);
        mesh.computeWorldMatrix(true);
        return mesh;
    }
} //# sourceMappingURL=csg.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/meshUVSpaceRenderer.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MeshUVSpaceRenderer",
    ()=>MeshUVSpaceRenderer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$shaderMaterial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/shaderMaterial.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$renderTargetTexture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/Textures/renderTargetTexture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.color.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$PostProcesses$2f$postProcess$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/PostProcesses/postProcess.js [app-client] (ecmascript)");
;
;
;
;
;
class MeshUVSpaceRenderer {
    static _GetShader(scene, shaderLanguage) {
        if (!scene._meshUVSpaceRendererShader) {
            const shader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$shaderMaterial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"]("meshUVSpaceRendererShader", scene, {
                vertex: "meshUVSpaceRenderer",
                fragment: "meshUVSpaceRenderer"
            }, {
                attributes: [
                    "position",
                    "normal",
                    "uv"
                ],
                uniforms: [
                    "world",
                    "projMatrix"
                ],
                samplers: [
                    "textureSampler"
                ],
                needAlphaBlending: true,
                shaderLanguage: shaderLanguage
            });
            shader.backFaceCulling = false;
            shader.alphaMode = 2;
            scene.onDisposeObservable.add(()=>{
                scene._meshUVSpaceRendererShader?.dispose();
                scene._meshUVSpaceRendererShader = null;
            });
            scene._meshUVSpaceRendererShader = shader;
        }
        return scene._meshUVSpaceRendererShader;
    }
    static _GetMaskShader(scene, shaderLanguage) {
        if (!scene._meshUVSpaceRendererMaskShader) {
            const shader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$shaderMaterial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"]("meshUVSpaceRendererMaskShader", scene, {
                vertex: "meshUVSpaceRendererMasker",
                fragment: "meshUVSpaceRendererMasker"
            }, {
                attributes: [
                    "position",
                    "uv"
                ],
                uniforms: [
                    "worldViewProjection"
                ],
                shaderLanguage: shaderLanguage
            });
            shader.backFaceCulling = false;
            shader.alphaMode = 2;
            scene.onDisposeObservable.add(()=>{
                scene._meshUVSpaceRendererMaskShader?.dispose();
                scene._meshUVSpaceRendererMaskShader = null;
            });
            scene._meshUVSpaceRendererMaskShader = shader;
        }
        return scene._meshUVSpaceRendererMaskShader;
    }
    static _IsRenderTargetTexture(texture) {
        return texture.renderList !== undefined;
    }
    /**
     * Gets the shader language used in this material.
     */ get shaderLanguage() {
        return this._shaderLanguage;
    }
    /**
     * Creates a new MeshUVSpaceRenderer
     * @param mesh The mesh used for the source UV space
     * @param scene The scene the mesh belongs to
     * @param options The options to use when creating the texture
     */ constructor(mesh, scene, options){
        this._textureCreatedInternally = false;
        this._configureUserCreatedTexture = true;
        this._maskTexture = null;
        this._finalPostProcess = null;
        this._shadersLoaded = false;
        this._isDisposed = false;
        /**
         * Clear color of the texture
         */ this.clearColor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color4"](0, 0, 0, 0);
        /**
         * Target texture used for rendering
         * If you don't set the property, a RenderTargetTexture will be created internally given the options provided to the constructor.
         * If you provide a RenderTargetTexture, it will be used directly.
         */ this.texture = null;
        /** Shader language used by the material */ this._shaderLanguage = 0 /* ShaderLanguage.GLSL */ ;
        this._mesh = mesh;
        this._scene = scene;
        this._options = {
            width: 1024,
            height: 1024,
            textureType: 0,
            generateMipMaps: true,
            optimizeUVAllocation: true,
            uvEdgeBlending: false,
            ...options
        };
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this._initShaderSourceAsync();
    }
    async _initShaderSourceAsync() {
        const engine = this._scene.getEngine();
        if (engine.isWebGPU) {
            this._shaderLanguage = 1 /* ShaderLanguage.WGSL */ ;
            await Promise.all([
                __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/meshUVSpaceRenderer.vertex.js [app-client] (ecmascript, async loader)"),
                __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/meshUVSpaceRenderer.fragment.js [app-client] (ecmascript, async loader)"),
                __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/meshUVSpaceRendererMasker.vertex.js [app-client] (ecmascript, async loader)"),
                __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/meshUVSpaceRendererMasker.fragment.js [app-client] (ecmascript, async loader)"),
                __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/meshUVSpaceRendererFinaliser.vertex.js [app-client] (ecmascript, async loader)"),
                __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/meshUVSpaceRendererFinaliser.fragment.js [app-client] (ecmascript, async loader)")
            ]);
        } else {
            await Promise.all([
                __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/meshUVSpaceRenderer.vertex.js [app-client] (ecmascript, async loader)"),
                __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/meshUVSpaceRenderer.fragment.js [app-client] (ecmascript, async loader)"),
                __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/meshUVSpaceRendererMasker.vertex.js [app-client] (ecmascript, async loader)"),
                __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/meshUVSpaceRendererMasker.fragment.js [app-client] (ecmascript, async loader)"),
                __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/meshUVSpaceRendererFinaliser.vertex.js [app-client] (ecmascript, async loader)"),
                __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/meshUVSpaceRendererFinaliser.fragment.js [app-client] (ecmascript, async loader)")
            ]);
        }
        if (this._isDisposed) {
            return;
        }
        this._shadersLoaded = true;
    }
    /**
     * Checks if the texture is ready to be used
     * @returns true if the texture is ready to be used
     */ isReady() {
        if (!this._shadersLoaded) {
            return false;
        }
        if (!this.texture) {
            this._createDiffuseRTT();
        } else if (this._configureUserCreatedTexture) {
            this._configureUserCreatedRTT();
        }
        // this.texture is guaranteed to be non-null here as it is created in _createDiffuseRTT above
        const textureIsReady = MeshUVSpaceRenderer._IsRenderTargetTexture(this.texture) ? this.texture.isReadyForRendering() : this.texture.isReady();
        const maskIsReady = this._maskTexture?.isReadyForRendering() ?? true;
        const postProcessIsReady = this._finalPostProcess?.isReady() ?? true;
        return textureIsReady && maskIsReady && postProcessIsReady;
    }
    /**
     * Projects and renders a texture in the mesh UV space
     * @param texture The texture
     * @param position The position of the center of projection (world space coordinates)
     * @param normal The direction of the projection (world space coordinates)
     * @param size The size of the projection
     * @param angle The rotation angle around the direction of the projection (default: 0)
     * @param checkIsReady If true, it will check if the texture is ready before rendering (default: true). If the texture is not ready, a new attempt will be scheduled in 16ms
     */ renderTexture(texture, position, normal, size, angle = 0, checkIsReady = true) {
        if (checkIsReady && !this.isReady()) {
            setTimeout(()=>{
                this.renderTexture(texture, position, normal, size, angle, checkIsReady);
            }, 16);
            return;
        }
        if (!this.texture) {
            this._createDiffuseRTT();
        } else if (this._configureUserCreatedTexture) {
            this._configureUserCreatedRTT();
        }
        // this.texture is guaranteed to be non-null here as it is created in _createDiffuseRTT above
        if (MeshUVSpaceRenderer._IsRenderTargetTexture(this.texture)) {
            const matrix = this._createProjectionMatrix(position, normal, size, angle);
            const shader = MeshUVSpaceRenderer._GetShader(this._scene, this._shaderLanguage);
            shader.setTexture("textureSampler", texture);
            shader.setMatrix("projMatrix", matrix);
            this.texture.render();
            // We needed the texture only once for the render() call above, so we can remove it from the shader.
            // It's important to do that, because this texture could be disposed by the user, meaning that shader.isReady() would return false as part of the this.texture.isReadyForRendering() call of isReady()
            shader.removeTexture("textureSampler");
        }
    }
    /**
     * Clears the texture map
     */ clear() {
        if (this.texture && MeshUVSpaceRenderer._IsRenderTargetTexture(this.texture) && this.texture.renderTarget) {
            const engine = this._scene.getEngine();
            engine.bindFramebuffer(this.texture.renderTarget);
            engine.clear(this.clearColor, true, true, true);
            engine.unBindFramebuffer(this.texture.renderTarget);
        }
        if (this._finalPostProcess?.inputTexture) {
            const engine = this._scene.getEngine();
            engine.bindFramebuffer(this._finalPostProcess?.inputTexture);
            engine.clear(this.clearColor, true, true, true);
            engine.unBindFramebuffer(this._finalPostProcess?.inputTexture);
        }
    }
    /**
     * Disposes of the resources
     */ dispose() {
        if (this._textureCreatedInternally) {
            this.texture?.dispose();
            this._textureCreatedInternally = false;
        }
        this._configureUserCreatedTexture = true;
        this._maskTexture?.dispose();
        this._maskTexture = null;
        this._finalPostProcess?.dispose();
        this._finalPostProcess = null;
        this._isDisposed = true;
    }
    _configureUserCreatedRTT() {
        this._configureUserCreatedTexture = false;
        if (this.texture && MeshUVSpaceRenderer._IsRenderTargetTexture(this.texture)) {
            this.texture.setMaterialForRendering(this._mesh, MeshUVSpaceRenderer._GetShader(this._scene, this._shaderLanguage));
            this.texture.onClearObservable.add(()=>{});
            this.texture.renderList = [
                this._mesh
            ];
            if (this._options.uvEdgeBlending) {
                this._createMaskTexture();
                this._createPostProcess();
                this.texture.addPostProcess(this._finalPostProcess);
            }
        }
    }
    _createDiffuseRTT() {
        this._textureCreatedInternally = true;
        const texture = this._createRenderTargetTexture(this._options.width, this._options.height);
        texture.setMaterialForRendering(this._mesh, MeshUVSpaceRenderer._GetShader(this._scene, this._shaderLanguage));
        this.texture = texture;
        this._configureUserCreatedTexture = false;
        if (this._options.uvEdgeBlending) {
            this._createMaskTexture();
            this._createPostProcess();
            texture.addPostProcess(this._finalPostProcess);
        }
    }
    _createMaskTexture() {
        if (this._maskTexture) {
            return;
        }
        this._maskTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$renderTargetTexture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RenderTargetTexture"](this._mesh.name + "_maskTexture", {
            width: this._options.width,
            height: this._options.height
        }, this._scene, false, true, 0, false, 2, undefined, undefined, undefined, 6);
        this._maskTexture.clearColor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color4"](0, 0, 0, 0);
        // Render the mesh with the mask material to the mask texture
        this._maskTexture.renderList.push(this._mesh);
        this._maskTexture.setMaterialForRendering(this._mesh, MeshUVSpaceRenderer._GetMaskShader(this._scene, this._shaderLanguage));
        // Ensure the mask texture is updated
        this._maskTexture.refreshRate = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$renderTargetTexture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RenderTargetTexture"].REFRESHRATE_RENDER_ONCE;
        this._scene.customRenderTargets.push(this._maskTexture);
    }
    _createPostProcess() {
        if (this._finalPostProcess) {
            return;
        }
        this._finalPostProcess = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$PostProcesses$2f$postProcess$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PostProcess"](this._mesh.name + "_fixSeamsPostProcess", "meshUVSpaceRendererFinaliser", [
            "textureSize"
        ], [
            "textureSampler",
            "maskTextureSampler"
        ], 1.0, null, 1, this._scene.getEngine(), false, null, this._options.textureType, undefined, undefined, undefined, undefined, this._shaderLanguage);
        this._finalPostProcess.onApplyObservable.add((effect)=>{
            effect.setTexture("maskTextureSampler", this._maskTexture);
            effect.setFloat2("textureSize", this._options.width, this._options.height);
        });
    }
    _createRenderTargetTexture(width, height) {
        const rtt = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$renderTargetTexture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RenderTargetTexture"](this._mesh.name + "_uvspaceTexture", {
            width,
            height
        }, this._scene, this._options.generateMipMaps, true, this._options.textureType, false, this._options.generateMipMaps ? 3 : 2, false, false, false, 5);
        rtt.renderParticles = false;
        rtt.optimizeUVAllocation = !!this._options.optimizeUVAllocation;
        rtt.onClearObservable.addOnce(()=>{
            this._scene.getEngine().clear(this.clearColor, true, true, true);
            rtt.onClearObservable.add(()=>{}); // this disables clearing the texture for the next frames
        });
        rtt.renderList = [
            this._mesh
        ];
        return rtt;
    }
    _createProjectionMatrix(position, normal, size, angle = 0) {
        const yaw = -Math.atan2(normal.z, normal.x) - Math.PI / 2;
        const len = Math.sqrt(normal.x * normal.x + normal.z * normal.z);
        const pitch = Math.atan2(normal.y, len);
        const p = position.add(normal.scale(size.z * 0.5));
        const projWorldMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].RotationYawPitchRoll(yaw, pitch, angle).multiply(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].Translation(p.x, p.y, p.z));
        const inverseProjWorldMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].Invert(projWorldMatrix);
        const projMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].FromArray([
            2 / size.x,
            0,
            0,
            0,
            0,
            2 / size.y,
            0,
            0,
            0,
            0,
            1 / size.z,
            0,
            0,
            0,
            0,
            1
        ]);
        const screenMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].FromArray([
            0.5,
            0,
            0,
            0,
            0,
            0.5,
            0,
            0,
            0,
            0,
            1,
            0,
            0.5,
            0.5,
            0.0,
            1
        ]);
        return inverseProjWorldMatrix.multiply(projMatrix).multiply(screenMatrix);
    }
} //# sourceMappingURL=meshUVSpaceRenderer.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/trailMesh.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TrailMesh",
    ()=>TrailMesh
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$abstractMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/abstractMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.vertexData.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.scalar.functions.js [app-client] (ecmascript)");
;
;
;
;
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"]._TrailMeshParser = (parsedMesh, scene)=>{
    return TrailMesh.Parse(parsedMesh, scene);
};
class TrailMesh extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"] {
    /** @internal */ constructor(name, generator, scene, diameterOrOptions, length = 60, autoStart = true){
        super(name, scene);
        this._sectionPolygonPointsCount = 4;
        this._running = false;
        this._generator = generator;
        if (typeof diameterOrOptions === "object" && diameterOrOptions !== null) {
            this.diameter = diameterOrOptions.diameter || 1;
            this._length = diameterOrOptions.length || 60;
            this._segments = diameterOrOptions.segments ? diameterOrOptions.segments > this._length ? this._length : diameterOrOptions.segments : this._length;
            this._sectionPolygonPointsCount = diameterOrOptions.sections || 4;
            this._doNotTaper = diameterOrOptions.doNotTaper ?? false;
            this._autoStart = diameterOrOptions.autoStart ?? true;
        } else {
            this.diameter = diameterOrOptions || 1;
            this._length = length;
            this._segments = this._length;
            this._doNotTaper = false;
            this._autoStart = autoStart;
        }
        this._sectionVectors = [];
        this._sectionNormalVectors = [];
        for(let i = 0; i <= this._sectionPolygonPointsCount; i++){
            this._sectionVectors[i] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Zero();
            this._sectionNormalVectors[i] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Zero();
        }
        this._createMesh();
    }
    /**
     * "TrailMesh"
     * @returns "TrailMesh"
     */ getClassName() {
        return "TrailMesh";
    }
    _createMesh() {
        const data = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexData"]();
        const positions = [];
        const normals = [];
        const indices = [];
        const uvs = [];
        let meshCenter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Zero();
        if (this._generator instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$abstractMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AbstractMesh"] && this._generator.hasBoundingInfo) {
            meshCenter = this._generator.getBoundingInfo().boundingBox.centerWorld;
        } else {
            meshCenter = this._generator.absolutePosition;
        }
        const alpha = 2 * Math.PI / this._sectionPolygonPointsCount;
        for(let i = 0; i <= this._sectionPolygonPointsCount; i++){
            const angle = i !== this._sectionPolygonPointsCount ? i * alpha : 0;
            positions.push(meshCenter.x + Math.cos(angle) * this.diameter, meshCenter.y + Math.sin(angle) * this.diameter, meshCenter.z);
            uvs.push(i / this._sectionPolygonPointsCount, 0);
        }
        for(let i = 1; i <= this._segments; i++){
            for(let j = 0; j <= this._sectionPolygonPointsCount; j++){
                const angle = j !== this._sectionPolygonPointsCount ? j * alpha : 0;
                positions.push(meshCenter.x + Math.cos(angle) * this.diameter, meshCenter.y + Math.sin(angle) * this.diameter, meshCenter.z);
                uvs.push(j / this._sectionPolygonPointsCount, i / this._segments);
            }
            const l = positions.length / 3 - 2 * (this._sectionPolygonPointsCount + 1);
            for(let j = 0; j <= this._sectionPolygonPointsCount; j++){
                indices.push(l + j, l + j + this._sectionPolygonPointsCount, l + j + this._sectionPolygonPointsCount + 1);
                indices.push(l + j, l + j + this._sectionPolygonPointsCount + 1, l + j + 1);
            }
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexData"].ComputeNormals(positions, indices, normals);
        data.positions = positions;
        data.normals = normals;
        data.indices = indices;
        data.uvs = uvs;
        data.applyToMesh(this, true);
        if (this._autoStart) {
            this.start();
        }
    }
    _updateSectionVectors() {
        const wm = this._generator.getWorldMatrix();
        const alpha = 2 * Math.PI / this._sectionPolygonPointsCount;
        for(let i = 0; i <= this._sectionPolygonPointsCount; i++){
            const angle = i !== this._sectionPolygonPointsCount ? i * alpha : 0;
            this._sectionVectors[i].copyFromFloats(Math.cos(angle) * this.diameter, Math.sin(angle) * this.diameter, 0);
            this._sectionNormalVectors[i].copyFromFloats(Math.cos(angle), Math.sin(angle), 0);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformCoordinatesToRef(this._sectionVectors[i], wm, this._sectionVectors[i]);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformNormalToRef(this._sectionNormalVectors[i], wm, this._sectionNormalVectors[i]);
        }
    }
    /**
     * Start trailing mesh.
     */ start() {
        if (!this._running) {
            this._running = true;
            this._beforeRenderObserver = this.getScene().onBeforeRenderObservable.add(()=>{
                this.update();
            });
        }
    }
    /**
     * Stop trailing mesh.
     */ stop() {
        if (this._beforeRenderObserver && this._running) {
            this._running = false;
            this.getScene().onBeforeRenderObservable.remove(this._beforeRenderObserver);
        }
    }
    /**
     * Update trailing mesh geometry.
     */ update() {
        const positions = this.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind);
        const normals = this.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].NormalKind);
        const index = 3 * (this._sectionPolygonPointsCount + 1);
        if (positions && normals) {
            if (this._doNotTaper) {
                for(let i = index; i < positions.length; i++){
                    positions[i - index] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Lerp"])(positions[i - index], positions[i], this._segments / this._length);
                }
            } else {
                for(let i = index; i < positions.length; i++){
                    positions[i - index] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Lerp"])(positions[i - index], positions[i], this._segments / this._length) - normals[i] / this._length * this.diameter;
                }
            }
            for(let i = index; i < normals.length; i++){
                normals[i - index] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Lerp"])(normals[i - index], normals[i], this._segments / this._length);
            }
            this._updateSectionVectors();
            const l = positions.length - 3 * (this._sectionPolygonPointsCount + 1);
            for(let i = 0; i <= this._sectionPolygonPointsCount; i++){
                positions[l + 3 * i] = this._sectionVectors[i].x;
                positions[l + 3 * i + 1] = this._sectionVectors[i].y;
                positions[l + 3 * i + 2] = this._sectionVectors[i].z;
                normals[l + 3 * i] = this._sectionNormalVectors[i].x;
                normals[l + 3 * i + 1] = this._sectionNormalVectors[i].y;
                normals[l + 3 * i + 2] = this._sectionNormalVectors[i].z;
            }
            this.updateVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind, positions, true, false);
            this.updateVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].NormalKind, normals, true, false);
        }
    }
    /**
     * Reset trailing mesh geometry.
     */ reset() {
        const positions = this.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind);
        const normals = this.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].NormalKind);
        if (positions && normals) {
            this._updateSectionVectors();
            for(let i = 0; i <= this._segments; i++){
                const l = 3 * i * (this._sectionPolygonPointsCount + 1);
                for(let j = 0; j <= this._sectionPolygonPointsCount; j++){
                    positions[l + 3 * j] = this._sectionVectors[j].x;
                    positions[l + 3 * j + 1] = this._sectionVectors[j].y;
                    positions[l + 3 * j + 2] = this._sectionVectors[j].z;
                    normals[l + 3 * j] = this._sectionNormalVectors[j].x;
                    normals[l + 3 * j + 1] = this._sectionNormalVectors[j].y;
                    normals[l + 3 * j + 2] = this._sectionNormalVectors[j].z;
                }
            }
            this.updateVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind, positions, true, false);
            this.updateVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].NormalKind, normals, true, false);
        }
    }
    /**
     * Returns a new TrailMesh object.
     * @param name is a string, the name given to the new mesh
     * @param newGenerator use new generator object for cloned trail mesh
     * @returns a new mesh
     */ clone(name = "", newGenerator) {
        const options = {
            diameter: this.diameter,
            length: this._length,
            segments: this._segments,
            sections: this._sectionPolygonPointsCount,
            doNotTaper: this._doNotTaper,
            autoStart: this._autoStart
        };
        return new TrailMesh(name, newGenerator ?? this._generator, this.getScene(), options);
    }
    /**
     * Serializes this trail mesh
     * @param serializationObject object to write serialization to
     */ serialize(serializationObject) {
        super.serialize(serializationObject);
        serializationObject.generatorId = this._generator.id;
    }
    /**
     * Parses a serialized trail mesh
     * @param parsedMesh the serialized mesh
     * @param scene the scene to create the trail mesh in
     * @returns the created trail mesh
     */ static Parse(parsedMesh, scene) {
        const generator = scene.getLastMeshById(parsedMesh.generatorId) ?? scene.getLastTransformNodeById(parsedMesh.generatorId);
        if (!generator) {
            throw new Error("TrailMesh: generator not found with ID " + parsedMesh.generatorId);
        }
        const options = {
            diameter: parsedMesh.diameter ?? parsedMesh._diameter,
            length: parsedMesh._length,
            segments: parsedMesh._segments,
            sections: parsedMesh._sectionPolygonPointsCount,
            doNotTaper: parsedMesh._doNotTaper,
            autoStart: parsedMesh._autoStart
        };
        return new TrailMesh(parsedMesh.name, generator, scene, options);
    }
} //# sourceMappingURL=trailMesh.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/meshSimplification.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "QuadraticErrorSimplification",
    ()=>QuadraticErrorSimplification,
    "SimplificationQueue",
    ()=>SimplificationQueue,
    "SimplificationSettings",
    ()=>SimplificationSettings,
    "SimplificationType",
    ()=>SimplificationType
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$subMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/subMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tools.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.constants.js [app-client] (ecmascript)");
;
;
;
;
;
;
class SimplificationSettings {
    /**
     * Creates a SimplificationSettings
     * @param quality expected quality
     * @param distance distance when this optimized version should be used
     * @param optimizeMesh already optimized mesh
     */ constructor(/** expected quality */ quality, /** distance when this optimized version should be used */ distance, /** already optimized mesh  */ optimizeMesh){
        this.quality = quality;
        this.distance = distance;
        this.optimizeMesh = optimizeMesh;
    }
}
class SimplificationQueue {
    /**
     * Creates a new queue
     */ constructor(){
        this.running = false;
        this._simplificationArray = [];
    }
    /**
     * Adds a new simplification task
     * @param task defines a task to add
     */ addTask(task) {
        this._simplificationArray.push(task);
    }
    /**
     * Execute next task
     */ executeNext() {
        const task = this._simplificationArray.pop();
        if (task) {
            this.running = true;
            this.runSimplification(task);
        } else {
            this.running = false;
        }
    }
    /**
     * Execute a simplification task
     * @param task defines the task to run
     */ runSimplification(task) {
        if (task.parallelProcessing) {
            //parallel simplifier
            for (const setting of task.settings){
                const simplifier = this._getSimplifier(task);
                simplifier.simplify(setting, (newMesh)=>{
                    if (setting.distance !== undefined) {
                        task.mesh.addLODLevel(setting.distance, newMesh);
                    }
                    newMesh.isVisible = true;
                    //check if it is the last
                    if (setting.quality === task.settings[task.settings.length - 1].quality && task.successCallback) {
                        //all done, run the success callback.
                        task.successCallback();
                    }
                    this.executeNext();
                });
            }
        } else {
            //single simplifier.
            const simplifier = this._getSimplifier(task);
            const runDecimation = (setting, callback)=>{
                simplifier.simplify(setting, (newMesh)=>{
                    if (setting.distance !== undefined) {
                        task.mesh.addLODLevel(setting.distance, newMesh);
                    }
                    newMesh.isVisible = true;
                    //run the next quality level
                    callback();
                });
            };
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AsyncLoop"].Run(task.settings.length, (loop)=>{
                runDecimation(task.settings[loop.index], ()=>{
                    loop.executeNext();
                });
            }, ()=>{
                //execution ended, run the success callback.
                if (task.successCallback) {
                    task.successCallback();
                }
                this.executeNext();
            });
        }
    }
    _getSimplifier(task) {
        switch(task.simplificationType){
            case 0 /* SimplificationType.QUADRATIC */ :
            default:
                return new QuadraticErrorSimplification(task.mesh);
        }
    }
}
var SimplificationType;
(function(SimplificationType) {
    /** Quadratic error decimation */ SimplificationType[SimplificationType["QUADRATIC"] = 0] = "QUADRATIC";
})(SimplificationType || (SimplificationType = {}));
class DecimationTriangle {
    constructor(_vertices){
        this._vertices = _vertices;
        this.error = new Array(4);
        this.deleted = false;
        this.isDirty = false;
        this.deletePending = false;
        this.borderFactor = 0;
    }
}
class DecimationVertex {
    constructor(position, id){
        this.position = position;
        this.id = id;
        this.isBorder = true;
        this.q = new QuadraticMatrix();
        this.triangleCount = 0;
        this.triangleStart = 0;
        this.originalOffsets = [];
    }
    updatePosition(newPosition) {
        this.position.copyFrom(newPosition);
    }
}
class QuadraticMatrix {
    constructor(data){
        this.data = new Array(10);
        for(let i = 0; i < 10; ++i){
            if (data && data[i]) {
                this.data[i] = data[i];
            } else {
                this.data[i] = 0;
            }
        }
    }
    det(a11, a12, a13, a21, a22, a23, a31, a32, a33) {
        const det = this.data[a11] * this.data[a22] * this.data[a33] + this.data[a13] * this.data[a21] * this.data[a32] + this.data[a12] * this.data[a23] * this.data[a31] - this.data[a13] * this.data[a22] * this.data[a31] - this.data[a11] * this.data[a23] * this.data[a32] - this.data[a12] * this.data[a21] * this.data[a33];
        return det;
    }
    addInPlace(matrix) {
        for(let i = 0; i < 10; ++i){
            this.data[i] += matrix.data[i];
        }
    }
    addArrayInPlace(data) {
        for(let i = 0; i < 10; ++i){
            this.data[i] += data[i];
        }
    }
    add(matrix) {
        const m = new QuadraticMatrix();
        for(let i = 0; i < 10; ++i){
            m.data[i] = this.data[i] + matrix.data[i];
        }
        return m;
    }
    static FromData(a, b, c, d) {
        return new QuadraticMatrix(QuadraticMatrix.DataFromNumbers(a, b, c, d));
    }
    //returning an array to avoid garbage collection
    static DataFromNumbers(a, b, c, d) {
        return [
            a * a,
            a * b,
            a * c,
            a * d,
            b * b,
            b * c,
            b * d,
            c * c,
            c * d,
            d * d
        ];
    }
}
class Reference {
    constructor(vertexId, triangleId){
        this.vertexId = vertexId;
        this.triangleId = triangleId;
    }
}
class QuadraticErrorSimplification {
    /**
     * Creates a new QuadraticErrorSimplification
     * @param _mesh defines the target mesh
     */ constructor(_mesh){
        this._mesh = _mesh;
        /** Gets or sets the number pf sync iterations */ this.syncIterations = 5000;
        this.aggressiveness = 7;
        this.decimationIterations = 100;
        this.boundingBoxEpsilon = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Epsilon"];
    }
    /**
     * Simplification of a given mesh according to the given settings.
     * Since this requires computation, it is assumed that the function runs async.
     * @param settings The settings of the simplification, including quality and distance
     * @param successCallback A callback that will be called after the mesh was simplified.
     */ simplify(settings, successCallback) {
        this._initDecimatedMesh();
        //iterating through the submeshes array, one after the other.
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AsyncLoop"].Run(this._mesh.subMeshes.length, (loop)=>{
            this._initWithMesh(loop.index, ()=>{
                this._runDecimation(settings, loop.index, ()=>{
                    loop.executeNext();
                });
            }, settings.optimizeMesh);
        }, ()=>{
            setTimeout(()=>{
                successCallback(this._reconstructedMesh);
            }, 0);
        });
    }
    _runDecimation(settings, submeshIndex, successCallback) {
        const targetCount = ~~(this._triangles.length * settings.quality);
        let deletedTriangles = 0;
        const triangleCount = this._triangles.length;
        const iterationFunction = (iteration, callback)=>{
            setTimeout(()=>{
                if (iteration % 5 === 0) {
                    this._updateMesh(iteration === 0);
                }
                for(let i = 0; i < this._triangles.length; ++i){
                    this._triangles[i].isDirty = false;
                }
                const threshold = 0.000000001 * Math.pow(iteration + 3, this.aggressiveness);
                const trianglesIterator = (i)=>{
                    const tIdx = ~~((this._triangles.length / 2 + i) % this._triangles.length);
                    const t = this._triangles[tIdx];
                    if (!t) {
                        return;
                    }
                    if (t.error[3] > threshold || t.deleted || t.isDirty) {
                        return;
                    }
                    for(let j = 0; j < 3; ++j){
                        if (t.error[j] < threshold) {
                            const deleted0 = [];
                            const deleted1 = [];
                            const v0 = t._vertices[j];
                            const v1 = t._vertices[(j + 1) % 3];
                            if (v0.isBorder || v1.isBorder) {
                                continue;
                            }
                            const p = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Zero();
                            // var n = Vector3.Zero();
                            // var uv = Vector2.Zero();
                            // var color = new Color4(0, 0, 0, 1);
                            this._calculateError(v0, v1, p);
                            const delTr = [];
                            if (this._isFlipped(v0, v1, p, deleted0, delTr)) {
                                continue;
                            }
                            if (this._isFlipped(v1, v0, p, deleted1, delTr)) {
                                continue;
                            }
                            if (deleted0.indexOf(true) < 0 || deleted1.indexOf(true) < 0) {
                                continue;
                            }
                            const uniqueArray = [];
                            for (const deletedT of delTr){
                                if (uniqueArray.indexOf(deletedT) === -1) {
                                    deletedT.deletePending = true;
                                    uniqueArray.push(deletedT);
                                }
                            }
                            if (uniqueArray.length % 2 !== 0) {
                                continue;
                            }
                            v0.q = v1.q.add(v0.q);
                            v0.updatePosition(p);
                            const tStart = this._references.length;
                            deletedTriangles = this._updateTriangles(v0, v0, deleted0, deletedTriangles);
                            deletedTriangles = this._updateTriangles(v0, v1, deleted1, deletedTriangles);
                            const tCount = this._references.length - tStart;
                            if (tCount <= v0.triangleCount) {
                                if (tCount) {
                                    for(let c = 0; c < tCount; c++){
                                        this._references[v0.triangleStart + c] = this._references[tStart + c];
                                    }
                                }
                            } else {
                                v0.triangleStart = tStart;
                            }
                            v0.triangleCount = tCount;
                            break;
                        }
                    }
                };
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AsyncLoop"].SyncAsyncForLoop(this._triangles.length, this.syncIterations, trianglesIterator, callback, ()=>{
                    return triangleCount - deletedTriangles <= targetCount;
                });
            }, 0);
        };
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AsyncLoop"].Run(this.decimationIterations, (loop)=>{
            if (triangleCount - deletedTriangles <= targetCount) {
                loop.breakLoop();
            } else {
                iterationFunction(loop.index, ()=>{
                    loop.executeNext();
                });
            }
        }, ()=>{
            setTimeout(()=>{
                //reconstruct this part of the mesh
                this._reconstructMesh(submeshIndex);
                successCallback();
            }, 0);
        });
    }
    _initWithMesh(submeshIndex, callback, optimizeMesh) {
        this._vertices = [];
        this._triangles = [];
        const positionData = this._mesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind);
        const indices = this._mesh.getIndices();
        const submesh = this._mesh.subMeshes[submeshIndex];
        const findInVertices = (positionToSearch)=>{
            if (optimizeMesh) {
                for(let ii = 0; ii < this._vertices.length; ++ii){
                    if (this._vertices[ii].position.equalsWithEpsilon(positionToSearch, 0.0001)) {
                        return this._vertices[ii];
                    }
                }
            }
            return null;
        };
        const vertexReferences = [];
        const vertexInit = (i)=>{
            if (!positionData) {
                return;
            }
            const offset = i + submesh.verticesStart;
            const position = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].FromArray(positionData, offset * 3);
            const vertex = findInVertices(position) || new DecimationVertex(position, this._vertices.length);
            vertex.originalOffsets.push(offset);
            if (vertex.id === this._vertices.length) {
                this._vertices.push(vertex);
            }
            vertexReferences.push(vertex.id);
        };
        //var totalVertices = mesh.getTotalVertices();
        const totalVertices = submesh.verticesCount;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AsyncLoop"].SyncAsyncForLoop(totalVertices, this.syncIterations / 4 >> 0, vertexInit, ()=>{
            const indicesInit = (i)=>{
                if (!indices) {
                    return;
                }
                const offset = submesh.indexStart / 3 + i;
                const pos = offset * 3;
                const i0 = indices[pos + 0];
                const i1 = indices[pos + 1];
                const i2 = indices[pos + 2];
                const v0 = this._vertices[vertexReferences[i0 - submesh.verticesStart]];
                const v1 = this._vertices[vertexReferences[i1 - submesh.verticesStart]];
                const v2 = this._vertices[vertexReferences[i2 - submesh.verticesStart]];
                const triangle = new DecimationTriangle([
                    v0,
                    v1,
                    v2
                ]);
                triangle.originalOffset = pos;
                this._triangles.push(triangle);
            };
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AsyncLoop"].SyncAsyncForLoop(submesh.indexCount / 3, this.syncIterations, indicesInit, ()=>{
                this._init(callback);
            });
        });
    }
    _init(callback) {
        const triangleInit1 = (i)=>{
            const t = this._triangles[i];
            t.normal = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Cross(t._vertices[1].position.subtract(t._vertices[0].position), t._vertices[2].position.subtract(t._vertices[0].position)).normalize();
            for(let j = 0; j < 3; j++){
                t._vertices[j].q.addArrayInPlace(QuadraticMatrix.DataFromNumbers(t.normal.x, t.normal.y, t.normal.z, -__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Dot(t.normal, t._vertices[0].position)));
            }
        };
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AsyncLoop"].SyncAsyncForLoop(this._triangles.length, this.syncIterations, triangleInit1, ()=>{
            const triangleInit2 = (i)=>{
                const t = this._triangles[i];
                for(let j = 0; j < 3; ++j){
                    t.error[j] = this._calculateError(t._vertices[j], t._vertices[(j + 1) % 3]);
                }
                t.error[3] = Math.min(t.error[0], t.error[1], t.error[2]);
            };
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AsyncLoop"].SyncAsyncForLoop(this._triangles.length, this.syncIterations, triangleInit2, ()=>{
                callback();
            });
        });
    }
    _reconstructMesh(submeshIndex) {
        const newTriangles = [];
        let i;
        for(i = 0; i < this._vertices.length; ++i){
            this._vertices[i].triangleCount = 0;
        }
        let t;
        let j;
        for(i = 0; i < this._triangles.length; ++i){
            if (!this._triangles[i].deleted) {
                t = this._triangles[i];
                for(j = 0; j < 3; ++j){
                    t._vertices[j].triangleCount = 1;
                }
                newTriangles.push(t);
            }
        }
        const newPositionData = this._reconstructedMesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind) || [];
        const newNormalData = this._reconstructedMesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].NormalKind) || [];
        const newUVsData = this._reconstructedMesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UVKind) || [];
        const newColorsData = this._reconstructedMesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorKind) || [];
        const normalData = this._mesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].NormalKind);
        const uvs = this._mesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UVKind);
        const colorsData = this._mesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorKind);
        let vertexCount = 0;
        for(i = 0; i < this._vertices.length; ++i){
            const vertex = this._vertices[i];
            vertex.id = vertexCount;
            if (vertex.triangleCount) {
                for (const originalOffset of vertex.originalOffsets){
                    newPositionData.push(vertex.position.x);
                    newPositionData.push(vertex.position.y);
                    newPositionData.push(vertex.position.z);
                    if (normalData && normalData.length) {
                        newNormalData.push(normalData[originalOffset * 3]);
                        newNormalData.push(normalData[originalOffset * 3 + 1]);
                        newNormalData.push(normalData[originalOffset * 3 + 2]);
                    }
                    if (uvs && uvs.length) {
                        newUVsData.push(uvs[originalOffset * 2]);
                        newUVsData.push(uvs[originalOffset * 2 + 1]);
                    }
                    if (colorsData && colorsData.length) {
                        newColorsData.push(colorsData[originalOffset * 4]);
                        newColorsData.push(colorsData[originalOffset * 4 + 1]);
                        newColorsData.push(colorsData[originalOffset * 4 + 2]);
                        newColorsData.push(colorsData[originalOffset * 4 + 3]);
                    }
                    ++vertexCount;
                }
            }
        }
        const startingIndex = this._reconstructedMesh.getTotalIndices();
        const startingVertex = this._reconstructedMesh.getTotalVertices();
        const submeshesArray = this._reconstructedMesh.subMeshes;
        this._reconstructedMesh.subMeshes = [];
        const newIndicesArray = this._reconstructedMesh.getIndices(); //[];
        const originalIndices = this._mesh.getIndices();
        for(i = 0; i < newTriangles.length; ++i){
            t = newTriangles[i]; //now get the new referencing point for each vertex
            for(let idx = 0; idx < 3; ++idx){
                const id = originalIndices[t.originalOffset + idx];
                let offset = t._vertices[idx].originalOffsets.indexOf(id);
                if (offset < 0) {
                    offset = 0;
                }
                newIndicesArray.push(t._vertices[idx].id + offset + startingVertex);
            }
        }
        //overwriting the old vertex buffers and indices.
        this._reconstructedMesh.setIndices(newIndicesArray);
        this._reconstructedMesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind, newPositionData);
        if (newNormalData.length > 0) {
            this._reconstructedMesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].NormalKind, newNormalData);
        }
        if (newUVsData.length > 0) {
            this._reconstructedMesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UVKind, newUVsData);
        }
        if (newColorsData.length > 0) {
            this._reconstructedMesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorKind, newColorsData);
        }
        //create submesh
        const originalSubmesh = this._mesh.subMeshes[submeshIndex];
        if (submeshIndex > 0) {
            this._reconstructedMesh.subMeshes = [];
            for (const submesh of submeshesArray){
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$subMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SubMesh"].AddToMesh(submesh.materialIndex, submesh.verticesStart, submesh.verticesCount, /* 0, newPositionData.length/3, */ submesh.indexStart, submesh.indexCount, submesh.getMesh());
            }
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$subMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SubMesh"].AddToMesh(originalSubmesh.materialIndex, startingVertex, vertexCount, /* 0, newPositionData.length / 3, */ startingIndex, newTriangles.length * 3, this._reconstructedMesh);
        }
    }
    _initDecimatedMesh() {
        this._reconstructedMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](this._mesh.name + "Decimated", this._mesh.getScene());
        this._reconstructedMesh.material = this._mesh.material;
        this._reconstructedMesh.parent = this._mesh.parent;
        this._reconstructedMesh.isVisible = false;
        this._reconstructedMesh.renderingGroupId = this._mesh.renderingGroupId;
    }
    _isFlipped(vertex1, vertex2, point, deletedArray, delTr) {
        for(let i = 0; i < vertex1.triangleCount; ++i){
            const t = this._triangles[this._references[vertex1.triangleStart + i].triangleId];
            if (t.deleted) {
                continue;
            }
            const s = this._references[vertex1.triangleStart + i].vertexId;
            const v1 = t._vertices[(s + 1) % 3];
            const v2 = t._vertices[(s + 2) % 3];
            if (v1 === vertex2 || v2 === vertex2) {
                deletedArray[i] = true;
                delTr.push(t);
                continue;
            }
            let d1 = v1.position.subtract(point);
            d1 = d1.normalize();
            let d2 = v2.position.subtract(point);
            d2 = d2.normalize();
            if (Math.abs(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Dot(d1, d2)) > 0.999) {
                return true;
            }
            const normal = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Cross(d1, d2).normalize();
            deletedArray[i] = false;
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Dot(normal, t.normal) < 0.2) {
                return true;
            }
        }
        return false;
    }
    _updateTriangles(origVertex, vertex, deletedArray, deletedTriangles) {
        let newDeleted = deletedTriangles;
        for(let i = 0; i < vertex.triangleCount; ++i){
            const ref = this._references[vertex.triangleStart + i];
            const t = this._triangles[ref.triangleId];
            if (t.deleted) {
                continue;
            }
            if (deletedArray[i] && t.deletePending) {
                t.deleted = true;
                newDeleted++;
                continue;
            }
            t._vertices[ref.vertexId] = origVertex;
            t.isDirty = true;
            t.error[0] = this._calculateError(t._vertices[0], t._vertices[1]) + t.borderFactor / 2;
            t.error[1] = this._calculateError(t._vertices[1], t._vertices[2]) + t.borderFactor / 2;
            t.error[2] = this._calculateError(t._vertices[2], t._vertices[0]) + t.borderFactor / 2;
            t.error[3] = Math.min(t.error[0], t.error[1], t.error[2]);
            this._references.push(ref);
        }
        return newDeleted;
    }
    _identifyBorder() {
        for(let i = 0; i < this._vertices.length; ++i){
            const vCount = [];
            const vId = [];
            const v = this._vertices[i];
            let j;
            for(j = 0; j < v.triangleCount; ++j){
                const triangle = this._triangles[this._references[v.triangleStart + j].triangleId];
                for(let ii = 0; ii < 3; ii++){
                    let ofs = 0;
                    const vv = triangle._vertices[ii];
                    while(ofs < vCount.length){
                        if (vId[ofs] === vv.id) {
                            break;
                        }
                        ++ofs;
                    }
                    if (ofs === vCount.length) {
                        vCount.push(1);
                        vId.push(vv.id);
                    } else {
                        vCount[ofs]++;
                    }
                }
            }
            for(j = 0; j < vCount.length; ++j){
                if (vCount[j] === 1) {
                    this._vertices[vId[j]].isBorder = true;
                } else {
                    this._vertices[vId[j]].isBorder = false;
                }
            }
        }
    }
    _updateMesh(identifyBorders = false) {
        let i;
        if (!identifyBorders) {
            const newTrianglesVector = [];
            for(i = 0; i < this._triangles.length; ++i){
                if (!this._triangles[i].deleted) {
                    newTrianglesVector.push(this._triangles[i]);
                }
            }
            this._triangles = newTrianglesVector;
        }
        for(i = 0; i < this._vertices.length; ++i){
            this._vertices[i].triangleCount = 0;
            this._vertices[i].triangleStart = 0;
        }
        let t;
        let j;
        let v;
        for(i = 0; i < this._triangles.length; ++i){
            t = this._triangles[i];
            for(j = 0; j < 3; ++j){
                v = t._vertices[j];
                v.triangleCount++;
            }
        }
        let tStart = 0;
        for(i = 0; i < this._vertices.length; ++i){
            this._vertices[i].triangleStart = tStart;
            tStart += this._vertices[i].triangleCount;
            this._vertices[i].triangleCount = 0;
        }
        const newReferences = new Array(this._triangles.length * 3);
        for(i = 0; i < this._triangles.length; ++i){
            t = this._triangles[i];
            for(j = 0; j < 3; ++j){
                v = t._vertices[j];
                newReferences[v.triangleStart + v.triangleCount] = new Reference(j, i);
                v.triangleCount++;
            }
        }
        this._references = newReferences;
        if (identifyBorders) {
            this._identifyBorder();
        }
    }
    _vertexError(q, point) {
        const x = point.x;
        const y = point.y;
        const z = point.z;
        return q.data[0] * x * x + 2 * q.data[1] * x * y + 2 * q.data[2] * x * z + 2 * q.data[3] * x + q.data[4] * y * y + 2 * q.data[5] * y * z + 2 * q.data[6] * y + q.data[7] * z * z + 2 * q.data[8] * z + q.data[9];
    }
    _calculateError(vertex1, vertex2, pointResult) {
        const q = vertex1.q.add(vertex2.q);
        const border = vertex1.isBorder && vertex2.isBorder;
        let error = 0;
        const qDet = q.det(0, 1, 2, 1, 4, 5, 2, 5, 7);
        if (qDet !== 0 && !border) {
            if (!pointResult) {
                pointResult = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Zero();
            }
            pointResult.x = -1 / qDet * q.det(1, 2, 3, 4, 5, 6, 5, 7, 8);
            pointResult.y = 1 / qDet * q.det(0, 2, 3, 1, 5, 6, 2, 7, 8);
            pointResult.z = -1 / qDet * q.det(0, 1, 3, 1, 4, 6, 2, 5, 8);
            error = this._vertexError(q, pointResult);
        } else {
            const p3 = vertex1.position.add(vertex2.position).divide(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](2, 2, 2));
            //var norm3 = (vertex1.normal.add(vertex2.normal)).divide(new Vector3(2, 2, 2)).normalize();
            const error1 = this._vertexError(q, vertex1.position);
            const error2 = this._vertexError(q, vertex2.position);
            const error3 = this._vertexError(q, p3);
            error = Math.min(error1, error2, error3);
            if (error === error1) {
                if (pointResult) {
                    pointResult.copyFrom(vertex1.position);
                }
            } else if (error === error2) {
                if (pointResult) {
                    pointResult.copyFrom(vertex2.position);
                }
            } else {
                if (pointResult) {
                    pointResult.copyFrom(p3);
                }
            }
        }
        return error;
    }
} //# sourceMappingURL=meshSimplification.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/meshSimplificationSceneComponent.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SimplicationQueueSceneComponent",
    ()=>SimplicationQueueSceneComponent
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$scene$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/scene.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$meshSimplification$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/meshSimplification.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$sceneComponent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/sceneComponent.js [app-client] (ecmascript)");
;
;
;
;
Object.defineProperty(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$scene$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scene"].prototype, "simplificationQueue", {
    get: function() {
        if (!this._simplificationQueue) {
            this._simplificationQueue = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$meshSimplification$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SimplificationQueue"]();
            let component = this._getComponent(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$sceneComponent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SceneComponentConstants"].NAME_SIMPLIFICATIONQUEUE);
            if (!component) {
                component = new SimplicationQueueSceneComponent(this);
                this._addComponent(component);
            }
        }
        return this._simplificationQueue;
    },
    set: function(value) {
        this._simplificationQueue = value;
    },
    enumerable: true,
    configurable: true
});
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"].prototype.simplify = function(settings, parallelProcessing = true, simplificationType = 0 /* SimplificationType.QUADRATIC */ , successCallback) {
    this.getScene().simplificationQueue.addTask({
        settings: settings,
        parallelProcessing: parallelProcessing,
        mesh: this,
        simplificationType: simplificationType,
        successCallback: successCallback
    });
    return this;
};
class SimplicationQueueSceneComponent {
    /**
     * Creates a new instance of the component for the given scene
     * @param scene Defines the scene to register the component in
     */ constructor(scene){
        /**
         * The component name helpfull to identify the component in the list of scene components.
         */ this.name = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$sceneComponent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SceneComponentConstants"].NAME_SIMPLIFICATIONQUEUE;
        this.scene = scene;
    }
    /**
     * Registers the component in a given scene
     */ register() {
        this.scene._beforeCameraUpdateStage.registerStep(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$sceneComponent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SceneComponentConstants"].STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE, this, this._beforeCameraUpdate);
    }
    /**
     * Rebuilds the elements related to this component in case of
     * context lost for instance.
     */ rebuild() {
    // Nothing to do for this component
    }
    /**
     * Disposes the component and the associated resources
     */ dispose() {
    // Nothing to do for this component
    }
    _beforeCameraUpdate() {
        if (this.scene._simplificationQueue && !this.scene._simplificationQueue.running) {
            this.scene._simplificationQueue.executeNext();
        }
    }
} //# sourceMappingURL=meshSimplificationSceneComponent.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/meshUtils.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RemoveUnreferencedVerticesData",
    ()=>RemoveUnreferencedVerticesData,
    "computeMaxExtents",
    ()=>computeMaxExtents
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-client] (ecmascript)");
;
;
function GetExtentCorners(extent) {
    const minX = extent.minimum.x;
    const minY = extent.minimum.y;
    const minZ = extent.minimum.z;
    const maxX = extent.maximum.x;
    const maxY = extent.maximum.y;
    const maxZ = extent.maximum.z;
    return [
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](minX, minY, minZ),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](maxX, maxY, maxZ),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](maxX, minY, minZ),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](minX, maxY, minZ),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](minX, minY, maxZ),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](maxX, maxY, minZ),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](minX, maxY, maxZ),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](maxX, minY, maxZ)
    ];
}
function computeMaxExtents(meshes, animationGroup = null, animationStep = 1 / 6) {
    // Local vector to avoid allocations.
    const position = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[0];
    const meshExtents = new Map();
    const skinnedMeshExtents = new Map();
    // Compute the non-skinned and skinned mesh extents.
    const maxLength = meshes.reduce((previous, current)=>Math.max(previous, current.getTotalVertices()), 0);
    const minPositions = Array.from({
        length: maxLength
    }, ()=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]());
    const maxPositions = Array.from({
        length: maxLength
    }, ()=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]());
    for (const mesh of meshes){
        const positions = mesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind);
        if (!positions) {
            continue;
        }
        // Initialize min/max positions with the original positions.
        const numVertices = mesh.getTotalVertices();
        minPositions.length = Math.max(minPositions.length, numVertices);
        maxPositions.length = Math.max(minPositions.length, numVertices);
        for(let i = 0, j = 0; i < numVertices; i++, j += 3){
            position.set(positions[j], positions[j + 1], positions[j + 2]);
            minPositions[i].copyFrom(position);
            maxPositions[i].copyFrom(position);
        }
        // Apply morph targets to the min/max positions.
        const morphTargetManager = mesh.morphTargetManager;
        if (morphTargetManager) {
            for(let targetIndex = 0; targetIndex < morphTargetManager.numTargets; ++targetIndex){
                const target = morphTargetManager.getTarget(targetIndex);
                const positions = target.getPositions();
                if (positions) {
                    for(let i = 0, j = 0; i < numVertices; i++, j += 3){
                        position.set(positions[j], positions[j + 1], positions[j + 2]);
                        minPositions[i].minimizeInPlace(position);
                        maxPositions[i].maximizeInPlace(position);
                    }
                }
            }
        }
        // Compute extent per mesh.
        const skeleton = mesh.skeleton;
        const weights = skeleton ? mesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesWeightsKind) : null;
        const indices = skeleton ? mesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesIndicesKind) : null;
        if (weights && indices) {
            // Compute extent per bone for skinned meshes.
            const needsExtra = mesh.numBoneInfluencers > 4;
            const weightsExtra = needsExtra ? mesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesWeightsExtraKind) : null;
            const indicesExtra = needsExtra ? mesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].MatricesIndicesExtraKind) : null;
            const perBoneExtents = skinnedMeshExtents.get(mesh.uniqueId) || new Map();
            skinnedMeshExtents.set(mesh.uniqueId, perBoneExtents);
            const updateExtents = (i, j, weights, indices)=>{
                for(let k = j; k < j + 4; k++){
                    if (weights[k] > 0) {
                        const boneIndex = indices[k];
                        const extent = perBoneExtents.get(boneIndex);
                        if (extent) {
                            extent.minimum.minimizeInPlace(minPositions[i]);
                            extent.maximum.maximizeInPlace(maxPositions[i]);
                        } else {
                            perBoneExtents.set(boneIndex, {
                                minimum: minPositions[i].clone(),
                                maximum: maxPositions[i].clone()
                            });
                        }
                    }
                }
            };
            for(let i = 0, j = 0; i < numVertices; i++, j += 4){
                updateExtents(i, j, weights, indices);
                if (weightsExtra && indicesExtra) {
                    updateExtents(i, j, weightsExtra, indicesExtra);
                }
            }
        } else {
            // Compute extent for the whole mesh for non-skinned meshes.
            const extent = meshExtents.get(mesh.uniqueId) || {
                minimum: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]().setAll(Number.POSITIVE_INFINITY),
                maximum: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]().setAll(Number.NEGATIVE_INFINITY)
            };
            meshExtents.set(mesh.uniqueId, extent);
            for(let i = 0; i < numVertices; i++){
                extent.minimum.minimizeInPlace(minPositions[i]);
                extent.maximum.maximizeInPlace(maxPositions[i]);
            }
        }
    }
    // Create the 8 corners of each non-skinned and skinned extent.
    const meshCorners = new Map();
    const skinnedMeshCorners = new Map();
    for (const mesh of meshes){
        const extent = meshExtents.get(mesh.uniqueId);
        if (extent) {
            meshCorners.set(mesh.uniqueId, GetExtentCorners(extent));
        } else {
            const perBoneExtents = skinnedMeshExtents.get(mesh.uniqueId);
            if (perBoneExtents) {
                const bones = mesh.skeleton.bones;
                const perBoneCorners = new Map();
                skinnedMeshCorners.set(mesh.uniqueId, perBoneCorners);
                perBoneExtents.forEach((extent, boneIndex)=>{
                    const corners = GetExtentCorners(extent);
                    // Transform the coordinates of the corners for skinned meshes to bone space.
                    const inverseBindMatrix = bones[boneIndex].getAbsoluteInverseBindMatrix();
                    for (const corner of corners){
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformCoordinatesToRef(corner, inverseBindMatrix, corner);
                    }
                    perBoneCorners.set(boneIndex, corners);
                });
            }
        }
    }
    const maxExtents = Array.from({
        length: meshes.length
    }, ()=>({
            minimum: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]().setAll(Number.POSITIVE_INFINITY),
            maximum: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]().setAll(Number.NEGATIVE_INFINITY)
        }));
    const updateMaxExtents = ()=>{
        for(let i = 0; i < meshes.length; i++){
            const mesh = meshes[i];
            const positions = mesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind);
            if (!positions) {
                continue;
            }
            const worldMatrix = mesh.computeWorldMatrix(true);
            const skeleton = mesh.skeleton;
            if (skeleton) {
                skeleton.prepare(true);
                const bones = skeleton.bones;
                const perBoneCorners = skinnedMeshCorners.get(mesh.uniqueId);
                perBoneCorners.forEach((corners, boneIndex)=>{
                    // Transform the per-bone corners into world space and update the max extent for each corner.
                    for (const corner of corners){
                        const matrix = bones[boneIndex].getFinalMatrix().multiplyToRef(worldMatrix, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[0]);
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformCoordinatesToRef(corner, matrix, position);
                        maxExtents[i].minimum.minimizeInPlace(position);
                        maxExtents[i].maximum.maximizeInPlace(position);
                    }
                });
            } else {
                // Transform the corners into world space and update the max extent for each corner.
                for (const corner of meshCorners.get(mesh.uniqueId)){
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformCoordinatesToRef(corner, worldMatrix, position);
                    maxExtents[i].minimum.minimizeInPlace(position);
                    maxExtents[i].maximum.maximizeInPlace(position);
                }
            }
        }
    };
    if (animationGroup && animationGroup.isStarted) {
        const currentFrame = animationGroup.getCurrentFrame();
        const step = animationStep / animationGroup.getLength(0, 1);
        for(let frame = animationGroup.from; frame <= animationGroup.to; frame += step){
            animationGroup.goToFrame(frame);
            updateMaxExtents();
        }
        animationGroup.goToFrame(currentFrame);
    } else {
        updateMaxExtents();
    }
    return maxExtents;
}
function RemoveUnreferencedVerticesData(meshes) {
    const uvIndexToKind = [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UVKind,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV2Kind,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV3Kind,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV4Kind,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV5Kind,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV6Kind
    ];
    for (const mesh of meshes){
        const unreferencedUVSets = new Set(uvIndexToKind);
        const textures = mesh.material?.getActiveTextures();
        if (textures) {
            for (const texture of textures){
                unreferencedUVSets.delete(uvIndexToKind[texture.coordinatesIndex]);
            }
        }
        unreferencedUVSets.forEach((unreferencedUVSet)=>{
            if (mesh.isVerticesDataPresent(unreferencedUVSet)) {
                mesh.removeVerticesData(unreferencedUVSet);
            }
        });
    }
} //# sourceMappingURL=meshUtils.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/lattice.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Lattice",
    ()=>Lattice
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/buffer.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.scalar.functions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.constants.js [app-client] (ecmascript)");
;
;
;
;
class Lattice {
    /**
     * @returns the string "Lattice"
     */ getClassName() {
        return "Lattice";
    }
    /**
     * Gets the resolution on x axis
     */ get resolutionX() {
        return this._resolutionX;
    }
    /**
     * Gets the resolution on y axis
     */ get resolutionY() {
        return this._resolutionY;
    }
    /**
     * Gets the resolution on z axis
     */ get resolutionZ() {
        return this._resolutionZ;
    }
    /**
     * Gets the size of the lattice along each axis in object space
     * Updating the size requires you to call update afterwards
     */ get size() {
        return this._size;
    }
    /**
     * Gets the lattice position in object space
     */ get position() {
        return this._position;
    }
    /**
     * Gets the data of the lattice
     */ get data() {
        return this._data;
    }
    /**
     * Gets the size of each cell in the lattice
     */ get cellSize() {
        return this._cellSize;
    }
    /**
     * Gets the min bounds of the lattice
     */ get min() {
        return this._min;
    }
    /**
     * Gets the max bounds of the lattice
     */ get max() {
        return this._max;
    }
    /**
     * Creates a new Lattice
     * @param options options for creating
     */ constructor(options){
        this._cellSize = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        // Cache
        this._min = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](-0.5, -0.5, -0.5);
        this._max = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0.5, 0.5, 0.5);
        this._localPos = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this._tmpVector = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this._lerpVector0 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this._lerpVector1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this._lerpVector2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this._lerpVector3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this._lerpVector4 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this._lerpVector5 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        const localOptions = {
            resolutionX: 3,
            resolutionY: 3,
            resolutionZ: 3,
            position: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Zero(),
            size: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].One(),
            ...options
        };
        this._resolutionX = localOptions.resolutionX;
        this._resolutionY = localOptions.resolutionY;
        this._resolutionZ = localOptions.resolutionZ;
        this._position = localOptions.position;
        this._size = localOptions.autoAdaptToMesh ? localOptions.autoAdaptToMesh.getBoundingInfo().boundingBox.extendSize.scale(2) : localOptions.size;
        // Allocate data
        this._allocateData();
        this.update();
    }
    _allocateData() {
        this._data = new Array(this.resolutionX);
        for(let i = 0; i < this.resolutionX; i++){
            this._data[i] = new Array(this.resolutionY);
            for(let j = 0; j < this.resolutionY; j++){
                this._data[i][j] = new Array(this.resolutionZ);
                for(let k = 0; k < this.resolutionZ; k++){
                    this._data[i][j][k] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Zero();
                }
            }
        }
    }
    /**
     * Update of the lattice data
     */ update() {
        for(let i = 0; i < this.resolutionX; i++){
            for(let j = 0; j < this.resolutionY; j++){
                for(let k = 0; k < this.resolutionZ; k++){
                    const x = -this.size.x / 2 + this.size.x * (i / (this.resolutionX - 1));
                    const y = -this.size.y / 2 + this.size.y * (j / (this.resolutionY - 1));
                    const z = -this.size.z / 2 + this.size.z * (k / (this.resolutionZ - 1));
                    this._data[i][j][k].set(x, y, z);
                }
            }
        }
    }
    /**
     * Apply the lattice to a mesh
     * @param mesh mesh to deform
     */ deformMesh(mesh) {
        const positions = mesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind);
        if (!positions) {
            return;
        }
        // Apply the lattice
        this.deform(positions);
        // Update back the mesh
        mesh.setVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind, positions, true);
    }
    /**
     * Update the lattice internals (like min, max and cell size)
     */ updateInternals() {
        const nx = this._resolutionX;
        const ny = this._resolutionY;
        const nz = this._resolutionZ;
        // Calculate the size of each cell in the lattice
        this._cellSize.set(this.size.x / (nx - 1), this.size.y / (ny - 1), this.size.z / (nz - 1));
        // Calculate the lattice bounds
        this._min.set(this.position.x - this.size.x / 2, this.position.y - this.size.y / 2, this.position.z - this.size.z / 2);
        this._min.addToRef(this._size, this._max);
    }
    /**
     * Apply the lattice to a set of points
     * @param positions vertex data to deform
     * @param target optional target array to store the result (operation will be done in place in not defined)
     */ deform(positions, target) {
        const nx = this._resolutionX;
        const ny = this._resolutionY;
        const nz = this._resolutionZ;
        this.updateInternals();
        const min = this._min;
        const max = this._max;
        // Loop over each vertex
        for(let i = 0; i < positions.length; i += 3){
            const vertex = this._tmpVector.fromArray(positions, i);
            // Check we are inside
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OutsideRange"])(vertex.x, min.x, max.x, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Epsilon"]) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OutsideRange"])(vertex.y, min.y, max.y, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Epsilon"]) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OutsideRange"])(vertex.z, min.z, max.z, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Epsilon"])) {
                if (target) {
                    vertex.toArray(target, i);
                }
                continue;
            }
            // Map vertex position to lattice local coordinates
            const localPos = this._localPos.set((vertex.x - min.x) / this._cellSize.x, (vertex.y - min.y) / this._cellSize.y, (vertex.z - min.z) / this._cellSize.z);
            // Get integer lattice indices
            const i0 = Math.floor(localPos.x);
            const j0 = Math.floor(localPos.y);
            const k0 = Math.floor(localPos.z);
            const i1 = Math.min(i0 + 1, nx - 1);
            const j1 = Math.min(j0 + 1, ny - 1);
            const k1 = Math.min(k0 + 1, nz - 1);
            // Compute interpolation weights
            const tx = localPos.x - i0;
            const ty = localPos.y - j0;
            const tz = localPos.z - k0;
            // Ensure indices are within bounds
            const ii0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Clamp"])(i0, 0, nx - 1);
            const jj0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Clamp"])(j0, 0, ny - 1);
            const kk0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Clamp"])(k0, 0, nz - 1);
            const ii1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Clamp"])(i1, 0, nx - 1);
            const jj1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Clamp"])(j1, 0, ny - 1);
            const kk1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Clamp"])(k1, 0, nz - 1);
            // Get lattice control points
            const p000 = this._data[ii0][jj0][kk0];
            const p100 = this._data[ii1][jj0][kk0];
            const p010 = this._data[ii0][jj1][kk0];
            const p110 = this._data[ii1][jj1][kk0];
            const p001 = this._data[ii0][jj0][kk1];
            const p101 = this._data[ii1][jj0][kk1];
            const p011 = this._data[ii0][jj1][kk1];
            const p111 = this._data[ii1][jj1][kk1];
            // Trilinear interpolation
            const p00 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].LerpToRef(p000, p100, tx, this._lerpVector0);
            const p01 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].LerpToRef(p001, p101, tx, this._lerpVector1);
            const p10 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].LerpToRef(p010, p110, tx, this._lerpVector2);
            const p11 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].LerpToRef(p011, p111, tx, this._lerpVector3);
            const p0 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].LerpToRef(p00, p10, ty, this._lerpVector4);
            const p1 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].LerpToRef(p01, p11, ty, this._lerpVector5);
            const deformedPos = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].LerpToRef(p0, p1, tz, this._lerpVector0);
            deformedPos.addInPlace(this.position);
            // Apply deformation to the vertex
            deformedPos.toArray(target || positions, i);
        }
    }
} //# sourceMappingURL=lattice.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/lattice.material.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "LatticePluginMaterial",
    ()=>LatticePluginMaterial
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$rawTexture3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/Textures/rawTexture3D.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$materialPluginBase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/materialPluginBase.js [app-client] (ecmascript)");
;
;
class LatticePluginMaterial extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$materialPluginBase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MaterialPluginBase"] {
    /**
     * Create a new LatticePluginMaterial
     * @param lattice defines the lattice this plugin is associated with
     * @param material defines the material this plugin is associated with
     */ constructor(lattice, material){
        super(material, "Lattice", 200);
        this._lattice = lattice;
        this.refreshData();
        // let's enable it by default
        this._enable(true);
    }
    /**
     * Get the class name of the plugin
     * @returns the string "LatticePluginMaterial"
     */ getClassName() {
        return "LatticePluginMaterial";
    }
    /**
     * Defines if the plugin supports the specified shader language
     * @param shaderLanguage defines the shader language to check
     * @returns true if supported, false otherwise
     */ isCompatible(shaderLanguage) {
        switch(shaderLanguage){
            case 0 /* ShaderLanguage.GLSL */ :
            case 1 /* ShaderLanguage.WGSL */ :
                return true;
            default:
                return false;
        }
    }
    /**
     * Must be called when the lattice data was updated
     */ refreshData() {
        const length = this._lattice.resolutionX * this._lattice.resolutionY * this._lattice.resolutionZ * 4;
        if (!this._latticeData || this._latticeData.length !== length) {
            this._latticeData = new Float32Array(length);
        }
        for(let i = 0; i < this._lattice.resolutionX; i++){
            for(let j = 0; j < this._lattice.resolutionY; j++){
                for(let k = 0; k < this._lattice.resolutionZ; k++){
                    const control = this._lattice.data[i][j][k];
                    const index = i + this._lattice.resolutionX * (j + this._lattice.resolutionY * k);
                    control.toArray(this._latticeData, index * 4);
                }
            }
        }
        if (!this._latticeDataTexture || this._latticeDataTexture.width !== this._lattice.resolutionX || this._latticeDataTexture.height !== this._lattice.resolutionY || this._latticeDataTexture.depth !== this._lattice.resolutionZ) {
            if (this._latticeDataTexture) {
                this._latticeDataTexture.dispose();
            }
            this._latticeDataTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$rawTexture3D$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RawTexture3D"](this._latticeData, this._lattice.resolutionX, this._lattice.resolutionY, this._lattice.resolutionZ, 5, this._material.getScene(), false, false, 1, 1);
        } else {
            this._latticeDataTexture.update(this._latticeData);
        }
    }
    /**
     * Gets the description of the uniforms to add to the ubo (if engine supports ubos) or to inject directly in the vertex/fragment shaders (if engine does not support ubos)
     * @param shaderLanguage The shader language to use.
     * @returns the description of the uniforms
     */ getUniforms(shaderLanguage = 0 /* ShaderLanguage.GLSL */ ) {
        if (shaderLanguage === 1 /* ShaderLanguage.WGSL */ ) {
            // For webgpu we only define the UBO with the correct type and size.
            return {
                ubo: [
                    {
                        name: "lattice_cellSize",
                        size: 3,
                        type: "vec3"
                    },
                    {
                        name: "lattice_min",
                        size: 3,
                        type: "vec3"
                    },
                    {
                        name: "lattice_max",
                        size: 3,
                        type: "vec3"
                    },
                    {
                        name: "lattice_resolution",
                        size: 3,
                        type: "vec3"
                    },
                    {
                        name: "lattice_position",
                        size: 3,
                        type: "vec3"
                    }
                ]
            };
        }
        return {
            // first, define the UBO with the correct type and size.
            ubo: [
                {
                    name: "lattice_cellSize",
                    size: 3,
                    type: "vec3"
                },
                {
                    name: "lattice_min",
                    size: 3,
                    type: "vec3"
                },
                {
                    name: "lattice_max",
                    size: 3,
                    type: "vec3"
                },
                {
                    name: "lattice_resolution",
                    size: 3,
                    type: "vec3"
                },
                {
                    name: "lattice_position",
                    size: 3,
                    type: "vec3"
                }
            ],
            // now, on the vertex shader, add the uniform itself in case uniform buffers are not supported by the engine
            vertex: `
                    uniform vec3 lattice_cellSize;
                    uniform vec3 lattice_min;
                    uniform vec3 lattice_max;
                    uniform vec3 lattice_resolution;
                    uniform vec3 lattice_position;
                    `
        };
    }
    /**
     * Binds the material data.
     * @param uniformBuffer defines the Uniform buffer to fill in.
     */ bindForSubMesh(uniformBuffer) {
        this._lattice.updateInternals();
        uniformBuffer.updateVector3("lattice_cellSize", this._lattice.cellSize);
        uniformBuffer.updateVector3("lattice_min", this._lattice.min);
        uniformBuffer.updateVector3("lattice_max", this._lattice.max);
        uniformBuffer.updateFloat3("lattice_resolution", this._lattice.resolutionX, this._lattice.resolutionY, this._lattice.resolutionZ);
        uniformBuffer.updateVector3("lattice_position", this._lattice.position);
        uniformBuffer.setTexture("latticeData", this._latticeDataTexture);
    }
    /**
     * Gets the samplers used by the plugin.
     * @param samplers list that the sampler names should be added to.
     */ getSamplers(samplers) {
        samplers.push("latticeData");
    }
    _prepareCode(shaderLanguage = 0 /* ShaderLanguage.GLSL */ ) {
        if (this._code) {
            return this._code;
        }
        let code = `
            if (positionUpdated.x >= lattice_min.x && positionUpdated.x <= lattice_max.x &&
                positionUpdated.y >= lattice_min.y && positionUpdated.y <= lattice_max.y &&
                positionUpdated.z >= lattice_min.z && positionUpdated.z <= lattice_max.z) {

                // Map vertex position to lattice local coordinates
                vec3d localPos = vec3c((positionUpdated.x - lattice_min.x) / lattice_cellSize.x, (positionUpdated.y - lattice_min.y) / lattice_cellSize.y, (positionUpdated.z - lattice_min.z) / lattice_cellSize.z);

                // Get integer lattice indices
                intd i0 = intc(floor(localPos.x));
                intd j0 = intc(floor(localPos.y));
                intd k0 = intc(floor(localPos.z));

                intd resX = intc(lattice_resolution.x) - 1;
                intd resY = intc(lattice_resolution.y) - 1;
                intd resZ = intc(lattice_resolution.z) - 1;

                intd i1 = min(i0 + 1, resX);
                intd j1 = min(j0 + 1, resY);
                intd k1 = min(k0 + 1, resZ);

                // Compute interpolation weights
                floatd tx = localPos.x - floatc(i0);
                floatd ty = localPos.y - floatc(j0);
                floatd tz = localPos.z - floatc(k0);

                // Ensure indices are within bounds
                intd ii0 = clamp(i0, 0, resX);
                intd jj0 = clamp(j0, 0, resY);
                intd kk0 = clamp(k0, 0, resZ);
                intd ii1 = clamp(i1, 0, resX);
                intd jj1 = clamp(j1, 0, resY);
                intd kk1 = clamp(k1, 0, resZ);

                // Get lattice control points
                vec3d p000 = texelFetch(latticeData, ivec3c(ii0, jj0, kk0), 0).rgb;
                vec3d p100 = texelFetch(latticeData, ivec3c(ii1, jj0, kk0), 0).rgb;
                vec3d p010 = texelFetch(latticeData, ivec3c(ii0, jj1, kk0), 0).rgb;
                vec3d p110 = texelFetch(latticeData, ivec3c(ii1, jj1, kk0), 0).rgb;
                vec3d p001 = texelFetch(latticeData, ivec3c(ii0, jj0, kk1), 0).rgb;
                vec3d p101 = texelFetch(latticeData, ivec3c(ii1, jj0, kk1), 0).rgb;
                vec3d p011 = texelFetch(latticeData, ivec3c(ii0, jj1, kk1), 0).rgb;
                vec3d p111 = texelFetch(latticeData, ivec3c(ii1, jj1, kk1), 0).rgb;

                // Trilinear interpolation
                vec3d p00 = mix(p000, p100, tx);
                vec3d p01 = mix(p001, p101, tx);
                vec3d p10 = mix(p010, p110, tx);
                vec3d p11 = mix(p011, p111, tx);

                vec3d p0 = mix(p00, p10, ty);
                vec3d p1 = mix(p01, p11, ty);

                vec3d deformedPos = mix(p0, p1, tz);
                positionUpdated = deformedPos + lattice_position;
            };
        `;
        if (shaderLanguage === 1 /* ShaderLanguage.WGSL */ ) {
            code = `
                let lattice_min = uniforms.lattice_min;
                let lattice_max = uniforms.lattice_max;
                let lattice_resolution = uniforms.lattice_resolution;
                let lattice_position = uniforms.lattice_position;
                let lattice_cellSize = uniforms.lattice_cellSize;
            ` + code;
            code = code.replace(/ivec3c/g, "vec3i");
            code = code.replace(/vec3d/g, "var");
            code = code.replace(/vec3c/g, "vec3f");
            code = code.replace(/intd/g, "var");
            code = code.replace(/intc/g, "i32");
            code = code.replace(/floatd/g, "var");
            code = code.replace(/floatc/g, "f32");
            code = code.replace(/texelFetch/g, "textureLoad");
        } else {
            code = code.replace(/ivec3c/g, "ivec3");
            code = code.replace(/vec3d/g, "vec3");
            code = code.replace(/vec3c/g, "vec3");
            code = code.replace(/intd/g, "int");
            code = code.replace(/intc/g, "int");
            code = code.replace(/floatd/g, "float");
            code = code.replace(/floatc/g, "float");
        }
        this._code = code;
        return this._code;
    }
    /**
     * Returns a list of custom shader code fragments to customize the shader.
     * @param shaderType "vertex" or "fragment"
     * @param shaderLanguage The shader language to use.
     * @returns null if no code to be added, or a list of pointName =\> code.
     */ getCustomCode(shaderType, shaderLanguage = 0 /* ShaderLanguage.GLSL */ ) {
        if (shaderType === "vertex") {
            // we're adding this specific code at the end of the main() function
            if (shaderLanguage === 1 /* ShaderLanguage.WGSL */ ) {
                return {
                    CUSTOM_VERTEX_DEFINITIONS: `
                        var latticeData: texture_3d<f32>;
                    `,
                    CUSTOM_VERTEX_UPDATE_POSITION: this._prepareCode(shaderLanguage)
                };
            }
            return {
                CUSTOM_VERTEX_DEFINITIONS: `
                    precision highp sampler3D;
                    uniform sampler3D latticeData;
                `,
                CUSTOM_VERTEX_UPDATE_POSITION: this._prepareCode(shaderLanguage)
            };
        }
        // for other shader types we're not doing anything, return null
        return null;
    }
    /**
     * Disposes the resources of the material.
     */ dispose() {
        if (this._latticeDataTexture) {
            this._latticeDataTexture.dispose();
            this._latticeDataTexture = null;
        }
    }
} //# sourceMappingURL=lattice.material.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/GreasedLine/greasedLineBaseMesh.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GreasedLineBaseMesh",
    ()=>GreasedLineBaseMesh,
    "GreasedLineRibbonAutoDirectionMode",
    ()=>GreasedLineRibbonAutoDirectionMode,
    "GreasedLineRibbonFacesMode",
    ()=>GreasedLineRibbonFacesMode,
    "GreasedLineRibbonPointsMode",
    ()=>GreasedLineRibbonPointsMode
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$GreasedLine$2f$greasedLinePluginMaterial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/GreasedLine/greasedLinePluginMaterial.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.vertexData.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$deepCopier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/deepCopier.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$GreasedLine$2f$greasedLineSimpleMaterial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/GreasedLine/greasedLineSimpleMaterial.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$greasedLineTools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/greasedLineTools.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
var GreasedLineRibbonPointsMode;
(function(GreasedLineRibbonPointsMode) {
    GreasedLineRibbonPointsMode[GreasedLineRibbonPointsMode["POINTS_MODE_POINTS"] = 0] = "POINTS_MODE_POINTS";
    GreasedLineRibbonPointsMode[GreasedLineRibbonPointsMode["POINTS_MODE_PATHS"] = 1] = "POINTS_MODE_PATHS";
})(GreasedLineRibbonPointsMode || (GreasedLineRibbonPointsMode = {}));
var GreasedLineRibbonFacesMode;
(function(GreasedLineRibbonFacesMode) {
    GreasedLineRibbonFacesMode[GreasedLineRibbonFacesMode["FACES_MODE_SINGLE_SIDED"] = 0] = "FACES_MODE_SINGLE_SIDED";
    GreasedLineRibbonFacesMode[GreasedLineRibbonFacesMode["FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING"] = 1] = "FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING";
    GreasedLineRibbonFacesMode[GreasedLineRibbonFacesMode["FACES_MODE_DOUBLE_SIDED"] = 2] = "FACES_MODE_DOUBLE_SIDED";
})(GreasedLineRibbonFacesMode || (GreasedLineRibbonFacesMode = {}));
var GreasedLineRibbonAutoDirectionMode;
(function(GreasedLineRibbonAutoDirectionMode) {
    GreasedLineRibbonAutoDirectionMode[GreasedLineRibbonAutoDirectionMode["AUTO_DIRECTIONS_FROM_FIRST_SEGMENT"] = 0] = "AUTO_DIRECTIONS_FROM_FIRST_SEGMENT";
    GreasedLineRibbonAutoDirectionMode[GreasedLineRibbonAutoDirectionMode["AUTO_DIRECTIONS_FROM_ALL_SEGMENTS"] = 1] = "AUTO_DIRECTIONS_FROM_ALL_SEGMENTS";
    GreasedLineRibbonAutoDirectionMode[GreasedLineRibbonAutoDirectionMode["AUTO_DIRECTIONS_ENHANCED"] = 2] = "AUTO_DIRECTIONS_ENHANCED";
    GreasedLineRibbonAutoDirectionMode[GreasedLineRibbonAutoDirectionMode["AUTO_DIRECTIONS_FACE_TO"] = 3] = "AUTO_DIRECTIONS_FACE_TO";
    GreasedLineRibbonAutoDirectionMode[GreasedLineRibbonAutoDirectionMode["AUTO_DIRECTIONS_NONE"] = 99] = "AUTO_DIRECTIONS_NONE";
})(GreasedLineRibbonAutoDirectionMode || (GreasedLineRibbonAutoDirectionMode = {}));
class GreasedLineBaseMesh extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"] {
    constructor(name, scene, _options){
        super(name, scene, null, null, false, false);
        this.name = name;
        this._options = _options;
        this._lazy = false;
        this._updatable = false;
        this._engine = scene.getEngine();
        this._lazy = _options.lazy ?? false;
        this._updatable = _options.updatable ?? false;
        this._vertexPositions = [];
        this._indices = [];
        this._uvs = [];
        this._points = [];
        this._colorPointers = _options.colorPointers ?? [];
        this._widths = _options.widths ?? new Array(_options.points.length).fill(1);
    }
    /**
     * "GreasedLineMesh"
     * @returns "GreasedLineMesh"
     */ getClassName() {
        return "GreasedLineMesh";
    }
    _updateWidthsWithValue(defaulValue) {
        let pointCount = 0;
        for (const points of this._points){
            pointCount += points.length;
        }
        const countDiff = pointCount / 3 * 2 - this._widths.length;
        for(let i = 0; i < countDiff; i++){
            this._widths.push(defaulValue);
        }
    }
    /**
     * Updated a lazy line. Rerenders the line and updates boundinfo as well.
     */ updateLazy() {
        this._setPoints(this._points);
        if (!this._options.colorPointers) {
            this._updateColorPointers();
        }
        this._createVertexBuffers(this._options.ribbonOptions?.smoothShading);
        !this.doNotSyncBoundingInfo && this.refreshBoundingInfo();
        this.greasedLineMaterial?.updateLazy();
    }
    /**
     * Adds new points to the line. It doesn't rerenders the line if in lazy mode.
     * @param points points table
     * @param options optional options
     */ addPoints(points, options) {
        for (const p of points){
            this._points.push(p);
        }
        if (!this._lazy) {
            this.setPoints(this._points, options);
        }
    }
    /**
     * Dispose the line and it's resources
     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
     */ dispose(doNotRecurse, disposeMaterialAndTextures = false) {
        super.dispose(doNotRecurse, disposeMaterialAndTextures);
    }
    /**
     * @returns true if the mesh was created in lazy mode
     */ isLazy() {
        return this._lazy;
    }
    /**
     * Returns the UVs
     */ get uvs() {
        return this._uvs;
    }
    /**
     * Sets the UVs
     * @param uvs the UVs
     */ set uvs(uvs) {
        this._uvs = uvs instanceof Float32Array ? uvs : new Float32Array(uvs);
        this._createVertexBuffers();
    }
    /**
     * Returns the points offsets
     * Return the points offsets
     */ get offsets() {
        return this._offsets;
    }
    /**
     * Sets point offests
     * @param offsets offset table [x,y,z, x,y,z, ....]
     */ set offsets(offsets) {
        if (this.material instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$GreasedLine$2f$greasedLineSimpleMaterial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GreasedLineSimpleMaterial"]) {
            this.material.setDefine(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$GreasedLine$2f$greasedLineSimpleMaterial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GreasedLineUseOffsetsSimpleMaterialDefine"], offsets?.length > 0);
        }
        this._offsets = offsets;
        if (!this._offsetsBuffer) {
            this._createOffsetsBuffer(offsets);
        } else {
            this._offsetsBuffer.update(offsets);
        }
    }
    /**
     * Gets widths at each line point like [widthLower, widthUpper, widthLower, widthUpper, ...]
     */ get widths() {
        return this._widths;
    }
    /**
     * Sets widths at each line point
     * @param widths width table [widthLower, widthUpper, widthLower, widthUpper ...]
     */ set widths(widths) {
        this._widths = widths;
        if (!this._lazy) {
            this._widthsBuffer && this._widthsBuffer.update(widths);
        }
    }
    /**
     * Gets the color pointer. Each vertex need a color pointer. These color pointers points to the colors in the color table @see colors
     */ get colorPointers() {
        return this._colorPointers;
    }
    /**
     * Sets the color pointer
     * @param colorPointers array of color pointer in the colors array. One pointer for every vertex is needed.
     */ set colorPointers(colorPointers) {
        this._colorPointers = colorPointers;
        if (!this._lazy) {
            this._colorPointersBuffer && this._colorPointersBuffer.update(colorPointers);
        }
    }
    /**
     * Gets the pluginMaterial associated with line
     */ get greasedLineMaterial() {
        if (this.material && this.material instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$GreasedLine$2f$greasedLineSimpleMaterial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GreasedLineSimpleMaterial"]) {
            return this.material;
        }
        const materialPlugin = this.material?.pluginManager?.getPlugin(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$GreasedLine$2f$greasedLinePluginMaterial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GreasedLinePluginMaterial"].GREASED_LINE_MATERIAL_NAME);
        if (materialPlugin) {
            return materialPlugin;
        }
        return;
    }
    /**
     * Return copy the points.
     */ get points() {
        const pointsCopy = [];
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$deepCopier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DeepCopier"].DeepCopy(this._points, pointsCopy);
        return pointsCopy;
    }
    /**
     * Sets line points and rerenders the line.
     * @param points points table
     * @param options optional options
     */ setPoints(points, options) {
        this._points = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$greasedLineTools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GreasedLineTools"].ConvertPoints(points, options?.pointsOptions ?? this._options.pointsOptions);
        this._updateWidths();
        if (!options?.colorPointers) {
            this._updateColorPointers();
        }
        this._setPoints(this._points, options);
    }
    _initGreasedLine() {
        this._vertexPositions = [];
        this._indices = [];
        this._uvs = [];
    }
    _createLineOptions() {
        const lineOptions = {
            points: this._points,
            colorPointers: this._colorPointers,
            lazy: this._lazy,
            updatable: this._updatable,
            uvs: this._uvs,
            widths: this._widths,
            ribbonOptions: this._options.ribbonOptions
        };
        return lineOptions;
    }
    /**
     * Serializes this GreasedLineMesh
     * @param serializationObject object to write serialization to
     */ serialize(serializationObject) {
        super.serialize(serializationObject);
        serializationObject.type = this.getClassName();
        serializationObject.lineOptions = this._createLineOptions();
    }
    _createVertexBuffers(computeNormals = false) {
        const vertexData = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexData"]();
        vertexData.positions = this._vertexPositions;
        vertexData.indices = this._indices;
        vertexData.uvs = this._uvs;
        if (computeNormals) {
            vertexData.normals = [];
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexData"].ComputeNormals(this._vertexPositions, this._indices, vertexData.normals);
        }
        vertexData.applyToMesh(this, this._options.updatable);
        return vertexData;
    }
    _createOffsetsBuffer(offsets) {
        const engine = this._scene.getEngine();
        const offsetBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"](engine, offsets, this._updatable, 3);
        this.setVerticesBuffer(offsetBuffer.createVertexBuffer("grl_offsets", 0, 3));
        this._offsetsBuffer = offsetBuffer;
    }
} //# sourceMappingURL=greasedLineBaseMesh.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/GreasedLine/greasedLineMesh.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GreasedLineMesh",
    ()=>GreasedLineMesh
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Collisions$2f$pickingInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Collisions/pickingInfo.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$deepCopier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/deepCopier.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$greasedLineTools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/greasedLineTools.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$GreasedLine$2f$greasedLineBaseMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/GreasedLine/greasedLineBaseMesh.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"]._GreasedLineMeshParser = (parsedMesh, scene)=>{
    return GreasedLineMesh.Parse(parsedMesh, scene);
};
class GreasedLineMesh extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$GreasedLine$2f$greasedLineBaseMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GreasedLineBaseMesh"] {
    /**
     * GreasedLineMesh
     * @param name name of the mesh
     * @param scene the scene
     * @param _options mesh options
     */ constructor(name, scene, _options){
        super(name, scene, _options);
        this.name = name;
        /**
         * Treshold used to pick the mesh
         */ this.intersectionThreshold = 0.1;
        this._previousAndSide = [];
        this._nextAndCounters = [];
        if (_options.points) {
            this.addPoints(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$greasedLineTools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GreasedLineTools"].ConvertPoints(_options.points));
        }
    }
    /**
     * "GreasedLineMesh"
     * @returns "GreasedLineMesh"
     */ getClassName() {
        return "GreasedLineMesh";
    }
    _updateColorPointers() {
        if (this._options.colorPointers) {
            return;
        }
        let colorPointer = 0;
        this._colorPointers = [];
        for (const p of this._points){
            for(let jj = 0; jj < p.length; jj += 3){
                this._colorPointers.push(colorPointer);
                this._colorPointers.push(colorPointer++);
            }
        }
    }
    _updateWidths() {
    // intentionally left blank
    }
    _setPoints(points) {
        this._points = points;
        this._options.points = points;
        this._initGreasedLine();
        let indiceOffset = 0;
        let vertexPositionsLen = 0, indicesLength = 0, uvLength = 0, previousAndSideLength = 0, maxLineLength = 0;
        for (const p of points){
            maxLineLength = Math.max(p.length, maxLineLength);
            vertexPositionsLen += p.length * 2;
            indicesLength += (p.length - 3) * 2;
            uvLength += p.length * 4 / 3;
            previousAndSideLength += p.length * 8 / 3;
        }
        const buffer = new ArrayBuffer(vertexPositionsLen * 4 + indicesLength * (vertexPositionsLen > 65535 ? 4 : 2) + uvLength * 4 + previousAndSideLength * 4 * 2);
        const tempBuffer = new ArrayBuffer((maxLineLength / 3 + maxLineLength * 4) * 4);
        let byteOffset = 0;
        const vertexPositionsArr = new Float32Array(buffer, byteOffset, vertexPositionsLen);
        byteOffset += vertexPositionsArr.byteLength;
        const indicesArr = vertexPositionsLen > 65535 ? new Uint32Array(buffer, byteOffset, indicesLength) : new Uint16Array(buffer, byteOffset, indicesLength);
        byteOffset += indicesArr.byteLength;
        const uvArr = new Float32Array(buffer, byteOffset, uvLength);
        byteOffset += uvArr.byteLength;
        const previousAndSide = new Float32Array(buffer, byteOffset, previousAndSideLength);
        byteOffset += previousAndSide.byteLength;
        // it's the same length here
        const nextAndCounters = new Float32Array(buffer, byteOffset, previousAndSideLength);
        let vertexPositionsOffset = 0, indicesOffset = 0, uvOffset = 0, previousAndSideOffset = 0, nextAndCountersOffset = 0;
        for (const p of points){
            const lengthArray = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$greasedLineTools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GreasedLineTools"].GetLineLengthArray(p, tempBuffer);
            const totalLength = lengthArray[lengthArray.length - 1];
            for(let j = 0, jj = 0; jj < p.length; j++, jj += 3){
                const baseOffset = vertexPositionsOffset + jj * 2;
                vertexPositionsArr[baseOffset + 0] = p[jj + 0];
                vertexPositionsArr[baseOffset + 1] = p[jj + 1];
                vertexPositionsArr[baseOffset + 2] = p[jj + 2];
                vertexPositionsArr[baseOffset + 3] = p[jj + 0];
                vertexPositionsArr[baseOffset + 4] = p[jj + 1];
                vertexPositionsArr[baseOffset + 5] = p[jj + 2];
                if (jj < p.length - 3) {
                    const n = j * 2 + indiceOffset;
                    const baseIndicesOffset = indicesOffset + jj * 2;
                    indicesArr[baseIndicesOffset + 0] = n;
                    indicesArr[baseIndicesOffset + 1] = n + 1;
                    indicesArr[baseIndicesOffset + 2] = n + 2;
                    indicesArr[baseIndicesOffset + 3] = n + 2;
                    indicesArr[baseIndicesOffset + 4] = n + 1;
                    indicesArr[baseIndicesOffset + 5] = n + 3;
                }
            }
            indiceOffset += p.length / 3 * 2;
            const currVertexPositionsOffsetLength = p.length * 2;
            const positions = vertexPositionsArr.subarray(vertexPositionsOffset, vertexPositionsOffset + currVertexPositionsOffsetLength);
            vertexPositionsOffset += currVertexPositionsOffsetLength;
            indicesOffset += (p.length - 3) * 2;
            let byteOffset = lengthArray.byteLength;
            const previous = new Float32Array(tempBuffer, byteOffset, positions.length);
            byteOffset += previous.byteLength;
            const next = new Float32Array(tempBuffer, byteOffset, positions.length);
            const l = positions.length / 6;
            let v;
            if (GreasedLineMesh._CompareV3(0, l - 1, positions)) {
                v = positions.subarray((l - 2) * 6, (l - 1) * 6);
            } else {
                v = positions.subarray(0, 6);
            }
            previous.set(v);
            previous.set(positions.subarray(0, positions.length - 6), 6);
            next.set(positions.subarray(6));
            if (GreasedLineMesh._CompareV3(l - 1, 0, positions)) {
                v = positions.subarray(6, 12);
            } else {
                v = positions.subarray((l - 1) * 6, l * 6);
            }
            next.set(v, next.length - 6);
            for(let i = 0, sidesLength = positions.length / 3; i < sidesLength; i++){
                previousAndSide[previousAndSideOffset++] = previous[i * 3];
                previousAndSide[previousAndSideOffset++] = previous[i * 3 + 1];
                previousAndSide[previousAndSideOffset++] = previous[i * 3 + 2];
                // side[i] = i % 2 ? -1 : 1;
                // side[i] = 1 - ((i & 1) << 1);
                previousAndSide[previousAndSideOffset++] = 1 - ((i & 1) << 1);
                nextAndCounters[nextAndCountersOffset++] = next[i * 3];
                nextAndCounters[nextAndCountersOffset++] = next[i * 3 + 1];
                nextAndCounters[nextAndCountersOffset++] = next[i * 3 + 2];
                // counters[i] = lengthArray[i >> 1] / totalLength;
                nextAndCounters[nextAndCountersOffset++] = lengthArray[i >> 1] / totalLength;
            }
            if (this._options.uvs) {
                for(let i = 0; i < this._options.uvs.length; i++){
                    uvArr[uvOffset++] = this._options.uvs[i];
                }
            } else {
                for(let j = 0; j < l; j++){
                    // uvs
                    const lengthRatio = lengthArray[j] / totalLength;
                    const uvOffsetBase = uvOffset + j * 4;
                    uvArr[uvOffsetBase + 0] = lengthRatio;
                    uvArr[uvOffsetBase + 1] = 0;
                    uvArr[uvOffsetBase + 2] = lengthRatio;
                    uvArr[uvOffsetBase + 3] = 1;
                }
            }
        }
        this._vertexPositions = vertexPositionsArr;
        this._indices = indicesArr;
        this._uvs = uvArr;
        this._previousAndSide = previousAndSide;
        this._nextAndCounters = nextAndCounters;
        if (!this._lazy) {
            if (!this._options.colorPointers) {
                this._updateColorPointers();
            }
            this._createVertexBuffers();
            !this.doNotSyncBoundingInfo && this.refreshBoundingInfo();
        }
    }
    /**
     * Clones the GreasedLineMesh.
     * @param name new line name
     * @param newParent new parent node
     * @returns cloned line
     */ clone(name = `${this.name}-cloned`, newParent) {
        const lineOptions = this._createLineOptions();
        const deepCopiedLineOptions = {};
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$deepCopier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DeepCopier"].DeepCopy(lineOptions, deepCopiedLineOptions, [
            "instance"
        ], undefined, true);
        const cloned = new GreasedLineMesh(name, this._scene, deepCopiedLineOptions);
        if (newParent) {
            cloned.parent = newParent;
        }
        cloned.material = this.material;
        return cloned;
    }
    /**
     * Serializes this GreasedLineMesh
     * @param serializationObject object to write serialization to
     */ serialize(serializationObject) {
        super.serialize(serializationObject);
        serializationObject.type = this.getClassName();
        serializationObject.lineOptions = this._createLineOptions();
    }
    /**
     * Parses a serialized GreasedLineMesh
     * @param parsedMesh the serialized GreasedLineMesh
     * @param scene the scene to create the GreasedLineMesh in
     * @returns the created GreasedLineMesh
     */ static Parse(parsedMesh, scene) {
        const lineOptions = parsedMesh.lineOptions;
        const name = parsedMesh.name;
        const result = new GreasedLineMesh(name, scene, lineOptions);
        return result;
    }
    _initGreasedLine() {
        super._initGreasedLine();
        this._previousAndSide = [];
        this._nextAndCounters = [];
    }
    /**
     * Checks whether a ray is intersecting this GreasedLineMesh
     * @param ray ray to check the intersection of this mesh with
     * @param fastCheck not supported
     * @param trianglePredicate not supported
     * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)
     * @param worldToUse not supported
     * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check
     * @returns the picking info
     */ intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo = false, worldToUse, skipBoundingInfo = false) {
        const pickingInfo = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Collisions$2f$pickingInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PickingInfo"]();
        const intersections = this.findAllIntersections(ray, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo, true);
        if (intersections?.length === 1) {
            const intersection = intersections[0];
            pickingInfo.hit = true;
            pickingInfo.distance = intersection.distance;
            pickingInfo.ray = ray;
            pickingInfo.pickedMesh = this;
            pickingInfo.pickedPoint = intersection.point;
        }
        return pickingInfo;
    }
    /**
     * Gets all intersections of a ray and the line
     * @param ray Ray to check the intersection of this mesh with
     * @param _fastCheck not supported
     * @param _trianglePredicate not supported
     * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)
     * @param _worldToUse not supported
     * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check
     * @param firstOnly If true, the first and only intersection is immediatelly returned if found
     * @returns intersection(s)
     */ findAllIntersections(ray, _fastCheck, _trianglePredicate, onlyBoundingInfo = false, _worldToUse, skipBoundingInfo = false, firstOnly = false) {
        if (onlyBoundingInfo && !skipBoundingInfo && ray.intersectsSphere(this._boundingSphere, this.intersectionThreshold) === false) {
            return;
        }
        const indices = this.getIndices();
        const positions = this.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind);
        const widths = this._widths;
        const lineWidth = this.greasedLineMaterial?.width ?? 1;
        const intersects = [];
        if (indices && positions && widths) {
            let i = 0, l = 0;
            for(i = 0, l = indices.length - 1; i < l; i += 3){
                const a = indices[i];
                const b = indices[i + 1];
                GreasedLineMesh._V_START.fromArray(positions, a * 3);
                GreasedLineMesh._V_END.fromArray(positions, b * 3);
                if (this._offsets) {
                    GreasedLineMesh._V_OFFSET_START.fromArray(this._offsets, a * 3);
                    GreasedLineMesh._V_OFFSET_END.fromArray(this._offsets, b * 3);
                    GreasedLineMesh._V_START.addInPlace(GreasedLineMesh._V_OFFSET_START);
                    GreasedLineMesh._V_END.addInPlace(GreasedLineMesh._V_OFFSET_END);
                }
                const iFloored = Math.floor(i / 3);
                const width = widths[iFloored] !== undefined ? widths[iFloored] : 1;
                const precision = this.intersectionThreshold * (lineWidth * width) / 2;
                const distance = ray.intersectionSegment(GreasedLineMesh._V_START, GreasedLineMesh._V_END, precision);
                if (distance !== -1) {
                    intersects.push({
                        distance: distance,
                        point: ray.direction.normalize().multiplyByFloats(distance, distance, distance).add(ray.origin)
                    });
                    if (firstOnly) {
                        return intersects;
                    }
                }
            }
            i = l;
        }
        return intersects;
    }
    get _boundingSphere() {
        return this.getBoundingInfo().boundingSphere;
    }
    static _CompareV3(positionIdx1, positionIdx2, positions) {
        const arrayIdx1 = positionIdx1 * 6;
        const arrayIdx2 = positionIdx2 * 6;
        return positions[arrayIdx1] === positions[arrayIdx2] && positions[arrayIdx1 + 1] === positions[arrayIdx2 + 1] && positions[arrayIdx1 + 2] === positions[arrayIdx2 + 2];
    }
    _createVertexBuffers() {
        const vertexData = super._createVertexBuffers();
        const engine = this._scene.getEngine();
        const previousAndSideBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"](engine, this._previousAndSide, false, 4);
        this.setVerticesBuffer(previousAndSideBuffer.createVertexBuffer("grl_previousAndSide", 0, 4));
        const nextAndCountersBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"](engine, this._nextAndCounters, false, 4);
        this.setVerticesBuffer(nextAndCountersBuffer.createVertexBuffer("grl_nextAndCounters", 0, 4));
        const widthBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"](engine, this._widths, this._updatable, 1);
        this.setVerticesBuffer(widthBuffer.createVertexBuffer("grl_widths", 0, 1));
        this._widthsBuffer = widthBuffer;
        const colorPointersBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"](engine, this._colorPointers, this._updatable, 1);
        this.setVerticesBuffer(colorPointersBuffer.createVertexBuffer("grl_colorPointers", 0, 1));
        this._colorPointersBuffer = colorPointersBuffer;
        return vertexData;
    }
}
GreasedLineMesh._V_START = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
GreasedLineMesh._V_END = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
GreasedLineMesh._V_OFFSET_START = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
GreasedLineMesh._V_OFFSET_END = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](); //# sourceMappingURL=greasedLineMesh.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/GreasedLine/greasedLineRibbonMesh.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GreasedLineRibbonMesh",
    ()=>GreasedLineRibbonMesh
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$deepCopier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/deepCopier.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$greasedLineTools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/greasedLineTools.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$GreasedLine$2f$greasedLineBaseMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/GreasedLine/greasedLineBaseMesh.js [app-client] (ecmascript)");
;
;
;
;
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"]._GreasedLineRibbonMeshParser = (parsedMesh, scene)=>{
    return GreasedLineRibbonMesh.Parse(parsedMesh, scene);
};
class GreasedLineRibbonMesh extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$GreasedLine$2f$greasedLineBaseMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GreasedLineBaseMesh"] {
    /**
     * GreasedLineRibbonMesh
     * @param name name of the mesh
     * @param scene the scene
     * @param _options mesh options
     * @param _pathOptions used internaly when parsing a serialized GreasedLineRibbonMesh
     */ constructor(name, scene, _options, _pathOptions){
        super(name, scene, _options);
        this.name = name;
        if (!_options.ribbonOptions) {
            // eslint-disable-next-line no-throw-literal
            throw "'GreasedLineMeshOptions.ribbonOptions' is not set.";
        }
        this._paths = [];
        this._counters = [];
        this._slopes = [];
        this._widths = _options.widths ?? [];
        this._ribbonWidths = [];
        this._pathsOptions = _pathOptions ?? [];
        if (_options.points) {
            this.addPoints(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$greasedLineTools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GreasedLineTools"].ConvertPoints(_options.points), _options, !!_pathOptions);
        }
    }
    /**
     * Adds new points to the line. It doesn't rerenders the line if in lazy mode.
     * @param points points table
     * @param options mesh options
     * @param hasPathOptions defaults to false
     */ addPoints(points, options, hasPathOptions = false) {
        if (!options.ribbonOptions) {
            // eslint-disable-next-line no-throw-literal
            throw "addPoints() on GreasedLineRibbonMesh instance requires 'GreasedLineMeshOptions.ribbonOptions'.";
        }
        if (!hasPathOptions) {
            this._pathsOptions.push({
                options,
                pathCount: points.length
            });
        }
        super.addPoints(points, options);
    }
    /**
     * "GreasedLineRibbonMesh"
     * @returns "GreasedLineRibbonMesh"
     */ getClassName() {
        return "GreasedLineRibbonMesh";
    }
    /**
     * Return true if the line was created from two edge paths or one points path.
     * In this case the line is always flat.
     */ get isFlatLine() {
        return this._paths.length < 3;
    }
    /**
     * Returns the slopes of the line at each point relative to the center of the line
     */ get slopes() {
        return this._slopes;
    }
    /**
     * Set the slopes of the line at each point relative to the center of the line
     */ set slopes(slopes) {
        this._slopes = slopes;
    }
    _updateColorPointers() {
        if (this._options.colorPointers) {
            return;
        }
        let colorPointer = 0;
        this._colorPointers = [];
        for(let i = 0; i < this._pathsOptions.length; i++){
            const { options: pathOptions, pathCount } = this._pathsOptions[i];
            const points = this._points[i];
            if (pathOptions.ribbonOptions.pointsMode === 0 /* GreasedLineRibbonPointsMode.POINTS_MODE_POINTS */ ) {
                for(let k = 0; k < pathCount; k++){
                    for(let j = 0; j < points.length; j += 3){
                        this._colorPointers.push(colorPointer);
                        this._colorPointers.push(colorPointer++);
                    }
                }
            } else {
                for(let j = 0; j < points.length; j += 3){
                    for(let k = 0; k < pathCount; k++){
                        this._colorPointers.push(colorPointer);
                    }
                    colorPointer++;
                }
            }
        }
    }
    _updateWidths() {
        super._updateWidthsWithValue(1);
    }
    _setPoints(points, _options) {
        if (!this._options.ribbonOptions) {
            // eslint-disable-next-line no-throw-literal
            throw "No 'GreasedLineMeshOptions.ribbonOptions' provided.";
        }
        this._points = points;
        this._options.points = points;
        this._initGreasedLine();
        let indiceOffset = 0;
        let directionPlanes = undefined;
        for(let i = 0, c = 0; i < this._pathsOptions.length; i++){
            const { options: pathOptions, pathCount } = this._pathsOptions[i];
            const subPoints = points.slice(c, c + pathCount);
            c += pathCount;
            if (pathOptions.ribbonOptions?.pointsMode === 1 /* GreasedLineRibbonPointsMode.POINTS_MODE_PATHS */ ) {
                indiceOffset = this._preprocess(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$greasedLineTools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GreasedLineTools"].ToVector3Array(subPoints), indiceOffset, pathOptions);
            } else {
                if (pathOptions.ribbonOptions?.directionsAutoMode === 99 /* GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_NONE */ ) {
                    if (!pathOptions.ribbonOptions.directions) {
                        // eslint-disable-next-line no-throw-literal
                        throw "In GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_NONE 'GreasedLineMeshOptions.ribbonOptions.directions' must be defined.";
                    }
                    directionPlanes = GreasedLineRibbonMesh._GetDirectionPlanesFromDirectionsOption(subPoints.length, pathOptions.ribbonOptions.directions);
                }
                for(let idx = 0; idx < subPoints.length; idx++){
                    const p = subPoints[idx];
                    const pathArray = GreasedLineRibbonMesh._ConvertToRibbonPath(p, pathOptions.ribbonOptions, this._scene.useRightHandedSystem, directionPlanes ? directionPlanes[idx] : directionPlanes);
                    indiceOffset = this._preprocess(pathArray, indiceOffset, pathOptions);
                }
            }
        }
        if (!this._lazy) {
            this._createVertexBuffers();
            !this.doNotSyncBoundingInfo && this.refreshBoundingInfo();
        }
    }
    static _GetDirectionPlanesFromDirectionsOption(count, directions) {
        if (Array.isArray(directions)) {
            return directions;
        }
        return new Array(count).fill(directions);
    }
    static _CreateRibbonVertexData(pathArray, options) {
        const numOfPaths = pathArray.length;
        if (numOfPaths < 2) {
            // eslint-disable-next-line no-throw-literal
            throw "Minimum of two paths are required to create a GreasedLineRibbonMesh.";
        }
        const positions = [];
        const indices = [];
        const path = pathArray[0];
        for(let i = 0; i < path.length; i++){
            for(let pi = 0; pi < pathArray.length; pi++){
                const v = pathArray[pi][i];
                positions.push(v.x, v.y, v.z);
            }
        }
        const v = [
            1,
            0,
            numOfPaths
        ];
        const doubleSided = options.ribbonOptions?.facesMode === 2 /* GreasedLineRibbonFacesMode.FACES_MODE_DOUBLE_SIDED */ ;
        const closePath = options.ribbonOptions?.pointsMode === 1 /* GreasedLineRibbonPointsMode.POINTS_MODE_PATHS */  && options.ribbonOptions.closePath;
        if (numOfPaths > 2) {
            for(let i = 0; i < path.length - 1; i++){
                v[0] = 1 + numOfPaths * i;
                v[1] = numOfPaths * i;
                v[2] = (i + 1) * numOfPaths;
                for(let pi = 0; pi < (numOfPaths - 1) * 2; pi++){
                    if (pi % 2 !== 0) {
                        v[2] += 1;
                    }
                    if (pi % 2 === 0 && pi > 0) {
                        v[0] += 1;
                        v[1] += 1;
                    }
                    indices.push(v[1] + (pi % 2 !== 0 ? numOfPaths : 0), v[0], v[2]);
                    if (doubleSided) {
                        indices.push(v[0], v[1] + (pi % 2 !== 0 ? numOfPaths : 0), v[2]);
                    }
                }
            }
        } else {
            for(let i = 0; i < positions.length / 3 - 3; i += 2){
                indices.push(i, i + 1, i + 2);
                indices.push(i + 2, i + 1, i + 3);
                if (doubleSided) {
                    indices.push(i + 1, i, i + 2);
                    indices.push(i + 1, i + 2, i + 3);
                }
            }
        }
        if (closePath) {
            let lastIndice = numOfPaths * (path.length - 1);
            for(let pi = 0; pi < numOfPaths - 1; pi++){
                indices.push(lastIndice, pi + 1, pi);
                indices.push(lastIndice + 1, pi + 1, lastIndice);
                if (doubleSided) {
                    indices.push(pi, pi + 1, lastIndice);
                    indices.push(lastIndice, pi + 1, lastIndice + 1);
                }
                lastIndice++;
            }
        }
        return {
            positions,
            indices
        };
    }
    _preprocess(pathArray, indiceOffset, options) {
        this._paths = pathArray;
        const ribbonVertexData = GreasedLineRibbonMesh._CreateRibbonVertexData(pathArray, options);
        const positions = ribbonVertexData.positions;
        if (!this._options.widths) {
            // eslint-disable-next-line no-throw-literal
            throw "No 'GreasedLineMeshOptions.widths' table is specified.";
        }
        const vertexPositions = Array.isArray(this._vertexPositions) ? this._vertexPositions : Array.from(this._vertexPositions);
        this._vertexPositions = vertexPositions;
        const uvs = Array.isArray(this._uvs) ? this._uvs : Array.from(this._uvs);
        this._uvs = uvs;
        const indices = Array.isArray(this._indices) ? this._indices : Array.from(this._indices);
        this._indices = indices;
        for (const p of positions){
            vertexPositions.push(p);
        }
        let pathArrayCopy = pathArray;
        if (options.ribbonOptions?.pointsMode === 1 /* GreasedLineRibbonPointsMode.POINTS_MODE_PATHS */  && options.ribbonOptions.closePath) {
            pathArrayCopy = [];
            for(let i = 0; i < pathArray.length; i++){
                const pathCopy = pathArray[i].slice();
                pathCopy.push(pathArray[i][0].clone());
                pathArrayCopy.push(pathCopy);
            }
        }
        this._calculateSegmentLengths(pathArrayCopy);
        const pathArrayLength = pathArrayCopy.length;
        const previousCounters = new Array(pathArrayLength).fill(0);
        for(let i = 0; i < pathArrayCopy[0].length; i++){
            let v = 0;
            for(let pi = 0; pi < pathArrayLength; pi++){
                const counter = previousCounters[pi] + this._vSegmentLengths[pi][i] / this._vTotalLengths[pi];
                this._counters.push(counter);
                uvs.push(counter, v);
                previousCounters[pi] = counter;
                v += this._uSegmentLengths[i][pi] / this._uTotalLengths[i];
            }
        }
        for(let i = 0, c = 0; i < pathArrayCopy[0].length; i++){
            const widthLower = this._uSegmentLengths[i][0] / 2;
            const widthUpper = this._uSegmentLengths[i][pathArrayLength - 1] / 2;
            this._ribbonWidths.push(((this._widths[c++] ?? 1) - 1) * widthLower);
            for(let pi = 0; pi < pathArrayLength - 2; pi++){
                this._ribbonWidths.push(0);
            }
            this._ribbonWidths.push(((this._widths[c++] ?? 1) - 1) * widthUpper);
        }
        const slopes = options.ribbonOptions?.pointsMode === 1 /* GreasedLineRibbonPointsMode.POINTS_MODE_PATHS */  ? new Array(pathArrayCopy[0].length * pathArrayCopy.length * 6).fill(0) : GreasedLineRibbonMesh._CalculateSlopes(pathArrayCopy);
        for (const s of slopes){
            this._slopes.push(s);
        }
        if (ribbonVertexData.indices) {
            for(let i = 0; i < ribbonVertexData.indices.length; i++){
                indices.push(ribbonVertexData.indices[i] + indiceOffset);
            }
        }
        indiceOffset += positions.length / 3;
        return indiceOffset;
    }
    static _ConvertToRibbonPath(points, ribbonInfo, rightHandedSystem, directionPlane) {
        if (ribbonInfo.pointsMode === 0 /* GreasedLineRibbonPointsMode.POINTS_MODE_POINTS */  && !ribbonInfo.width) {
            // eslint-disable-next-line no-throw-literal
            throw "'GreasedLineMeshOptions.ribbonOptiosn.width' must be specified in GreasedLineRibbonPointsMode.POINTS_MODE_POINTS.";
        }
        const path1 = [];
        const path2 = [];
        if (ribbonInfo.pointsMode === 0 /* GreasedLineRibbonPointsMode.POINTS_MODE_POINTS */ ) {
            const width = ribbonInfo.width / 2;
            const pointVectors = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$greasedLineTools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GreasedLineTools"].ToVector3Array(points);
            let direction = null;
            let fatDirection = null;
            if (ribbonInfo.directionsAutoMode === 0 /* GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT */ ) {
                // set the direction plane from the first line segment for the whole line
                directionPlane = GreasedLineRibbonMesh._GetDirectionFromPoints(pointVectors[0], pointVectors[1], null);
            }
            if (ribbonInfo.directionsAutoMode === 3 /* GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_FACE_TO */  && !(ribbonInfo.directions instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"])) {
                // eslint-disable-next-line no-throw-literal
                throw "In GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_FACE_TO 'GreasedLineMeshOptions.ribbonOptions.directions' must be a Vector3.";
            }
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[1] = ribbonInfo.directions instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"] ? ribbonInfo.directions : GreasedLineRibbonMesh.DIRECTION_XZ;
            for(let i = 0; i < pointVectors.length - (directionPlane ? 0 : 1); i++){
                const p1 = pointVectors[i];
                const p2 = pointVectors[i + 1];
                if (directionPlane) {
                    direction = directionPlane;
                } else if (ribbonInfo.directionsAutoMode === 3 /* GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_FACE_TO */ ) {
                    p2.subtractToRef(p1, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[0]);
                    direction = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].CrossToRef(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[0], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[1], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[2]).normalize();
                } else if (ribbonInfo.directionsAutoMode === 1 /* GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS */ ) {
                    direction = GreasedLineRibbonMesh._GetDirectionFromPoints(p1, p2, direction);
                } else {
                    // GreasedLineRibbonAutoDirectionMode.DIRECTION_ENHANCED
                    const directionTemp = p2.subtract(p1);
                    directionTemp.applyRotationQuaternionInPlace(directionTemp.x > directionTemp.y && directionTemp.x > directionTemp.z ? rightHandedSystem ? GreasedLineRibbonMesh._RightHandedForwardReadOnlyQuaternion : GreasedLineRibbonMesh._LeftHandedForwardReadOnlyQuaternion : GreasedLineRibbonMesh._LeftReadOnlyQuaternion);
                    direction = directionTemp.normalize();
                }
                fatDirection = direction.multiplyByFloats(width, width, width);
                path1.push(p1.add(fatDirection));
                path2.push(p1.subtract(fatDirection));
            }
            if (!directionPlane) {
                path1.push(pointVectors[pointVectors.length - 1].add(fatDirection));
                path2.push(pointVectors[pointVectors.length - 1].subtract(fatDirection));
            }
        }
        return [
            path1,
            path2
        ];
    }
    static _GetDirectionFromPoints(p1, p2, previousDirection) {
        // handle straight lines
        if (p1.x === p2.x && (!previousDirection || previousDirection?.x === 1)) {
            return GreasedLineRibbonMesh.DIRECTION_YZ;
        }
        if (p1.y === p2.y) {
            return GreasedLineRibbonMesh.DIRECTION_XZ;
        }
        if (p1.z === p2.z) {
            return GreasedLineRibbonMesh.DIRECTION_XY;
        }
        return GreasedLineRibbonMesh.DIRECTION_XZ;
    }
    /**
     * Clones the GreasedLineRibbonMesh.
     * @param name new line name
     * @param newParent new parent node
     * @returns cloned line
     */ clone(name = `${this.name}-cloned`, newParent) {
        const lineOptions = this._createLineOptions();
        const deepCopiedLineOptions = {};
        const pathOptionsCloned = [];
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$deepCopier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DeepCopier"].DeepCopy(this._pathsOptions, pathOptionsCloned, undefined, undefined, true);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$deepCopier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DeepCopier"].DeepCopy(lineOptions, deepCopiedLineOptions, [
            "instance"
        ], undefined, true);
        const cloned = new GreasedLineRibbonMesh(name, this._scene, deepCopiedLineOptions, pathOptionsCloned);
        if (newParent) {
            cloned.parent = newParent;
        }
        cloned.material = this.material;
        return cloned;
    }
    /**
     * Serializes this GreasedLineRibbonMesh
     * @param serializationObject object to write serialization to
     */ serialize(serializationObject) {
        super.serialize(serializationObject);
        serializationObject.type = this.getClassName();
        serializationObject.lineOptions = this._createLineOptions();
        serializationObject.pathsOptions = this._pathsOptions;
    }
    /**
     * Parses a serialized GreasedLineRibbonMesh
     * @param parsedMesh the serialized GreasedLineRibbonMesh
     * @param scene the scene to create the GreasedLineRibbonMesh in
     * @returns the created GreasedLineRibbonMesh
     */ static Parse(parsedMesh, scene) {
        const lineOptions = parsedMesh.lineOptions;
        const name = parsedMesh.name;
        const pathOptions = parsedMesh.pathOptions;
        const result = new GreasedLineRibbonMesh(name, scene, lineOptions, pathOptions);
        return result;
    }
    _initGreasedLine() {
        super._initGreasedLine();
        this._paths = [];
        this._counters = [];
        this._slopes = [];
        this._ribbonWidths = [];
    }
    _calculateSegmentLengths(pathArray) {
        const pathArrayLength = pathArray.length;
        this._vSegmentLengths = new Array(pathArrayLength);
        this._vTotalLengths = new Array(pathArrayLength);
        let length = 0;
        for(let pi = 0; pi < pathArrayLength; pi++){
            const points = pathArray[pi];
            this._vSegmentLengths[pi] = [
                0
            ]; // first point has 0 distance
            length = 0;
            for(let i = 0; i < points.length - 1; i++){
                const l = Math.abs(points[i].subtract(points[i + 1]).lengthSquared()); // it's ok to have lengthSquared() here
                length += l;
                this._vSegmentLengths[pi].push(l);
            }
            this._vTotalLengths[pi] = length;
        }
        const positionsLength = pathArray[0].length;
        this._uSegmentLengths = new Array(positionsLength).fill([]);
        this._uTotalLengths = new Array(positionsLength).fill([]);
        const uLength = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        for(let i = 0; i < positionsLength; i++){
            length = 0;
            for(let pi = 1; pi < pathArrayLength; pi++){
                pathArray[pi][i].subtractToRef(pathArray[pi - 1][i], uLength);
                const l = uLength.length(); // must be length()
                length += l;
                this._uSegmentLengths[i].push(l);
            }
            this._uTotalLengths[i] = length;
        }
    }
    static _CalculateSlopes(paths) {
        const points1 = paths[0];
        const points2 = paths.length === 2 ? paths[1] : paths[paths.length - 1];
        const slopes = [];
        const slope = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        for(let i = 0; i < points1.length; i++){
            for(let pi = 0; pi < paths.length; pi++){
                if (pi === 0 || pi === paths.length - 1) {
                    points1[i].subtract(points2[i]).normalizeToRef(slope);
                    slopes.push(slope.x, slope.y, slope.z);
                    slopes.push(-slope.x, -slope.y, -slope.z);
                } else {
                    slopes.push(0, 0, 0, 0, 0, 0);
                }
            }
        }
        return slopes;
    }
    _createVertexBuffers() {
        this._uvs = this._options.uvs ?? this._uvs;
        const vertexData = super._createVertexBuffers(this._options.ribbonOptions?.smoothShading);
        const countersBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"](this._engine, this._counters, this._updatable, 1);
        this.setVerticesBuffer(countersBuffer.createVertexBuffer("grl_counters", 0, 1));
        const colorPointersBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"](this._engine, this._colorPointers, this._updatable, 1);
        this.setVerticesBuffer(colorPointersBuffer.createVertexBuffer("grl_colorPointers", 0, 1));
        const slopesBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"](this._engine, this._slopes, this._updatable, 3);
        this.setVerticesBuffer(slopesBuffer.createVertexBuffer("grl_slopes", 0, 3));
        const widthsBuffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"](this._engine, this._ribbonWidths, this._updatable, 1);
        this.setVerticesBuffer(widthsBuffer.createVertexBuffer("grl_widths", 0, 1));
        this._widthsBuffer = widthsBuffer;
        return vertexData;
    }
}
/**
 * Default line width
 */ GreasedLineRibbonMesh.DEFAULT_WIDTH = 0.1;
GreasedLineRibbonMesh._RightHandedForwardReadOnlyQuaternion = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"].RotationAxis(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].RightHandedForwardReadOnly, Math.PI / 2);
GreasedLineRibbonMesh._LeftHandedForwardReadOnlyQuaternion = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"].RotationAxis(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].LeftHandedForwardReadOnly, Math.PI / 2);
GreasedLineRibbonMesh._LeftReadOnlyQuaternion = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Quaternion"].RotationAxis(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].LeftReadOnly, Math.PI / 2);
/**
 * Direction which the line segment will be thickened if drawn on the XY plane
 */ GreasedLineRibbonMesh.DIRECTION_XY = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].LeftHandedForwardReadOnly; // doesn't matter in which handed system the scene operates
/**
 * Direction which the line segment will be thickened if drawn on the XZ plane
 */ GreasedLineRibbonMesh.DIRECTION_XZ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].UpReadOnly;
/**
 * Direction which the line segment will be thickened if drawn on the YZ plane
 */ GreasedLineRibbonMesh.DIRECTION_YZ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].LeftReadOnly; //# sourceMappingURL=greasedLineRibbonMesh.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/csg2.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CSG2",
    ()=>CSG2,
    "InitializeCSG2Async",
    ()=>InitializeCSG2Async,
    "IsCSG2Ready",
    ()=>IsCSG2Ready
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.vertexData.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/buffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/logger.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$multiMaterial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/multiMaterial.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$subMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/subMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$internals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tools.internals.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
/**
 * Main manifold library
 */ // eslint-disable-next-line @typescript-eslint/naming-convention
let Manifold;
/**
 * Promise to wait for the manifold library to be ready
 */ // eslint-disable-next-line @typescript-eslint/naming-convention
let ManifoldPromise;
/**
 * Manifold mesh
 */ // eslint-disable-next-line @typescript-eslint/naming-convention
let ManifoldMesh;
/**
 * First ID to use for materials indexing
 */ // eslint-disable-next-line @typescript-eslint/naming-convention
let FirstID;
class CSG2 {
    /**
     * Return the size of a vertex (at least 3 for the position)
     */ get numProp() {
        return this._numProp;
    }
    constructor(manifold, numProp, vertexStructure){
        this._manifold = manifold;
        this._numProp = numProp;
        this._vertexStructure = vertexStructure;
    }
    _process(operation, csg) {
        if (this.numProp !== csg.numProp) {
            throw new Error("CSG must be used with geometries having the same number of properties");
        }
        return new CSG2(Manifold[operation](this._manifold, csg._manifold), this.numProp, this._vertexStructure);
    }
    /**
     * Run a difference operation between two CSG
     * @param csg defines the CSG to use to create the difference
     * @returns a new csg
     */ subtract(csg) {
        return this._process("difference", csg);
    }
    /**
     * Run an intersection operation between two CSG
     * @param csg defines the CSG to use to create the intersection
     * @returns a new csg
     */ intersect(csg) {
        return this._process("intersection", csg);
    }
    /**
     * Run an union operation between two CSG
     * @param csg defines the CSG to use to create the union
     * @returns a new csg
     */ add(csg) {
        return this._process("union", csg);
    }
    /**
     * Print debug information about the CSG
     */ printDebug() {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].Log("Genus:" + this._manifold.genus());
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].Log("Volume:" + this._manifold.volume());
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].Log("surface area:" + this._manifold.surfaceArea());
    }
    /**
     * Generate a vertex data from the CSG
     * @param options defines the options to use to rebuild the vertex data
     * @returns a new vertex data
     */ toVertexData(options) {
        const localOptions = {
            rebuildNormals: false,
            ...options
        };
        const vertexData = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexData"]();
        const normalComponent = this._vertexStructure.find((c)=>c.kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].NormalKind);
        const manifoldMesh = this._manifold.getMesh(localOptions.rebuildNormals && normalComponent ? [
            3,
            4,
            5
        ] : undefined);
        vertexData.indices = manifoldMesh.triVerts.length > 65535 ? new Uint32Array(manifoldMesh.triVerts) : new Uint16Array(manifoldMesh.triVerts);
        for(let i = 0; i < manifoldMesh.triVerts.length; i += 3){
            vertexData.indices[i] = manifoldMesh.triVerts[i + 2];
            vertexData.indices[i + 1] = manifoldMesh.triVerts[i + 1];
            vertexData.indices[i + 2] = manifoldMesh.triVerts[i];
        }
        const vertexCount = manifoldMesh.vertProperties.length / manifoldMesh.numProp;
        // Attributes
        let offset = 0;
        for(let componentIndex = 0; componentIndex < this._vertexStructure.length; componentIndex++){
            const component = this._vertexStructure[componentIndex];
            const data = new Float32Array(vertexCount * component.stride);
            for(let i = 0; i < vertexCount; i++){
                for(let strideIndex = 0; strideIndex < component.stride; strideIndex++){
                    data[i * component.stride + strideIndex] = manifoldMesh.vertProperties[i * manifoldMesh.numProp + offset + strideIndex];
                }
            }
            vertexData.set(data, component.kind);
            offset += component.stride;
        }
        // Rebuild mesh from vertex data
        return vertexData;
    }
    /**
     * Generate a mesh from the CSG
     * @param name defines the name of the mesh
     * @param scene defines the scene to use to create the mesh
     * @param options defines the options to use to rebuild the mesh
     * @returns a new Mesh
     */ toMesh(name, scene, options) {
        const localOptions = {
            rebuildNormals: false,
            centerMesh: true,
            ...options
        };
        const vertexData = this.toVertexData({
            rebuildNormals: localOptions.rebuildNormals
        });
        const normalComponent = this._vertexStructure.find((c)=>c.kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].NormalKind);
        const manifoldMesh = this._manifold.getMesh(localOptions.rebuildNormals && normalComponent ? [
            3,
            4,
            5
        ] : undefined);
        const vertexCount = manifoldMesh.vertProperties.length / manifoldMesh.numProp;
        // Rebuild mesh from vertex data
        const output = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](name, scene);
        vertexData.applyToMesh(output);
        if (!vertexCount) {
            throw new Error("Unable to build a mesh. Manifold has 0 vertex");
        }
        // Center mesh
        if (localOptions.centerMesh) {
            const extents = output.getBoundingInfo().boundingSphere.center;
            output.position.set(-extents.x, -extents.y, -extents.z);
            output.bakeCurrentTransformIntoVertices();
        }
        // Submeshes
        let id = manifoldMesh.runOriginalID[0];
        let start = manifoldMesh.runIndex[0];
        let materialIndex = 0;
        const materials = [];
        scene = output.getScene();
        for(let run = 0; run < manifoldMesh.numRun; ++run){
            const nextID = manifoldMesh.runOriginalID[run + 1];
            if (nextID !== id) {
                const end = manifoldMesh.runIndex[run + 1];
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$subMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SubMesh"](materialIndex, 0, vertexCount, start, end - start, output);
                materials.push(scene.getMaterialByUniqueID(id - FirstID) || scene.defaultMaterial);
                id = nextID;
                start = end;
                materialIndex++;
            }
        }
        if (localOptions.materialToUse) {
            output.material = localOptions.materialToUse;
        } else {
            if (materials.length > 1) {
                const multiMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$multiMaterial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MultiMaterial"](name, scene);
                multiMaterial.subMaterials = materials;
                output.material = multiMaterial;
            } else {
                if (output.subMeshes.length > 1) {
                    // Remove the submeshes as they are not needed
                    output._createGlobalSubMesh(true);
                }
                output.material = materials[0];
            }
        }
        return output;
    }
    /**
     * Dispose the CSG resources
     */ dispose() {
        if (this._manifold) {
            this._manifold.delete();
            this._manifold = null;
        }
    }
    static _ProcessData(vertexCount, triVerts, structure, numProp, runIndex, runOriginalID) {
        const vertProperties = new Float32Array(vertexCount * structure.reduce((acc, cur)=>acc + cur.stride, 0));
        for(let i = 0; i < vertexCount; i++){
            let offset = 0;
            for(let idx = 0; idx < structure.length; idx++){
                const component = structure[idx];
                for(let strideIndex = 0; strideIndex < component.stride; strideIndex++){
                    vertProperties[i * numProp + offset + strideIndex] = component.data[i * component.stride + strideIndex];
                }
                offset += component.stride;
            }
        }
        // eslint-disable-next-line @typescript-eslint/naming-convention
        const manifoldMesh = new ManifoldMesh({
            numProp: numProp,
            vertProperties,
            triVerts,
            runIndex,
            runOriginalID
        });
        manifoldMesh.merge();
        let returnValue;
        try {
            returnValue = new CSG2(new Manifold(manifoldMesh), numProp, structure);
        } catch (e) {
            throw new Error("Error while creating the CSG: " + e.message);
        }
        return returnValue;
    }
    static _Construct(data, worldMatrix, runIndex, runOriginalID) {
        // Create the MeshGL for I/O with Manifold library.
        const triVerts = new Uint32Array(data.indices.length);
        // Revert order
        for(let i = 0; i < data.indices.length; i += 3){
            triVerts[i] = data.indices[i + 2];
            triVerts[i + 1] = data.indices[i + 1];
            triVerts[i + 2] = data.indices[i];
        }
        const tempVector3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        let numProp = 3;
        const structure = [
            {
                stride: 3,
                kind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind
            }
        ];
        if (!worldMatrix) {
            structure[0].data = data.positions;
        } else {
            const positions = new Float32Array(data.positions.length);
            for(let i = 0; i < data.positions.length; i += 3){
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformCoordinatesFromFloatsToRef(data.positions[i], data.positions[i + 1], data.positions[i + 2], worldMatrix, tempVector3);
                tempVector3.toArray(positions, i);
            }
            structure[0].data = positions;
        }
        // Normals
        const sourceNormals = data.normals;
        if (sourceNormals) {
            numProp += 3;
            structure.push({
                stride: 3,
                kind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].NormalKind
            });
            if (!worldMatrix) {
                structure[1].data = sourceNormals;
            } else {
                const normals = new Float32Array(sourceNormals.length);
                for(let i = 0; i < sourceNormals.length; i += 3){
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformNormalFromFloatsToRef(sourceNormals[i], sourceNormals[i + 1], sourceNormals[i + 2], worldMatrix, tempVector3);
                    tempVector3.toArray(normals, i);
                }
                structure[1].data = normals;
            }
        }
        // UVs
        for (const kind of [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UVKind,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV2Kind,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV3Kind,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV4Kind,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV5Kind,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV6Kind
        ]){
            const sourceUV = data[kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UVKind ? "uvs" : kind];
            if (sourceUV) {
                numProp += 2;
                structure.push({
                    stride: 2,
                    kind: kind,
                    data: sourceUV
                });
            }
        }
        // Colors
        const sourceColors = data.colors;
        if (sourceColors) {
            numProp += 4;
            structure.push({
                stride: 4,
                kind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorKind,
                data: sourceColors
            });
        }
        return this._ProcessData(data.positions.length / 3, triVerts, structure, numProp, runIndex, runOriginalID);
    }
    /**
     * Create a new Constructive Solid Geometry from a vertexData
     * @param vertexData defines the vertexData to use to create the CSG
     * @returns a new CSG2 class
     */ static FromVertexData(vertexData) {
        const sourceVertices = vertexData.positions;
        const sourceIndices = vertexData.indices;
        if (!sourceVertices || !sourceIndices) {
            throw new Error("The vertexData must at least have positions and indices");
        }
        return this._Construct(vertexData, null);
    }
    /**
     * Create a new Constructive Solid Geometry from a mesh
     * @param mesh defines the mesh to use to create the CSG
     * @param ignoreWorldMatrix defines if the world matrix should be ignored
     * @returns a new CSG2 class
     */ static FromMesh(mesh, ignoreWorldMatrix = false) {
        const sourceVertices = mesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind);
        const sourceIndices = mesh.getIndices();
        const worldMatrix = mesh.computeWorldMatrix(true);
        if (!sourceVertices || !sourceIndices) {
            throw new Error("The mesh must at least have positions and indices");
        }
        // Create a triangle run for each submesh (material)
        const starts = [
            ...Array(mesh.subMeshes.length)
        ].map((_, idx)=>mesh.subMeshes[idx].indexStart);
        // Map the materials to ID.
        const sourceMaterial = mesh.material || mesh.getScene().defaultMaterial;
        const isMultiMaterial = sourceMaterial.getClassName() === "MultiMaterial";
        const originalIDs = [
            ...Array(mesh.subMeshes.length)
        ].map((_, idx)=>{
            if (isMultiMaterial) {
                return FirstID + sourceMaterial.subMaterials[mesh.subMeshes[idx].materialIndex].uniqueId;
            }
            return FirstID + sourceMaterial.uniqueId;
        });
        // List the runs in sequence.
        const indices = Array.from(starts.keys());
        indices.sort((a, b)=>starts[a] - starts[b]);
        const runIndex = new Uint32Array(indices.map((i)=>starts[i]));
        const runOriginalID = new Uint32Array(indices.map((i)=>originalIDs[i]));
        // Process
        const data = {
            positions: sourceVertices,
            indices: sourceIndices,
            normals: mesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].NormalKind),
            colors: mesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].ColorKind),
            uvs: mesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UVKind),
            uvs2: mesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV2Kind),
            uvs3: mesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV3Kind),
            uvs4: mesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV4Kind),
            uvs5: mesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV5Kind),
            uvs6: mesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexBuffer"].UV6Kind)
        };
        return this._Construct(data, ignoreWorldMatrix ? null : worldMatrix, runIndex, runOriginalID);
    }
}
function IsCSG2Ready() {
    return Manifold !== undefined;
}
async function InitializeCSG2Async(options) {
    const localOptions = {
        manifoldUrl: "https://unpkg.com/manifold-3d@3.3.0",
        ...options
    };
    if (Manifold) {
        return; // Already initialized
    }
    if (ManifoldPromise) {
        await ManifoldPromise;
        return;
    }
    if (localOptions.manifoldInstance) {
        Manifold = localOptions.manifoldInstance;
        ManifoldMesh = localOptions.manifoldMeshInstance;
    } else {
        ManifoldPromise = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$internals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_LoadScriptModuleAsync"])(`
            import Module from '${localOptions.manifoldUrl}/manifold.js';
            const wasm = await Module();
            wasm.setup();
            const {Manifold, Mesh} = wasm;
            const returnedValue =  {Manifold, Mesh};
        `);
        const result = await ManifoldPromise;
        Manifold = result.Manifold;
        ManifoldMesh = result.Mesh;
    }
    // Reserve IDs for materials (we consider that there will be no more than 65536 materials)
    FirstID = Manifold.reserveIDs(65536);
} //# sourceMappingURL=csg2.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.vertexData.functions.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "OptimizeIndices",
    ()=>OptimizeIndices
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$bitArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/bitArray.js [app-client] (ecmascript)");
;
function OptimizeIndices(indices) {
    const faces = [];
    const faceCount = indices.length / 3;
    // Step 1: Break the indices array into faces
    for(let i = 0; i < faceCount; i++){
        faces.push([
            indices[i * 3],
            indices[i * 3 + 1],
            indices[i * 3 + 2]
        ]);
    }
    // Step 2: Build a graph connecting faces sharing a vertex
    const vertexToFaceMap = new Map();
    for(let faceIndex = 0; faceIndex < faces.length; faceIndex++){
        const face = faces[faceIndex];
        for (const vertex of face){
            let face = vertexToFaceMap.get(vertex);
            if (!face) {
                vertexToFaceMap.set(vertex, face = []);
            }
            face.push(faceIndex);
        }
    }
    // Step 3: Traverse faces using DFS to ensure connected faces are close
    const visited = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$bitArray$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BitArray"](faceCount);
    const sortedFaces = [];
    // Using a stack and not a recursive version to avoid call stack overflow
    const deepFirstSearchStack = (startFaceIndex)=>{
        const stack = [
            startFaceIndex
        ];
        while(stack.length > 0){
            const currentFaceIndex = stack.pop();
            if (visited.get(currentFaceIndex)) {
                continue;
            }
            visited.set(currentFaceIndex, true);
            sortedFaces.push(faces[currentFaceIndex]);
            // Push unvisited neighbors (faces sharing a vertex) onto the stack
            for (const vertex of faces[currentFaceIndex]){
                const neighbors = vertexToFaceMap.get(vertex);
                if (!neighbors) {
                    return;
                }
                for (const neighborFaceIndex of neighbors){
                    if (!visited.get(neighborFaceIndex)) {
                        stack.push(neighborFaceIndex);
                    }
                }
            }
        }
    };
    // Start DFS from the first face
    for(let i = 0; i < faceCount; i++){
        if (!visited.get(i)) {
            deepFirstSearchStack(i);
        }
    }
    // Step 4: Flatten the sorted faces back into an array
    let index = 0;
    for (const face of sortedFaces){
        indices[index++] = face[0];
        indices[index++] = face[1];
        indices[index++] = face[2];
    }
} //# sourceMappingURL=mesh.vertexData.functions.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.vertexData.subdivide.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Subdivide",
    ()=>Subdivide
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.vertexData.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.scalar.js [app-client] (ecmascript)");
;
;
;
const PositionShift = Math.pow(10, 4);
/**
 * Rounds a number (simulate integer rounding)
 * @internal
 */ function Round(x) {
    return x + (x > 0 ? 0.5 : -0.5) << 0;
}
/**
 * Generates a hash string from a number
 * @internal
 */ function HashFromNumber(num, shift = PositionShift) {
    let roundedNumber = Round(num * shift);
    if (roundedNumber === 0) {
        roundedNumber = 0; // prevent -0
    }
    return `${roundedNumber}`;
}
/**
 * Generates a hash string from a Vector3
 * @internal
 */ function HashFromVector(v, shift = PositionShift) {
    return `${HashFromNumber(v.x, shift)},${HashFromNumber(v.y, shift)},${HashFromNumber(v.z, shift)}`;
}
/**
 * Gathers attribute names from a VertexData object
 * @internal
 */ function GatherAttributes(vertexData) {
    const desired = [
        "positions",
        "normals",
        "uvs"
    ];
    const available = Object.keys(vertexData).filter((k)=>Array.isArray(vertexData[k]));
    return Array.from(new Set([
        ...desired,
        ...available
    ]));
}
/**
 * Sets triangle data into an attribute array
 * @internal
 */ function SetTriangle(arr, index, itemSize, vec0, vec1, vec2) {
    for(let i = 0; i < itemSize; i++){
        arr[index + i] = vec0[i];
        arr[index + itemSize + i] = vec1[i];
        arr[index + 2 * itemSize + i] = vec2[i];
    }
}
/**
 * Converts indexed VertexData to a non-indexed form
 * @internal
 */ function ToNonIndexed(vertexData) {
    if (!vertexData.indices || vertexData.indices.length === 0) {
        return vertexData; // already non-indexed
    }
    const newPositions = [];
    const newNormals = [];
    const newUVs = [];
    const indices = vertexData.indices;
    const pos = vertexData.positions;
    const norm = vertexData.normals;
    const uv = vertexData.uvs;
    for(let i = 0; i < indices.length; i++){
        const idx = indices[i];
        newPositions.push(pos[3 * idx], pos[3 * idx + 1], pos[3 * idx + 2]);
        if (norm) {
            newNormals.push(norm[3 * idx], norm[3 * idx + 1], norm[3 * idx + 2]);
        }
        if (uv) {
            newUVs.push(uv[2 * idx], uv[2 * idx + 1]);
        }
    }
    const newVertexData = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexData"]();
    newVertexData.positions = newPositions;
    if (newNormals.length) {
        newVertexData.normals = newNormals;
    }
    if (newUVs.length) {
        newVertexData.uvs = newUVs;
    }
    return newVertexData;
}
/** Helper to read a Vector3 from an attribute array
 * @internal
 */ function ReadVector(destination, attribute, index, itemSize) {
    if (itemSize === 3) {
        destination.fromArray(attribute, index * 3);
        return;
    }
    // For uvs (itemSize 2), return a Vector3 with z = 0.
    destination.set(attribute[index * 2], attribute[index * 2 + 1], 0);
}
function ProcessFlatAttribute(source, vertexCount, output) {
    const v0 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    const v1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    const v2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    const m01 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    const m12 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    const m20 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    for(let i = 0; i < vertexCount; i += 3){
        const j = i * 3;
        v0.set(source[j], source[j + 1], source[j + 2]);
        v1.set(source[j + 3], source[j + 4], source[j + 5]);
        v2.set(source[j + 6], source[j + 7], source[j + 8]);
        v0.addToRef(v1, m01);
        m01.scaleInPlace(0.5);
        v1.addToRef(v2, m12);
        m12.scaleInPlace(0.5);
        v2.addToRef(v0, m20);
        m20.scaleInPlace(0.5);
        // Positions
        output.push(v0.x, v0.y, v0.z, m01.x, m01.y, m01.z, m20.x, m20.y, m20.z);
        output.push(v1.x, v1.y, v1.z, m12.x, m12.y, m12.z, m01.x, m01.y, m01.z);
        output.push(v2.x, v2.y, v2.z, m20.x, m20.y, m20.z, m12.x, m12.y, m12.z);
        output.push(m01.x, m01.y, m01.z, m12.x, m12.y, m12.z, m20.x, m20.y, m20.z);
    }
}
/**
 * Applies one iteration of flat subdivision (each triangle becomes 4).
 * @internal
 */ function Flat(vertexData) {
    const data = ToNonIndexed(vertexData);
    const positions = data.positions;
    const normals = data.normals;
    const uvs = data.uvs;
    const vertexCount = positions.length / 3;
    const newPositions = [];
    const newNormals = [];
    const newUVs = [];
    ProcessFlatAttribute(positions, vertexCount, newPositions);
    if (normals && normals.length) {
        ProcessFlatAttribute(normals, vertexCount, newNormals);
    }
    if (uvs && uvs.length) {
        for(let i = 0; i < vertexCount; i += 3){
            const j = i * 2;
            const uv0 = [
                uvs[j],
                uvs[j + 1]
            ];
            const uv1 = [
                uvs[j + 2],
                uvs[j + 3]
            ];
            const uv2 = [
                uvs[j + 4],
                uvs[j + 5]
            ];
            const uv01 = [
                (uv0[0] + uv1[0]) / 2,
                (uv0[1] + uv1[1]) / 2
            ];
            const uv12 = [
                (uv1[0] + uv2[0]) / 2,
                (uv1[1] + uv2[1]) / 2
            ];
            const uv20 = [
                (uv2[0] + uv0[0]) / 2,
                (uv2[1] + uv0[1]) / 2
            ];
            newUVs.push(...uv0, ...uv01, ...uv20);
            newUVs.push(...uv1, ...uv12, ...uv01);
            newUVs.push(...uv2, ...uv20, ...uv12);
            newUVs.push(...uv01, ...uv12, ...uv20);
        }
    }
    const newVertexCount = newPositions.length / 3;
    const newIndices = [];
    for(let i = 0; i < newVertexCount; i++){
        newIndices.push(i);
    }
    const newVertexData = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexData"]();
    newVertexData.positions = newPositions;
    if (newNormals.length) {
        newVertexData.normals = newNormals;
    }
    if (newUVs.length) {
        newVertexData.uvs = newUVs;
    }
    newVertexData.indices = newIndices;
    return newVertexData;
}
/**
 * Applies one iteration of smooth subdivision with vertex averaging.
 * This function uses the subdivideAttribute routine to adjust vertex data.
 * @internal
 */ function Smooth(vertexData, options) {
    // Convert to non-indexed and apply flat subdivision first.
    const sourceData = ToNonIndexed(vertexData);
    const flatData = Flat(sourceData);
    const attributeList = GatherAttributes(sourceData);
    const origPositions = sourceData.positions;
    const flatPositions = flatData.positions;
    const vertexCount = origPositions.length / 3;
    // Build connectivity maps from the original geometry.
    const hashToIndex = {};
    const existingNeighbors = {};
    const flatOpposites = {};
    const existingEdges = {};
    function addNeighbor(posHash, neighborHash, index) {
        if (!existingNeighbors[posHash]) {
            existingNeighbors[posHash] = {};
        }
        if (!existingNeighbors[posHash][neighborHash]) {
            existingNeighbors[posHash][neighborHash] = [];
        }
        existingNeighbors[posHash][neighborHash].push(index);
    }
    function addOpposite(posHash, index) {
        if (!flatOpposites[posHash]) {
            flatOpposites[posHash] = [];
        }
        flatOpposites[posHash].push(index);
    }
    function addEdgePoint(posHash, edgeHash) {
        if (!existingEdges[posHash]) {
            existingEdges[posHash] = new Set();
        }
        existingEdges[posHash].add(edgeHash);
    }
    const temp = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    const v0 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    const v1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    const v2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    const m01 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    const m12 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    const m20 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    // Process original positions
    for(let i = 0; i < vertexCount; i += 3){
        ReadVector(v0, origPositions, i, 3);
        ReadVector(v1, origPositions, i + 1, 3);
        ReadVector(v2, origPositions, i + 2, 3);
        const h0 = HashFromVector(v0);
        const h1 = HashFromVector(v1);
        const h2 = HashFromVector(v2);
        addNeighbor(h0, h1, i + 1);
        addNeighbor(h0, h2, i + 2);
        addNeighbor(h1, h0, i);
        addNeighbor(h1, h2, i + 2);
        addNeighbor(h2, h0, i);
        addNeighbor(h2, h1, i + 1);
        // Opposites from flat subdivision: calculate midpoints.
        v0.addToRef(v1, m01);
        m01.scaleInPlace(0.5);
        v1.addToRef(v2, m12);
        m12.scaleInPlace(0.5);
        v2.addToRef(v0, m20);
        m20.scaleInPlace(0.5);
        addOpposite(HashFromVector(m01), i + 2);
        addOpposite(HashFromVector(m12), i);
        addOpposite(HashFromVector(m20), i + 1);
        // Track edges for preserveEdges.
        addEdgePoint(h0, HashFromVector(m01));
        addEdgePoint(h0, HashFromVector(m20));
        addEdgePoint(h1, HashFromVector(m01));
        addEdgePoint(h1, HashFromVector(m12));
        addEdgePoint(h2, HashFromVector(m12));
        addEdgePoint(h2, HashFromVector(m20));
    }
    // Build map from flat positions to indices.
    for(let i = 0; i < flatPositions.length / 3; i++){
        ReadVector(temp, flatPositions, i, 3);
        const h = HashFromVector(temp);
        if (!hashToIndex[h]) {
            hashToIndex[h] = [];
        }
        hashToIndex[h].push(i);
    }
    // Prepare temporary vectors for subdivideAttribute.
    const _vertex = [
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()
    ];
    const _position = [
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()
    ];
    const _average = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    const _temp = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    // subdivideAttribute: adjusts vertex attributes using Loops averaging rules.
    function subdivideAttribute(attributeName, existingAttribute, flattenedAttribute) {
        const itemSize = attributeName === "uvs" ? 2 : 3;
        const flatVertexCount = flatPositions.length / 3;
        const floatArray = new Array(flatVertexCount * itemSize);
        let index = 0;
        for(let i = 0; i < flatVertexCount; i += 3){
            for(let v = 0; v < 3; v++){
                if (attributeName === "uvs" && !options.uvSmooth) {
                    // Simply copy UVs.
                    ReadVector(_vertex[v], flattenedAttribute, i + v, 2);
                } else if (attributeName === "normals") {
                    ReadVector(_position[v], flatPositions, i + v, 3);
                    const positionHash = HashFromVector(_position[v]);
                    const positionsArr = hashToIndex[positionHash] || [];
                    const k = positionsArr.length;
                    const beta = 0.75 / k;
                    const startWeight = 1.0 - beta * k;
                    ReadVector(_vertex[v], flattenedAttribute, i + v, 3);
                    _vertex[v].scaleInPlace(startWeight);
                    for (const positionIndex of positionsArr){
                        ReadVector(_average, flattenedAttribute, positionIndex, 3);
                        _average.scaleInPlace(beta);
                        _vertex[v].addInPlace(_average);
                    }
                } else {
                    // 'positions', 'colors', etc.
                    ReadVector(_vertex[v], flattenedAttribute, i + v, itemSize);
                    ReadVector(_position[v], flatPositions, i + v, 3);
                    const positionHash = HashFromVector(_position[v]);
                    const neighbors = existingNeighbors[positionHash];
                    const opposites = flatOpposites[positionHash];
                    if (neighbors) {
                        if (options.preserveEdges) {
                            const edgeSet = existingEdges[positionHash];
                            let hasPair = true;
                            edgeSet.forEach((edgeHash)=>{
                                if (flatOpposites[edgeHash] && flatOpposites[edgeHash].length % 2 !== 0) {
                                    hasPair = false;
                                }
                            });
                            if (!hasPair) {
                                continue;
                            }
                        }
                        const neighborKeys = Object.keys(neighbors);
                        const k = neighborKeys.length;
                        const beta = 1 / k * (5 / 8 - Math.pow(3 / 8 + 1 / 4 * Math.cos(2 * Math.PI / k), 2));
                        const heavy = 1 / k / k;
                        const weight = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scalar"].Lerp(heavy, beta, options.weight);
                        const startWeight = 1.0 - weight * k;
                        _vertex[v].scaleInPlace(startWeight);
                        for(const neighborHash in neighbors){
                            const neighborIndices = neighbors[neighborHash];
                            _average.set(0, 0, 0);
                            for (const neighborIndex of neighborIndices){
                                ReadVector(_temp, existingAttribute, neighborIndex, itemSize);
                                _average.addInPlace(_temp);
                            }
                            _average.scaleInPlace(1 / neighborIndices.length);
                            _average.scaleInPlace(weight);
                            _vertex[v].addInPlace(_average);
                        }
                    } else if (opposites && opposites.length === 2) {
                        const k = opposites.length;
                        const beta = 0.125; // 1/8
                        const startWeight = 1.0 - beta * k;
                        _vertex[v].scaleInPlace(startWeight);
                        for (const oppositeIndex of opposites){
                            ReadVector(_average, existingAttribute, oppositeIndex, itemSize);
                            _average.scaleInPlace(beta);
                            _vertex[v].addInPlace(_average);
                        }
                    }
                }
            }
            // Write out new triangle vertices.
            SetTriangle(floatArray, index, itemSize, _vertex[0].asArray(), _vertex[1].asArray(), _vertex[2].asArray());
            index += itemSize * 3;
        }
        return floatArray;
    }
    // Build new attributes for the smoothed geometry.
    const smoothData = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexData"]();
    for (const attributeName of attributeList){
        if (attributeName === "indices") {
            continue;
        }
        const existingAttribute = sourceData[attributeName];
        const flattenedAttribute = flatData[attributeName];
        if (!existingAttribute || !flattenedAttribute) {
            continue;
        }
        const newArray = subdivideAttribute(attributeName, existingAttribute, flattenedAttribute);
        smoothData[attributeName] = newArray;
    }
    // Rebuild indices sequentially.
    const newPositions = smoothData.positions;
    const newIndices = [];
    for(let i = 0; i < newPositions.length / 3; i++){
        newIndices.push(i);
    }
    smoothData.indices = newIndices;
    return smoothData;
}
function Subdivide(vertexData, level, options) {
    options = {
        flatOnly: false,
        uvSmooth: false,
        preserveEdges: false,
        weight: 1,
        ...options
    };
    if (!vertexData.positions || vertexData.positions.length === 0 || level <= 0) {
        return vertexData;
    }
    // Clone the input
    let modified = vertexData.clone();
    for(let i = 0; i < level; i++){
        if (options.flatOnly) {
            modified = Flat(modified);
        } else {
            modified = Smooth(modified, options);
        }
    }
    return modified;
} //# sourceMappingURL=mesh.vertexData.subdivide.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/GaussianSplatting/gaussianSplattingMesh.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GaussianSplattingMesh",
    ()=>GaussianSplattingMesh
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$subMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/subMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.vertexData.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/logger.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$GaussianSplatting$2f$gaussianSplattingMaterial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/GaussianSplatting/gaussianSplattingMaterial.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$rawTexture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/Textures/rawTexture.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tools.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$thinInstanceMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/thinInstanceMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/textureTools.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.scalar.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$coroutine$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/coroutine.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engineStore$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Engines/engineStore.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
// @internal
const UnpackUnorm = (value, bits)=>{
    const t = (1 << bits) - 1;
    return (value & t) / t;
};
// @internal
const Unpack111011 = (value, result)=>{
    result.x = UnpackUnorm(value >>> 21, 11);
    result.y = UnpackUnorm(value >>> 11, 10);
    result.z = UnpackUnorm(value, 11);
};
// @internal
const Unpack8888 = (value, result)=>{
    result[0] = UnpackUnorm(value >>> 24, 8) * 255;
    result[1] = UnpackUnorm(value >>> 16, 8) * 255;
    result[2] = UnpackUnorm(value >>> 8, 8) * 255;
    result[3] = UnpackUnorm(value, 8) * 255;
};
// @internal
// unpack quaternion with 2,10,10,10 format (largest element, 3x10bit element)
const UnpackRot = (value, result)=>{
    const norm = 1.0 / (Math.sqrt(2) * 0.5);
    const a = (UnpackUnorm(value >>> 20, 10) - 0.5) * norm;
    const b = (UnpackUnorm(value >>> 10, 10) - 0.5) * norm;
    const c = (UnpackUnorm(value, 10) - 0.5) * norm;
    const m = Math.sqrt(1.0 - (a * a + b * b + c * c));
    switch(value >>> 30){
        case 0:
            result.set(m, a, b, c);
            break;
        case 1:
            result.set(a, m, b, c);
            break;
        case 2:
            result.set(a, b, m, c);
            break;
        case 3:
            result.set(a, b, c, m);
            break;
    }
};
/**
 * Representation of the types
 */ var PLYType;
(function(PLYType) {
    PLYType[PLYType["FLOAT"] = 0] = "FLOAT";
    PLYType[PLYType["INT"] = 1] = "INT";
    PLYType[PLYType["UINT"] = 2] = "UINT";
    PLYType[PLYType["DOUBLE"] = 3] = "DOUBLE";
    PLYType[PLYType["UCHAR"] = 4] = "UCHAR";
    PLYType[PLYType["UNDEFINED"] = 5] = "UNDEFINED";
})(PLYType || (PLYType = {}));
/**
 * Usage types of the PLY values
 */ var PLYValue;
(function(PLYValue) {
    PLYValue[PLYValue["MIN_X"] = 0] = "MIN_X";
    PLYValue[PLYValue["MIN_Y"] = 1] = "MIN_Y";
    PLYValue[PLYValue["MIN_Z"] = 2] = "MIN_Z";
    PLYValue[PLYValue["MAX_X"] = 3] = "MAX_X";
    PLYValue[PLYValue["MAX_Y"] = 4] = "MAX_Y";
    PLYValue[PLYValue["MAX_Z"] = 5] = "MAX_Z";
    PLYValue[PLYValue["MIN_SCALE_X"] = 6] = "MIN_SCALE_X";
    PLYValue[PLYValue["MIN_SCALE_Y"] = 7] = "MIN_SCALE_Y";
    PLYValue[PLYValue["MIN_SCALE_Z"] = 8] = "MIN_SCALE_Z";
    PLYValue[PLYValue["MAX_SCALE_X"] = 9] = "MAX_SCALE_X";
    PLYValue[PLYValue["MAX_SCALE_Y"] = 10] = "MAX_SCALE_Y";
    PLYValue[PLYValue["MAX_SCALE_Z"] = 11] = "MAX_SCALE_Z";
    PLYValue[PLYValue["PACKED_POSITION"] = 12] = "PACKED_POSITION";
    PLYValue[PLYValue["PACKED_ROTATION"] = 13] = "PACKED_ROTATION";
    PLYValue[PLYValue["PACKED_SCALE"] = 14] = "PACKED_SCALE";
    PLYValue[PLYValue["PACKED_COLOR"] = 15] = "PACKED_COLOR";
    PLYValue[PLYValue["X"] = 16] = "X";
    PLYValue[PLYValue["Y"] = 17] = "Y";
    PLYValue[PLYValue["Z"] = 18] = "Z";
    PLYValue[PLYValue["SCALE_0"] = 19] = "SCALE_0";
    PLYValue[PLYValue["SCALE_1"] = 20] = "SCALE_1";
    PLYValue[PLYValue["SCALE_2"] = 21] = "SCALE_2";
    PLYValue[PLYValue["DIFFUSE_RED"] = 22] = "DIFFUSE_RED";
    PLYValue[PLYValue["DIFFUSE_GREEN"] = 23] = "DIFFUSE_GREEN";
    PLYValue[PLYValue["DIFFUSE_BLUE"] = 24] = "DIFFUSE_BLUE";
    PLYValue[PLYValue["OPACITY"] = 25] = "OPACITY";
    PLYValue[PLYValue["F_DC_0"] = 26] = "F_DC_0";
    PLYValue[PLYValue["F_DC_1"] = 27] = "F_DC_1";
    PLYValue[PLYValue["F_DC_2"] = 28] = "F_DC_2";
    PLYValue[PLYValue["F_DC_3"] = 29] = "F_DC_3";
    PLYValue[PLYValue["ROT_0"] = 30] = "ROT_0";
    PLYValue[PLYValue["ROT_1"] = 31] = "ROT_1";
    PLYValue[PLYValue["ROT_2"] = 32] = "ROT_2";
    PLYValue[PLYValue["ROT_3"] = 33] = "ROT_3";
    PLYValue[PLYValue["MIN_COLOR_R"] = 34] = "MIN_COLOR_R";
    PLYValue[PLYValue["MIN_COLOR_G"] = 35] = "MIN_COLOR_G";
    PLYValue[PLYValue["MIN_COLOR_B"] = 36] = "MIN_COLOR_B";
    PLYValue[PLYValue["MAX_COLOR_R"] = 37] = "MAX_COLOR_R";
    PLYValue[PLYValue["MAX_COLOR_G"] = 38] = "MAX_COLOR_G";
    PLYValue[PLYValue["MAX_COLOR_B"] = 39] = "MAX_COLOR_B";
    PLYValue[PLYValue["SH_0"] = 40] = "SH_0";
    PLYValue[PLYValue["SH_1"] = 41] = "SH_1";
    PLYValue[PLYValue["SH_2"] = 42] = "SH_2";
    PLYValue[PLYValue["SH_3"] = 43] = "SH_3";
    PLYValue[PLYValue["SH_4"] = 44] = "SH_4";
    PLYValue[PLYValue["SH_5"] = 45] = "SH_5";
    PLYValue[PLYValue["SH_6"] = 46] = "SH_6";
    PLYValue[PLYValue["SH_7"] = 47] = "SH_7";
    PLYValue[PLYValue["SH_8"] = 48] = "SH_8";
    PLYValue[PLYValue["SH_9"] = 49] = "SH_9";
    PLYValue[PLYValue["SH_10"] = 50] = "SH_10";
    PLYValue[PLYValue["SH_11"] = 51] = "SH_11";
    PLYValue[PLYValue["SH_12"] = 52] = "SH_12";
    PLYValue[PLYValue["SH_13"] = 53] = "SH_13";
    PLYValue[PLYValue["SH_14"] = 54] = "SH_14";
    PLYValue[PLYValue["SH_15"] = 55] = "SH_15";
    PLYValue[PLYValue["SH_16"] = 56] = "SH_16";
    PLYValue[PLYValue["SH_17"] = 57] = "SH_17";
    PLYValue[PLYValue["SH_18"] = 58] = "SH_18";
    PLYValue[PLYValue["SH_19"] = 59] = "SH_19";
    PLYValue[PLYValue["SH_20"] = 60] = "SH_20";
    PLYValue[PLYValue["SH_21"] = 61] = "SH_21";
    PLYValue[PLYValue["SH_22"] = 62] = "SH_22";
    PLYValue[PLYValue["SH_23"] = 63] = "SH_23";
    PLYValue[PLYValue["SH_24"] = 64] = "SH_24";
    PLYValue[PLYValue["SH_25"] = 65] = "SH_25";
    PLYValue[PLYValue["SH_26"] = 66] = "SH_26";
    PLYValue[PLYValue["SH_27"] = 67] = "SH_27";
    PLYValue[PLYValue["SH_28"] = 68] = "SH_28";
    PLYValue[PLYValue["SH_29"] = 69] = "SH_29";
    PLYValue[PLYValue["SH_30"] = 70] = "SH_30";
    PLYValue[PLYValue["SH_31"] = 71] = "SH_31";
    PLYValue[PLYValue["SH_32"] = 72] = "SH_32";
    PLYValue[PLYValue["SH_33"] = 73] = "SH_33";
    PLYValue[PLYValue["SH_34"] = 74] = "SH_34";
    PLYValue[PLYValue["SH_35"] = 75] = "SH_35";
    PLYValue[PLYValue["SH_36"] = 76] = "SH_36";
    PLYValue[PLYValue["SH_37"] = 77] = "SH_37";
    PLYValue[PLYValue["SH_38"] = 78] = "SH_38";
    PLYValue[PLYValue["SH_39"] = 79] = "SH_39";
    PLYValue[PLYValue["SH_40"] = 80] = "SH_40";
    PLYValue[PLYValue["SH_41"] = 81] = "SH_41";
    PLYValue[PLYValue["SH_42"] = 82] = "SH_42";
    PLYValue[PLYValue["SH_43"] = 83] = "SH_43";
    PLYValue[PLYValue["SH_44"] = 84] = "SH_44";
    PLYValue[PLYValue["UNDEFINED"] = 85] = "UNDEFINED";
})(PLYValue || (PLYValue = {}));
class GaussianSplattingMesh extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"] {
    /**
     * View direction factor used to compute the SH view direction in the shader.
     */ get viewDirectionFactor() {
        return this._viewDirectionFactor;
    }
    /**
     * SH degree. 0 = no sh (default). 1 = 3 parameters. 2 = 8 parameters. 3 = 15 parameters.
     */ get shDegree() {
        return this._shDegree;
    }
    /**
     * Number of splats in the mesh
     */ get splatCount() {
        return this._splatIndex?.length;
    }
    /**
     * returns the splats data array buffer that contains in order : postions (3 floats), size (3 floats), color (4 bytes), orientation quaternion (4 bytes)
     */ get splatsData() {
        return this._splatsData;
    }
    /**
     * Gets the covariancesA texture
     */ get covariancesATexture() {
        return this._covariancesATexture;
    }
    /**
     * Gets the covariancesB texture
     */ get covariancesBTexture() {
        return this._covariancesBTexture;
    }
    /**
     * Gets the centers texture
     */ get centersTexture() {
        return this._centersTexture;
    }
    /**
     * Gets the colors texture
     */ get colorsTexture() {
        return this._colorsTexture;
    }
    /**
     * Gets the SH textures
     */ get shTextures() {
        return this._shTextures;
    }
    /**
     * Gets the kernel size
     * Documentation and mathematical explanations here:
     * https://github.com/graphdeco-inria/gaussian-splatting/issues/294#issuecomment-1772688093
     * https://github.com/autonomousvision/mip-splatting/issues/18#issuecomment-1929388931
     */ get kernelSize() {
        return this._material instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$GaussianSplatting$2f$gaussianSplattingMaterial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GaussianSplattingMaterial"] ? this._material.kernelSize : 0;
    }
    /**
     * Get the compensation state
     */ get compensation() {
        return this._material instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$GaussianSplatting$2f$gaussianSplattingMaterial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GaussianSplattingMaterial"] ? this._material.compensation : false;
    }
    /**
     * set rendering material
     */ set material(value) {
        this._material = value;
        this._material.backFaceCulling = true;
        this._material.cullBackFaces = false;
        value.resetDrawCache();
    }
    /**
     * get rendering material
     */ get material() {
        return this._material;
    }
    /**
     * Creates a new gaussian splatting mesh
     * @param name defines the name of the mesh
     * @param url defines the url to load from (optional)
     * @param scene defines the hosting scene (optional)
     * @param keepInRam keep datas in ram for editing purpose
     */ constructor(name, url = null, scene = null, keepInRam = false){
        super(name, scene);
        this._vertexCount = 0;
        this._worker = null;
        this._frameIdLastUpdate = -1;
        this._modelViewMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].Identity();
        this._canPostToWorker = true;
        this._readyToDisplay = false;
        this._covariancesATexture = null;
        this._covariancesBTexture = null;
        this._centersTexture = null;
        this._colorsTexture = null;
        this._splatPositions = null;
        this._splatIndex = null;
        this._shTextures = null;
        this._splatsData = null;
        this._sh = null;
        this._keepInRam = false;
        this._delayedTextureUpdate = null;
        this._oldDirection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this._useRGBACovariants = false;
        this._material = null;
        this._tmpCovariances = [
            0,
            0,
            0,
            0,
            0,
            0
        ];
        this._sortIsDirty = false;
        this._shDegree = 0;
        this._viewDirectionFactor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](1, 1, -1);
        const vertexData = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexData"]();
        const originPositions = [
            -2,
            -2,
            0,
            2,
            -2,
            0,
            2,
            2,
            0,
            -2,
            2,
            0
        ];
        const originIndices = [
            0,
            1,
            2,
            0,
            2,
            3
        ];
        const positions = [];
        const indices = [];
        const batchSize = 16; // 16 splats per instance
        for(let i = 0; i < batchSize; i++){
            for(let j = 0; j < 12; j++){
                if (j == 2 || j == 5 || j == 8 || j == 11) {
                    positions.push(i); // local splat index
                } else {
                    positions.push(originPositions[j]);
                }
            }
            indices.push(originIndices.map((v)=>v + i * 4));
        }
        vertexData.positions = positions;
        vertexData.indices = indices.flat();
        vertexData.applyToMesh(this);
        this.subMeshes = [];
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$subMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SubMesh"](0, 0, 4 * batchSize, 0, 6 * batchSize, this);
        this.setEnabled(false);
        // webGL2 and webGPU support for RG texture with float16 is fine. not webGL1
        this._useRGBACovariants = !this.getEngine().isWebGPU && this.getEngine().version === 1.0;
        this._keepInRam = keepInRam;
        if (url) {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            this.loadFileAsync(url);
        }
        this._material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$GaussianSplatting$2f$gaussianSplattingMaterial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GaussianSplattingMaterial"](this.name + "_material", this._scene);
    }
    /**
     * Returns the class name
     * @returns "GaussianSplattingMesh"
     */ getClassName() {
        return "GaussianSplattingMesh";
    }
    /**
     * Returns the total number of vertices (splats) within the mesh
     * @returns the total number of vertices
     */ getTotalVertices() {
        return this._vertexCount;
    }
    /**
     * Is this node ready to be used/rendered
     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)
     * @returns true when ready
     */ isReady(completeCheck = false) {
        if (!super.isReady(completeCheck, true)) {
            return false;
        }
        if (!this._readyToDisplay) {
            // mesh is ready when worker has done at least 1 sorting
            this._postToWorker(true);
            return false;
        }
        return true;
    }
    /** @internal */ _postToWorker(forced = false) {
        const frameId = this.getScene().getFrameId();
        if ((forced || frameId !== this._frameIdLastUpdate) && this._worker && this._scene.activeCamera && this._canPostToWorker) {
            const cameraMatrix = this._scene.activeCamera.getViewMatrix();
            this.getWorldMatrix().multiplyToRef(cameraMatrix, this._modelViewMatrix);
            cameraMatrix.invertToRef(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[0]);
            this.getWorldMatrix().multiplyToRef(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[0], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[1]);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].TransformNormalToRef(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Forward(this._scene.useRightHandedSystem), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[1], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[2]);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[2].normalize();
            const dot = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"].Dot(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[2], this._oldDirection);
            if (forced || Math.abs(dot - 1) >= 0.01) {
                this._oldDirection.copyFrom(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[2]);
                this._frameIdLastUpdate = frameId;
                this._canPostToWorker = false;
                this._worker.postMessage({
                    view: this._modelViewMatrix.m,
                    depthMix: this._depthMix,
                    useRightHandedSystem: this._scene.useRightHandedSystem
                }, [
                    this._depthMix.buffer
                ]);
            }
        }
    }
    /**
     * Triggers the draw call for the mesh. Usually, you don't need to call this method by your own because the mesh rendering is handled by the scene rendering manager
     * @param subMesh defines the subMesh to render
     * @param enableAlphaMode defines if alpha mode can be changed
     * @param effectiveMeshReplacement defines an optional mesh used to provide info for the rendering
     * @returns the current mesh
     */ render(subMesh, enableAlphaMode, effectiveMeshReplacement) {
        this._postToWorker();
        return super.render(subMesh, enableAlphaMode, effectiveMeshReplacement);
    }
    static _TypeNameToEnum(name) {
        switch(name){
            case "float":
                return 0 /* PLYType.FLOAT */ ;
            case "int":
                return 1 /* PLYType.INT */ ;
                //TURBOPACK unreachable
                ;
            case "uint":
                return 2 /* PLYType.UINT */ ;
            case "double":
                return 3 /* PLYType.DOUBLE */ ;
            case "uchar":
                return 4 /* PLYType.UCHAR */ ;
        }
        return 5 /* PLYType.UNDEFINED */ ;
    }
    static _ValueNameToEnum(name) {
        switch(name){
            case "min_x":
                return 0 /* PLYValue.MIN_X */ ;
            case "min_y":
                return 1 /* PLYValue.MIN_Y */ ;
            case "min_z":
                return 2 /* PLYValue.MIN_Z */ ;
            case "max_x":
                return 3 /* PLYValue.MAX_X */ ;
            case "max_y":
                return 4 /* PLYValue.MAX_Y */ ;
            case "max_z":
                return 5 /* PLYValue.MAX_Z */ ;
            case "min_scale_x":
                return 6 /* PLYValue.MIN_SCALE_X */ ;
            case "min_scale_y":
                return 7 /* PLYValue.MIN_SCALE_Y */ ;
            case "min_scale_z":
                return 8 /* PLYValue.MIN_SCALE_Z */ ;
            case "max_scale_x":
                return 9 /* PLYValue.MAX_SCALE_X */ ;
            case "max_scale_y":
                return 10 /* PLYValue.MAX_SCALE_Y */ ;
            case "max_scale_z":
                return 11 /* PLYValue.MAX_SCALE_Z */ ;
            case "packed_position":
                return 12 /* PLYValue.PACKED_POSITION */ ;
            case "packed_rotation":
                return 13 /* PLYValue.PACKED_ROTATION */ ;
            case "packed_scale":
                return 14 /* PLYValue.PACKED_SCALE */ ;
            case "packed_color":
                return 15 /* PLYValue.PACKED_COLOR */ ;
            case "x":
                return 16 /* PLYValue.X */ ;
            case "y":
                return 17 /* PLYValue.Y */ ;
            case "z":
                return 18 /* PLYValue.Z */ ;
            case "scale_0":
                return 19 /* PLYValue.SCALE_0 */ ;
            case "scale_1":
                return 20 /* PLYValue.SCALE_1 */ ;
            case "scale_2":
                return 21 /* PLYValue.SCALE_2 */ ;
            case "diffuse_red":
            case "red":
                return 22 /* PLYValue.DIFFUSE_RED */ ;
            case "diffuse_green":
            case "green":
                return 23 /* PLYValue.DIFFUSE_GREEN */ ;
            case "diffuse_blue":
            case "blue":
                return 24 /* PLYValue.DIFFUSE_BLUE */ ;
            case "f_dc_0":
                return 26 /* PLYValue.F_DC_0 */ ;
            case "f_dc_1":
                return 27 /* PLYValue.F_DC_1 */ ;
            case "f_dc_2":
                return 28 /* PLYValue.F_DC_2 */ ;
            case "f_dc_3":
                return 29 /* PLYValue.F_DC_3 */ ;
            case "opacity":
                return 25 /* PLYValue.OPACITY */ ;
            case "rot_0":
                return 30 /* PLYValue.ROT_0 */ ;
            case "rot_1":
                return 31 /* PLYValue.ROT_1 */ ;
            case "rot_2":
                return 32 /* PLYValue.ROT_2 */ ;
            case "rot_3":
                return 33 /* PLYValue.ROT_3 */ ;
            case "min_r":
                return 34 /* PLYValue.MIN_COLOR_R */ ;
            case "min_g":
                return 35 /* PLYValue.MIN_COLOR_G */ ;
            case "min_b":
                return 36 /* PLYValue.MIN_COLOR_B */ ;
            case "max_r":
                return 37 /* PLYValue.MAX_COLOR_R */ ;
            case "max_g":
                return 38 /* PLYValue.MAX_COLOR_G */ ;
            case "max_b":
                return 39 /* PLYValue.MAX_COLOR_B */ ;
            case "f_rest_0":
                return 40 /* PLYValue.SH_0 */ ;
            case "f_rest_1":
                return 41 /* PLYValue.SH_1 */ ;
            case "f_rest_2":
                return 42 /* PLYValue.SH_2 */ ;
            case "f_rest_3":
                return 43 /* PLYValue.SH_3 */ ;
            case "f_rest_4":
                return 44 /* PLYValue.SH_4 */ ;
            case "f_rest_5":
                return 45 /* PLYValue.SH_5 */ ;
            case "f_rest_6":
                return 46 /* PLYValue.SH_6 */ ;
            case "f_rest_7":
                return 47 /* PLYValue.SH_7 */ ;
            case "f_rest_8":
                return 48 /* PLYValue.SH_8 */ ;
            case "f_rest_9":
                return 49 /* PLYValue.SH_9 */ ;
            case "f_rest_10":
                return 50 /* PLYValue.SH_10 */ ;
            case "f_rest_11":
                return 51 /* PLYValue.SH_11 */ ;
            case "f_rest_12":
                return 52 /* PLYValue.SH_12 */ ;
            case "f_rest_13":
                return 53 /* PLYValue.SH_13 */ ;
            case "f_rest_14":
                return 54 /* PLYValue.SH_14 */ ;
            case "f_rest_15":
                return 55 /* PLYValue.SH_15 */ ;
            case "f_rest_16":
                return 56 /* PLYValue.SH_16 */ ;
            case "f_rest_17":
                return 57 /* PLYValue.SH_17 */ ;
            case "f_rest_18":
                return 58 /* PLYValue.SH_18 */ ;
            case "f_rest_19":
                return 59 /* PLYValue.SH_19 */ ;
            case "f_rest_20":
                return 60 /* PLYValue.SH_20 */ ;
            case "f_rest_21":
                return 61 /* PLYValue.SH_21 */ ;
            case "f_rest_22":
                return 62 /* PLYValue.SH_22 */ ;
            case "f_rest_23":
                return 63 /* PLYValue.SH_23 */ ;
            case "f_rest_24":
                return 64 /* PLYValue.SH_24 */ ;
            case "f_rest_25":
                return 65 /* PLYValue.SH_25 */ ;
            case "f_rest_26":
                return 66 /* PLYValue.SH_26 */ ;
            case "f_rest_27":
                return 67 /* PLYValue.SH_27 */ ;
            case "f_rest_28":
                return 68 /* PLYValue.SH_28 */ ;
            case "f_rest_29":
                return 69 /* PLYValue.SH_29 */ ;
            case "f_rest_30":
                return 70 /* PLYValue.SH_30 */ ;
            case "f_rest_31":
                return 71 /* PLYValue.SH_31 */ ;
            case "f_rest_32":
                return 72 /* PLYValue.SH_32 */ ;
            case "f_rest_33":
                return 73 /* PLYValue.SH_33 */ ;
            case "f_rest_34":
                return 74 /* PLYValue.SH_34 */ ;
            case "f_rest_35":
                return 75 /* PLYValue.SH_35 */ ;
            case "f_rest_36":
                return 76 /* PLYValue.SH_36 */ ;
            case "f_rest_37":
                return 77 /* PLYValue.SH_37 */ ;
            case "f_rest_38":
                return 78 /* PLYValue.SH_38 */ ;
            case "f_rest_39":
                return 79 /* PLYValue.SH_39 */ ;
            case "f_rest_40":
                return 80 /* PLYValue.SH_40 */ ;
            case "f_rest_41":
                return 81 /* PLYValue.SH_41 */ ;
            case "f_rest_42":
                return 82 /* PLYValue.SH_42 */ ;
            case "f_rest_43":
                return 83 /* PLYValue.SH_43 */ ;
            case "f_rest_44":
                return 84 /* PLYValue.SH_44 */ ;
        }
        return 85 /* PLYValue.UNDEFINED */ ;
    }
    /**
     * Parse a PLY file header and returns metas infos on splats and chunks
     * @param data the loaded buffer
     * @returns a PLYHeader
     */ static ParseHeader(data) {
        const ubuf = new Uint8Array(data);
        const header = new TextDecoder().decode(ubuf.slice(0, 1024 * 10));
        const headerEnd = "end_header\n";
        const headerEndIndex = header.indexOf(headerEnd);
        if (headerEndIndex < 0 || !header) {
            // standard splat
            return null;
        }
        const vertexCount = parseInt(/element vertex (\d+)\n/.exec(header)[1]);
        const chunkElement = /element chunk (\d+)\n/.exec(header);
        let chunkCount = 0;
        if (chunkElement) {
            chunkCount = parseInt(chunkElement[1]);
        }
        let rowVertexOffset = 0;
        let rowChunkOffset = 0;
        const offsets = {
            double: 8,
            int: 4,
            uint: 4,
            float: 4,
            short: 2,
            ushort: 2,
            uchar: 1,
            list: 0
        };
        let ElementMode;
        (function(ElementMode) {
            ElementMode[ElementMode["Vertex"] = 0] = "Vertex";
            ElementMode[ElementMode["Chunk"] = 1] = "Chunk";
            ElementMode[ElementMode["SH"] = 2] = "SH";
        })(ElementMode || (ElementMode = {}));
        let chunkMode = 1 /* ElementMode.Chunk */ ;
        const vertexProperties = [];
        const chunkProperties = [];
        const filtered = header.slice(0, headerEndIndex).split("\n");
        let shDegree = 0;
        for (const prop of filtered){
            if (prop.startsWith("property ")) {
                const [, typeName, name] = prop.split(" ");
                const value = GaussianSplattingMesh._ValueNameToEnum(name);
                if (value != 85 /* PLYValue.UNDEFINED */ ) {
                    // SH degree 1,2 or 3 for 9, 24 or 45 values
                    if (value >= 84 /* PLYValue.SH_44 */ ) {
                        shDegree = 3;
                    } else if (value >= 64 /* PLYValue.SH_24 */ ) {
                        shDegree = 2;
                    } else if (value >= 48 /* PLYValue.SH_8 */ ) {
                        shDegree = 1;
                    }
                }
                const type = GaussianSplattingMesh._TypeNameToEnum(typeName);
                if (chunkMode == 1 /* ElementMode.Chunk */ ) {
                    chunkProperties.push({
                        value,
                        type,
                        offset: rowChunkOffset
                    });
                    rowChunkOffset += offsets[typeName];
                } else if (chunkMode == 0 /* ElementMode.Vertex */ ) {
                    vertexProperties.push({
                        value,
                        type,
                        offset: rowVertexOffset
                    });
                    rowVertexOffset += offsets[typeName];
                } else if (chunkMode == 2 /* ElementMode.SH */ ) {
                    // SH doesn't count for vertex row size but its properties are used to retrieve SH
                    vertexProperties.push({
                        value,
                        type,
                        offset: rowVertexOffset
                    });
                }
                if (!offsets[typeName]) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].Warn(`Unsupported property type: ${typeName}.`);
                }
            } else if (prop.startsWith("element ")) {
                const [, type] = prop.split(" ");
                if (type == "chunk") {
                    chunkMode = 1 /* ElementMode.Chunk */ ;
                } else if (type == "vertex") {
                    chunkMode = 0 /* ElementMode.Vertex */ ;
                } else if (type == "sh") {
                    chunkMode = 2 /* ElementMode.SH */ ;
                }
            }
        }
        const dataView = new DataView(data, headerEndIndex + headerEnd.length);
        const buffer = new ArrayBuffer(GaussianSplattingMesh._RowOutputLength * vertexCount);
        let shBuffer = null;
        let shCoefficientCount = 0;
        if (shDegree) {
            const shVectorCount = (shDegree + 1) * (shDegree + 1) - 1;
            shCoefficientCount = shVectorCount * 3;
            shBuffer = new ArrayBuffer(shCoefficientCount * vertexCount);
        }
        return {
            vertexCount: vertexCount,
            chunkCount: chunkCount,
            rowVertexLength: rowVertexOffset,
            rowChunkLength: rowChunkOffset,
            vertexProperties: vertexProperties,
            chunkProperties: chunkProperties,
            dataView: dataView,
            buffer: buffer,
            shDegree: shDegree,
            shCoefficientCount: shCoefficientCount,
            shBuffer: shBuffer
        };
    }
    static _GetCompressedChunks(header, offset) {
        if (!header.chunkCount) {
            return null;
        }
        const dataView = header.dataView;
        const compressedChunks = new Array(header.chunkCount);
        for(let i = 0; i < header.chunkCount; i++){
            const currentChunk = {
                min: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
                max: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
                minScale: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
                maxScale: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](),
                minColor: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 0, 0),
                maxColor: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](1, 1, 1)
            };
            compressedChunks[i] = currentChunk;
            for(let propertyIndex = 0; propertyIndex < header.chunkProperties.length; propertyIndex++){
                const property = header.chunkProperties[propertyIndex];
                let value;
                switch(property.type){
                    case 0 /* PLYType.FLOAT */ :
                        value = dataView.getFloat32(property.offset + offset.value, true);
                        break;
                    default:
                        continue;
                }
                switch(property.value){
                    case 0 /* PLYValue.MIN_X */ :
                        currentChunk.min.x = value;
                        break;
                    case 1 /* PLYValue.MIN_Y */ :
                        currentChunk.min.y = value;
                        break;
                    case 2 /* PLYValue.MIN_Z */ :
                        currentChunk.min.z = value;
                        break;
                    case 3 /* PLYValue.MAX_X */ :
                        currentChunk.max.x = value;
                        break;
                    case 4 /* PLYValue.MAX_Y */ :
                        currentChunk.max.y = value;
                        break;
                    case 5 /* PLYValue.MAX_Z */ :
                        currentChunk.max.z = value;
                        break;
                    case 6 /* PLYValue.MIN_SCALE_X */ :
                        currentChunk.minScale.x = value;
                        break;
                    case 7 /* PLYValue.MIN_SCALE_Y */ :
                        currentChunk.minScale.y = value;
                        break;
                    case 8 /* PLYValue.MIN_SCALE_Z */ :
                        currentChunk.minScale.z = value;
                        break;
                    case 9 /* PLYValue.MAX_SCALE_X */ :
                        currentChunk.maxScale.x = value;
                        break;
                    case 10 /* PLYValue.MAX_SCALE_Y */ :
                        currentChunk.maxScale.y = value;
                        break;
                    case 11 /* PLYValue.MAX_SCALE_Z */ :
                        currentChunk.maxScale.z = value;
                        break;
                    case 34 /* PLYValue.MIN_COLOR_R */ :
                        currentChunk.minColor.x = value;
                        break;
                    case 35 /* PLYValue.MIN_COLOR_G */ :
                        currentChunk.minColor.y = value;
                        break;
                    case 36 /* PLYValue.MIN_COLOR_B */ :
                        currentChunk.minColor.z = value;
                        break;
                    case 37 /* PLYValue.MAX_COLOR_R */ :
                        currentChunk.maxColor.x = value;
                        break;
                    case 38 /* PLYValue.MAX_COLOR_G */ :
                        currentChunk.maxColor.y = value;
                        break;
                    case 39 /* PLYValue.MAX_COLOR_B */ :
                        currentChunk.maxColor.z = value;
                        break;
                }
            }
            offset.value += header.rowChunkLength;
        }
        return compressedChunks;
    }
    static _GetSplat(header, index, compressedChunks, offset) {
        const q = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Quaternion[0];
        const temp3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[0];
        const rowOutputLength = GaussianSplattingMesh._RowOutputLength;
        const buffer = header.buffer;
        const dataView = header.dataView;
        const position = new Float32Array(buffer, index * rowOutputLength, 3);
        const scale = new Float32Array(buffer, index * rowOutputLength + 12, 3);
        const rgba = new Uint8ClampedArray(buffer, index * rowOutputLength + 24, 4);
        const rot = new Uint8ClampedArray(buffer, index * rowOutputLength + 28, 4);
        let sh = null;
        if (header.shBuffer) {
            sh = new Uint8ClampedArray(header.shBuffer, index * header.shCoefficientCount, header.shCoefficientCount);
        }
        const chunkIndex = index >> 8;
        let r0 = 255;
        let r1 = 0;
        let r2 = 0;
        let r3 = 0;
        const plySH = [];
        for(let propertyIndex = 0; propertyIndex < header.vertexProperties.length; propertyIndex++){
            const property = header.vertexProperties[propertyIndex];
            let value;
            switch(property.type){
                case 0 /* PLYType.FLOAT */ :
                    value = dataView.getFloat32(offset.value + property.offset, true);
                    break;
                case 1 /* PLYType.INT */ :
                    value = dataView.getInt32(offset.value + property.offset, true);
                    break;
                case 2 /* PLYType.UINT */ :
                    value = dataView.getUint32(offset.value + property.offset, true);
                    break;
                case 3 /* PLYType.DOUBLE */ :
                    value = dataView.getFloat64(offset.value + property.offset, true);
                    break;
                case 4 /* PLYType.UCHAR */ :
                    value = dataView.getUint8(offset.value + property.offset);
                    break;
                default:
                    continue;
            }
            switch(property.value){
                case 12 /* PLYValue.PACKED_POSITION */ :
                    {
                        const compressedChunk = compressedChunks[chunkIndex];
                        Unpack111011(value, temp3);
                        position[0] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scalar"].Lerp(compressedChunk.min.x, compressedChunk.max.x, temp3.x);
                        position[1] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scalar"].Lerp(compressedChunk.min.y, compressedChunk.max.y, temp3.y);
                        position[2] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scalar"].Lerp(compressedChunk.min.z, compressedChunk.max.z, temp3.z);
                    }
                    break;
                case 13 /* PLYValue.PACKED_ROTATION */ :
                    {
                        UnpackRot(value, q);
                        r0 = q.x;
                        r1 = q.y;
                        r2 = q.z;
                        r3 = q.w;
                    }
                    break;
                case 14 /* PLYValue.PACKED_SCALE */ :
                    {
                        const compressedChunk = compressedChunks[chunkIndex];
                        Unpack111011(value, temp3);
                        scale[0] = Math.exp(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scalar"].Lerp(compressedChunk.minScale.x, compressedChunk.maxScale.x, temp3.x));
                        scale[1] = Math.exp(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scalar"].Lerp(compressedChunk.minScale.y, compressedChunk.maxScale.y, temp3.y));
                        scale[2] = Math.exp(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scalar"].Lerp(compressedChunk.minScale.z, compressedChunk.maxScale.z, temp3.z));
                    }
                    break;
                case 15 /* PLYValue.PACKED_COLOR */ :
                    {
                        const compressedChunk = compressedChunks[chunkIndex];
                        Unpack8888(value, rgba);
                        rgba[0] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scalar"].Lerp(compressedChunk.minColor.x, compressedChunk.maxColor.x, rgba[0] / 255) * 255;
                        rgba[1] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scalar"].Lerp(compressedChunk.minColor.y, compressedChunk.maxColor.y, rgba[1] / 255) * 255;
                        rgba[2] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scalar"].Lerp(compressedChunk.minColor.z, compressedChunk.maxColor.z, rgba[2] / 255) * 255;
                    }
                    break;
                case 16 /* PLYValue.X */ :
                    position[0] = value;
                    break;
                case 17 /* PLYValue.Y */ :
                    position[1] = value;
                    break;
                case 18 /* PLYValue.Z */ :
                    position[2] = value;
                    break;
                case 19 /* PLYValue.SCALE_0 */ :
                    scale[0] = Math.exp(value);
                    break;
                case 20 /* PLYValue.SCALE_1 */ :
                    scale[1] = Math.exp(value);
                    break;
                case 21 /* PLYValue.SCALE_2 */ :
                    scale[2] = Math.exp(value);
                    break;
                case 22 /* PLYValue.DIFFUSE_RED */ :
                    rgba[0] = value;
                    break;
                case 23 /* PLYValue.DIFFUSE_GREEN */ :
                    rgba[1] = value;
                    break;
                case 24 /* PLYValue.DIFFUSE_BLUE */ :
                    rgba[2] = value;
                    break;
                case 26 /* PLYValue.F_DC_0 */ :
                    rgba[0] = (0.5 + GaussianSplattingMesh._SH_C0 * value) * 255;
                    break;
                case 27 /* PLYValue.F_DC_1 */ :
                    rgba[1] = (0.5 + GaussianSplattingMesh._SH_C0 * value) * 255;
                    break;
                case 28 /* PLYValue.F_DC_2 */ :
                    rgba[2] = (0.5 + GaussianSplattingMesh._SH_C0 * value) * 255;
                    break;
                case 29 /* PLYValue.F_DC_3 */ :
                    rgba[3] = (0.5 + GaussianSplattingMesh._SH_C0 * value) * 255;
                    break;
                case 25 /* PLYValue.OPACITY */ :
                    rgba[3] = 1 / (1 + Math.exp(-value)) * 255;
                    break;
                case 30 /* PLYValue.ROT_0 */ :
                    r0 = value;
                    break;
                case 31 /* PLYValue.ROT_1 */ :
                    r1 = value;
                    break;
                case 32 /* PLYValue.ROT_2 */ :
                    r2 = value;
                    break;
                case 33 /* PLYValue.ROT_3 */ :
                    r3 = value;
                    break;
            }
            if (sh && property.value >= 40 /* PLYValue.SH_0 */  && property.value <= 84 /* PLYValue.SH_44 */ ) {
                const shIndex = property.value - 40 /* PLYValue.SH_0 */ ;
                if (property.type == 4 /* PLYType.UCHAR */  && header.chunkCount) {
                    // compressed ply. dataView points to beginning of vertex
                    // could be improved with a direct copy instead of a per SH index computation + copy
                    const compressedValue = dataView.getUint8(header.rowChunkLength * header.chunkCount + header.vertexCount * header.rowVertexLength + index * header.shCoefficientCount + shIndex);
                    // compressed .ply SH import : https://github.com/playcanvas/engine/blob/fda3f0368b45d7381f0b5a1722bd2056128eaebe/src/scene/gsplat/gsplat-compressed-data.js#L88C81-L88C98
                    plySH[shIndex] = (compressedValue * (8 / 255) - 4) * 127.5 + 127.5;
                } else {
                    const clampedValue = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scalar"].Clamp(value * 127.5 + 127.5, 0, 255);
                    plySH[shIndex] = clampedValue;
                }
            }
        }
        if (sh) {
            const shDim = header.shDegree == 1 ? 3 : header.shDegree == 2 ? 8 : 15;
            for(let j = 0; j < shDim; j++){
                sh[j * 3 + 0] = plySH[j];
                sh[j * 3 + 1] = plySH[j + shDim];
                sh[j * 3 + 2] = plySH[j + shDim * 2];
            }
        }
        q.set(r1, r2, r3, r0);
        q.normalize();
        rot[0] = q.w * 127.5 + 127.5;
        rot[1] = q.x * 127.5 + 127.5;
        rot[2] = q.y * 127.5 + 127.5;
        rot[3] = q.z * 127.5 + 127.5;
        offset.value += header.rowVertexLength;
    }
    /**
     * Converts a .ply data with SH coefficients splat
     * if data array buffer is not ply, returns the original buffer
     * @param data the .ply data to load
     * @param useCoroutine use coroutine and yield
     * @returns the loaded splat buffer and optional array of sh coefficients
     */ static *ConvertPLYWithSHToSplat(data, useCoroutine = false) {
        const header = GaussianSplattingMesh.ParseHeader(data);
        if (!header) {
            return {
                buffer: data
            };
        }
        const offset = {
            value: 0
        };
        const compressedChunks = GaussianSplattingMesh._GetCompressedChunks(header, offset);
        for(let i = 0; i < header.vertexCount; i++){
            GaussianSplattingMesh._GetSplat(header, i, compressedChunks, offset);
            if (i % GaussianSplattingMesh._PlyConversionBatchSize === 0 && useCoroutine) {
                yield;
            }
        }
        let sh = null;
        // make SH texture buffers
        if (header.shDegree && header.shBuffer) {
            const textureCount = Math.ceil(header.shCoefficientCount / 16); // 4 components can be stored per texture, 4 sh per component
            let shIndexRead = 0;
            const ubuf = new Uint8Array(header.shBuffer);
            // sh is an array of uint8array that will be used to create sh textures
            sh = [];
            const splatCount = header.vertexCount;
            const engine = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engineStore$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EngineStore"].LastCreatedEngine;
            if (engine) {
                const width = engine.getCaps().maxTextureSize;
                const height = Math.ceil(splatCount / width);
                // create array for the number of textures needed.
                for(let textureIndex = 0; textureIndex < textureCount; textureIndex++){
                    const texture = new Uint8Array(height * width * 4 * 4); // 4 components per texture, 4 sh per component
                    sh.push(texture);
                }
                for(let i = 0; i < splatCount; i++){
                    for(let shIndexWrite = 0; shIndexWrite < header.shCoefficientCount; shIndexWrite++){
                        const shValue = ubuf[shIndexRead++];
                        const textureIndex = Math.floor(shIndexWrite / 16);
                        const shArray = sh[textureIndex];
                        const byteIndexInTexture = shIndexWrite % 16; // [0..15]
                        const offsetPerSplat = i * 16; // 16 sh values per texture per splat.
                        shArray[byteIndexInTexture + offsetPerSplat] = shValue;
                    }
                }
            }
        }
        return {
            buffer: header.buffer,
            sh: sh
        };
    }
    /**
     * Converts a .ply data array buffer to splat
     * if data array buffer is not ply, returns the original buffer
     * @param data the .ply data to load
     * @param useCoroutine use coroutine and yield
     * @returns the loaded splat buffer without SH coefficient, whether ply contains or not SH.
     */ static *ConvertPLYToSplat(data, useCoroutine = false) {
        const header = GaussianSplattingMesh.ParseHeader(data);
        if (!header) {
            return data;
        }
        const offset = {
            value: 0
        };
        const compressedChunks = GaussianSplattingMesh._GetCompressedChunks(header, offset);
        for(let i = 0; i < header.vertexCount; i++){
            GaussianSplattingMesh._GetSplat(header, i, compressedChunks, offset);
            if (i % GaussianSplattingMesh._PlyConversionBatchSize === 0 && useCoroutine) {
                yield;
            }
        }
        return header.buffer;
    }
    /**
     * Converts a .ply data array buffer to splat
     * if data array buffer is not ply, returns the original buffer
     * @param data the .ply data to load
     * @returns the loaded splat buffer
     */ static async ConvertPLYToSplatAsync(data) {
        return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$coroutine$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["runCoroutineAsync"])(GaussianSplattingMesh.ConvertPLYToSplat(data, true), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$coroutine$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createYieldingScheduler"])());
    }
    /**
     * Converts a .ply with SH data array buffer to splat
     * if data array buffer is not ply, returns the original buffer
     * @param data the .ply data to load
     * @returns the loaded splat buffer with SH
     */ static async ConvertPLYWithSHToSplatAsync(data) {
        return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$coroutine$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["runCoroutineAsync"])(GaussianSplattingMesh.ConvertPLYWithSHToSplat(data, true), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$coroutine$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createYieldingScheduler"])());
    }
    /**
     * Loads a .splat Gaussian Splatting array buffer asynchronously
     * @param data arraybuffer containing splat file
     * @returns a promise that resolves when the operation is complete
     */ async loadDataAsync(data) {
        return await this.updateDataAsync(data);
    }
    /**
     * Loads a .splat Gaussian or .ply Splatting file asynchronously
     * @param url path to the splat file to load
     * @returns a promise that resolves when the operation is complete
     * @deprecated Please use SceneLoader.ImportMeshAsync instead
     */ async loadFileAsync(url) {
        const plyBuffer = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tools"].LoadFileAsync(url, true);
        const splatsData = await GaussianSplattingMesh.ConvertPLYWithSHToSplatAsync(plyBuffer);
        await this.updateDataAsync(splatsData.buffer, splatsData.sh);
    }
    /**
     * Releases resources associated with this mesh.
     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
     */ dispose(doNotRecurse) {
        this._covariancesATexture?.dispose();
        this._covariancesBTexture?.dispose();
        this._centersTexture?.dispose();
        this._colorsTexture?.dispose();
        if (this._shTextures) {
            for (const shTexture of this._shTextures){
                shTexture.dispose();
            }
        }
        this._covariancesATexture = null;
        this._covariancesBTexture = null;
        this._centersTexture = null;
        this._colorsTexture = null;
        this._shTextures = null;
        this._worker?.terminate();
        this._worker = null;
        super.dispose(doNotRecurse, true);
    }
    _copyTextures(source) {
        this._covariancesATexture = source.covariancesATexture?.clone();
        this._covariancesBTexture = source.covariancesBTexture?.clone();
        this._centersTexture = source.centersTexture?.clone();
        this._colorsTexture = source.colorsTexture?.clone();
        if (source._shTextures) {
            this._shTextures = [];
            for (const shTexture of this._shTextures){
                this._shTextures?.push(shTexture.clone());
            }
        }
    }
    /**
     * Returns a new Mesh object generated from the current mesh properties.
     * @param name is a string, the name given to the new mesh
     * @returns a new Gaussian Splatting Mesh
     */ clone(name = "") {
        const newGS = new GaussianSplattingMesh(name, undefined, this.getScene());
        newGS._copySource(this);
        newGS.makeGeometryUnique();
        newGS._vertexCount = this._vertexCount;
        newGS._copyTextures(this);
        newGS._modelViewMatrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].Identity();
        newGS._splatPositions = this._splatPositions;
        newGS._readyToDisplay = false;
        newGS._instanciateWorker();
        const binfo = this.getBoundingInfo();
        newGS.getBoundingInfo().reConstruct(binfo.minimum, binfo.maximum, this.getWorldMatrix());
        newGS.forcedInstanceCount = this.forcedInstanceCount;
        newGS.setEnabled(true);
        return newGS;
    }
    _makeEmptySplat(index, covA, covB, colorArray) {
        const covBSItemSize = this._useRGBACovariants ? 4 : 2;
        this._splatPositions[4 * index + 0] = 0;
        this._splatPositions[4 * index + 1] = 0;
        this._splatPositions[4 * index + 2] = 0;
        covA[index * 4 + 0] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToHalfFloat"])(0);
        covA[index * 4 + 1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToHalfFloat"])(0);
        covA[index * 4 + 2] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToHalfFloat"])(0);
        covA[index * 4 + 3] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToHalfFloat"])(0);
        covB[index * covBSItemSize + 0] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToHalfFloat"])(0);
        covB[index * covBSItemSize + 1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToHalfFloat"])(0);
        colorArray[index * 4 + 3] = 0;
    }
    _makeSplat(index, fBuffer, uBuffer, covA, covB, colorArray, minimum, maximum) {
        const matrixRotation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[0];
        const matrixScale = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[1];
        const quaternion = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Quaternion[0];
        const covBSItemSize = this._useRGBACovariants ? 4 : 2;
        const x = fBuffer[8 * index + 0];
        const y = -fBuffer[8 * index + 1];
        const z = fBuffer[8 * index + 2];
        this._splatPositions[4 * index + 0] = x;
        this._splatPositions[4 * index + 1] = y;
        this._splatPositions[4 * index + 2] = z;
        minimum.minimizeInPlaceFromFloats(x, y, z);
        maximum.maximizeInPlaceFromFloats(x, y, z);
        quaternion.set((uBuffer[32 * index + 28 + 1] - 127.5) / 127.5, (uBuffer[32 * index + 28 + 2] - 127.5) / 127.5, (uBuffer[32 * index + 28 + 3] - 127.5) / 127.5, -(uBuffer[32 * index + 28 + 0] - 127.5) / 127.5);
        quaternion.normalize();
        quaternion.toRotationMatrix(matrixRotation);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"].ScalingToRef(fBuffer[8 * index + 3 + 0] * 2, fBuffer[8 * index + 3 + 1] * 2, fBuffer[8 * index + 3 + 2] * 2, matrixScale);
        const m = matrixRotation.multiplyToRef(matrixScale, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TmpVectors"].Matrix[0]).m;
        const covariances = this._tmpCovariances;
        covariances[0] = m[0] * m[0] + m[1] * m[1] + m[2] * m[2];
        covariances[1] = m[0] * m[4] + m[1] * m[5] + m[2] * m[6];
        covariances[2] = m[0] * m[8] + m[1] * m[9] + m[2] * m[10];
        covariances[3] = m[4] * m[4] + m[5] * m[5] + m[6] * m[6];
        covariances[4] = m[4] * m[8] + m[5] * m[9] + m[6] * m[10];
        covariances[5] = m[8] * m[8] + m[9] * m[9] + m[10] * m[10];
        // normalize covA, covB
        let factor = -10000;
        for(let covIndex = 0; covIndex < 6; covIndex++){
            factor = Math.max(factor, Math.abs(covariances[covIndex]));
        }
        this._splatPositions[4 * index + 3] = factor;
        const transform = factor;
        covA[index * 4 + 0] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToHalfFloat"])(covariances[0] / transform);
        covA[index * 4 + 1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToHalfFloat"])(covariances[1] / transform);
        covA[index * 4 + 2] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToHalfFloat"])(covariances[2] / transform);
        covA[index * 4 + 3] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToHalfFloat"])(covariances[3] / transform);
        covB[index * covBSItemSize + 0] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToHalfFloat"])(covariances[4] / transform);
        covB[index * covBSItemSize + 1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ToHalfFloat"])(covariances[5] / transform);
        // colors
        colorArray[index * 4 + 0] = uBuffer[32 * index + 24 + 0];
        colorArray[index * 4 + 1] = uBuffer[32 * index + 24 + 1];
        colorArray[index * 4 + 2] = uBuffer[32 * index + 24 + 2];
        colorArray[index * 4 + 3] = uBuffer[32 * index + 24 + 3];
    }
    _updateTextures(covA, covB, colorArray, sh) {
        const textureSize = this._getTextureSize(this._vertexCount);
        // Update the textures
        const createTextureFromData = (data, width, height, format)=>{
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$rawTexture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RawTexture"](data, width, height, format, this._scene, false, false, 2, 1);
        };
        const createTextureFromDataU8 = (data, width, height, format)=>{
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$rawTexture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RawTexture"](data, width, height, format, this._scene, false, false, 2, 0);
        };
        const createTextureFromDataU32 = (data, width, height, format)=>{
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$rawTexture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RawTexture"](data, width, height, format, this._scene, false, false, 1, 7);
        };
        const createTextureFromDataF16 = (data, width, height, format)=>{
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$rawTexture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RawTexture"](data, width, height, format, this._scene, false, false, 2, 2);
        };
        if (this._covariancesATexture) {
            this._delayedTextureUpdate = {
                covA: covA,
                covB: covB,
                colors: colorArray,
                centers: this._splatPositions,
                sh: sh
            };
            const positions = Float32Array.from(this._splatPositions);
            const vertexCount = this._vertexCount;
            this._worker.postMessage({
                positions,
                vertexCount
            }, [
                positions.buffer
            ]);
            this._postToWorker(true);
        } else {
            this._covariancesATexture = createTextureFromDataF16(covA, textureSize.x, textureSize.y, 5);
            this._covariancesBTexture = createTextureFromDataF16(covB, textureSize.x, textureSize.y, this._useRGBACovariants ? 5 : 7);
            this._centersTexture = createTextureFromData(this._splatPositions, textureSize.x, textureSize.y, 5);
            this._colorsTexture = createTextureFromDataU8(colorArray, textureSize.x, textureSize.y, 5);
            if (sh) {
                this._shTextures = [];
                for (const shData of sh){
                    const buffer = new Uint32Array(shData.buffer);
                    const shTexture = createTextureFromDataU32(buffer, textureSize.x, textureSize.y, 11);
                    shTexture.wrapU = 0;
                    shTexture.wrapV = 0;
                    this._shTextures.push(shTexture);
                }
            }
            this._instanciateWorker();
        }
    }
    *_updateData(data, isAsync, sh) {
        // if a covariance texture is present, then it's not a creation but an update
        if (!this._covariancesATexture) {
            this._readyToDisplay = false;
        }
        // Parse the data
        const uBuffer = new Uint8Array(data);
        const fBuffer = new Float32Array(uBuffer.buffer);
        if (this._keepInRam) {
            this._splatsData = data;
            if (sh) {
                this._sh = sh;
            }
        }
        const vertexCount = uBuffer.length / GaussianSplattingMesh._RowOutputLength;
        if (vertexCount != this._vertexCount) {
            this._updateSplatIndexBuffer(vertexCount);
        }
        this._vertexCount = vertexCount;
        // degree == 1 for 1 texture (3 terms), 2 for 2 textures(8 terms) and 3 for 3 textures (15 terms)
        this._shDegree = sh ? sh.length : 0;
        const textureSize = this._getTextureSize(vertexCount);
        const textureLength = textureSize.x * textureSize.y;
        const lineCountUpdate = GaussianSplattingMesh.ProgressiveUpdateAmount ?? textureSize.y;
        const textureLengthPerUpdate = textureSize.x * lineCountUpdate;
        this._splatPositions = new Float32Array(4 * textureLength);
        const covA = new Uint16Array(textureLength * 4);
        const covB = new Uint16Array((this._useRGBACovariants ? 4 : 2) * textureLength);
        const colorArray = new Uint8Array(textureLength * 4);
        const minimum = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        const maximum = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        if (GaussianSplattingMesh.ProgressiveUpdateAmount) {
            // create textures with not filled-yet array, then update directly portions of it
            this._updateTextures(covA, covB, colorArray, sh);
            this.setEnabled(true);
            const partCount = Math.ceil(textureSize.y / lineCountUpdate);
            for(let partIndex = 0; partIndex < partCount; partIndex++){
                const updateLine = partIndex * lineCountUpdate;
                const splatIndexBase = updateLine * textureSize.x;
                for(let i = 0; i < textureLengthPerUpdate; i++){
                    this._makeSplat(splatIndexBase + i, fBuffer, uBuffer, covA, covB, colorArray, minimum, maximum);
                }
                this._updateSubTextures(this._splatPositions, covA, covB, colorArray, updateLine, Math.min(lineCountUpdate, textureSize.y - updateLine));
                // Update the binfo
                this.getBoundingInfo().reConstruct(minimum, maximum, this.getWorldMatrix());
                if (isAsync) {
                    yield;
                }
            }
            // sort will be dirty here as just finished filled positions will not be sorted
            const positions = Float32Array.from(this._splatPositions);
            const vertexCount = this._vertexCount;
            this._worker.postMessage({
                positions,
                vertexCount
            }, [
                positions.buffer
            ]);
            this._sortIsDirty = true;
        } else {
            const paddedVertexCount = vertexCount + 15 & ~0xf;
            for(let i = 0; i < vertexCount; i++){
                this._makeSplat(i, fBuffer, uBuffer, covA, covB, colorArray, minimum, maximum);
                if (isAsync && i % GaussianSplattingMesh._SplatBatchSize === 0) {
                    yield;
                }
            }
            // pad the rest
            for(let i = vertexCount; i < paddedVertexCount; i++){
                this._makeEmptySplat(i, covA, covB, colorArray);
            }
            // textures
            this._updateTextures(covA, covB, colorArray, sh);
            // Update the binfo
            this.getBoundingInfo().reConstruct(minimum, maximum, this.getWorldMatrix());
            this.setEnabled(true);
        }
        this._postToWorker(true);
    }
    /**
     * Update asynchronously the buffer
     * @param data array buffer containing center, color, orientation and scale of splats
     * @param sh optional array of uint8 array for SH data
     * @returns a promise
     */ async updateDataAsync(data, sh) {
        return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$coroutine$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["runCoroutineAsync"])(this._updateData(data, true, sh), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$coroutine$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createYieldingScheduler"])());
    }
    /**
     * @experimental
     * Update data from GS (position, orientation, color, scaling)
     * @param data array that contain all the datas
     * @param sh optional array of uint8 array for SH data
     */ updateData(data, sh) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$coroutine$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["runCoroutineSync"])(this._updateData(data, false, sh));
    }
    /**
     * Refreshes the bounding info, taking into account all the thin instances defined
     * @returns the current Gaussian Splatting
     */ refreshBoundingInfo() {
        this.thinInstanceRefreshBoundingInfo(false);
        return this;
    }
    // in case size is different
    _updateSplatIndexBuffer(vertexCount) {
        const paddedVertexCount = vertexCount + 15 & ~0xf;
        if (!this._splatIndex || vertexCount > this._splatIndex.length) {
            this._splatIndex = new Float32Array(paddedVertexCount);
            this.thinInstanceSetBuffer("splatIndex", this._splatIndex, 16, false);
        }
        this.forcedInstanceCount = paddedVertexCount >> 4;
    }
    _updateSubTextures(centers, covA, covB, colors, lineStart, lineCount, sh) {
        const updateTextureFromData = (texture, data, width, lineStart, lineCount)=>{
            this.getEngine().updateTextureData(texture.getInternalTexture(), data, 0, lineStart, width, lineCount, 0, 0, false);
        };
        const textureSize = this._getTextureSize(this._vertexCount);
        const covBSItemSize = this._useRGBACovariants ? 4 : 2;
        const texelStart = lineStart * textureSize.x;
        const texelCount = lineCount * textureSize.x;
        const covAView = new Uint16Array(covA.buffer, texelStart * 4 * Uint16Array.BYTES_PER_ELEMENT, texelCount * 4);
        const covBView = new Uint16Array(covB.buffer, texelStart * covBSItemSize * Uint16Array.BYTES_PER_ELEMENT, texelCount * covBSItemSize);
        const colorsView = new Uint8Array(colors.buffer, texelStart * 4, texelCount * 4);
        const centersView = new Float32Array(centers.buffer, texelStart * 4 * Float32Array.BYTES_PER_ELEMENT, texelCount * 4);
        updateTextureFromData(this._covariancesATexture, covAView, textureSize.x, lineStart, lineCount);
        updateTextureFromData(this._covariancesBTexture, covBView, textureSize.x, lineStart, lineCount);
        updateTextureFromData(this._centersTexture, centersView, textureSize.x, lineStart, lineCount);
        updateTextureFromData(this._colorsTexture, colorsView, textureSize.x, lineStart, lineCount);
        if (sh) {
            for(let i = 0; i < sh.length; i++){
                const componentCount = 4;
                const shView = new Uint8Array(this._sh[i].buffer, texelStart * componentCount, texelCount * componentCount);
                updateTextureFromData(this._shTextures[i], shView, textureSize.x, lineStart, lineCount);
            }
        }
    }
    _instanciateWorker() {
        if (!this._vertexCount) {
            return;
        }
        this._updateSplatIndexBuffer(this._vertexCount);
        // Start the worker thread
        this._worker?.terminate();
        this._worker = new Worker(URL.createObjectURL(new Blob([
            "(",
            GaussianSplattingMesh._CreateWorker.toString(),
            ")(self)"
        ], {
            type: "application/javascript"
        })));
        const vertexCountPadded = this._vertexCount + 15 & ~0xf;
        this._depthMix = new BigInt64Array(vertexCountPadded);
        const positions = Float32Array.from(this._splatPositions);
        this._worker.postMessage({
            positions,
            vertexCountPadded
        }, [
            positions.buffer
        ]);
        this._worker.onmessage = (e)=>{
            this._depthMix = e.data.depthMix;
            const indexMix = new Uint32Array(e.data.depthMix.buffer);
            if (this._splatIndex) {
                for(let j = 0; j < vertexCountPadded; j++){
                    this._splatIndex[j] = indexMix[2 * j];
                }
            }
            if (this._delayedTextureUpdate) {
                const textureSize = this._getTextureSize(vertexCountPadded);
                this._updateSubTextures(this._delayedTextureUpdate.centers, this._delayedTextureUpdate.covA, this._delayedTextureUpdate.covB, this._delayedTextureUpdate.colors, 0, textureSize.y, this._delayedTextureUpdate.sh);
                this._delayedTextureUpdate = null;
            }
            this.thinInstanceBufferUpdated("splatIndex");
            this._canPostToWorker = true;
            this._readyToDisplay = true;
            // sort is dirty when GS is visible for progressive update with a this message arriving but positions were partially filled
            // another update needs to be kicked. The kick can't happen just when the position buffer is ready because _canPostToWorker might be false.
            if (this._sortIsDirty) {
                this._postToWorker(true);
                this._sortIsDirty = false;
            }
        };
    }
    _getTextureSize(length) {
        const engine = this._scene.getEngine();
        const width = engine.getCaps().maxTextureSize;
        let height = 1;
        if (engine.version === 1 && !engine.isWebGPU) {
            while(width * height < length){
                height *= 2;
            }
        } else {
            height = Math.ceil(length / width);
        }
        if (height > width) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Logger"].Error("GaussianSplatting texture size: (" + width + ", " + height + "), maxTextureSize: " + width);
            height = width;
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](width, height);
    }
}
GaussianSplattingMesh._RowOutputLength = 3 * 4 + 3 * 4 + 4 + 4; // Vector3 position, Vector3 scale, 1 u8 quaternion, 1 color with alpha
GaussianSplattingMesh._SH_C0 = 0.28209479177387814;
// batch size between 2 yield calls. This value is a tradeoff between updates overhead and framerate hiccups
// This step is faster the PLY conversion. So batch size can be bigger
GaussianSplattingMesh._SplatBatchSize = 327680;
// batch size between 2 yield calls during the PLY to splat conversion.
GaussianSplattingMesh._PlyConversionBatchSize = 32768;
/**
 * Set the number of batch (a batch is 16384 splats) after which a display update is performed
 * A value of 0 (default) means display update will not happens before splat is ready.
 */ GaussianSplattingMesh.ProgressiveUpdateAmount = 0;
GaussianSplattingMesh._CreateWorker = function(self) {
    let vertexCountPadded = 0;
    let positions;
    let depthMix;
    let indices;
    let floatMix;
    self.onmessage = (e)=>{
        // updated on init
        if (e.data.positions) {
            positions = e.data.positions;
            vertexCountPadded = e.data.vertexCountPadded;
        } else {
            const viewProj = e.data.view;
            if (!positions || !viewProj) {
                // Sanity check, it shouldn't happen!
                throw new Error("positions or view is not defined!");
            }
            depthMix = e.data.depthMix;
            indices = new Uint32Array(depthMix.buffer);
            floatMix = new Float32Array(depthMix.buffer);
            // Sort
            for(let j = 0; j < vertexCountPadded; j++){
                indices[2 * j] = j;
            }
            let depthFactor = -1;
            if (e.data.useRightHandedSystem) {
                depthFactor = 1;
            }
            for(let j = 0; j < vertexCountPadded; j++){
                floatMix[2 * j + 1] = 10000 + (viewProj[2] * positions[4 * j + 0] + viewProj[6] * positions[4 * j + 1] + viewProj[10] * positions[4 * j + 2]) * depthFactor;
            }
            depthMix.sort();
            self.postMessage({
                depthMix
            }, [
                depthMix.buffer
            ]);
        }
    };
}; //# sourceMappingURL=gaussianSplattingMesh.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

/* eslint-disable import/export */ /* eslint-disable @typescript-eslint/no-restricted-imports */ __turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$abstractMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/abstractMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$abstractMesh$2e$decalMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/abstractMesh.decalMap.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$abstractMesh$2e$hotSpot$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/abstractMesh.hotSpot.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Compression/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$csg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/csg.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$meshUVSpaceRenderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/meshUVSpaceRenderer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$groundMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/groundMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$goldbergMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/goldbergMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$trailMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/trailMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$instancedMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/instancedMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$linesMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/linesMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.vertexData.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$meshBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/meshBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$meshSimplification$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/meshSimplification.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$meshSimplificationSceneComponent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/meshSimplificationSceneComponent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$meshUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/meshUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$polygonMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/polygonMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$geodesicMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/geodesicMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$subMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/subMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$subMesh$2e$project$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/subMesh.project.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$lattice$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/lattice.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$lattice$2e$material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/lattice.material.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$meshLODLevel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/meshLODLevel.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$transformNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/transformNode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Builders/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$WebGL$2f$webGLDataBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/WebGL/webGLDataBuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$WebGPU$2f$webgpuDataBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/WebGPU/webgpuDataBuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$GreasedLine$2f$greasedLineMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/GreasedLine/greasedLineMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$GreasedLine$2f$greasedLineRibbonMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/GreasedLine/greasedLineRibbonMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$GreasedLine$2f$greasedLineBaseMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/GreasedLine/greasedLineBaseMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$csg2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/csg2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.vertexData.functions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$subdivide$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.vertexData.subdivide.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$thinInstanceMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/thinInstanceMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Node/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$GaussianSplatting$2f$gaussianSplattingMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/GaussianSplatting/gaussianSplattingMesh.js [app-client] (ecmascript)");
// LineMesh
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$color$2e$fragment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/color.fragment.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$color$2e$vertex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/color.vertex.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$color$2e$fragment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/color.fragment.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$color$2e$vertex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/color.vertex.js [app-client] (ecmascript)");
// MeshUVSPaceRenderer
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$meshUVSpaceRenderer$2e$vertex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/meshUVSpaceRenderer.vertex.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$meshUVSpaceRenderer$2e$fragment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/meshUVSpaceRenderer.fragment.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$meshUVSpaceRendererMasker$2e$vertex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/meshUVSpaceRendererMasker.vertex.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$meshUVSpaceRendererMasker$2e$fragment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/meshUVSpaceRendererMasker.fragment.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$meshUVSpaceRendererFinaliser$2e$fragment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/meshUVSpaceRendererFinaliser.fragment.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$meshUVSpaceRendererFinaliser$2e$vertex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/meshUVSpaceRendererFinaliser.vertex.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$meshUVSpaceRenderer$2e$vertex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/meshUVSpaceRenderer.vertex.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$meshUVSpaceRenderer$2e$fragment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/meshUVSpaceRenderer.fragment.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$meshUVSpaceRendererMasker$2e$vertex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/meshUVSpaceRendererMasker.vertex.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$meshUVSpaceRendererMasker$2e$fragment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/meshUVSpaceRendererMasker.fragment.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$meshUVSpaceRendererFinaliser$2e$fragment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/meshUVSpaceRendererFinaliser.fragment.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$meshUVSpaceRendererFinaliser$2e$vertex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/meshUVSpaceRendererFinaliser.vertex.js [app-client] (ecmascript)"); //# sourceMappingURL=index.js.map
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AbstractMesh",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$abstractMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AbstractMesh"],
    "Aggregations",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Aggregations"],
    "AggregatorBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AggregatorBlock"],
    "AlignBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AlignBlock"],
    "BooleanGeometryBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BooleanGeometryBlock"],
    "BooleanGeometryOperations",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BooleanGeometryOperations"],
    "BoundingBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BoundingBlock"],
    "BoxBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BoxBlock"],
    "BoxBuilder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BoxBuilder"],
    "CSG",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$csg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CSG"],
    "CSG2",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$csg2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CSG2"],
    "CapsuleBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CapsuleBlock"],
    "CapsuleBuilder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CapsuleBuilder"],
    "CleanGeometryBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CleanGeometryBlock"],
    "CompleteGreasedLineColorTable",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CompleteGreasedLineColorTable"],
    "CompleteGreasedLineWidthTable",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CompleteGreasedLineWidthTable"],
    "ComputeNormalsBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ComputeNormalsBlock"],
    "ConditionBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ConditionBlock"],
    "ConditionBlockTests",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ConditionBlockTests"],
    "CreateBox",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateBox"],
    "CreateBoxVertexData",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateBoxVertexData"],
    "CreateCapsule",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateCapsule"],
    "CreateCapsuleVertexData",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateCapsuleVertexData"],
    "CreateCylinder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateCylinder"],
    "CreateCylinderVertexData",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateCylinderVertexData"],
    "CreateDashedLines",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateDashedLines"],
    "CreateDashedLinesVertexData",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateDashedLinesVertexData"],
    "CreateDecal",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateDecal"],
    "CreateDisc",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateDisc"],
    "CreateDiscVertexData",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateDiscVertexData"],
    "CreateGeodesic",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateGeodesic"],
    "CreateGoldberg",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateGoldberg"],
    "CreateGoldbergVertexData",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateGoldbergVertexData"],
    "CreateGreasedLine",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateGreasedLine"],
    "CreateGreasedLineMaterial",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateGreasedLineMaterial"],
    "CreateGround",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateGround"],
    "CreateGroundFromHeightMap",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateGroundFromHeightMap"],
    "CreateGroundFromHeightMapVertexData",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateGroundFromHeightMapVertexData"],
    "CreateGroundVertexData",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateGroundVertexData"],
    "CreateHemisphere",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateHemisphere"],
    "CreateHotSpotQueryForPickingInfo",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$abstractMesh$2e$hotSpot$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateHotSpotQueryForPickingInfo"],
    "CreateIcoSphere",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateIcoSphere"],
    "CreateIcoSphereVertexData",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateIcoSphereVertexData"],
    "CreateLathe",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateLathe"],
    "CreateLineSystem",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateLineSystem"],
    "CreateLineSystemVertexData",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateLineSystemVertexData"],
    "CreateLines",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateLines"],
    "CreatePlane",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreatePlane"],
    "CreatePlaneVertexData",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreatePlaneVertexData"],
    "CreatePolygon",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreatePolygon"],
    "CreatePolygonVertexData",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreatePolygonVertexData"],
    "CreatePolyhedron",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreatePolyhedron"],
    "CreatePolyhedronVertexData",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreatePolyhedronVertexData"],
    "CreateRibbon",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateRibbon"],
    "CreateRibbonVertexData",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateRibbonVertexData"],
    "CreateSegmentedBoxVertexData",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateSegmentedBoxVertexData"],
    "CreateSphere",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateSphere"],
    "CreateSphereVertexData",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateSphereVertexData"],
    "CreateText",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateText"],
    "CreateTextShapePaths",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateTextShapePaths"],
    "CreateTiledBox",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateTiledBox"],
    "CreateTiledBoxVertexData",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateTiledBoxVertexData"],
    "CreateTiledGround",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateTiledGround"],
    "CreateTiledGroundVertexData",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateTiledGroundVertexData"],
    "CreateTiledPlane",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateTiledPlane"],
    "CreateTiledPlaneVertexData",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateTiledPlaneVertexData"],
    "CreateTorus",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateTorus"],
    "CreateTorusKnot",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateTorusKnot"],
    "CreateTorusKnotVertexData",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateTorusKnotVertexData"],
    "CreateTorusVertexData",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateTorusVertexData"],
    "CreateTube",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CreateTube"],
    "CylinderBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CylinderBlock"],
    "CylinderBuilder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CylinderBuilder"],
    "DebugBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DebugBlock"],
    "DecalBuilder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DecalBuilder"],
    "DiscBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DiscBlock"],
    "DiscBuilder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DiscBuilder"],
    "DracoCompression",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DracoCompression"],
    "DracoDecoder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DracoDecoder"],
    "DracoEncoder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DracoEncoder"],
    "ExtrudePolygon",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtrudePolygon"],
    "ExtrudeShape",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtrudeShape"],
    "ExtrudeShapeCustom",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ExtrudeShapeCustom"],
    "GaussianSplattingMesh",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$GaussianSplatting$2f$gaussianSplattingMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GaussianSplattingMesh"],
    "GeodesicData",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$geodesicMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeodesicData"],
    "Geometry",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Geometry"],
    "GeometryArcTan2Block",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryArcTan2Block"],
    "GeometryClampBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryClampBlock"],
    "GeometryCollectionBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryCollectionBlock"],
    "GeometryCrossBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryCrossBlock"],
    "GeometryCurveBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryCurveBlock"],
    "GeometryCurveBlockTypes",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryCurveBlockTypes"],
    "GeometryDesaturateBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryDesaturateBlock"],
    "GeometryDistanceBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryDistanceBlock"],
    "GeometryDotBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryDotBlock"],
    "GeometryEaseBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryEaseBlock"],
    "GeometryEaseBlockTypes",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryEaseBlockTypes"],
    "GeometryElbowBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryElbowBlock"],
    "GeometryInfoBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryInfoBlock"],
    "GeometryInputBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryInputBlock"],
    "GeometryInterceptorBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryInterceptorBlock"],
    "GeometryLengthBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryLengthBlock"],
    "GeometryLerpBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryLerpBlock"],
    "GeometryModBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryModBlock"],
    "GeometryNLerpBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryNLerpBlock"],
    "GeometryOptimizeBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryOptimizeBlock"],
    "GeometryOutputBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryOutputBlock"],
    "GeometryPosterizeBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryPosterizeBlock"],
    "GeometryPowBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryPowBlock"],
    "GeometryReplaceColorBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryReplaceColorBlock"],
    "GeometryRotate2dBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryRotate2dBlock"],
    "GeometrySmoothStepBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometrySmoothStepBlock"],
    "GeometryStepBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryStepBlock"],
    "GeometryTextureBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryTextureBlock"],
    "GeometryTextureFetchBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryTextureFetchBlock"],
    "GeometryTransformBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryTransformBlock"],
    "GeometryTrigonometryBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryTrigonometryBlock"],
    "GeometryTrigonometryBlockOperations",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GeometryTrigonometryBlockOperations"],
    "GetHotSpotToRef",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$abstractMesh$2e$hotSpot$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GetHotSpotToRef"],
    "GetPointsCount",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GetPointsCount"],
    "GetTransformedPosition",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$abstractMesh$2e$hotSpot$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GetTransformedPosition"],
    "GoldbergMesh",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$goldbergMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GoldbergMesh"],
    "GreasedLineBaseMesh",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$GreasedLine$2f$greasedLineBaseMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GreasedLineBaseMesh"],
    "GreasedLineMesh",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$GreasedLine$2f$greasedLineMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GreasedLineMesh"],
    "GreasedLineMeshColorDistribution",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GreasedLineMeshColorDistribution"],
    "GreasedLineMeshWidthDistribution",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GreasedLineMeshWidthDistribution"],
    "GreasedLineRibbonAutoDirectionMode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$GreasedLine$2f$greasedLineBaseMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GreasedLineRibbonAutoDirectionMode"],
    "GreasedLineRibbonFacesMode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$GreasedLine$2f$greasedLineBaseMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GreasedLineRibbonFacesMode"],
    "GreasedLineRibbonMesh",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$GreasedLine$2f$greasedLineRibbonMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GreasedLineRibbonMesh"],
    "GreasedLineRibbonPointsMode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$GreasedLine$2f$greasedLineBaseMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GreasedLineRibbonPointsMode"],
    "GridBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GridBlock"],
    "GroundBuilder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GroundBuilder"],
    "GroundMesh",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$groundMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GroundMesh"],
    "HemisphereBuilder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HemisphereBuilder"],
    "IcoSphereBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IcoSphereBlock"],
    "IcoSphereBuilder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IcoSphereBuilder"],
    "InitializeCSG2Async",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$csg2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InitializeCSG2Async"],
    "InstancedLinesMesh",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$linesMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstancedLinesMesh"],
    "InstancedMesh",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$instancedMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstancedMesh"],
    "InstantiateBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstantiateBlock"],
    "InstantiateLinearBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstantiateLinearBlock"],
    "InstantiateOnFacesBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstantiateOnFacesBlock"],
    "InstantiateOnVerticesBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstantiateOnVerticesBlock"],
    "InstantiateOnVolumeBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstantiateOnVolumeBlock"],
    "InstantiateRadialBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstantiateRadialBlock"],
    "IntFloatConverterBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IntFloatConverterBlock"],
    "IsCSG2Ready",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$csg2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IsCSG2Ready"],
    "LatheBuilder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LatheBuilder"],
    "Lattice",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$lattice$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Lattice"],
    "LatticeBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LatticeBlock"],
    "LatticePluginMaterial",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$lattice$2e$material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LatticePluginMaterial"],
    "LinesBuilder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinesBuilder"],
    "LinesMesh",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$linesMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinesMesh"],
    "MapRangeBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MapRangeBlock"],
    "MappingBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MappingBlock"],
    "MappingTypes",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MappingTypes"],
    "MathBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathBlock"],
    "MathBlockOperations",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MathBlockOperations"],
    "MatrixComposeBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MatrixComposeBlock"],
    "MergeGeometryBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MergeGeometryBlock"],
    "Mesh",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"],
    "MeshBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBlock"],
    "MeshBuilder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$meshBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBuilder"],
    "MeshLODLevel",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$meshLODLevel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshLODLevel"],
    "MeshUVSpaceRenderer",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$meshUVSpaceRenderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshUVSpaceRenderer"],
    "MeshoptCompression",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshoptCompression"],
    "NodeGeometry",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NodeGeometry"],
    "NodeGeometryBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NodeGeometryBlock"],
    "NodeGeometryBlockConnectionPointTypes",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NodeGeometryBlockConnectionPointTypes"],
    "NodeGeometryBuildState",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NodeGeometryBuildState"],
    "NodeGeometryConnectionPoint",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NodeGeometryConnectionPoint"],
    "NodeGeometryConnectionPointCompatibilityStates",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NodeGeometryConnectionPointCompatibilityStates"],
    "NodeGeometryConnectionPointDirection",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NodeGeometryConnectionPointDirection"],
    "NodeGeometryContextualSources",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NodeGeometryContextualSources"],
    "NoiseBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NoiseBlock"],
    "NormalizeVectorBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NormalizeVectorBlock"],
    "NullBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NullBlock"],
    "OptimizeIndices",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OptimizeIndices"],
    "PlaneBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlaneBlock"],
    "PlaneBuilder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlaneBuilder"],
    "PointListBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PointListBlock"],
    "Polygon",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$polygonMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Polygon"],
    "PolygonBuilder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PolygonBuilder"],
    "PolygonMeshBuilder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$polygonMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PolygonMeshBuilder"],
    "PolyhedronBuilder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PolyhedronBuilder"],
    "PolyhedronData",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$geodesicMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PolyhedronData"],
    "QuadraticErrorSimplification",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$meshSimplification$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["QuadraticErrorSimplification"],
    "RandomBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RandomBlock"],
    "RandomBlockLocks",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RandomBlockLocks"],
    "RemoveUnreferencedVerticesData",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$meshUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RemoveUnreferencedVerticesData"],
    "RibbonBuilder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RibbonBuilder"],
    "RotationXBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RotationXBlock"],
    "RotationYBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RotationYBlock"],
    "RotationZBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RotationZBlock"],
    "ScalingBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalingBlock"],
    "SetColorsBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SetColorsBlock"],
    "SetMaterialIDBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SetMaterialIDBlock"],
    "SetNormalsBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SetNormalsBlock"],
    "SetPositionsBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SetPositionsBlock"],
    "SetTangentsBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SetTangentsBlock"],
    "SetUVsBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SetUVsBlock"],
    "ShapeBuilder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShapeBuilder"],
    "SimplicationQueueSceneComponent",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$meshSimplificationSceneComponent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SimplicationQueueSceneComponent"],
    "SimplificationQueue",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$meshSimplification$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SimplificationQueue"],
    "SimplificationSettings",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$meshSimplification$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SimplificationSettings"],
    "SimplificationType",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$meshSimplification$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SimplificationType"],
    "SphereBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SphereBlock"],
    "SphereBuilder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SphereBuilder"],
    "SubMesh",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$subMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SubMesh"],
    "Subdivide",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$subdivide$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Subdivide"],
    "SubdivideBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SubdivideBlock"],
    "TeleportInBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TeleportInBlock"],
    "TeleportOutBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TeleportOutBlock"],
    "TiledBoxBuilder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TiledBoxBuilder"],
    "TiledPlaneBuilder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TiledPlaneBuilder"],
    "TorusBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TorusBlock"],
    "TorusBuilder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TorusBuilder"],
    "TorusKnotBuilder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TorusKnotBuilder"],
    "TrailMesh",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$trailMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TrailMesh"],
    "TransformNode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$transformNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransformNode"],
    "TranslationBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TranslationBlock"],
    "TubeBuilder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TubeBuilder"],
    "VectorConverterBlock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VectorConverterBlock"],
    "VertexData",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexData"],
    "VertexDataMaterialInfo",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VertexDataMaterialInfo"],
    "WebGLDataBuffer",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$WebGL$2f$webGLDataBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLDataBuffer"],
    "WebGPUDataBuffer",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$WebGPU$2f$webgpuDataBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGPUDataBuffer"],
    "_CreationDataStorage",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_CreationDataStorage"],
    "_InstancesBatch",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_InstancesBatch"],
    "_PrimaryIsoTriangle",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$geodesicMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_PrimaryIsoTriangle"],
    "colorPixelShader",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$color$2e$fragment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["colorPixelShader"],
    "colorPixelShaderWGSL",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$color$2e$fragment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["colorPixelShaderWGSL"],
    "colorVertexShader",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$color$2e$vertex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["colorVertexShader"],
    "colorVertexShaderWGSL",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$color$2e$vertex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["colorVertexShaderWGSL"],
    "computeMaxExtents",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$meshUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["computeMaxExtents"],
    "meshUVSpaceRendererFinaliserPixelShader",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$meshUVSpaceRendererFinaliser$2e$fragment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["meshUVSpaceRendererFinaliserPixelShader"],
    "meshUVSpaceRendererFinaliserPixelShaderWGSL",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$meshUVSpaceRendererFinaliser$2e$fragment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["meshUVSpaceRendererFinaliserPixelShaderWGSL"],
    "meshUVSpaceRendererFinaliserVertexShader",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$meshUVSpaceRendererFinaliser$2e$vertex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["meshUVSpaceRendererFinaliserVertexShader"],
    "meshUVSpaceRendererFinaliserVertexShaderWGSL",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$meshUVSpaceRendererFinaliser$2e$vertex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["meshUVSpaceRendererFinaliserVertexShaderWGSL"],
    "meshUVSpaceRendererMaskerPixelShader",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$meshUVSpaceRendererMasker$2e$fragment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["meshUVSpaceRendererMaskerPixelShader"],
    "meshUVSpaceRendererMaskerPixelShaderWGSL",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$meshUVSpaceRendererMasker$2e$fragment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["meshUVSpaceRendererMaskerPixelShaderWGSL"],
    "meshUVSpaceRendererMaskerVertexShader",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$meshUVSpaceRendererMasker$2e$vertex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["meshUVSpaceRendererMaskerVertexShader"],
    "meshUVSpaceRendererMaskerVertexShaderWGSL",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$meshUVSpaceRendererMasker$2e$vertex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["meshUVSpaceRendererMaskerVertexShaderWGSL"],
    "meshUVSpaceRendererPixelShader",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$meshUVSpaceRenderer$2e$fragment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["meshUVSpaceRendererPixelShader"],
    "meshUVSpaceRendererPixelShaderWGSL",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$meshUVSpaceRenderer$2e$fragment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["meshUVSpaceRendererPixelShaderWGSL"],
    "meshUVSpaceRendererVertexShader",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$meshUVSpaceRenderer$2e$vertex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["meshUVSpaceRendererVertexShader"],
    "meshUVSpaceRendererVertexShaderWGSL",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$meshUVSpaceRenderer$2e$vertex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["meshUVSpaceRendererVertexShaderWGSL"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$abstractMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/abstractMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$abstractMesh$2e$hotSpot$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/abstractMesh.hotSpot.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Compression$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Compression/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$csg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/csg.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$meshUVSpaceRenderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/meshUVSpaceRenderer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$groundMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/groundMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$goldbergMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/goldbergMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$trailMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/trailMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$instancedMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/instancedMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$linesMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/linesMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.vertexData.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$meshBuilder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/meshBuilder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$meshSimplification$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/meshSimplification.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$meshSimplificationSceneComponent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/meshSimplificationSceneComponent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$meshUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/meshUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$polygonMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/polygonMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$geodesicMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/geodesicMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$subMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/subMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$subMesh$2e$project$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/subMesh.project.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$lattice$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/lattice.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$lattice$2e$material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/lattice.material.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$meshLODLevel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/meshLODLevel.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$transformNode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/transformNode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Builders/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$WebGL$2f$webGLDataBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/WebGL/webGLDataBuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$WebGPU$2f$webgpuDataBuffer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/WebGPU/webgpuDataBuffer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$GreasedLine$2f$greasedLineMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/GreasedLine/greasedLineMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$GreasedLine$2f$greasedLineRibbonMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/GreasedLine/greasedLineRibbonMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$GreasedLine$2f$greasedLineBaseMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/GreasedLine/greasedLineBaseMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$csg2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/csg2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$functions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.vertexData.functions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$vertexData$2e$subdivide$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.vertexData.subdivide.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$thinInstanceMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/thinInstanceMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Node/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$GaussianSplatting$2f$gaussianSplattingMesh$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/GaussianSplatting/gaussianSplattingMesh.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$color$2e$fragment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/color.fragment.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$color$2e$vertex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/color.vertex.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$color$2e$fragment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/color.fragment.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$color$2e$vertex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/color.vertex.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$meshUVSpaceRenderer$2e$vertex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/meshUVSpaceRenderer.vertex.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$meshUVSpaceRenderer$2e$fragment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/meshUVSpaceRenderer.fragment.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$meshUVSpaceRendererMasker$2e$vertex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/meshUVSpaceRendererMasker.vertex.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$meshUVSpaceRendererMasker$2e$fragment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/meshUVSpaceRendererMasker.fragment.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$meshUVSpaceRendererFinaliser$2e$fragment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/meshUVSpaceRendererFinaliser.fragment.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$meshUVSpaceRendererFinaliser$2e$vertex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/meshUVSpaceRendererFinaliser.vertex.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$meshUVSpaceRenderer$2e$vertex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/meshUVSpaceRenderer.vertex.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$meshUVSpaceRenderer$2e$fragment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/meshUVSpaceRenderer.fragment.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$meshUVSpaceRendererMasker$2e$vertex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/meshUVSpaceRendererMasker.vertex.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$meshUVSpaceRendererMasker$2e$fragment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/meshUVSpaceRendererMasker.fragment.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$meshUVSpaceRendererFinaliser$2e$fragment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/meshUVSpaceRendererFinaliser.fragment.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$meshUVSpaceRendererFinaliser$2e$vertex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/meshUVSpaceRendererFinaliser.vertex.js [app-client] (ecmascript)");
}),
]);

//# sourceMappingURL=dcdbf_%40babylonjs_core_Meshes_128fc171._.js.map