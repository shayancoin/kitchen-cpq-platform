module.exports = [
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/observable.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "EventState",
    ()=>EventState,
    "Observable",
    ()=>Observable,
    "Observer",
    ()=>Observer
]);
const IsWeakRefSupported = typeof WeakRef !== "undefined";
class EventState {
    /**
     * Create a new EventState
     * @param mask defines the mask associated with this state
     * @param skipNextObservers defines a flag which will instruct the observable to skip following observers when set to true
     * @param target defines the original target of the state
     * @param currentTarget defines the current target of the state
     */ constructor(mask, skipNextObservers = false, target, currentTarget){
        this.initialize(mask, skipNextObservers, target, currentTarget);
    }
    /**
     * Initialize the current event state
     * @param mask defines the mask associated with this state
     * @param skipNextObservers defines a flag which will instruct the observable to skip following observers when set to true
     * @param target defines the original target of the state
     * @param currentTarget defines the current target of the state
     * @returns the current event state
     */ initialize(mask, skipNextObservers = false, target, currentTarget) {
        this.mask = mask;
        this.skipNextObservers = skipNextObservers;
        this.target = target;
        this.currentTarget = currentTarget;
        return this;
    }
}
class Observer {
    /**
     * Creates a new observer
     * @param callback defines the callback to call when the observer is notified
     * @param mask defines the mask of the observer (used to filter notifications)
     * @param scope defines the current scope used to restore the JS context
     */ constructor(/**
     * Defines the callback to call when the observer is notified
     */ callback, /**
     * Defines the mask of the observer (used to filter notifications)
     */ mask, /**
     * [null] Defines the current scope used to restore the JS context
     */ scope = null){
        this.callback = callback;
        this.mask = mask;
        this.scope = scope;
        /** @internal */ this._willBeUnregistered = false;
        /**
         * Gets or sets a property defining that the observer as to be unregistered after the next notification
         */ this.unregisterOnNextCall = false;
        /**
         * this function can be used to remove the observer from the observable.
         * It will be set by the observable that the observer belongs to.
         * @internal
         */ this._remove = null;
    }
    /**
     * Remove the observer from its observable
     * This can be used instead of using the observable's remove function.
     * @param defer if true, the removal will be deferred to avoid callback skipping (default: false)
     */ remove(defer = false) {
        if (this._remove) {
            this._remove(defer);
        }
    }
}
class Observable {
    /**
     * Create an observable from a Promise.
     * @param promise a promise to observe for fulfillment.
     * @param onErrorObservable an observable to notify if a promise was rejected.
     * @returns the new Observable
     */ static FromPromise(promise, onErrorObservable) {
        const observable = new Observable();
        promise// eslint-disable-next-line github/no-then
        .then((ret)=>{
            observable.notifyObservers(ret);
        })// eslint-disable-next-line github/no-then
        .catch((err)=>{
            if (onErrorObservable) {
                onErrorObservable.notifyObservers(err);
            } else {
                throw err;
            }
        });
        return observable;
    }
    /**
     * Gets the list of observers
     * Note that observers that were recently deleted may still be present in the list because they are only really deleted on the next javascript tick!
     */ get observers() {
        return this._observers;
    }
    /**
     * Creates a new observable
     * @param onObserverAdded defines a callback to call when a new observer is added
     * @param notifyIfTriggered If set to true the observable will notify when an observer was added if the observable was already triggered.
     */ constructor(onObserverAdded, /**
     * [false] If set to true the observable will notify when an observer was added if the observable was already triggered.
     * This is helpful to single-state observables like the scene onReady or the dispose observable.
     */ notifyIfTriggered = false){
        this.notifyIfTriggered = notifyIfTriggered;
        this._observers = new Array();
        this._numObserversMarkedAsDeleted = 0;
        this._hasNotified = false;
        this._eventState = new EventState(0);
        if (onObserverAdded) {
            this._onObserverAdded = onObserverAdded;
        }
    }
    add(callback, mask = -1, insertFirst = false, scope = null, unregisterOnFirstCall = false) {
        if (!callback) {
            return null;
        }
        const observer = new Observer(callback, mask, scope);
        observer.unregisterOnNextCall = unregisterOnFirstCall;
        if (insertFirst) {
            this._observers.unshift(observer);
        } else {
            this._observers.push(observer);
        }
        if (this._onObserverAdded) {
            this._onObserverAdded(observer);
        }
        // If the observable was already triggered and the observable is set to notify if triggered, notify the new observer
        if (this._hasNotified && this.notifyIfTriggered) {
            if (this._lastNotifiedValue !== undefined) {
                this.notifyObserver(observer, this._lastNotifiedValue);
            }
        }
        // attach the remove function to the observer
        const observableWeakRef = IsWeakRefSupported ? new WeakRef(this) : {
            deref: ()=>this
        };
        observer._remove = (defer = false)=>{
            const observable = observableWeakRef.deref();
            if (observable) {
                defer ? observable.remove(observer) : observable._remove(observer);
            }
        };
        return observer;
    }
    addOnce(callback) {
        return this.add(callback, undefined, undefined, undefined, true);
    }
    /**
     * Remove an Observer from the Observable object
     * @param observer the instance of the Observer to remove
     * @returns false if it doesn't belong to this Observable
     */ remove(observer) {
        if (!observer) {
            return false;
        }
        observer._remove = null;
        const index = this._observers.indexOf(observer);
        if (index !== -1) {
            this._deferUnregister(observer);
            return true;
        }
        return false;
    }
    /**
     * Remove a callback from the Observable object
     * @param callback the callback to remove
     * @param scope optional scope. If used only the callbacks with this scope will be removed
     * @returns false if it doesn't belong to this Observable
     */ removeCallback(callback, scope) {
        for(let index = 0; index < this._observers.length; index++){
            const observer = this._observers[index];
            if (observer._willBeUnregistered) {
                continue;
            }
            if (observer.callback === callback && (!scope || scope === observer.scope)) {
                this._deferUnregister(observer);
                return true;
            }
        }
        return false;
    }
    /**
     * @internal
     */ _deferUnregister(observer) {
        if (observer._willBeUnregistered) {
            return;
        }
        this._numObserversMarkedAsDeleted++;
        observer.unregisterOnNextCall = false;
        observer._willBeUnregistered = true;
        setTimeout(()=>{
            this._remove(observer);
        }, 0);
    }
    // This should only be called when not iterating over _observers to avoid callback skipping.
    // Removes an observer from the _observer Array.
    _remove(observer, updateCounter = true) {
        if (!observer) {
            return false;
        }
        const index = this._observers.indexOf(observer);
        if (index !== -1) {
            if (updateCounter) {
                this._numObserversMarkedAsDeleted--;
            }
            this._observers.splice(index, 1);
            return true;
        }
        return false;
    }
    /**
     * Moves the observable to the top of the observer list making it get called first when notified
     * @param observer the observer to move
     */ makeObserverTopPriority(observer) {
        this._remove(observer, false);
        this._observers.unshift(observer);
    }
    /**
     * Moves the observable to the bottom of the observer list making it get called last when notified
     * @param observer the observer to move
     */ makeObserverBottomPriority(observer) {
        this._remove(observer, false);
        this._observers.push(observer);
    }
    /**
     * Notify all Observers by calling their respective callback with the given data
     * Will return true if all observers were executed, false if an observer set skipNextObservers to true, then prevent the subsequent ones to execute
     * @param eventData defines the data to send to all observers
     * @param mask defines the mask of the current notification (observers with incompatible mask (ie mask & observer.mask === 0) will not be notified)
     * @param target defines the original target of the state
     * @param currentTarget defines the current target of the state
     * @param userInfo defines any user info to send to observers
     * @returns false if the complete observer chain was not processed (because one observer set the skipNextObservers to true)
     */ notifyObservers(eventData, mask = -1, target, currentTarget, userInfo) {
        // this prevents potential memory leaks - if an object is disposed but the observable doesn't get cleared.
        if (this.notifyIfTriggered) {
            this._hasNotified = true;
            this._lastNotifiedValue = eventData;
        }
        if (!this._observers.length) {
            return true;
        }
        const state = this._eventState;
        state.mask = mask;
        state.target = target;
        state.currentTarget = currentTarget;
        state.skipNextObservers = false;
        state.lastReturnValue = eventData;
        state.userInfo = userInfo;
        for (const obs of this._observers){
            if (obs._willBeUnregistered) {
                continue;
            }
            if (obs.mask & mask) {
                if (obs.unregisterOnNextCall) {
                    this._deferUnregister(obs);
                }
                if (obs.scope) {
                    state.lastReturnValue = obs.callback.apply(obs.scope, [
                        eventData,
                        state
                    ]);
                } else {
                    state.lastReturnValue = obs.callback(eventData, state);
                }
            }
            if (state.skipNextObservers) {
                return false;
            }
        }
        return true;
    }
    /**
     * Notify a specific observer
     * @param observer defines the observer to notify
     * @param eventData defines the data to be sent to each callback
     * @param mask is used to filter observers defaults to -1
     */ notifyObserver(observer, eventData, mask = -1) {
        // this prevents potential memory leaks - if an object is disposed but the observable doesn't get cleared.
        if (this.notifyIfTriggered) {
            this._hasNotified = true;
            this._lastNotifiedValue = eventData;
        }
        if (observer._willBeUnregistered) {
            return;
        }
        const state = this._eventState;
        state.mask = mask;
        state.skipNextObservers = false;
        if (observer.unregisterOnNextCall) {
            this._deferUnregister(observer);
        }
        observer.callback(eventData, state);
    }
    /**
     * Gets a boolean indicating if the observable has at least one observer
     * @returns true is the Observable has at least one Observer registered
     */ hasObservers() {
        return this._observers.length - this._numObserversMarkedAsDeleted > 0;
    }
    /**
     * Clear the list of observers
     */ clear() {
        while(this._observers.length){
            const o = this._observers.pop();
            if (o) {
                o._remove = null;
            }
        }
        this._onObserverAdded = null;
        this._numObserversMarkedAsDeleted = 0;
        this.cleanLastNotifiedState();
    }
    /**
     * Clean the last notified state - both the internal last value and the has-notified flag
     */ cleanLastNotifiedState() {
        this._hasNotified = false;
        this._lastNotifiedValue = undefined;
    }
    /**
     * Clone the current observable
     * @returns a new observable
     */ clone() {
        const result = new Observable();
        result._observers = this._observers.slice(0);
        return result;
    }
    /**
     * Does this observable handles observer registered with a given mask
     * @param mask defines the mask to be tested
     * @returns whether or not one observer registered with the given mask is handled
     **/ hasSpecificMask(mask = -1) {
        for (const obs of this._observers){
            if (obs.mask & mask || obs.mask === mask) {
                return true;
            }
        }
        return false;
    }
} //# sourceMappingURL=observable.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/arrayTools.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint-disable @typescript-eslint/naming-convention */ /**
 * Returns an array of the given size filled with elements built from the given constructor and the parameters.
 * @param size the number of element to construct and put in the array.
 * @param itemBuilder a callback responsible for creating new instance of item. Called once per array entry.
 * @returns a new array filled with new objects.
 */ __turbopack_context__.s([
    "BuildArray",
    ()=>BuildArray,
    "BuildTuple",
    ()=>BuildTuple,
    "_ObserveArray",
    ()=>_ObserveArray
]);
function BuildArray(size, itemBuilder) {
    const a = [];
    for(let i = 0; i < size; ++i){
        a.push(itemBuilder());
    }
    return a;
}
function BuildTuple(size, itemBuilder) {
    return BuildArray(size, itemBuilder);
}
/**
 * Observes a function and calls the given callback when it is called.
 * @param object Defines the object the function to observe belongs to.
 * @param functionName Defines the name of the function to observe.
 * @param callback Defines the callback to call when the function is called.
 * @returns A function to call to stop observing
 */ function ObserveArrayFunction(object, functionName, callback) {
    // Finds the function to observe
    const oldFunction = object[functionName];
    if (typeof oldFunction !== "function") {
        return null;
    }
    // Creates a new function that calls the callback and the old function
    const newFunction = function() {
        const previousLength = object.length;
        const returnValue = newFunction.previous.apply(object, arguments);
        callback(functionName, previousLength);
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return returnValue;
    };
    // Doublishly links the new function and the old function
    oldFunction.next = newFunction;
    newFunction.previous = oldFunction;
    // Replaces the old function with the new function
    object[functionName] = newFunction;
    // Returns a function to disable the hook
    return ()=>{
        // Only unhook if the function is still hooked
        const previous = newFunction.previous;
        if (!previous) {
            return;
        }
        // Finds the ref to the next function in the chain
        const next = newFunction.next;
        // If in the middle of the chain, link the previous and next functions
        if (next) {
            previous.next = next;
            next.previous = previous;
        } else {
            previous.next = undefined;
            object[functionName] = previous;
        }
        // Lose reference to the previous and next functions
        newFunction.next = undefined;
        newFunction.previous = undefined;
    };
}
/**
 * Defines the list of functions to proxy when observing an array.
 * The scope is currently reduced to the common functions used in the render target render list and the scene cameras.
 */ const observedArrayFunctions = [
    "push",
    "splice",
    "pop",
    "shift",
    "unshift"
];
function _ObserveArray(array, callback) {
    // Observes all the required array functions and stores the unhook functions
    const unObserveFunctions = observedArrayFunctions.map((name)=>{
        return ObserveArrayFunction(array, name, callback);
    });
    // Returns a function that unhook all the observed functions
    return ()=>{
        for (const unObserveFunction of unObserveFunctions){
            unObserveFunction?.();
        }
    };
} //# sourceMappingURL=arrayTools.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/typeStore.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/** @internal */ // eslint-disable-next-line @typescript-eslint/naming-convention
__turbopack_context__.s([
    "GetClass",
    ()=>GetClass,
    "GetClassName",
    ()=>GetClassName,
    "RegisterClass",
    ()=>RegisterClass
]);
const RegisteredTypes = {};
function RegisterClass(className, type) {
    RegisteredTypes[className] = type;
}
function GetClass(fqdn) {
    return RegisteredTypes[fqdn];
}
function GetClassName(obj) {
    for(const key in RegisteredTypes){
        if (obj instanceof RegisteredTypes[key] && !key.includes("Abstract")) {
            return key;
        }
    }
    return "Unknown";
} //# sourceMappingURL=typeStore.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/logger.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint-disable no-console */ /**
 * Logger used throughout the application to allow configuration of
 * the log level required for the messages.
 */ __turbopack_context__.s([
    "Logger",
    ()=>Logger
]);
class Logger {
    static _CheckLimit(message, limit) {
        let entry = Logger._LogLimitOutputs[message];
        if (!entry) {
            entry = {
                limit,
                current: 1
            };
            Logger._LogLimitOutputs[message] = entry;
        } else {
            entry.current++;
        }
        return entry.current <= entry.limit;
    }
    static _GenerateLimitMessage(message, level = 1) {
        const entry = Logger._LogLimitOutputs[message];
        if (!entry || !Logger.MessageLimitReached) {
            return;
        }
        const type = this._Levels[level];
        if (entry.current === entry.limit) {
            Logger[type.name](Logger.MessageLimitReached.replace(/%LIMIT%/g, "" + entry.limit).replace(/%TYPE%/g, type.name ?? ""));
        }
    }
    static _AddLogEntry(entry) {
        Logger._LogCache = entry + Logger._LogCache;
        if (Logger.OnNewCacheEntry) {
            Logger.OnNewCacheEntry(entry);
        }
    }
    static _FormatMessage(message) {
        const padStr = (i)=>i < 10 ? "0" + i : "" + i;
        const date = new Date();
        return "[" + padStr(date.getHours()) + ":" + padStr(date.getMinutes()) + ":" + padStr(date.getSeconds()) + "]: " + message;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static _LogDisabled(message, limit) {
    // nothing to do
    }
    static _LogEnabled(level = 1, message, limit) {
        // take first message if array
        const msg = Array.isArray(message) ? message[0] : message;
        if (limit !== undefined && !Logger._CheckLimit(msg, limit)) {
            return;
        }
        const formattedMessage = Logger._FormatMessage(msg);
        const type = this._Levels[level];
        const optionals = Array.isArray(message) ? message.slice(1) : [];
        type.logFunc && type.logFunc("BJS - " + formattedMessage, ...optionals);
        const entry = `<div style='color:${type.color}'>${formattedMessage}</div><br>`;
        Logger._AddLogEntry(entry);
        Logger._GenerateLimitMessage(msg, level);
    }
    /**
     * Gets current log cache (list of logs)
     */ static get LogCache() {
        return Logger._LogCache;
    }
    /**
     * Clears the log cache
     */ static ClearLogCache() {
        Logger._LogCache = "";
        Logger._LogLimitOutputs = {};
        Logger.errorsCount = 0;
    }
    /**
     * Sets the current log level. This property is a bit field, allowing you to combine different levels (MessageLogLevel / WarningLogLevel / ErrorLogLevel).
     * Use NoneLogLevel to disable logging and AllLogLevel for a quick way to enable all levels.
     */ static set LogLevels(level) {
        Logger.Log = Logger._LogDisabled;
        Logger.Warn = Logger._LogDisabled;
        Logger.Error = Logger._LogDisabled;
        const levels = [
            Logger.MessageLogLevel,
            Logger.WarningLogLevel,
            Logger.ErrorLogLevel
        ];
        for (const l of levels){
            if ((level & l) === l) {
                const type = this._Levels[l];
                Logger[type.name] = Logger._LogEnabled.bind(Logger, l);
            }
        }
    }
}
/**
 * No log
 */ Logger.NoneLogLevel = 0;
/**
 * Only message logs
 */ Logger.MessageLogLevel = 1;
/**
 * Only warning logs
 */ Logger.WarningLogLevel = 2;
/**
 * Only error logs
 */ Logger.ErrorLogLevel = 4;
/**
 * All logs
 */ Logger.AllLogLevel = 7;
/**
 * Message to display when a message has been logged too many times
 */ Logger.MessageLimitReached = "Too many %TYPE%s (%LIMIT%), no more %TYPE%s will be reported for this message.";
Logger._LogCache = "";
Logger._LogLimitOutputs = {};
// levels according to the (binary) numbering.
Logger._Levels = [
    {},
    {
        color: "white",
        logFunc: console.log,
        name: "Log"
    },
    {
        color: "orange",
        logFunc: console.warn,
        name: "Warn"
    },
    {},
    {
        color: "red",
        logFunc: console.error,
        name: "Error"
    }
];
/**
 * Gets a value indicating the number of loading errors
 * @ignorenaming
 */ // eslint-disable-next-line @typescript-eslint/naming-convention
Logger.errorsCount = 0;
/**
 * Log a message to the console
 */ Logger.Log = Logger._LogEnabled.bind(Logger, Logger.MessageLogLevel);
/**
 * Write a warning message to the console
 */ Logger.Warn = Logger._LogEnabled.bind(Logger, Logger.WarningLogLevel);
/**
 * Write an error message to the console
 */ Logger.Error = Logger._LogEnabled.bind(Logger, Logger.ErrorLogLevel); //# sourceMappingURL=logger.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/deepCopier.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DeepCopier",
    ()=>DeepCopier
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/logger.js [app-ssr] (ecmascript)");
;
const CloneValue = (source, destinationObject, shallowCopyValues)=>{
    if (!source) {
        return null;
    }
    if (source.getClassName && source.getClassName() === "Mesh") {
        return null;
    }
    if (source.getClassName && (source.getClassName() === "SubMesh" || source.getClassName() === "PhysicsBody")) {
        return source.clone(destinationObject);
    } else if (source.clone) {
        return source.clone();
    } else if (Array.isArray(source)) {
        return source.slice();
    } else if (shallowCopyValues && typeof source === "object") {
        return {
            ...source
        };
    }
    return null;
};
function GetAllPropertyNames(obj) {
    const props = [];
    do {
        const propNames = Object.getOwnPropertyNames(obj);
        for (const prop of propNames){
            if (props.indexOf(prop) === -1) {
                props.push(prop);
            }
        }
    }while (obj = Object.getPrototypeOf(obj))
    return props;
}
class DeepCopier {
    /**
     * Tries to copy an object by duplicating every property
     * @param source defines the source object
     * @param destination defines the target object
     * @param doNotCopyList defines a list of properties to avoid
     * @param mustCopyList defines a list of properties to copy (even if they start with _)
     * @param shallowCopyValues defines wether properties referencing objects (none cloneable) must be shallow copied (false by default)
     * @remarks shallowCopyValues will not instantite the copied values which makes it only usable for "JSON objects"
     */ static DeepCopy(source, destination, doNotCopyList, mustCopyList, shallowCopyValues = false) {
        const properties = GetAllPropertyNames(source);
        for (const prop of properties){
            if (prop[0] === "_" && (!mustCopyList || mustCopyList.indexOf(prop) === -1)) {
                continue;
            }
            if (prop.endsWith("Observable")) {
                continue;
            }
            if (doNotCopyList && doNotCopyList.indexOf(prop) !== -1) {
                continue;
            }
            const sourceValue = source[prop];
            const typeOfSourceValue = typeof sourceValue;
            if (typeOfSourceValue === "function") {
                continue;
            }
            try {
                if (typeOfSourceValue === "object") {
                    if (sourceValue instanceof Uint8Array) {
                        destination[prop] = Uint8Array.from(sourceValue);
                    } else if (sourceValue instanceof Array) {
                        destination[prop] = [];
                        if (sourceValue.length > 0) {
                            if (typeof sourceValue[0] == "object") {
                                for(let index = 0; index < sourceValue.length; index++){
                                    const clonedValue = CloneValue(sourceValue[index], destination, shallowCopyValues);
                                    if (destination[prop].indexOf(clonedValue) === -1) {
                                        // Test if auto inject was not done
                                        destination[prop].push(clonedValue);
                                    }
                                }
                            } else {
                                destination[prop] = sourceValue.slice(0);
                            }
                        }
                    } else {
                        destination[prop] = CloneValue(sourceValue, destination, shallowCopyValues);
                    }
                } else {
                    destination[prop] = sourceValue;
                }
            } catch (e) {
                // Log a warning (it could be because of a read-only property)
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Warn(e.message);
            }
        }
    }
} //# sourceMappingURL=deepCopier.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/decorators.functions.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GetDirectStore",
    ()=>GetDirectStore,
    "GetMergedStore",
    ()=>GetMergedStore
]);
const MergedStore = {};
const DecoratorInitialStore = {};
function GetDirectStore(target) {
    const classKey = target.getClassName();
    if (!DecoratorInitialStore[classKey]) {
        DecoratorInitialStore[classKey] = {};
    }
    return DecoratorInitialStore[classKey];
}
function GetMergedStore(target) {
    const classKey = target.getClassName();
    if (MergedStore[classKey]) {
        return MergedStore[classKey];
    }
    MergedStore[classKey] = {};
    const store = MergedStore[classKey];
    let currentTarget = target;
    let currentKey = classKey;
    while(currentKey){
        const initialStore = DecoratorInitialStore[currentKey];
        for(const property in initialStore){
            store[property] = initialStore[property];
        }
        let parent;
        let done = false;
        do {
            parent = Object.getPrototypeOf(currentTarget);
            if (!parent.getClassName) {
                done = true;
                break;
            }
            if (parent.getClassName() !== currentKey) {
                break;
            }
            currentTarget = parent;
        }while (parent)
        if (done) {
            break;
        }
        currentKey = parent.getClassName();
        currentTarget = parent;
    }
    return store;
} //# sourceMappingURL=decorators.functions.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/decorators.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "addAccessorsForMaterialProperty",
    ()=>addAccessorsForMaterialProperty,
    "expandToProperty",
    ()=>expandToProperty,
    "nativeOverride",
    ()=>nativeOverride,
    "serialize",
    ()=>serialize,
    "serializeAsCameraReference",
    ()=>serializeAsCameraReference,
    "serializeAsColor3",
    ()=>serializeAsColor3,
    "serializeAsColor4",
    ()=>serializeAsColor4,
    "serializeAsColorCurves",
    ()=>serializeAsColorCurves,
    "serializeAsFresnelParameters",
    ()=>serializeAsFresnelParameters,
    "serializeAsImageProcessingConfiguration",
    ()=>serializeAsImageProcessingConfiguration,
    "serializeAsMatrix",
    ()=>serializeAsMatrix,
    "serializeAsMeshReference",
    ()=>serializeAsMeshReference,
    "serializeAsQuaternion",
    ()=>serializeAsQuaternion,
    "serializeAsTexture",
    ()=>serializeAsTexture,
    "serializeAsVector2",
    ()=>serializeAsVector2,
    "serializeAsVector3",
    ()=>serializeAsVector3
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/decorators.functions.js [app-ssr] (ecmascript)");
;
function generateSerializableMember(type, sourceName) {
    return (target, propertyKey)=>{
        const classStore = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GetDirectStore"])(target);
        if (!classStore[propertyKey]) {
            classStore[propertyKey] = {
                type: type,
                sourceName: sourceName
            };
        }
    };
}
function generateExpandMember(setCallback, targetKey = null) {
    return (target, propertyKey)=>{
        const key = targetKey || "_" + propertyKey;
        Object.defineProperty(target, propertyKey, {
            get: function() {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                return this[key];
            },
            set: function(value) {
                // does this object (i.e. vector3) has an equals function? use it!
                // Note - not using "with epsilon" here, it is expected te behave like the internal cache does.
                if (typeof this[key]?.equals === "function") {
                    if (this[key].equals(value)) {
                        return;
                    }
                }
                if (this[key] === value) {
                    return;
                }
                this[key] = value;
                target[setCallback].apply(this);
            },
            enumerable: true,
            configurable: true
        });
    };
}
function expandToProperty(callback, targetKey = null) {
    return generateExpandMember(callback, targetKey);
}
function serialize(sourceName) {
    return generateSerializableMember(0, sourceName); // value member
}
function serializeAsTexture(sourceName) {
    return generateSerializableMember(1, sourceName); // texture member
}
function serializeAsColor3(sourceName) {
    return generateSerializableMember(2, sourceName); // color3 member
}
function serializeAsFresnelParameters(sourceName) {
    return generateSerializableMember(3, sourceName); // fresnel parameters member
}
function serializeAsVector2(sourceName) {
    return generateSerializableMember(4, sourceName); // vector2 member
}
function serializeAsVector3(sourceName) {
    return generateSerializableMember(5, sourceName); // vector3 member
}
function serializeAsMeshReference(sourceName) {
    return generateSerializableMember(6, sourceName); // mesh reference member
}
function serializeAsColorCurves(sourceName) {
    return generateSerializableMember(7, sourceName); // color curves
}
function serializeAsColor4(sourceName) {
    return generateSerializableMember(8, sourceName); // color 4
}
function serializeAsImageProcessingConfiguration(sourceName) {
    return generateSerializableMember(9, sourceName); // image processing
}
function serializeAsQuaternion(sourceName) {
    return generateSerializableMember(10, sourceName); // quaternion member
}
function serializeAsMatrix(sourceName) {
    return generateSerializableMember(12, sourceName); // matrix member
}
function serializeAsCameraReference(sourceName) {
    return generateSerializableMember(11, sourceName); // camera reference member
}
function nativeOverride(target, propertyKey, descriptor, predicate) {
    // Cache the original JS function for later.
    const jsFunc = descriptor.value;
    // Override the JS function to check for a native override on first invocation. Setting descriptor.value overrides the function at the early stage of code being loaded/imported.
    descriptor.value = (...params)=>{
        // Assume the resolved function will be the original JS function, then we will check for the Babylon Native context.
        let func = jsFunc;
        // Check if we are executing in a Babylon Native context (e.g. check the presence of the _native global property) and if so also check if a function override is available.
        if (typeof _native !== "undefined" && _native[propertyKey]) {
            const nativeFunc = _native[propertyKey];
            // If a predicate was provided, then we'll need to invoke the predicate on each invocation of the underlying function to determine whether to call the native function or the JS function.
            if (predicate) {
                // The resolved function will execute the predicate and then either execute the native function or the JS function.
                func = (...params)=>predicate(...params) ? nativeFunc(...params) : jsFunc(...params);
            } else {
                // The resolved function will directly execute the native function.
                func = nativeFunc;
            }
        }
        // Override the JS function again with the final resolved target function.
        target[propertyKey] = func;
        // The JS function has now been overridden based on whether we're executing in the context of Babylon Native, but we still need to invoke that function.
        // Future invocations of the function will just directly invoke the final overridden function, not any of the decorator setup logic above.
        return func(...params);
    };
}
/**
 * Decorator factory that applies the nativeOverride decorator, but determines whether to redirect to the native implementation based on a filter function that evaluates the function arguments.
 * @param predicate
 * @example @nativeOverride.filter((...[arg1]: Parameters<typeof someClass.someMethod>) => arg1.length > 20)
 *          public someMethod(arg1: string, arg2: number): string {
 * @internal
 */ nativeOverride.filter = function(predicate) {
    return (target, propertyKey, descriptor)=>nativeOverride(target, propertyKey, descriptor, predicate);
};
function addAccessorsForMaterialProperty(setCallback, targetKey = null) {
    return (target, propertyKey)=>{
        const key = propertyKey;
        const newKey = targetKey || "";
        Object.defineProperty(target, newKey, {
            get: function() {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                return this[key].value;
            },
            set: function(value) {
                // does this object (i.e. vector3) has an equals function? use it!
                // Note - not using "with epsilon" here, it is expected te behave like the internal cache does.
                if (typeof this[key]?.value?.equals === "function") {
                    if (this[key].value.equals(value)) {
                        return;
                    }
                }
                if (this[key].value === value) {
                    return;
                }
                this[key].value = value;
                target[setCallback].apply(this);
            },
            enumerable: true,
            configurable: true
        });
    };
} //# sourceMappingURL=decorators.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/devTools.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_WarnImport",
    ()=>_WarnImport
]);
const WarnedMap = {};
function _WarnImport(name, warnOnce = false) {
    if (warnOnce && WarnedMap[name]) {
        return;
    }
    WarnedMap[name] = true;
    return `${name} needs to be imported before as it contains a side-effect required by your code.`;
} //# sourceMappingURL=devTools.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/andOrNotEvaluator.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Class used to evaluate queries containing `and` and `or` operators
 */ __turbopack_context__.s([
    "AndOrNotEvaluator",
    ()=>AndOrNotEvaluator
]);
class AndOrNotEvaluator {
    /**
     * Evaluate a query
     * @param query defines the query to evaluate
     * @param evaluateCallback defines the callback used to filter result
     * @returns true if the query matches
     */ static Eval(query, evaluateCallback) {
        if (!query.match(/\([^()]*\)/g)) {
            query = AndOrNotEvaluator._HandleParenthesisContent(query, evaluateCallback);
        } else {
            query = query.replace(/\([^()]*\)/g, (r)=>{
                // remove parenthesis
                r = r.slice(1, r.length - 1);
                return AndOrNotEvaluator._HandleParenthesisContent(r, evaluateCallback);
            });
        }
        if (query === "true") {
            return true;
        }
        if (query === "false") {
            return false;
        }
        return AndOrNotEvaluator.Eval(query, evaluateCallback);
    }
    static _HandleParenthesisContent(parenthesisContent, evaluateCallback) {
        evaluateCallback = evaluateCallback || ((r)=>{
            return r === "true" ? true : false;
        });
        let result;
        const or = parenthesisContent.split("||");
        for(const i in or){
            if (Object.prototype.hasOwnProperty.call(or, i)) {
                let ori = AndOrNotEvaluator._SimplifyNegation(or[i].trim());
                const and = ori.split("&&");
                if (and.length > 1) {
                    for(let j = 0; j < and.length; ++j){
                        const andj = AndOrNotEvaluator._SimplifyNegation(and[j].trim());
                        if (andj !== "true" && andj !== "false") {
                            if (andj[0] === "!") {
                                result = !evaluateCallback(andj.substring(1));
                            } else {
                                result = evaluateCallback(andj);
                            }
                        } else {
                            result = andj === "true" ? true : false;
                        }
                        if (!result) {
                            // no need to continue since 'false && ... && ...' will always return false
                            ori = "false";
                            break;
                        }
                    }
                }
                if (result || ori === "true") {
                    // no need to continue since 'true || ... || ...' will always return true
                    result = true;
                    break;
                }
                // result equals false (or undefined)
                if (ori !== "true" && ori !== "false") {
                    if (ori[0] === "!") {
                        result = !evaluateCallback(ori.substring(1));
                    } else {
                        result = evaluateCallback(ori);
                    }
                } else {
                    result = ori === "true" ? true : false;
                }
            }
        }
        // the whole parenthesis scope is replaced by 'true' or 'false'
        return result ? "true" : "false";
    }
    static _SimplifyNegation(booleanString) {
        booleanString = booleanString.replace(/^[\s!]+/, (r)=>{
            // remove whitespaces
            r = r.replace(/[\s]/g, ()=>"");
            return r.length % 2 ? "!" : "";
        });
        booleanString = booleanString.trim();
        if (booleanString === "!true") {
            booleanString = "false";
        } else if (booleanString === "!false") {
            booleanString = "true";
        }
        return booleanString;
    }
} //# sourceMappingURL=andOrNotEvaluator.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tags.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Tags",
    ()=>Tags
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$andOrNotEvaluator$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/andOrNotEvaluator.js [app-ssr] (ecmascript)");
;
class Tags {
    /**
     * Adds support for tags on the given object
     * @param obj defines the object to use
     */ static EnableFor(obj) {
        obj._tags = obj._tags || {};
        obj.hasTags = ()=>{
            return Tags.HasTags(obj);
        };
        obj.addTags = (tagsString)=>{
            return Tags.AddTagsTo(obj, tagsString);
        };
        obj.removeTags = (tagsString)=>{
            return Tags.RemoveTagsFrom(obj, tagsString);
        };
        obj.matchesTagsQuery = (tagsQuery)=>{
            return Tags.MatchesQuery(obj, tagsQuery);
        };
    }
    /**
     * Removes tags support
     * @param obj defines the object to use
     */ static DisableFor(obj) {
        delete obj._tags;
        delete obj.hasTags;
        delete obj.addTags;
        delete obj.removeTags;
        delete obj.matchesTagsQuery;
    }
    /**
     * Gets a boolean indicating if the given object has tags
     * @param obj defines the object to use
     * @returns a boolean
     */ static HasTags(obj) {
        if (!obj._tags) {
            return false;
        }
        const tags = obj._tags;
        for(const i in tags){
            if (Object.prototype.hasOwnProperty.call(tags, i)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Gets the tags available on a given object
     * @param obj defines the object to use
     * @param asString defines if the tags must be returned as a string instead of an array of strings
     * @returns the tags
     */ static GetTags(obj, asString = true) {
        if (!obj._tags) {
            return null;
        }
        if (asString) {
            const tagsArray = [];
            for(const tag in obj._tags){
                if (Object.prototype.hasOwnProperty.call(obj._tags, tag) && obj._tags[tag] === true) {
                    tagsArray.push(tag);
                }
            }
            return tagsArray.join(" ");
        } else {
            return obj._tags;
        }
    }
    /**
     * Adds tags to an object
     * @param obj defines the object to use
     * @param tagsString defines the tag string. The tags 'true' and 'false' are reserved and cannot be used as tags.
     * A tag cannot start with '||', '&&', and '!'. It cannot contain whitespaces
     */ static AddTagsTo(obj, tagsString) {
        if (!tagsString) {
            return;
        }
        if (typeof tagsString !== "string") {
            return;
        }
        const tags = tagsString.split(" ");
        for (const tag of tags){
            Tags._AddTagTo(obj, tag);
        }
    }
    /**
     * @internal
     */ static _AddTagTo(obj, tag) {
        tag = tag.trim();
        if (tag === "" || tag === "true" || tag === "false") {
            return;
        }
        if (tag.match(/[\s]/) || tag.match(/^([!]|([|]|[&]){2})/)) {
            return;
        }
        Tags.EnableFor(obj);
        obj._tags[tag] = true;
    }
    /**
     * Removes specific tags from a specific object
     * @param obj defines the object to use
     * @param tagsString defines the tags to remove
     */ static RemoveTagsFrom(obj, tagsString) {
        if (!Tags.HasTags(obj)) {
            return;
        }
        const tags = tagsString.split(" ");
        for(const t in tags){
            Tags._RemoveTagFrom(obj, tags[t]);
        }
    }
    /**
     * @internal
     */ static _RemoveTagFrom(obj, tag) {
        delete obj._tags[tag];
    }
    /**
     * Defines if tags hosted on an object match a given query
     * @param obj defines the object to use
     * @param tagsQuery defines the tag query
     * @returns a boolean
     */ static MatchesQuery(obj, tagsQuery) {
        if (tagsQuery === undefined) {
            return true;
        }
        if (tagsQuery === "") {
            return Tags.HasTags(obj);
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$andOrNotEvaluator$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AndOrNotEvaluator"].Eval(tagsQuery, (r)=>Tags.HasTags(obj) && obj._tags[r]);
    }
} //# sourceMappingURL=tags.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/decorators.serialization.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SerializationHelper",
    ()=>SerializationHelper
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$devTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/devTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tags$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tags.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$color$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.color.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/decorators.functions.js [app-ssr] (ecmascript)");
;
;
;
;
;
const CopySource = function(creationFunction, source, instanciate, options = {}) {
    const destination = creationFunction();
    // Tags
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tags$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tags"] && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tags$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tags"].HasTags(source)) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tags$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tags"].AddTagsTo(destination, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tags$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tags"].GetTags(source, true));
    }
    const classStore = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GetMergedStore"])(destination);
    // Map from source texture uniqueId to destination texture
    const textureMap = {};
    // Properties
    for(const property in classStore){
        const propertyDescriptor = classStore[property];
        const sourceProperty = source[property];
        const propertyType = propertyDescriptor.type;
        if (sourceProperty !== undefined && sourceProperty !== null && (property !== "uniqueId" || SerializationHelper.AllowLoadingUniqueId)) {
            switch(propertyType){
                case 0:
                case 6:
                case 9:
                case 11:
                    destination[property] = sourceProperty;
                    break;
                case 1:
                    if (options.cloneTexturesOnlyOnce && textureMap[sourceProperty.uniqueId]) {
                        destination[property] = textureMap[sourceProperty.uniqueId];
                    } else {
                        destination[property] = instanciate || sourceProperty.isRenderTarget ? sourceProperty : sourceProperty.clone();
                        textureMap[sourceProperty.uniqueId] = destination[property];
                    }
                    break;
                case 2:
                case 3:
                case 4:
                case 5:
                case 7:
                case 8:
                case 10:
                case 12:
                    destination[property] = instanciate ? sourceProperty : sourceProperty.clone();
                    break;
            }
        }
    }
    return destination;
};
class SerializationHelper {
    /**
     * Appends the serialized animations from the source animations
     * @param source Source containing the animations
     * @param destination Target to store the animations
     */ static AppendSerializedAnimations(source, destination) {
        if (source.animations) {
            destination.animations = [];
            for(let animationIndex = 0; animationIndex < source.animations.length; animationIndex++){
                const animation = source.animations[animationIndex];
                destination.animations.push(animation.serialize());
            }
        }
    }
    /**
     * Static function used to serialized a specific entity
     * @param entity defines the entity to serialize
     * @param serializationObject defines the optional target object where serialization data will be stored
     * @returns a JSON compatible object representing the serialization of the entity
     */ static Serialize(entity, serializationObject) {
        if (!serializationObject) {
            serializationObject = {};
        }
        // Tags
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tags$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tags"]) {
            serializationObject.tags = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tags$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tags"].GetTags(entity);
        }
        const serializedProperties = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GetMergedStore"])(entity);
        // Properties
        for(const property in serializedProperties){
            const propertyDescriptor = serializedProperties[property];
            const targetPropertyName = propertyDescriptor.sourceName || property;
            const propertyType = propertyDescriptor.type;
            const sourceProperty = entity[property];
            if (sourceProperty !== undefined && sourceProperty !== null && (property !== "uniqueId" || SerializationHelper.AllowLoadingUniqueId)) {
                switch(propertyType){
                    case 0:
                        if (Array.isArray(sourceProperty)) {
                            serializationObject[targetPropertyName] = sourceProperty.slice();
                        } else {
                            serializationObject[targetPropertyName] = sourceProperty;
                        }
                        break;
                    case 1:
                        serializationObject[targetPropertyName] = sourceProperty.serialize();
                        break;
                    case 2:
                        serializationObject[targetPropertyName] = sourceProperty.asArray();
                        break;
                    case 3:
                        serializationObject[targetPropertyName] = sourceProperty.serialize();
                        break;
                    case 4:
                        serializationObject[targetPropertyName] = sourceProperty.asArray();
                        break;
                    case 5:
                        serializationObject[targetPropertyName] = sourceProperty.asArray();
                        break;
                    case 6:
                        serializationObject[targetPropertyName] = sourceProperty.id;
                        break;
                    case 7:
                        serializationObject[targetPropertyName] = sourceProperty.serialize();
                        break;
                    case 8:
                        serializationObject[targetPropertyName] = sourceProperty.asArray();
                        break;
                    case 9:
                        serializationObject[targetPropertyName] = sourceProperty.serialize();
                        break;
                    case 10:
                        serializationObject[targetPropertyName] = sourceProperty.asArray();
                        break;
                    case 11:
                        serializationObject[targetPropertyName] = sourceProperty.id;
                        break;
                    case 12:
                        serializationObject[targetPropertyName] = sourceProperty.asArray();
                        break;
                }
            }
        }
        return serializationObject;
    }
    /**
     * Given a source json and a destination object in a scene, this function will parse the source and will try to apply its content to the destination object
     * @param source the source json data
     * @param destination the destination object
     * @param scene the scene where the object is
     * @param rootUrl root url to use to load assets
     */ static ParseProperties(source, destination, scene, rootUrl) {
        if (!rootUrl) {
            rootUrl = "";
        }
        const classStore = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GetMergedStore"])(destination);
        // Properties
        for(const property in classStore){
            const propertyDescriptor = classStore[property];
            const sourceProperty = source[propertyDescriptor.sourceName || property];
            const propertyType = propertyDescriptor.type;
            if (sourceProperty !== undefined && sourceProperty !== null && (property !== "uniqueId" || SerializationHelper.AllowLoadingUniqueId)) {
                const dest = destination;
                switch(propertyType){
                    case 0:
                        dest[property] = sourceProperty;
                        break;
                    case 1:
                        if (scene) {
                            dest[property] = SerializationHelper._TextureParser(sourceProperty, scene, rootUrl);
                        }
                        break;
                    case 2:
                        dest[property] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$color$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color3"].FromArray(sourceProperty);
                        break;
                    case 3:
                        dest[property] = SerializationHelper._FresnelParametersParser(sourceProperty);
                        break;
                    case 4:
                        dest[property] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"].FromArray(sourceProperty);
                        break;
                    case 5:
                        dest[property] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"].FromArray(sourceProperty);
                        break;
                    case 6:
                        if (scene) {
                            dest[property] = scene.getLastMeshById(sourceProperty);
                        }
                        break;
                    case 7:
                        dest[property] = SerializationHelper._ColorCurvesParser(sourceProperty);
                        break;
                    case 8:
                        dest[property] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$color$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color4"].FromArray(sourceProperty);
                        break;
                    case 9:
                        dest[property] = SerializationHelper._ImageProcessingConfigurationParser(sourceProperty);
                        break;
                    case 10:
                        dest[property] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Quaternion"].FromArray(sourceProperty);
                        break;
                    case 11:
                        if (scene) {
                            dest[property] = scene.getCameraById(sourceProperty);
                        }
                        break;
                    case 12:
                        dest[property] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"].FromArray(sourceProperty);
                        break;
                }
            }
        }
    }
    /**
     * Creates a new entity from a serialization data object
     * @param creationFunction defines a function used to instanciated the new entity
     * @param source defines the source serialization data
     * @param scene defines the hosting scene
     * @param rootUrl defines the root url for resources
     * @returns a new entity
     */ static Parse(creationFunction, source, scene, rootUrl = null) {
        const destination = creationFunction();
        // Tags
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tags$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tags"]) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tags$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tags"].AddTagsTo(destination, source.tags);
        }
        SerializationHelper.ParseProperties(source, destination, scene, rootUrl);
        return destination;
    }
    /**
     * Clones an object
     * @param creationFunction defines the function used to instanciate the new object
     * @param source defines the source object
     * @param options defines the options to use
     * @returns the cloned object
     */ static Clone(creationFunction, source, options = {}) {
        return CopySource(creationFunction, source, false, options);
    }
    /**
     * Instanciates a new object based on a source one (some data will be shared between both object)
     * @param creationFunction defines the function used to instanciate the new object
     * @param source defines the source object
     * @returns the new object
     */ static Instanciate(creationFunction, source) {
        return CopySource(creationFunction, source, true);
    }
}
/**
 * Gets or sets a boolean to indicate if the UniqueId property should be serialized
 */ SerializationHelper.AllowLoadingUniqueId = false;
/**
 * @internal
 */ SerializationHelper._ImageProcessingConfigurationParser = (sourceProperty)=>{
    throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$devTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_WarnImport"])("ImageProcessingConfiguration");
};
/**
 * @internal
 */ SerializationHelper._FresnelParametersParser = (sourceProperty)=>{
    throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$devTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_WarnImport"])("FresnelParameters");
};
/**
 * @internal
 */ SerializationHelper._ColorCurvesParser = (sourceProperty)=>{
    throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$devTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_WarnImport"])("ColorCurves");
};
/**
 * @internal
 */ SerializationHelper._TextureParser = (sourceProperty, scene, rootUrl)=>{
    throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$devTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_WarnImport"])("Texture");
}; //# sourceMappingURL=decorators.serialization.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/webRequest.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/** @internal */ // eslint-disable-next-line @typescript-eslint/naming-convention
__turbopack_context__.s([
    "WebRequest",
    ()=>WebRequest
]);
function createXMLHttpRequest() {
    // If running in Babylon Native, then defer to the native XMLHttpRequest, which has the same public contract
    if (typeof _native !== "undefined" && _native.XMLHttpRequest) {
        return new _native.XMLHttpRequest();
    } else {
        return new XMLHttpRequest();
    }
}
class WebRequest {
    constructor(){
        this._xhr = createXMLHttpRequest();
        this._requestURL = "";
    }
    /**
     * This function can be called to check if there are request modifiers for network requests
     * @returns true if there are any custom requests available
     */ static get IsCustomRequestAvailable() {
        return Object.keys(WebRequest.CustomRequestHeaders).length > 0 || WebRequest.CustomRequestModifiers.length > 0;
    }
    /**
     * Returns the requested URL once open has been called
     */ get requestURL() {
        return this._requestURL;
    }
    _injectCustomRequestHeaders() {
        if (this._shouldSkipRequestModifications(this._requestURL)) {
            return;
        }
        for(const key in WebRequest.CustomRequestHeaders){
            const val = WebRequest.CustomRequestHeaders[key];
            if (val) {
                this._xhr.setRequestHeader(key, val);
            }
        }
    }
    _shouldSkipRequestModifications(url) {
        return WebRequest.SkipRequestModificationForBabylonCDN && (url.includes("preview.babylonjs.com") || url.includes("cdn.babylonjs.com"));
    }
    /**
     * Gets or sets a function to be called when loading progress changes
     */ get onprogress() {
        return this._xhr.onprogress;
    }
    set onprogress(value) {
        this._xhr.onprogress = value;
    }
    /**
     * Returns client's state
     */ get readyState() {
        return this._xhr.readyState;
    }
    /**
     * Returns client's status
     */ get status() {
        return this._xhr.status;
    }
    /**
     * Returns client's status as a text
     */ get statusText() {
        return this._xhr.statusText;
    }
    /**
     * Returns client's response
     */ get response() {
        return this._xhr.response;
    }
    /**
     * Returns client's response url
     */ get responseURL() {
        return this._xhr.responseURL;
    }
    /**
     * Returns client's response as text
     */ get responseText() {
        return this._xhr.responseText;
    }
    /**
     * Gets or sets the expected response type
     */ get responseType() {
        return this._xhr.responseType;
    }
    set responseType(value) {
        this._xhr.responseType = value;
    }
    /**
     * Gets or sets the timeout value in milliseconds
     */ get timeout() {
        return this._xhr.timeout;
    }
    set timeout(value) {
        this._xhr.timeout = value;
    }
    addEventListener(type, listener, options) {
        this._xhr.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
        this._xhr.removeEventListener(type, listener, options);
    }
    /**
     * Cancels any network activity
     */ abort() {
        this._xhr.abort();
    }
    /**
     * Initiates the request. The optional argument provides the request body. The argument is ignored if request method is GET or HEAD
     * @param body defines an optional request body
     */ send(body) {
        if (WebRequest.CustomRequestHeaders) {
            this._injectCustomRequestHeaders();
        }
        this._xhr.send(body);
    }
    /**
     * Sets the request method, request URL
     * @param method defines the method to use (GET, POST, etc..)
     * @param url defines the url to connect with
     */ open(method, url) {
        for (const update of WebRequest.CustomRequestModifiers){
            if (this._shouldSkipRequestModifications(url)) {
                return;
            }
            url = update(this._xhr, url) || url;
        }
        // Clean url
        url = url.replace("file:http:", "http:");
        url = url.replace("file:https:", "https:");
        this._requestURL = url;
        this._xhr.open(method, url, true);
    }
    /**
     * Sets the value of a request header.
     * @param name The name of the header whose value is to be set
     * @param value The value to set as the body of the header
     */ setRequestHeader(name, value) {
        this._xhr.setRequestHeader(name, value);
    }
    /**
     * Get the string containing the text of a particular header's value.
     * @param name The name of the header
     * @returns The string containing the text of the given header name
     */ getResponseHeader(name) {
        return this._xhr.getResponseHeader(name);
    }
}
/**
 * Custom HTTP Request Headers to be sent with XMLHttpRequests
 * i.e. when loading files, where the server/service expects an Authorization header
 */ WebRequest.CustomRequestHeaders = {};
/**
 * Add callback functions in this array to update all the requests before they get sent to the network
 */ WebRequest.CustomRequestModifiers = new Array();
/**
 * If set to true, requests to Babylon.js CDN requests will not be modified
 */ WebRequest.SkipRequestModificationForBabylonCDN = true; //# sourceMappingURL=webRequest.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/domManagement.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint-disable @typescript-eslint/naming-convention */ /**
 * Checks if the window object exists
 * @returns true if the window object exists
 */ __turbopack_context__.s([
    "DomManagement",
    ()=>DomManagement,
    "GetDOMTextContent",
    ()=>GetDOMTextContent,
    "IsDocumentAvailable",
    ()=>IsDocumentAvailable,
    "IsNavigatorAvailable",
    ()=>IsNavigatorAvailable,
    "IsWindowObjectExist",
    ()=>IsWindowObjectExist
]);
function IsWindowObjectExist() {
    return ("TURBOPACK compile-time value", "undefined") !== "undefined";
}
function IsNavigatorAvailable() {
    return typeof navigator !== "undefined";
}
function IsDocumentAvailable() {
    return typeof document !== "undefined";
}
function GetDOMTextContent(element) {
    let result = "";
    let child = element.firstChild;
    while(child){
        if (child.nodeType === 3) {
            result += child.textContent;
        }
        child = child.nextSibling;
    }
    return result;
}
const DomManagement = {
    /**
     * Checks if the window object exists
     * @returns true if the window object exists
     */ IsWindowObjectExist,
    /**
     * Checks if the navigator object exists
     * @returns true if the navigator object exists
     */ IsNavigatorAvailable,
    /**
     * Check if the document object exists
     * @returns true if the document object exists
     */ IsDocumentAvailable,
    /**
     * Extracts text content from a DOM element hierarchy
     * @param element defines the root element
     * @returns a string
     */ GetDOMTextContent
}; //# sourceMappingURL=domManagement.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/precisionDate.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PrecisionDate",
    ()=>PrecisionDate
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$domManagement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/domManagement.js [app-ssr] (ecmascript)");
;
class PrecisionDate {
    /**
     * Gets either window.performance.now() if supported or Date.now() else
     */ static get Now() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$domManagement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["IsWindowObjectExist"])() && window.performance && window.performance.now) {
            return window.performance.now();
        }
        return Date.now();
    }
} //# sourceMappingURL=precisionDate.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/filesInputStore.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Class used to help managing file picking and drag'n'drop
 * File Storage
 */ __turbopack_context__.s([
    "FilesInputStore",
    ()=>FilesInputStore
]);
class FilesInputStore {
}
/**
 * List of files ready to be loaded
 */ FilesInputStore.FilesToLoad = {}; //# sourceMappingURL=filesInputStore.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/retryStrategy.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Class used to define a retry strategy when error happens while loading assets
 */ __turbopack_context__.s([
    "RetryStrategy",
    ()=>RetryStrategy
]);
class RetryStrategy {
    /**
     * Function used to defines an exponential back off strategy
     * @param maxRetries defines the maximum number of retries (3 by default)
     * @param baseInterval defines the interval between retries
     * @returns the strategy function to use
     */ static ExponentialBackoff(maxRetries = 3, baseInterval = 500) {
        return (url, request, retryIndex)=>{
            if (request.status !== 0 || retryIndex >= maxRetries || url.indexOf("file:") !== -1) {
                return -1;
            }
            return Math.pow(2, retryIndex) * baseInterval;
        };
    }
} //# sourceMappingURL=retryStrategy.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/error.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint-disable @typescript-eslint/naming-convention */ /**
 * Base error. Due to limitations of typedoc-check and missing documentation
 * in lib.es5.d.ts, cannot extend Error directly for RuntimeError.
 * @ignore
 */ __turbopack_context__.s([
    "AbortError",
    ()=>AbortError,
    "BaseError",
    ()=>BaseError,
    "ErrorCodes",
    ()=>ErrorCodes,
    "RuntimeError",
    ()=>RuntimeError
]);
class BaseError extends Error {
}
// See https://stackoverflow.com/questions/12915412/how-do-i-extend-a-host-object-e-g-error-in-typescript
// and https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
// Polyfill for Object.setPrototypeOf if necessary.
BaseError._setPrototypeOf = Object.setPrototypeOf || ((o, proto)=>{
    o.__proto__ = proto;
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return o;
});
const ErrorCodes = {
    // Mesh errors 0-999
    /** Invalid or empty mesh vertex positions. */ MeshInvalidPositionsError: 0,
    // Texture errors 1000-1999
    /** Unsupported texture found. */ UnsupportedTextureError: 1000,
    // GLTFLoader errors 2000-2999
    /** Unexpected magic number found in GLTF file header. */ GLTFLoaderUnexpectedMagicError: 2000,
    // SceneLoader errors 3000-3999
    /** SceneLoader generic error code. Ideally wraps the inner exception. */ SceneLoaderError: 3000,
    // File related errors 4000-4999
    /** Load file error */ LoadFileError: 4000,
    /** Request file error */ RequestFileError: 4001,
    /** Read file error */ ReadFileError: 4002
};
class RuntimeError extends BaseError {
    /**
     * Creates a new RuntimeError
     * @param message defines the message of the error
     * @param errorCode the error code
     * @param innerError the error that caused the outer error
     */ constructor(message, errorCode, innerError){
        super(message);
        this.errorCode = errorCode;
        this.innerError = innerError;
        this.name = "RuntimeError";
        BaseError._setPrototypeOf(this, RuntimeError.prototype);
    }
}
class AbortError extends BaseError {
    constructor(message = "Operation aborted"){
        super(message);
        this.name = "AbortError";
        BaseError._setPrototypeOf(this, AbortError.prototype);
    }
} //# sourceMappingURL=error.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/stringTools.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint-disable @typescript-eslint/naming-convention */ /**
 * Checks for a matching suffix at the end of a string (for ES5 and lower)
 * @param str Source string
 * @param suffix Suffix to search for in the source string
 * @returns Boolean indicating whether the suffix was found (true) or not (false)
 * @deprecated Please use native string function instead
 */ __turbopack_context__.s([
    "Decode",
    ()=>Decode,
    "DecodeBase64ToBinary",
    ()=>DecodeBase64ToBinary,
    "DecodeBase64ToString",
    ()=>DecodeBase64ToString,
    "EncodeArrayBufferToBase64",
    ()=>EncodeArrayBufferToBase64,
    "EndsWith",
    ()=>EndsWith,
    "PadNumber",
    ()=>PadNumber,
    "StartsWith",
    ()=>StartsWith,
    "StringTools",
    ()=>StringTools
]);
const EndsWith = (str, suffix)=>{
    return str.endsWith(suffix);
};
const StartsWith = (str, suffix)=>{
    if (!str) {
        return false;
    }
    return str.startsWith(suffix);
};
const Decode = (buffer)=>{
    if (typeof TextDecoder !== "undefined") {
        return new TextDecoder().decode(buffer);
    }
    let result = "";
    for(let i = 0; i < buffer.byteLength; i++){
        result += String.fromCharCode(buffer[i]);
    }
    return result;
};
const EncodeArrayBufferToBase64 = (buffer)=>{
    const keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    let output = "";
    let chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    let i = 0;
    const bytes = ArrayBuffer.isView(buffer) ? new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength) : new Uint8Array(buffer);
    while(i < bytes.length){
        chr1 = bytes[i++];
        chr2 = i < bytes.length ? bytes[i++] : Number.NaN;
        chr3 = i < bytes.length ? bytes[i++] : Number.NaN;
        enc1 = chr1 >> 2;
        enc2 = (chr1 & 3) << 4 | chr2 >> 4;
        enc3 = (chr2 & 15) << 2 | chr3 >> 6;
        enc4 = chr3 & 63;
        if (isNaN(chr2)) {
            enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
            enc4 = 64;
        }
        output += keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
    }
    return output;
};
const DecodeBase64ToString = (base64Data)=>{
    return atob(base64Data);
};
const DecodeBase64ToBinary = (base64Data)=>{
    const decodedString = DecodeBase64ToString(base64Data);
    const bufferLength = decodedString.length;
    const bufferView = new Uint8Array(new ArrayBuffer(bufferLength));
    for(let i = 0; i < bufferLength; i++){
        bufferView[i] = decodedString.charCodeAt(i);
    }
    return bufferView.buffer;
};
const PadNumber = (num, length)=>{
    let str = String(num);
    while(str.length < length){
        str = "0" + str;
    }
    return str;
};
const StringTools = {
    EndsWith,
    StartsWith,
    Decode,
    EncodeArrayBufferToBase64,
    DecodeBase64ToString,
    DecodeBase64ToBinary,
    PadNumber
}; //# sourceMappingURL=stringTools.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/timingTools.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TimingTools",
    ()=>TimingTools,
    "_RetryWithInterval",
    ()=>_RetryWithInterval
]);
let ImmediateQueue = [];
class TimingTools {
    /**
     * Execute a function after the current execution block
     * @param action defines the action to execute after the current execution block
     */ static SetImmediate(action) {
        if (ImmediateQueue.length === 0) {
            setTimeout(()=>{
                // Execute all immediate functions
                const functionsToCall = ImmediateQueue;
                ImmediateQueue = [];
                for (const func of functionsToCall){
                    func();
                }
            }, 1);
        }
        ImmediateQueue.push(action);
    }
}
function RunWithCondition(condition, onSuccess, onError) {
    try {
        if (condition()) {
            onSuccess();
            return true;
        }
    } catch (e) {
        onError?.(e);
        return true;
    }
    return false;
}
const _RetryWithInterval = (condition, onSuccess, onError, step = 16, maxTimeout = 30000, checkConditionOnCall = true, additionalStringOnTimeout)=>{
    // if checkConditionOnCall is true, we check the condition immediately. If it is true, run everything synchronously
    if (checkConditionOnCall) {
        // that means that one of the two happened - either the condition is true or an exception was thrown when checking the condition
        if (RunWithCondition(condition, onSuccess, onError)) {
            // don't schedule the interval, no reason to check it again.
            return null;
        }
    }
    const int = setInterval(()=>{
        if (RunWithCondition(condition, onSuccess, onError)) {
            clearInterval(int);
        } else {
            maxTimeout -= step;
            if (maxTimeout < 0) {
                clearInterval(int);
                onError?.(new Error("Operation timed out after maximum retries. " + (additionalStringOnTimeout || "")), true);
            }
        }
    }, step);
    return ()=>clearInterval(int);
}; //# sourceMappingURL=timingTools.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/fileTools.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint-disable @typescript-eslint/no-unsafe-return */ /* eslint-disable @typescript-eslint/naming-convention */ __turbopack_context__.s([
    "DecodeBase64UrlToBinary",
    ()=>DecodeBase64UrlToBinary,
    "DecodeBase64UrlToString",
    ()=>DecodeBase64UrlToString,
    "FileTools",
    ()=>FileTools,
    "FileToolsOptions",
    ()=>FileToolsOptions,
    "GetMimeType",
    ()=>GetMimeType,
    "IsBase64DataUrl",
    ()=>IsBase64DataUrl,
    "IsFileURL",
    ()=>IsFileURL,
    "LoadFile",
    ()=>LoadFile,
    "LoadFileError",
    ()=>LoadFileError,
    "LoadImage",
    ()=>LoadImage,
    "LoadImageConfiguration",
    ()=>LoadImageConfiguration,
    "ReadFile",
    ()=>ReadFile,
    "ReadFileError",
    ()=>ReadFileError,
    "RequestFile",
    ()=>RequestFile,
    "RequestFileError",
    ()=>RequestFileError,
    "SetCorsBehavior",
    ()=>SetCorsBehavior,
    "TestBase64DataUrl",
    ()=>TestBase64DataUrl,
    "_injectLTSFileTools",
    ()=>_injectLTSFileTools
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$webRequest$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/webRequest.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$domManagement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/domManagement.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/observable.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$filesInputStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/filesInputStore.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$retryStrategy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/retryStrategy.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/error.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$stringTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/stringTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$Processors$2f$shaderProcessor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Engines/Processors/shaderProcessor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engineStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Engines/engineStore.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/logger.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$timingTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/timingTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$abstractEngine$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Engines/abstractEngine.functions.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$abstractEngine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Engines/abstractEngine.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
const Base64DataUrlRegEx = new RegExp(/^data:([^,]+\/[^,]+)?;base64,/i);
class LoadFileError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RuntimeError"] {
    /**
     * Creates a new LoadFileError
     * @param message defines the message of the error
     * @param object defines the optional web request
     */ constructor(message, object){
        super(message, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ErrorCodes"].LoadFileError);
        this.name = "LoadFileError";
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseError"]._setPrototypeOf(this, LoadFileError.prototype);
        if (object instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$webRequest$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WebRequest"]) {
            this.request = object;
        } else {
            this.file = object;
        }
    }
}
class RequestFileError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RuntimeError"] {
    /**
     * Creates a new LoadFileError
     * @param message defines the message of the error
     * @param request defines the optional web request
     */ constructor(message, request){
        super(message, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ErrorCodes"].RequestFileError);
        this.request = request;
        this.name = "RequestFileError";
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseError"]._setPrototypeOf(this, RequestFileError.prototype);
    }
}
class ReadFileError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RuntimeError"] {
    /**
     * Creates a new ReadFileError
     * @param message defines the message of the error
     * @param file defines the optional file
     */ constructor(message, file){
        super(message, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ErrorCodes"].ReadFileError);
        this.file = file;
        this.name = "ReadFileError";
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseError"]._setPrototypeOf(this, ReadFileError.prototype);
    }
}
/**
 * Removes unwanted characters from an url
 * @param url defines the url to clean
 * @returns the cleaned url
 */ const CleanUrl = (url)=>{
    url = url.replace(/#/gm, "%23");
    return url;
};
const FileToolsOptions = {
    /**
     * Gets or sets the retry strategy to apply when an error happens while loading an asset.
     * When defining this function, return the wait time before trying again or return -1 to
     * stop retrying and error out.
     */ DefaultRetryStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$retryStrategy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RetryStrategy"].ExponentialBackoff(),
    /**
     * Gets or sets the base URL to use to load assets
     */ BaseUrl: "",
    /**
     * Default behaviour for cors in the application.
     * It can be a string if the expected behavior is identical in the entire app.
     * Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)
     */ CorsBehavior: "anonymous",
    /**
     * Gets or sets a function used to pre-process url before using them to load assets
     * @param url
     * @returns the processed url
     */ PreprocessUrl: (url)=>url,
    /**
     * Gets or sets the base URL to use to load scripts
     * Used for both JS and WASM
     */ ScriptBaseUrl: "",
    /**
     * Gets or sets a function used to pre-process script url before using them to load.
     * Used for both JS and WASM
     * @param url defines the url to process
     * @returns the processed url
     */ ScriptPreprocessUrl: (url)=>url,
    /**
     * Gets or sets a function used to clean the url before using it to load assets
     * @param url defines the url to clean
     * @returns the cleaned url
     */ CleanUrl
};
const SetCorsBehavior = (url, element)=>{
    if (url && url.indexOf("data:") === 0) {
        return;
    }
    if (FileToolsOptions.CorsBehavior) {
        if (typeof FileToolsOptions.CorsBehavior === "string" || FileToolsOptions.CorsBehavior instanceof String) {
            element.crossOrigin = FileToolsOptions.CorsBehavior;
        } else {
            const result = FileToolsOptions.CorsBehavior(url);
            if (result) {
                element.crossOrigin = result;
            }
        }
    }
};
const LoadImageConfiguration = {
    getRequiredSize: null
};
const LoadImage = (input, onLoad, onError, offlineProvider, mimeType = "", imageBitmapOptions, engine = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engineStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EngineStore"].LastCreatedEngine)=>{
    if (typeof HTMLImageElement === "undefined" && !engine?._features.forceBitmapOverHTMLImageElement) {
        onError("LoadImage is only supported in web or BabylonNative environments.");
        return null;
    }
    let url;
    let usingObjectURL = false;
    if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {
        if (typeof Blob !== "undefined" && typeof URL !== "undefined") {
            url = URL.createObjectURL(new Blob([
                input
            ], {
                type: mimeType
            }));
            usingObjectURL = true;
        } else {
            url = `data:${mimeType};base64,` + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$stringTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EncodeArrayBufferToBase64"])(input);
        }
    } else if (input instanceof Blob) {
        url = URL.createObjectURL(input);
        usingObjectURL = true;
    } else {
        url = FileToolsOptions.CleanUrl(input);
        url = FileToolsOptions.PreprocessUrl(url);
    }
    const onErrorHandler = (exception)=>{
        if (onError) {
            // eslint-disable-next-line @typescript-eslint/no-base-to-string
            const inputText = url || input.toString();
            onError(`Error while trying to load image: ${inputText.indexOf("http") === 0 || inputText.length <= 128 ? inputText : inputText.slice(0, 128) + "..."}`, exception);
        }
    };
    if (engine?._features.forceBitmapOverHTMLImageElement) {
        LoadFile(url, (data)=>{
            engine.createImageBitmap(new Blob([
                data
            ], {
                type: mimeType
            }), {
                premultiplyAlpha: "none",
                ...imageBitmapOptions
            })// eslint-disable-next-line github/no-then
            .then((imgBmp)=>{
                onLoad(imgBmp);
                if (usingObjectURL) {
                    URL.revokeObjectURL(url);
                }
            })// eslint-disable-next-line github/no-then
            .catch((reason)=>{
                if (onError) {
                    // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
                    onError("Error while trying to load image: " + input, reason);
                }
            });
        }, undefined, offlineProvider || undefined, true, (request, exception)=>{
            onErrorHandler(exception);
        });
        return null;
    }
    const img = new Image();
    if (LoadImageConfiguration.getRequiredSize) {
        const size = LoadImageConfiguration.getRequiredSize(input);
        if (size.width) {
            img.width = size.width;
        }
        if (size.height) {
            img.height = size.height;
        }
    }
    SetCorsBehavior(url, img);
    const handlersList = [];
    const loadHandlersList = ()=>{
        for (const handler of handlersList){
            handler.target.addEventListener(handler.name, handler.handler);
        }
    };
    const unloadHandlersList = ()=>{
        for (const handler of handlersList){
            handler.target.removeEventListener(handler.name, handler.handler);
        }
        handlersList.length = 0;
    };
    const loadHandler = ()=>{
        unloadHandlersList();
        onLoad(img);
        // Must revoke the URL after calling onLoad to avoid security exceptions in
        // certain scenarios (e.g. when hosted in vscode).
        if (usingObjectURL && img.src) {
            URL.revokeObjectURL(img.src);
        }
    };
    const errorHandler = (err)=>{
        unloadHandlersList();
        onErrorHandler(err);
        if (usingObjectURL && img.src) {
            URL.revokeObjectURL(img.src);
        }
    };
    const cspHandler = (err)=>{
        if (err.blockedURI !== img.src || err.disposition === "report") {
            return;
        }
        unloadHandlersList();
        const cspException = new Error(`CSP violation of policy ${err.effectiveDirective} ${err.blockedURI}. Current policy is ${err.originalPolicy}`);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engineStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EngineStore"].UseFallbackTexture = false;
        onErrorHandler(cspException);
        if (usingObjectURL && img.src) {
            URL.revokeObjectURL(img.src);
        }
        img.src = "";
    };
    handlersList.push({
        target: img,
        name: "load",
        handler: loadHandler
    });
    handlersList.push({
        target: img,
        name: "error",
        handler: errorHandler
    });
    handlersList.push({
        target: document,
        name: "securitypolicyviolation",
        handler: cspHandler
    });
    loadHandlersList();
    const fromBlob = url.substring(0, 5) === "blob:";
    const fromData = url.substring(0, 5) === "data:";
    const noOfflineSupport = ()=>{
        if (fromBlob || fromData || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$webRequest$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WebRequest"].IsCustomRequestAvailable) {
            img.src = url;
        } else {
            LoadFile(url, (data, _, contentType)=>{
                const type = !mimeType && contentType ? contentType : mimeType;
                const blob = new Blob([
                    data
                ], {
                    type
                });
                const url = URL.createObjectURL(blob);
                usingObjectURL = true;
                img.src = url;
            }, undefined, offlineProvider || undefined, true, (_request, exception)=>{
                onErrorHandler(exception);
            });
        }
    };
    const loadFromOfflineSupport = ()=>{
        if (offlineProvider) {
            offlineProvider.loadImage(url, img);
        }
    };
    if (!fromBlob && !fromData && offlineProvider && offlineProvider.enableTexturesOffline) {
        offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);
    } else {
        if (url.indexOf("file:") !== -1) {
            const textureName = decodeURIComponent(url.substring(5).toLowerCase());
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$filesInputStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FilesInputStore"].FilesToLoad[textureName] && typeof URL !== "undefined") {
                try {
                    let blobURL;
                    try {
                        blobURL = URL.createObjectURL(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$filesInputStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FilesInputStore"].FilesToLoad[textureName]);
                    } catch (ex) {
                        // Chrome doesn't support oneTimeOnly parameter
                        blobURL = URL.createObjectURL(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$filesInputStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FilesInputStore"].FilesToLoad[textureName]);
                    }
                    img.src = blobURL;
                    usingObjectURL = true;
                } catch (e) {
                    img.src = "";
                }
                return img;
            }
        }
        noOfflineSupport();
    }
    return img;
};
const ReadFile = (file, onSuccess, onProgress, useArrayBuffer, onError)=>{
    const reader = new FileReader();
    const fileRequest = {
        onCompleteObservable: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Observable"](),
        abort: ()=>reader.abort()
    };
    reader.onloadend = ()=>fileRequest.onCompleteObservable.notifyObservers(fileRequest);
    if (onError) {
        reader.onerror = ()=>{
            onError(new ReadFileError(`Unable to read ${file.name}`, file));
        };
    }
    reader.onload = (e)=>{
        //target doesn't have result from ts 1.3
        onSuccess(e.target["result"]);
    };
    if (onProgress) {
        reader.onprogress = onProgress;
    }
    if (!useArrayBuffer) {
        // Asynchronous read
        reader.readAsText(file);
    } else {
        reader.readAsArrayBuffer(file);
    }
    return fileRequest;
};
const LoadFile = (fileOrUrl, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened)=>{
    if (fileOrUrl.name) {
        return ReadFile(fileOrUrl, onSuccess, onProgress, useArrayBuffer, onError ? (error)=>{
            onError(undefined, error);
        } : undefined);
    }
    const url = fileOrUrl;
    // If file and file input are set
    if (url.indexOf("file:") !== -1) {
        let fileName = decodeURIComponent(url.substring(5).toLowerCase());
        if (fileName.indexOf("./") === 0) {
            fileName = fileName.substring(2);
        }
        const file = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$filesInputStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FilesInputStore"].FilesToLoad[fileName];
        if (file) {
            return ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError ? (error)=>onError(undefined, new LoadFileError(error.message, error.file)) : undefined);
        }
    }
    // For a Base64 Data URL
    const { match, type } = TestBase64DataUrl(url);
    if (match) {
        const fileRequest = {
            onCompleteObservable: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Observable"](),
            abort: ()=>()=>{}
        };
        try {
            const data = useArrayBuffer ? DecodeBase64UrlToBinary(url) : DecodeBase64UrlToString(url);
            onSuccess(data, undefined, type);
        } catch (error) {
            if (onError) {
                onError(undefined, error);
            } else {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Error(error.message || "Failed to parse the Data URL");
            }
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$timingTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TimingTools"].SetImmediate(()=>{
            fileRequest.onCompleteObservable.notifyObservers(fileRequest);
        });
        return fileRequest;
    }
    return RequestFile(url, (data, request)=>{
        onSuccess(data, request?.responseURL, request?.getResponseHeader("content-type"));
    }, onProgress, offlineProvider, useArrayBuffer, onError ? (error)=>{
        onError(error.request, new LoadFileError(error.message, error.request));
    } : undefined, onOpened);
};
const RequestFile = (url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened)=>{
    if (offlineProvider !== null) {
        offlineProvider ?? (offlineProvider = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engineStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EngineStore"].LastCreatedScene?.offlineProvider);
    }
    url = FileToolsOptions.CleanUrl(url);
    url = FileToolsOptions.PreprocessUrl(url);
    const loadUrl = FileToolsOptions.BaseUrl + url;
    let aborted = false;
    const fileRequest = {
        onCompleteObservable: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Observable"](),
        abort: ()=>aborted = true
    };
    const requestFile = ()=>{
        let request = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$webRequest$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WebRequest"]();
        let retryHandle = null;
        let onReadyStateChange;
        const unbindEvents = ()=>{
            if (!request) {
                return;
            }
            if (onProgress) {
                request.removeEventListener("progress", onProgress);
            }
            if (onReadyStateChange) {
                request.removeEventListener("readystatechange", onReadyStateChange);
            }
            request.removeEventListener("loadend", onLoadEnd);
        };
        let onLoadEnd = ()=>{
            unbindEvents();
            fileRequest.onCompleteObservable.notifyObservers(fileRequest);
            fileRequest.onCompleteObservable.clear();
            onProgress = undefined;
            onReadyStateChange = null;
            onLoadEnd = null;
            onError = undefined;
            onOpened = undefined;
            onSuccess = undefined;
        };
        fileRequest.abort = ()=>{
            aborted = true;
            if (onLoadEnd) {
                onLoadEnd();
            }
            if (request && request.readyState !== (XMLHttpRequest.DONE || 4)) {
                request.abort();
            }
            if (retryHandle !== null) {
                clearTimeout(retryHandle);
                retryHandle = null;
            }
            request = null;
        };
        const handleError = (error)=>{
            const message = error.message || "Unknown error";
            if (onError && request) {
                onError(new RequestFileError(message, request));
            } else {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Error(message);
            }
        };
        const retryLoop = (retryIndex)=>{
            if (!request) {
                return;
            }
            request.open("GET", loadUrl);
            if (onOpened) {
                try {
                    onOpened(request);
                } catch (e) {
                    handleError(e);
                    return;
                }
            }
            if (useArrayBuffer) {
                request.responseType = "arraybuffer";
            }
            if (onProgress) {
                request.addEventListener("progress", onProgress);
            }
            if (onLoadEnd) {
                request.addEventListener("loadend", onLoadEnd);
            }
            onReadyStateChange = ()=>{
                if (aborted || !request) {
                    return;
                }
                // In case of undefined state in some browsers.
                if (request.readyState === (XMLHttpRequest.DONE || 4)) {
                    // Some browsers have issues where onreadystatechange can be called multiple times with the same value.
                    if (onReadyStateChange) {
                        request.removeEventListener("readystatechange", onReadyStateChange);
                    }
                    if (request.status >= 200 && request.status < 300 || request.status === 0 && (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$domManagement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["IsWindowObjectExist"])() || IsFileURL())) {
                        // It's possible for the request to have a success status code but null response if the underlying
                        // underlying HTTP connection was closed prematurely. See _onHttpResponseClose in xhr2.js. In this
                        // case we will throw an exception if we call the onSuccess handler because "data" will be null
                        // and that then bypasses the retry strategy.
                        const data = useArrayBuffer ? request.response : request.responseText;
                        if (data !== null) {
                            try {
                                if (onSuccess) {
                                    onSuccess(data, request);
                                }
                            } catch (e) {
                                handleError(e);
                            }
                            return;
                        }
                    }
                    const retryStrategy = FileToolsOptions.DefaultRetryStrategy;
                    if (retryStrategy) {
                        const waitTime = retryStrategy(loadUrl, request, retryIndex);
                        if (waitTime !== -1) {
                            // Prevent the request from completing for retry.
                            unbindEvents();
                            request = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$webRequest$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WebRequest"]();
                            retryHandle = setTimeout(()=>retryLoop(retryIndex + 1), waitTime);
                            return;
                        }
                    }
                    const error = new RequestFileError("Error status: " + request.status + " " + request.statusText + " - Unable to load " + loadUrl, request);
                    if (onError) {
                        onError(error);
                    }
                }
            };
            request.addEventListener("readystatechange", onReadyStateChange);
            request.send();
        };
        retryLoop(0);
    };
    // Caching all files
    if (offlineProvider && offlineProvider.enableSceneOffline && !url.startsWith("blob:")) {
        const noOfflineSupport = (request)=>{
            if (request && request.status > 400) {
                if (onError) {
                    onError(request);
                }
            } else {
                requestFile();
            }
        };
        const loadFromOfflineSupport = ()=>{
            // TODO: database needs to support aborting and should return a IFileRequest
            if (offlineProvider) {
                offlineProvider.loadFile(FileToolsOptions.BaseUrl + url, (data)=>{
                    if (!aborted && onSuccess) {
                        onSuccess(data);
                    }
                    fileRequest.onCompleteObservable.notifyObservers(fileRequest);
                }, onProgress ? (event)=>{
                    if (!aborted && onProgress) {
                        onProgress(event);
                    }
                } : undefined, noOfflineSupport, useArrayBuffer);
            }
        };
        offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);
    } else {
        requestFile();
    }
    return fileRequest;
};
const GetMimeType = (url)=>{
    const { match, type } = TestBase64DataUrl(url);
    if (match) {
        return type || undefined;
    }
    const lastDot = url.lastIndexOf(".");
    const extension = url.substring(lastDot + 1).toLowerCase();
    switch(extension){
        case "glb":
            return "model/gltf-binary";
        case "bin":
            return "application/octet-stream";
        case "gltf":
            return "model/gltf+json";
        case "jpg":
        case "jpeg":
            return "image/jpeg";
        case "png":
            return "image/png";
        case "webp":
            return "image/webp";
        case "ktx":
            return "image/ktx";
        case "ktx2":
            return "image/ktx2";
        case "avif":
            return "image/avif";
        default:
            return undefined;
    }
};
const IsFileURL = ()=>{
    return typeof location !== "undefined" && location.protocol === "file:";
};
const IsBase64DataUrl = (uri)=>{
    return Base64DataUrlRegEx.test(uri);
};
const TestBase64DataUrl = (uri)=>{
    const results = Base64DataUrlRegEx.exec(uri);
    if (results === null || results.length === 0) {
        return {
            match: false,
            type: ""
        };
    } else {
        const type = results[0].replace("data:", "").replace(";base64,", "");
        return {
            match: true,
            type
        };
    }
};
function DecodeBase64UrlToBinary(uri) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$stringTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DecodeBase64ToBinary"])(uri.split(",")[1]);
}
const DecodeBase64UrlToString = (uri)=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$stringTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DecodeBase64ToString"])(uri.split(",")[1]);
};
/**
 * This will be executed automatically for UMD and es5.
 * If esm dev wants the side effects to execute they will have to run it manually
 * Once we build native modules those need to be exported.
 * @internal
 */ const initSideEffects = ()=>{
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$abstractEngine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AbstractEngine"]._FileToolsLoadImage = LoadImage;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$abstractEngine$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EngineFunctionContext"].loadFile = LoadFile;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$Processors$2f$shaderProcessor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_FunctionContainer"].loadFile = LoadFile;
};
initSideEffects();
let FileTools;
const _injectLTSFileTools = (DecodeBase64UrlToBinary, DecodeBase64UrlToString, FileToolsOptions, IsBase64DataUrl, IsFileURL, LoadFile, LoadImage, ReadFile, RequestFile, SetCorsBehavior)=>{
    /**
     * Backwards compatibility.
     * @internal
     * @deprecated
     */ FileTools = {
        DecodeBase64UrlToBinary,
        DecodeBase64UrlToString,
        DefaultRetryStrategy: FileToolsOptions.DefaultRetryStrategy,
        BaseUrl: FileToolsOptions.BaseUrl,
        CorsBehavior: FileToolsOptions.CorsBehavior,
        PreprocessUrl: FileToolsOptions.PreprocessUrl,
        IsBase64DataUrl,
        IsFileURL,
        LoadFile,
        LoadImage,
        ReadFile,
        RequestFile,
        SetCorsBehavior
    };
    Object.defineProperty(FileTools, "DefaultRetryStrategy", {
        get: function() {
            return FileToolsOptions.DefaultRetryStrategy;
        },
        set: function(value) {
            FileToolsOptions.DefaultRetryStrategy = value;
        }
    });
    Object.defineProperty(FileTools, "BaseUrl", {
        get: function() {
            return FileToolsOptions.BaseUrl;
        },
        set: function(value) {
            FileToolsOptions.BaseUrl = value;
        }
    });
    Object.defineProperty(FileTools, "PreprocessUrl", {
        get: function() {
            return FileToolsOptions.PreprocessUrl;
        },
        set: function(value) {
            FileToolsOptions.PreprocessUrl = value;
        }
    });
    Object.defineProperty(FileTools, "CorsBehavior", {
        get: function() {
            return FileToolsOptions.CorsBehavior;
        },
        set: function(value) {
            FileToolsOptions.CorsBehavior = value;
        }
    });
};
_injectLTSFileTools(DecodeBase64UrlToBinary, DecodeBase64UrlToString, FileToolsOptions, IsBase64DataUrl, IsFileURL, LoadFile, LoadImage, ReadFile, RequestFile, SetCorsBehavior); //# sourceMappingURL=fileTools.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/instantiationTools.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "InstantiationTools",
    ()=>InstantiationTools
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/logger.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$typeStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/typeStore.js [app-ssr] (ecmascript)");
;
;
class InstantiationTools {
    /**
     * Tries to instantiate a new object from a given class name
     * @param className defines the class name to instantiate
     * @returns the new object or null if the system was not able to do the instantiation
     */ static Instantiate(className) {
        if (this.RegisteredExternalClasses && this.RegisteredExternalClasses[className]) {
            return this.RegisteredExternalClasses[className];
        }
        const internalClass = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$typeStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GetClass"])(className);
        if (internalClass) {
            return internalClass;
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Warn(className + " not found, you may have missed an import.");
        const arr = className.split(".");
        let fn = window || this;
        for(let i = 0, len = arr.length; i < len; i++){
            fn = fn[arr[i]];
        }
        if (typeof fn !== "function") {
            return null;
        }
        return fn;
    }
}
/**
 * Use this object to register external classes like custom textures or material
 * to allow the loaders to instantiate them
 */ InstantiationTools.RegisteredExternalClasses = {}; //# sourceMappingURL=instantiationTools.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/guid.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523
 * Be aware Math.random() could cause collisions, but:
 * "All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide"
 * @returns a pseudo random id
 */ __turbopack_context__.s([
    "GUID",
    ()=>GUID,
    "RandomGUID",
    ()=>RandomGUID
]);
function RandomGUID() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c)=>{
        const r = Math.random() * 16 | 0, v = c === "x" ? r : r & 0x3 | 0x8;
        return v.toString(16);
    });
}
const GUID = {
    /**
     * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523
     * Be aware Math.random() could cause collisions, but:
     * "All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide"
     * @returns a pseudo random id
     */ // eslint-disable-next-line @typescript-eslint/naming-convention
    RandomId: RandomGUID
}; //# sourceMappingURL=guid.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tools.functions.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Function indicating if a number is an exponent of 2
 * @param value defines the value to test
 * @returns true if the value is an exponent of 2
 */ __turbopack_context__.s([
    "CeilingPOT",
    ()=>CeilingPOT,
    "FloorPOT",
    ()=>FloorPOT,
    "GetExponentOfTwo",
    ()=>GetExponentOfTwo,
    "IsExponentOfTwo",
    ()=>IsExponentOfTwo,
    "Mix",
    ()=>Mix,
    "NearestPOT",
    ()=>NearestPOT
]);
function IsExponentOfTwo(value) {
    let count = 1;
    do {
        count *= 2;
    }while (count < value)
    return count === value;
}
function Mix(a, b, alpha) {
    return a * (1 - alpha) + b * alpha;
}
function NearestPOT(x) {
    const c = CeilingPOT(x);
    const f = FloorPOT(x);
    return c - x > x - f ? f : c;
}
function CeilingPOT(x) {
    x--;
    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    x++;
    return x;
}
function FloorPOT(x) {
    x = x | x >> 1;
    x = x | x >> 2;
    x = x | x >> 4;
    x = x | x >> 8;
    x = x | x >> 16;
    return x - (x >> 1);
}
function GetExponentOfTwo(value, max, mode = 2) {
    let pot;
    switch(mode){
        case 1:
            pot = FloorPOT(value);
            break;
        case 2:
            pot = NearestPOT(value);
            break;
        case 3:
        default:
            pot = CeilingPOT(value);
            break;
    }
    return Math.min(pot, max);
} //# sourceMappingURL=tools.functions.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tools.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AsyncLoop",
    ()=>AsyncLoop,
    "Tools",
    ()=>Tools,
    "className",
    ()=>className
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/observable.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$domManagement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/domManagement.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/logger.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$deepCopier$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/deepCopier.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/precisionDate.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$devTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/devTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$webRequest$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/webRequest.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engineStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Engines/engineStore.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/fileTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$timingTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/timingTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$instantiationTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/instantiationTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$guid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/guid.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tools.functions.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
class Tools {
    /**
     * Gets or sets the base URL to use to load assets
     */ static get BaseUrl() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FileToolsOptions"].BaseUrl;
    }
    static set BaseUrl(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FileToolsOptions"].BaseUrl = value;
    }
    /**
     * Gets or sets the clean URL function to use to load assets
     */ static get CleanUrl() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FileToolsOptions"].CleanUrl;
    }
    static set CleanUrl(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FileToolsOptions"].CleanUrl = value;
    }
    /**
     * This function checks whether a URL is absolute or not.
     * It will also detect data and blob URLs
     * @param url the url to check
     * @returns is the url absolute or relative
     */ static IsAbsoluteUrl(url) {
        // See https://stackoverflow.com/a/38979205.
        // URL is protocol-relative (= absolute)
        if (url.indexOf("//") === 0) {
            return true;
        }
        // URL has no protocol (= relative)
        if (url.indexOf("://") === -1) {
            return false;
        }
        // URL does not contain a dot, i.e. no TLD (= relative, possibly REST)
        if (url.indexOf(".") === -1) {
            return false;
        }
        // URL does not contain a single slash (= relative)
        if (url.indexOf("/") === -1) {
            return false;
        }
        // The first colon comes after the first slash (= relative)
        if (url.indexOf(":") > url.indexOf("/")) {
            return false;
        }
        // Protocol is defined before first dot (= absolute)
        if (url.indexOf("://") < url.indexOf(".")) {
            return true;
        }
        if (url.indexOf("data:") === 0 || url.indexOf("blob:") === 0) {
            return true;
        }
        // Anything else must be relative
        return false;
    }
    /**
     * Sets the base URL to use to load scripts
     */ static set ScriptBaseUrl(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FileToolsOptions"].ScriptBaseUrl = value;
    }
    static get ScriptBaseUrl() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FileToolsOptions"].ScriptBaseUrl;
    }
    /**
     * Sets both the script base URL and the assets base URL to the same value.
     * Setter only!
     */ // eslint-disable-next-line @typescript-eslint/naming-convention
    static set CDNBaseUrl(value) {
        Tools.ScriptBaseUrl = value;
        Tools.AssetBaseUrl = value;
    }
    /**
     * Sets a preprocessing function to run on a source URL before importing it
     * Note that this function will execute AFTER the base URL is appended to the URL
     */ static set ScriptPreprocessUrl(func) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FileToolsOptions"].ScriptPreprocessUrl = func;
    }
    static get ScriptPreprocessUrl() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FileToolsOptions"].ScriptPreprocessUrl;
    }
    /**
     * Gets or sets the retry strategy to apply when an error happens while loading an asset
     */ static get DefaultRetryStrategy() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FileToolsOptions"].DefaultRetryStrategy;
    }
    static set DefaultRetryStrategy(strategy) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FileToolsOptions"].DefaultRetryStrategy = strategy;
    }
    /**
     * Default behavior for cors in the application.
     * It can be a string if the expected behavior is identical in the entire app.
     * Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)
     */ static get CorsBehavior() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FileToolsOptions"].CorsBehavior;
    }
    static set CorsBehavior(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FileToolsOptions"].CorsBehavior = value;
    }
    /**
     * Gets or sets a global variable indicating if fallback texture must be used when a texture cannot be loaded
     * @ignorenaming
     */ static get UseFallbackTexture() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engineStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EngineStore"].UseFallbackTexture;
    }
    static set UseFallbackTexture(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engineStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EngineStore"].UseFallbackTexture = value;
    }
    /**
     * Use this object to register external classes like custom textures or material
     * to allow the loaders to instantiate them
     */ static get RegisteredExternalClasses() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$instantiationTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InstantiationTools"].RegisteredExternalClasses;
    }
    static set RegisteredExternalClasses(classes) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$instantiationTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InstantiationTools"].RegisteredExternalClasses = classes;
    }
    /**
     * Texture content used if a texture cannot loaded
     * @ignorenaming
     */ // eslint-disable-next-line @typescript-eslint/naming-convention
    static get fallbackTexture() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engineStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EngineStore"].FallbackTexture;
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    static set fallbackTexture(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engineStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EngineStore"].FallbackTexture = value;
    }
    /**
     * Read the content of a byte array at a specified coordinates (taking in account wrapping)
     * @param u defines the coordinate on X axis
     * @param v defines the coordinate on Y axis
     * @param width defines the width of the source data
     * @param height defines the height of the source data
     * @param pixels defines the source byte array
     * @param color defines the output color
     */ static FetchToRef(u, v, width, height, pixels, color) {
        const wrappedU = Math.abs(u) * width % width | 0;
        const wrappedV = Math.abs(v) * height % height | 0;
        const position = (wrappedU + wrappedV * width) * 4;
        color.r = pixels[position] / 255;
        color.g = pixels[position + 1] / 255;
        color.b = pixels[position + 2] / 255;
        color.a = pixels[position + 3] / 255;
    }
    /**
     * Interpolates between a and b via alpha
     * @param a The lower value (returned when alpha = 0)
     * @param b The upper value (returned when alpha = 1)
     * @param alpha The interpolation-factor
     * @returns The mixed value
     */ static Mix(a, b, alpha) {
        return 0;
    }
    /**
     * Tries to instantiate a new object from a given class name
     * @param className defines the class name to instantiate
     * @returns the new object or null if the system was not able to do the instantiation
     */ static Instantiate(className) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$instantiationTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InstantiationTools"].Instantiate(className);
    }
    /**
     * Polyfill for setImmediate
     * @param action defines the action to execute after the current execution block
     */ static SetImmediate(action) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$timingTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TimingTools"].SetImmediate(action);
    }
    /**
     * Function indicating if a number is an exponent of 2
     * @param value defines the value to test
     * @returns true if the value is an exponent of 2
     */ static IsExponentOfTwo(value) {
        return true;
    }
    /**
     * Returns the nearest 32-bit single precision float representation of a Number
     * @param value A Number.  If the parameter is of a different type, it will get converted
     * to a number or to NaN if it cannot be converted
     * @returns number
     */ static FloatRound(value) {
        return Math.fround(value);
    }
    /**
     * Extracts the filename from a path
     * @param path defines the path to use
     * @returns the filename
     */ static GetFilename(path) {
        const index = path.lastIndexOf("/");
        if (index < 0) {
            return path;
        }
        return path.substring(index + 1);
    }
    /**
     * Extracts the "folder" part of a path (everything before the filename).
     * @param uri The URI to extract the info from
     * @param returnUnchangedIfNoSlash Do not touch the URI if no slashes are present
     * @returns The "folder" part of the path
     */ static GetFolderPath(uri, returnUnchangedIfNoSlash = false) {
        const index = uri.lastIndexOf("/");
        if (index < 0) {
            if (returnUnchangedIfNoSlash) {
                return uri;
            }
            return "";
        }
        return uri.substring(0, index + 1);
    }
    /**
     * Convert an angle in radians to degrees
     * @param angle defines the angle to convert
     * @returns the angle in degrees
     */ static ToDegrees(angle) {
        return angle * 180 / Math.PI;
    }
    /**
     * Convert an angle in degrees to radians
     * @param angle defines the angle to convert
     * @returns the angle in radians
     */ static ToRadians(angle) {
        return angle * Math.PI / 180;
    }
    /**
     * Smooth angle changes (kind of low-pass filter), in particular for device orientation "shaking"
     * Use trigonometric functions to avoid discontinuity (0/360, -180/180)
     * @param previousAngle defines last angle value, in degrees
     * @param newAngle defines new angle value, in degrees
     * @param smoothFactor defines smoothing sensitivity; min 0: no smoothing, max 1: new data ignored
     * @returns the angle in degrees
     */ static SmoothAngleChange(previousAngle, newAngle, smoothFactor = 0.9) {
        const previousAngleRad = this.ToRadians(previousAngle);
        const newAngleRad = this.ToRadians(newAngle);
        return this.ToDegrees(Math.atan2((1 - smoothFactor) * Math.sin(newAngleRad) + smoothFactor * Math.sin(previousAngleRad), (1 - smoothFactor) * Math.cos(newAngleRad) + smoothFactor * Math.cos(previousAngleRad)));
    }
    /**
     * Returns an array if obj is not an array
     * @param obj defines the object to evaluate as an array
     * @param allowsNullUndefined defines a boolean indicating if obj is allowed to be null or undefined
     * @returns either obj directly if obj is an array or a new array containing obj
     */ static MakeArray(obj, allowsNullUndefined) {
        if (allowsNullUndefined !== true && (obj === undefined || obj == null)) {
            return null;
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return Array.isArray(obj) ? obj : [
            obj
        ];
    }
    /**
     * Gets the pointer prefix to use
     * @param engine defines the engine we are finding the prefix for
     * @returns "pointer" if touch is enabled. Else returns "mouse"
     */ static GetPointerPrefix(engine) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$domManagement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["IsWindowObjectExist"])() && !window.PointerEvent ? "mouse" : "pointer";
    }
    /**
     * Sets the cors behavior on a dom element. This will add the required Tools.CorsBehavior to the element.
     * @param url define the url we are trying
     * @param element define the dom element where to configure the cors policy
     * @param element.crossOrigin
     */ static SetCorsBehavior(url, element) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SetCorsBehavior"])(url, element);
    }
    /**
     * Sets the referrerPolicy behavior on a dom element.
     * @param referrerPolicy define the referrer policy to use
     * @param element define the dom element where to configure the referrer policy
     * @param element.referrerPolicy
     */ static SetReferrerPolicyBehavior(referrerPolicy, element) {
        element.referrerPolicy = referrerPolicy;
    }
    // External files
    /**
     * Gets or sets a function used to pre-process url before using them to load assets
     */ static get PreprocessUrl() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FileToolsOptions"].PreprocessUrl;
    }
    static set PreprocessUrl(processor) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FileToolsOptions"].PreprocessUrl = processor;
    }
    /**
     * Loads an image as an HTMLImageElement.
     * @param input url string, ArrayBuffer, or Blob to load
     * @param onLoad callback called when the image successfully loads
     * @param onError callback called when the image fails to load
     * @param offlineProvider offline provider for caching
     * @param mimeType optional mime type
     * @param imageBitmapOptions optional the options to use when creating an ImageBitmap
     * @returns the HTMLImageElement of the loaded image
     */ static LoadImage(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LoadImage"])(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions);
    }
    /**
     * Loads a file from a url
     * @param url url string, ArrayBuffer, or Blob to load
     * @param onSuccess callback called when the file successfully loads
     * @param onProgress callback called while file is loading (if the server supports this mode)
     * @param offlineProvider defines the offline provider for caching
     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer
     * @param onError callback called when the file fails to load
     * @returns a file request object
     */ static LoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LoadFile"])(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);
    }
    /**
     * Loads a file from a url
     * @param url the file url to load
     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer
     * @returns a promise containing an ArrayBuffer corresponding to the loaded file
     */ static async LoadFileAsync(url, useArrayBuffer = true) {
        return await new Promise((resolve, reject)=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LoadFile"])(url, (data)=>{
                resolve(data);
            }, undefined, undefined, useArrayBuffer, (request, exception)=>{
                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
                reject(exception);
            });
        });
    }
    /**
     * This function will convert asset URLs if the AssetBaseUrl parameter is set.
     * Any URL with `assets.babylonjs.com/core` will be replaced with the value of AssetBaseUrl.
     * @param url the URL to convert
     * @returns a new URL
     */ static GetAssetUrl(url) {
        if (!url) {
            return "";
        }
        if (Tools.AssetBaseUrl && url.startsWith(Tools._DefaultAssetsUrl)) {
            // normalize the baseUrl
            const baseUrl = Tools.AssetBaseUrl[Tools.AssetBaseUrl.length - 1] === "/" ? Tools.AssetBaseUrl.substring(0, Tools.AssetBaseUrl.length - 1) : Tools.AssetBaseUrl;
            return url.replace(Tools._DefaultAssetsUrl, baseUrl);
        }
        return url;
    }
    /**
     * Get a script URL including preprocessing
     * @param scriptUrl the script Url to process
     * @param forceAbsoluteUrl force the script to be an absolute url (adding the current base url if necessary)
     * @returns a modified URL to use
     */ static GetBabylonScriptURL(scriptUrl, forceAbsoluteUrl) {
        if (!scriptUrl) {
            return "";
        }
        // if the base URL was set, and the script Url is an absolute path change the default path
        if (Tools.ScriptBaseUrl && scriptUrl.startsWith(Tools._DefaultCdnUrl)) {
            // change the default host, which is https://cdn.babylonjs.com with the one defined
            // make sure no trailing slash is present
            const baseUrl = Tools.ScriptBaseUrl[Tools.ScriptBaseUrl.length - 1] === "/" ? Tools.ScriptBaseUrl.substring(0, Tools.ScriptBaseUrl.length - 1) : Tools.ScriptBaseUrl;
            scriptUrl = scriptUrl.replace(Tools._DefaultCdnUrl, baseUrl);
        }
        // run the preprocessor
        scriptUrl = Tools.ScriptPreprocessUrl(scriptUrl);
        if (forceAbsoluteUrl && !Tools.IsAbsoluteUrl(scriptUrl)) {
            scriptUrl = Tools.GetAbsoluteUrl(scriptUrl);
        }
        return scriptUrl;
    }
    /**
     * This function is used internally by babylon components to load a script (identified by an url). When the url returns, the
     * content of this file is added into a new script element, attached to the DOM (body element)
     * @param scriptUrl defines the url of the script to load
     * @param onSuccess defines the callback called when the script is loaded
     * @param onError defines the callback to call if an error occurs
     * @param scriptId defines the id of the script element
     */ static LoadBabylonScript(scriptUrl, onSuccess, onError, scriptId) {
        scriptUrl = Tools.GetBabylonScriptURL(scriptUrl);
        Tools.LoadScript(scriptUrl, onSuccess, onError);
    }
    /**
     * Load an asynchronous script (identified by an url). When the url returns, the
     * content of this file is added into a new script element, attached to the DOM (body element)
     * @param scriptUrl defines the url of the script to laod
     * @returns a promise request object
     */ static async LoadBabylonScriptAsync(scriptUrl) {
        scriptUrl = Tools.GetBabylonScriptURL(scriptUrl);
        return await Tools.LoadScriptAsync(scriptUrl);
    }
    /**
     * This function is used internally by babylon components to load a script (identified by an url). When the url returns, the
     * content of this file is added into a new script element, attached to the DOM (body element)
     * @param scriptUrl defines the url of the script to load
     * @param onSuccess defines the callback called when the script is loaded
     * @param onError defines the callback to call if an error occurs
     * @param scriptId defines the id of the script element
     * @param useModule defines if we should use the module strategy to load the script
     */ static LoadScript(scriptUrl, onSuccess, onError, scriptId, useModule = false) {
        if (typeof importScripts === "function") {
            try {
                importScripts(scriptUrl);
                if (onSuccess) {
                    onSuccess();
                }
            } catch (e) {
                onError?.(`Unable to load script '${scriptUrl}' in worker`, e);
            }
            return;
        } else if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$domManagement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["IsWindowObjectExist"])()) {
            onError?.(`Cannot load script '${scriptUrl}' outside of a window or a worker`);
            return;
        }
        const head = document.getElementsByTagName("head")[0];
        const script = document.createElement("script");
        if (useModule) {
            script.setAttribute("type", "module");
            script.innerText = scriptUrl;
        } else {
            script.setAttribute("type", "text/javascript");
            script.setAttribute("src", scriptUrl);
        }
        if (scriptId) {
            script.id = scriptId;
        }
        script.onload = ()=>{
            if (onSuccess) {
                onSuccess();
            }
        };
        script.onerror = (e)=>{
            if (onError) {
                onError(`Unable to load script '${scriptUrl}'`, e);
            }
        };
        head.appendChild(script);
    }
    /**
     * Load an asynchronous script (identified by an url). When the url returns, the
     * content of this file is added into a new script element, attached to the DOM (body element)
     * @param scriptUrl defines the url of the script to load
     * @param scriptId defines the id of the script element
     * @returns a promise request object
     */ static async LoadScriptAsync(scriptUrl, scriptId) {
        return await new Promise((resolve, reject)=>{
            this.LoadScript(scriptUrl, ()=>{
                resolve();
            }, (message, exception)=>{
                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
                reject(exception || new Error(message));
            }, scriptId);
        });
    }
    /**
     * Loads a file from a blob
     * @param fileToLoad defines the blob to use
     * @param callback defines the callback to call when data is loaded
     * @param progressCallback defines the callback to call during loading process
     * @returns a file request object
     */ static ReadFileAsDataURL(fileToLoad, callback, progressCallback) {
        const reader = new FileReader();
        const request = {
            onCompleteObservable: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Observable"](),
            abort: ()=>reader.abort()
        };
        reader.onloadend = ()=>{
            request.onCompleteObservable.notifyObservers(request);
        };
        reader.onload = (e)=>{
            //target doesn't have result from ts 1.3
            callback(e.target["result"]);
        };
        reader.onprogress = progressCallback;
        reader.readAsDataURL(fileToLoad);
        return request;
    }
    /**
     * Reads a file from a File object
     * @param file defines the file to load
     * @param onSuccess defines the callback to call when data is loaded
     * @param onProgress defines the callback to call during loading process
     * @param useArrayBuffer defines a boolean indicating that data must be returned as an ArrayBuffer
     * @param onError defines the callback to call when an error occurs
     * @returns a file request object
     */ static ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ReadFile"])(file, onSuccess, onProgress, useArrayBuffer, onError);
    }
    /**
     * Creates a data url from a given string content
     * @param content defines the content to convert
     * @returns the new data url link
     */ static FileAsURL(content) {
        const fileBlob = new Blob([
            content
        ]);
        const url = window.URL;
        const link = url.createObjectURL(fileBlob);
        return link;
    }
    /**
     * Format the given number to a specific decimal format
     * @param value defines the number to format
     * @param decimals defines the number of decimals to use
     * @returns the formatted string
     */ static Format(value, decimals = 2) {
        return value.toFixed(decimals);
    }
    /**
     * Tries to copy an object by duplicating every property
     * @param source defines the source object
     * @param destination defines the target object
     * @param doNotCopyList defines a list of properties to avoid
     * @param mustCopyList defines a list of properties to copy (even if they start with _)
     */ static DeepCopy(source, destination, doNotCopyList, mustCopyList) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$deepCopier$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DeepCopier"].DeepCopy(source, destination, doNotCopyList, mustCopyList);
    }
    /**
     * Gets a boolean indicating if the given object has no own property
     * @param obj defines the object to test
     * @returns true if object has no own property
     */ static IsEmpty(obj) {
        for(const i in obj){
            if (Object.prototype.hasOwnProperty.call(obj, i)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Function used to register events at window level
     * @param windowElement defines the Window object to use
     * @param events defines the events to register
     */ static RegisterTopRootEvents(windowElement, events) {
        for(let index = 0; index < events.length; index++){
            const event = events[index];
            windowElement.addEventListener(event.name, event.handler, false);
            try {
                if (window.parent) {
                    window.parent.addEventListener(event.name, event.handler, false);
                }
            } catch (e) {
            // Silently fails...
            }
        }
    }
    /**
     * Function used to unregister events from window level
     * @param windowElement defines the Window object to use
     * @param events defines the events to unregister
     */ static UnregisterTopRootEvents(windowElement, events) {
        for(let index = 0; index < events.length; index++){
            const event = events[index];
            windowElement.removeEventListener(event.name, event.handler);
            try {
                if (windowElement.parent) {
                    windowElement.parent.removeEventListener(event.name, event.handler);
                }
            } catch (e) {
            // Silently fails...
            }
        }
    }
    /**
     * Dumps the current bound framebuffer
     * @param width defines the rendering width
     * @param height defines the rendering height
     * @param engine defines the hosting engine
     * @param successCallback defines the callback triggered once the data are available
     * @param mimeType defines the mime type of the result
     * @param fileName defines the filename to download. If present, the result will automatically be downloaded
     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
     * @returns a void promise
     */ // Should end with Async but this is a breaking change
    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/require-await, @typescript-eslint/naming-convention
    static async DumpFramebuffer(width, height, engine, successCallback, mimeType = "image/png", fileName, quality) {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$devTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_WarnImport"])("DumpTools");
    }
    /**
     * Dumps an array buffer
     * @param width defines the rendering width
     * @param height defines the rendering height
     * @param data the data array
     * @param successCallback defines the callback triggered once the data are available
     * @param mimeType defines the mime type of the result
     * @param fileName defines the filename to download. If present, the result will automatically be downloaded
     * @param invertY true to invert the picture in the Y dimension
     * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string
     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
     */ static DumpData(width, height, data, successCallback, mimeType = "image/png", fileName, invertY = false, toArrayBuffer = false, quality) {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$devTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_WarnImport"])("DumpTools");
    }
    // eslint-disable-next-line jsdoc/require-returns-check
    /**
     * Dumps an array buffer
     * @param width defines the rendering width
     * @param height defines the rendering height
     * @param data the data array
     * @param mimeType defines the mime type of the result
     * @param fileName defines the filename to download. If present, the result will automatically be downloaded
     * @param invertY true to invert the picture in the Y dimension
     * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string
     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
     * @returns a promise that resolve to the final data
     */ // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/require-await
    static async DumpDataAsync(width, height, data, mimeType = "image/png", fileName, invertY = false, toArrayBuffer = false, quality) {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$devTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_WarnImport"])("DumpTools");
    }
    static _IsOffScreenCanvas(canvas) {
        return canvas.convertToBlob !== undefined;
    }
    /**
     * Converts the canvas data to blob.
     * This acts as a polyfill for browsers not supporting the to blob function.
     * @param canvas Defines the canvas to extract the data from (can be an offscreen canvas)
     * @param successCallback Defines the callback triggered once the data are available
     * @param mimeType Defines the mime type of the result
     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
     */ static ToBlob(canvas, successCallback, mimeType = "image/png", quality) {
        // We need HTMLCanvasElement.toBlob for HD screenshots
        if (!Tools._IsOffScreenCanvas(canvas) && !canvas.toBlob) {
            //  low performance polyfill based on toDataURL (https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob)
            canvas.toBlob = function(callback, type, quality) {
                setTimeout(()=>{
                    const binStr = atob(this.toDataURL(type, quality).split(",")[1]), len = binStr.length, arr = new Uint8Array(len);
                    for(let i = 0; i < len; i++){
                        arr[i] = binStr.charCodeAt(i);
                    }
                    callback(new Blob([
                        arr
                    ]));
                });
            };
        }
        if (Tools._IsOffScreenCanvas(canvas)) {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            canvas.convertToBlob({
                type: mimeType,
                quality
            })// eslint-disable-next-line github/no-then
            .then((blob)=>successCallback(blob));
        } else {
            canvas.toBlob(function(blob) {
                successCallback(blob);
            }, mimeType, quality);
        }
    }
    /**
     * Download a Blob object
     * @param blob the Blob object
     * @param fileName the file name to download
     */ static DownloadBlob(blob, fileName) {
        //Creating a link if the browser have the download attribute on the a tag, to automatically start download generated image.
        if ("download" in document.createElement("a")) {
            if (!fileName) {
                const date = new Date();
                const stringDate = (date.getFullYear() + "-" + (date.getMonth() + 1)).slice(2) + "-" + date.getDate() + "_" + date.getHours() + "-" + ("0" + date.getMinutes()).slice(-2);
                fileName = "screenshot_" + stringDate + ".png";
            }
            Tools.Download(blob, fileName);
        } else {
            if (blob && typeof URL !== "undefined") {
                const url = URL.createObjectURL(blob);
                const newWindow = window.open("");
                if (!newWindow) {
                    return;
                }
                const img = newWindow.document.createElement("img");
                img.onload = function() {
                    // no longer need to read the blob so it's revoked
                    URL.revokeObjectURL(url);
                };
                img.src = url;
                newWindow.document.body.appendChild(img);
            }
        }
    }
    /**
     * Encodes the canvas data to base 64, or automatically downloads the result if `fileName` is defined.
     * @param canvas The canvas to get the data from, which can be an offscreen canvas.
     * @param successCallback The callback which is triggered once the data is available. If `fileName` is defined, the callback will be invoked after the download occurs, and the `data` argument will be an empty string.
     * @param mimeType The mime type of the result.
     * @param fileName The name of the file to download. If defined, the result will automatically be downloaded. If not defined, and `successCallback` is also not defined, the result will automatically be downloaded with an auto-generated file name.
     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
     */ static EncodeScreenshotCanvasData(canvas, successCallback, mimeType = "image/png", fileName, quality) {
        if (typeof fileName === "string" || !successCallback) {
            this.ToBlob(canvas, function(blob) {
                if (blob) {
                    Tools.DownloadBlob(blob, fileName);
                }
                if (successCallback) {
                    successCallback("");
                }
            }, mimeType, quality);
        } else if (successCallback) {
            if (Tools._IsOffScreenCanvas(canvas)) {
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                canvas.convertToBlob({
                    type: mimeType,
                    quality
                })// eslint-disable-next-line github/no-then
                .then((blob)=>{
                    const reader = new FileReader();
                    reader.readAsDataURL(blob);
                    reader.onloadend = ()=>{
                        const base64data = reader.result;
                        successCallback(base64data);
                    };
                });
                return;
            }
            const base64Image = canvas.toDataURL(mimeType, quality);
            successCallback(base64Image);
        }
    }
    /**
     * Downloads a blob in the browser
     * @param blob defines the blob to download
     * @param fileName defines the name of the downloaded file
     */ static Download(blob, fileName) {
        if (typeof URL === "undefined") {
            return;
        }
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement("a");
        document.body.appendChild(a);
        a.style.display = "none";
        a.href = url;
        a.download = fileName;
        a.addEventListener("click", ()=>{
            if (a.parentElement) {
                a.parentElement.removeChild(a);
            }
        });
        a.click();
        window.URL.revokeObjectURL(url);
    }
    /**
     * Will return the right value of the noPreventDefault variable
     * Needed to keep backwards compatibility to the old API.
     *
     * @param args arguments passed to the attachControl function
     * @returns the correct value for noPreventDefault
     */ static BackCompatCameraNoPreventDefault(args) {
        // is it used correctly?
        if (typeof args[0] === "boolean") {
            return args[0];
        } else if (typeof args[1] === "boolean") {
            return args[1];
        }
        return false;
    }
    /**
     * Captures a screenshot of the current rendering
     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG
     * @param engine defines the rendering engine
     * @param camera defines the source camera
     * @param size This parameter can be set to a single number or to an object with the
     * following (optional) properties: precision, width, height. If a single number is passed,
     * it will be used for both width and height. If an object is passed, the screenshot size
     * will be derived from the parameters. The precision property is a multiplier allowing
     * rendering at a higher or lower resolution
     * @param successCallback defines the callback receives a single parameter which contains the
     * screenshot as a string of base64-encoded characters. This string can be assigned to the
     * src parameter of an <img> to display it
     * @param mimeType defines the MIME type of the screenshot image (default: image/png).
     * Check your browser for supported MIME types
     * @param forceDownload force the system to download the image even if a successCallback is provided
     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
     */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static CreateScreenshot(engine, camera, size, successCallback, mimeType = "image/png", forceDownload = false, quality) {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$devTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_WarnImport"])("ScreenshotTools");
    }
    // eslint-disable-next-line jsdoc/require-returns-check
    /**
     * Captures a screenshot of the current rendering
     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG
     * @param engine defines the rendering engine
     * @param camera defines the source camera
     * @param size This parameter can be set to a single number or to an object with the
     * following (optional) properties: precision, width, height. If a single number is passed,
     * it will be used for both width and height. If an object is passed, the screenshot size
     * will be derived from the parameters. The precision property is a multiplier allowing
     * rendering at a higher or lower resolution
     * @param mimeType defines the MIME type of the screenshot image (default: image/png).
     * Check your browser for supported MIME types
     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
     * @returns screenshot as a string of base64-encoded characters. This string can be assigned
     * to the src parameter of an <img> to display it
     */ // eslint-disable-next-line @typescript-eslint/no-unused-vars, no-restricted-syntax, @typescript-eslint/require-await
    static async CreateScreenshotAsync(engine, camera, size, mimeType = "image/png", quality) {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$devTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_WarnImport"])("ScreenshotTools");
    }
    /**
     * Generates an image screenshot from the specified camera.
     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG
     * @param engine The engine to use for rendering
     * @param camera The camera to use for rendering
     * @param size This parameter can be set to a single number or to an object with the
     * following (optional) properties: precision, width, height. If a single number is passed,
     * it will be used for both width and height. If an object is passed, the screenshot size
     * will be derived from the parameters. The precision property is a multiplier allowing
     * rendering at a higher or lower resolution
     * @param successCallback The callback receives a single parameter which contains the
     * screenshot as a string of base64-encoded characters. This string can be assigned to the
     * src parameter of an <img> to display it
     * @param mimeType The MIME type of the screenshot image (default: image/png).
     * Check your browser for supported MIME types
     * @param samples Texture samples (default: 1)
     * @param antialiasing Whether antialiasing should be turned on or not (default: false)
     * @param fileName A name for for the downloaded file.
     * @param renderSprites Whether the sprites should be rendered or not (default: false)
     * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)
     * @param useLayerMask if the camera's layer mask should be used to filter what should be rendered (default: true)
     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
     * @param customizeTexture An optional callback that can be used to modify the render target texture before taking the screenshot. This can be used, for instance, to enable camera post-processes before taking the screenshot.
     */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static CreateScreenshotUsingRenderTarget(engine, camera, size, successCallback, mimeType = "image/png", samples = 1, antialiasing = false, fileName, renderSprites = false, enableStencilBuffer = false, useLayerMask = true, quality, customizeTexture) {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$devTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_WarnImport"])("ScreenshotTools");
    }
    // eslint-disable-next-line jsdoc/require-returns-check
    /**
     * Generates an image screenshot from the specified camera.
     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG
     * @param engine The engine to use for rendering
     * @param camera The camera to use for rendering
     * @param size This parameter can be set to a single number or to an object with the
     * following (optional) properties: precision, width, height. If a single number is passed,
     * it will be used for both width and height. If an object is passed, the screenshot size
     * will be derived from the parameters. The precision property is a multiplier allowing
     * rendering at a higher or lower resolution
     * @param mimeType The MIME type of the screenshot image (default: image/png).
     * Check your browser for supported MIME types
     * @param samples Texture samples (default: 1)
     * @param antialiasing Whether antialiasing should be turned on or not (default: false)
     * @param fileName A name for for the downloaded file.
     * @param renderSprites Whether the sprites should be rendered or not (default: false)
     * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)
     * @param useLayerMask if the camera's layer mask should be used to filter what should be rendered (default: true)
     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
     * @param customizeTexture An optional callback that can be used to modify the render target texture before taking the screenshot. This can be used, for instance, to enable camera post-processes before taking the screenshot.
     * @returns screenshot as a string of base64-encoded characters. This string can be assigned
     * to the src parameter of an <img> to display it
     */ // eslint-disable-next-line @typescript-eslint/no-unused-vars, no-restricted-syntax, @typescript-eslint/require-await
    static async CreateScreenshotUsingRenderTargetAsync(engine, camera, size, mimeType = "image/png", samples = 1, antialiasing = false, fileName, renderSprites = false, enableStencilBuffer = false, useLayerMask = true, quality, customizeTexture) {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$devTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_WarnImport"])("ScreenshotTools");
    }
    /**
     * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523
     * Be aware Math.random() could cause collisions, but:
     * "All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide"
     * @returns a pseudo random id
     */ static RandomId() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$guid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RandomGUID"])();
    }
    /**
     * Test if the given uri is a base64 string
     * @deprecated Please use FileTools.IsBase64DataUrl instead.
     * @param uri The uri to test
     * @returns True if the uri is a base64 string or false otherwise
     */ static IsBase64(uri) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["IsBase64DataUrl"])(uri);
    }
    /**
     * Decode the given base64 uri.
     * @deprecated Please use FileTools.DecodeBase64UrlToBinary instead.
     * @param uri The uri to decode
     * @returns The decoded base64 data.
     */ static DecodeBase64(uri) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DecodeBase64UrlToBinary"])(uri);
    }
    /**
     * Gets a value indicating the number of loading errors
     * @ignorenaming
     */ // eslint-disable-next-line @typescript-eslint/naming-convention
    static get errorsCount() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].errorsCount;
    }
    /**
     * Log a message to the console
     * @param message defines the message to log
     */ static Log(message) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Log(message);
    }
    /**
     * Write a warning message to the console
     * @param message defines the message to log
     */ static Warn(message) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Warn(message);
    }
    /**
     * Write an error message to the console
     * @param message defines the message to log
     */ static Error(message) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Error(message);
    }
    /**
     * Gets current log cache (list of logs)
     */ static get LogCache() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].LogCache;
    }
    /**
     * Clears the log cache
     */ static ClearLogCache() {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].ClearLogCache();
    }
    /**
     * Sets the current log level (MessageLogLevel / WarningLogLevel / ErrorLogLevel)
     */ static set LogLevels(level) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].LogLevels = level;
    }
    /**
     * Sets the current performance log level
     */ static set PerformanceLogLevel(level) {
        if ((level & Tools.PerformanceUserMarkLogLevel) === Tools.PerformanceUserMarkLogLevel) {
            if (_native?.enablePerformanceLogging) {
                _native.enablePerformanceLogging(1 /* NativeTraceLevel.Mark */ );
                Tools.StartPerformanceCounter = Tools._StartMarkNative;
                Tools.EndPerformanceCounter = Tools._EndMarkNative;
            } else {
                Tools.StartPerformanceCounter = Tools._StartUserMark;
                Tools.EndPerformanceCounter = Tools._EndUserMark;
            }
            return;
        }
        if ((level & Tools.PerformanceConsoleLogLevel) === Tools.PerformanceConsoleLogLevel) {
            if (_native?.enablePerformanceLogging) {
                _native.enablePerformanceLogging(2 /* NativeTraceLevel.Log */ );
                Tools.StartPerformanceCounter = Tools._StartMarkNative;
                Tools.EndPerformanceCounter = Tools._EndMarkNative;
            } else {
                Tools.StartPerformanceCounter = Tools._StartPerformanceConsole;
                Tools.EndPerformanceCounter = Tools._EndPerformanceConsole;
            }
            return;
        }
        Tools.StartPerformanceCounter = Tools._StartPerformanceCounterDisabled;
        Tools.EndPerformanceCounter = Tools._EndPerformanceCounterDisabled;
        _native?.disablePerformanceLogging?.();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static _StartPerformanceCounterDisabled(counterName, condition) {}
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static _EndPerformanceCounterDisabled(counterName, condition) {}
    static _StartUserMark(counterName, condition = true) {
        if (!Tools._Performance) {
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$domManagement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["IsWindowObjectExist"])()) {
                return;
            }
            Tools._Performance = window.performance;
        }
        if (!condition || !Tools._Performance.mark) {
            return;
        }
        Tools._Performance.mark(counterName + "-Begin");
    }
    static _EndUserMark(counterName, condition = true) {
        if (!condition || !Tools._Performance.mark) {
            return;
        }
        Tools._Performance.mark(counterName + "-End");
        Tools._Performance.measure(counterName, counterName + "-Begin", counterName + "-End");
    }
    static _StartPerformanceConsole(counterName, condition = true) {
        if (!condition) {
            return;
        }
        Tools._StartUserMark(counterName, condition);
        if (console.time) {
            console.time(counterName);
        }
    }
    static _EndPerformanceConsole(counterName, condition = true) {
        if (!condition) {
            return;
        }
        Tools._EndUserMark(counterName, condition);
        console.timeEnd(counterName);
    }
    static _StartMarkNative(counterName, condition = true) {
        if (condition && _native?.startPerformanceCounter) {
            if (Tools._NativePerformanceCounterHandles.has(counterName)) {
                Tools.Warn(`Performance counter with name ${counterName} is already started.`);
            } else {
                const handle = _native.startPerformanceCounter(counterName);
                Tools._NativePerformanceCounterHandles.set(counterName, handle);
            }
        }
    }
    static _EndMarkNative(counterName, condition = true) {
        if (condition && _native?.endPerformanceCounter) {
            const handle = Tools._NativePerformanceCounterHandles.get(counterName);
            if (handle) {
                _native.endPerformanceCounter(handle);
                Tools._NativePerformanceCounterHandles.delete(counterName);
            } else {
                Tools.Warn(`Performance counter with name ${counterName} was not started.`);
            }
        }
    }
    /**
     * Gets either window.performance.now() if supported or Date.now() else
     */ static get Now() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now;
    }
    /**
     * This method will return the name of the class used to create the instance of the given object.
     * It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator.
     * @param object the object to get the class name from
     * @param isType defines if the object is actually a type
     * @returns the name of the class, will be "object" for a custom data type not using the @className decorator
     */ static GetClassName(object, isType = false) {
        let name = null;
        if (!isType && object.getClassName) {
            name = object.getClassName();
        } else {
            if (object instanceof Object) {
                const classObj = isType ? object : Object.getPrototypeOf(object);
                name = classObj.constructor["__bjsclassName__"];
            }
            if (!name) {
                name = typeof object;
            }
        }
        return name;
    }
    /**
     * Gets the first element of an array satisfying a given predicate
     * @param array defines the array to browse
     * @param predicate defines the predicate to use
     * @returns null if not found or the element
     */ static First(array, predicate) {
        for (const el of array){
            if (predicate(el)) {
                return el;
            }
        }
        return null;
    }
    /**
     * This method will return the name of the full name of the class, including its owning module (if any).
     * It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator or implementing a method getClassName():string (in which case the module won't be specified).
     * @param object the object to get the class name from
     * @param isType defines if the object is actually a type
     * @returns a string that can have two forms: "moduleName.className" if module was specified when the class' Name was registered or "className" if there was not module specified.
     * @ignorenaming
     */ // eslint-disable-next-line @typescript-eslint/naming-convention
    static getFullClassName(object, isType = false) {
        let className = null;
        let moduleName = null;
        if (!isType && object.getClassName) {
            className = object.getClassName();
        } else {
            if (object instanceof Object) {
                const classObj = isType ? object : Object.getPrototypeOf(object);
                className = classObj.constructor["__bjsclassName__"];
                moduleName = classObj.constructor["__bjsmoduleName__"];
            }
            if (!className) {
                className = typeof object;
            }
        }
        if (!className) {
            return null;
        }
        return (moduleName != null ? moduleName + "." : "") + className;
    }
    /**
     * Returns a promise that resolves after the given amount of time.
     * @param delay Number of milliseconds to delay
     * @returns Promise that resolves after the given amount of time
     */ static async DelayAsync(delay) {
        await new Promise((resolve)=>{
            setTimeout(()=>{
                resolve();
            }, delay);
        });
    }
    /**
     * Utility function to detect if the current user agent is Safari
     * @returns whether or not the current user agent is safari
     */ static IsSafari() {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$domManagement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["IsNavigatorAvailable"])()) {
            return false;
        }
        return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    }
}
/**
 * The base URL to use to load assets. If empty the default base url is used.
 */ Tools.AssetBaseUrl = "";
/**
 * Enable/Disable Custom HTTP Request Headers globally.
 * default = false
 * @see CustomRequestHeaders
 */ Tools.UseCustomRequestHeaders = false;
/**
 * Custom HTTP Request Headers to be sent with XMLHttpRequests
 * i.e. when loading files, where the server/service expects an Authorization header
 */ Tools.CustomRequestHeaders = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$webRequest$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WebRequest"].CustomRequestHeaders;
/**
 * Extracts text content from a DOM element hierarchy
 * Back Compat only, please use GetDOMTextContent instead.
 */ Tools.GetDOMTextContent = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$domManagement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GetDOMTextContent"];
/**
 * @internal
 */ Tools._DefaultCdnUrl = "https://cdn.babylonjs.com";
/**
 * @internal
 */ Tools._DefaultAssetsUrl = "https://assets.babylonjs.com/core";
// eslint-disable-next-line jsdoc/require-returns-check, jsdoc/require-param
/**
 * @returns the absolute URL of a given (relative) url
 */ Tools.GetAbsoluteUrl = typeof document === "object" ? (url)=>{
    const a = document.createElement("a");
    a.href = url;
    return a.href;
} : typeof URL === "function" && typeof location === "object" ? (url)=>new URL(url, location.origin).href : ()=>{
    throw new Error("Unable to get absolute URL. Override BABYLON.Tools.GetAbsoluteUrl to a custom implementation for the current context.");
};
// Logs
/**
 * No log
 */ Tools.NoneLogLevel = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].NoneLogLevel;
/**
 * Only message logs
 */ Tools.MessageLogLevel = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].MessageLogLevel;
/**
 * Only warning logs
 */ Tools.WarningLogLevel = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].WarningLogLevel;
/**
 * Only error logs
 */ Tools.ErrorLogLevel = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].ErrorLogLevel;
/**
 * All logs
 */ Tools.AllLogLevel = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].AllLogLevel;
/**
 * Checks if the window object exists
 * Back Compat only, please use IsWindowObjectExist instead.
 */ Tools.IsWindowObjectExist = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$domManagement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["IsWindowObjectExist"];
// Performances
/**
 * No performance log
 */ Tools.PerformanceNoneLogLevel = 0;
/**
 * Use user marks to log performance
 */ Tools.PerformanceUserMarkLogLevel = 1;
/**
 * Log performance to the console
 */ Tools.PerformanceConsoleLogLevel = 2;
Tools._NativePerformanceCounterHandles = new Map();
/**
 * Starts a performance counter
 */ Tools.StartPerformanceCounter = Tools._StartPerformanceCounterDisabled;
/**
 * Ends a specific performance counter
 */ Tools.EndPerformanceCounter = Tools._EndPerformanceCounterDisabled;
function className(name, module) {
    return (target)=>{
        target["__bjsclassName__"] = name;
        target["__bjsmoduleName__"] = module != null ? module : null;
    };
}
class AsyncLoop {
    /**
     * Constructor.
     * @param iterations the number of iterations.
     * @param func the function to run each iteration
     * @param successCallback the callback that will be called upon successful execution
     * @param offset starting offset.
     */ constructor(/**
     * Defines the number of iterations for the loop
     */ iterations, func, successCallback, offset = 0){
        this.iterations = iterations;
        this.index = offset - 1;
        this._done = false;
        this._fn = func;
        this._successCallback = successCallback;
    }
    /**
     * Execute the next iteration. Must be called after the last iteration was finished.
     */ executeNext() {
        if (!this._done) {
            if (this.index + 1 < this.iterations) {
                ++this.index;
                this._fn(this);
            } else {
                this.breakLoop();
            }
        }
    }
    /**
     * Break the loop and run the success callback.
     */ breakLoop() {
        this._done = true;
        this._successCallback();
    }
    /**
     * Create and run an async loop.
     * @param iterations the number of iterations.
     * @param fn the function to run each iteration
     * @param successCallback the callback that will be called upon successful execution
     * @param offset starting offset.
     * @returns the created async loop object
     */ static Run(iterations, fn, successCallback, offset = 0) {
        const loop = new AsyncLoop(iterations, fn, successCallback, offset);
        loop.executeNext();
        return loop;
    }
    /**
     * A for-loop that will run a given number of iterations synchronous and the rest async.
     * @param iterations total number of iterations
     * @param syncedIterations number of synchronous iterations in each async iteration.
     * @param fn the function to call each iteration.
     * @param callback a success call back that will be called when iterating stops.
     * @param breakFunction a break condition (optional)
     * @param timeout timeout settings for the setTimeout function. default - 0.
     * @returns the created async loop object
     */ static SyncAsyncForLoop(iterations, syncedIterations, fn, callback, breakFunction, timeout = 0) {
        return AsyncLoop.Run(Math.ceil(iterations / syncedIterations), (loop)=>{
            if (breakFunction && breakFunction()) {
                loop.breakLoop();
            } else {
                setTimeout(()=>{
                    for(let i = 0; i < syncedIterations; ++i){
                        const iteration = loop.index * syncedIterations + i;
                        if (iteration >= iterations) {
                            break;
                        }
                        fn(iteration);
                        if (breakFunction && breakFunction()) {
                            loop.breakLoop();
                            break;
                        }
                    }
                    loop.executeNext();
                }, timeout);
            }
        }, callback);
    }
}
Tools.Mix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Mix"];
Tools.IsExponentOfTwo = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["IsExponentOfTwo"];
// Will only be define if Tools is imported freeing up some space when only engine is required
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engineStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EngineStore"].FallbackTexture = "data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDQuMC41AP/bAEMABAIDAwMCBAMDAwQEBAQFCQYFBQUFCwgIBgkNCw0NDQsMDA4QFBEODxMPDAwSGBITFRYXFxcOERkbGRYaFBYXFv/bAEMBBAQEBQUFCgYGChYPDA8WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFv/AABEIAQABAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APH6KKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76P//Z"; //# sourceMappingURL=tools.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/smartArray.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Defines an GC Friendly array where the backfield array do not shrink to prevent over allocations.
 */ __turbopack_context__.s([
    "SmartArray",
    ()=>SmartArray,
    "SmartArrayNoDuplicate",
    ()=>SmartArrayNoDuplicate
]);
class SmartArray {
    /**
     * Instantiates a Smart Array.
     * @param capacity defines the default capacity of the array.
     */ constructor(capacity){
        /**
         * The active length of the array.
         */ this.length = 0;
        this.data = new Array(capacity);
        this._id = SmartArray._GlobalId++;
    }
    /**
     * Pushes a value at the end of the active data.
     * @param value defines the object to push in the array.
     */ push(value) {
        this.data[this.length++] = value;
        if (this.length > this.data.length) {
            this.data.length *= 2;
        }
    }
    /**
     * Iterates over the active data and apply the lambda to them.
     * @param func defines the action to apply on each value.
     */ forEach(func) {
        for(let index = 0; index < this.length; index++){
            func(this.data[index]);
        }
    }
    /**
     * Sorts the full sets of data.
     * @param compareFn defines the comparison function to apply.
     */ sort(compareFn) {
        this.data.sort(compareFn);
    }
    /**
     * Resets the active data to an empty array.
     */ reset() {
        this.length = 0;
    }
    /**
     * Releases all the data from the array as well as the array.
     */ dispose() {
        this.reset();
        if (this.data) {
            this.data.length = 0;
        }
    }
    /**
     * Concats the active data with a given array.
     * @param array defines the data to concatenate with.
     */ concat(array) {
        if (array.length === 0) {
            return;
        }
        if (this.length + array.length > this.data.length) {
            this.data.length = (this.length + array.length) * 2;
        }
        for(let index = 0; index < array.length; index++){
            this.data[this.length++] = (array.data || array)[index];
        }
    }
    /**
     * Returns the position of a value in the active data.
     * @param value defines the value to find the index for
     * @returns the index if found in the active data otherwise -1
     */ indexOf(value) {
        const position = this.data.indexOf(value);
        if (position >= this.length) {
            return -1;
        }
        return position;
    }
    /**
     * Returns whether an element is part of the active data.
     * @param value defines the value to look for
     * @returns true if found in the active data otherwise false
     */ contains(value) {
        return this.indexOf(value) !== -1;
    }
}
// Statics
SmartArray._GlobalId = 0;
class SmartArrayNoDuplicate extends SmartArray {
    constructor(){
        super(...arguments);
        this._duplicateId = 0;
    }
    /**
     * Pushes a value at the end of the active data.
     * THIS DOES NOT PREVENT DUPPLICATE DATA
     * @param value defines the object to push in the array.
     */ push(value) {
        super.push(value);
        if (!value.__smartArrayFlags) {
            value.__smartArrayFlags = {};
        }
        value.__smartArrayFlags[this._id] = this._duplicateId;
    }
    /**
     * Pushes a value at the end of the active data.
     * If the data is already present, it won t be added again
     * @param value defines the object to push in the array.
     * @returns true if added false if it was already present
     */ pushNoDuplicate(value) {
        if (value.__smartArrayFlags && value.__smartArrayFlags[this._id] === this._duplicateId) {
            return false;
        }
        this.push(value);
        return true;
    }
    /**
     * Resets the active data to an empty array.
     */ reset() {
        super.reset();
        this._duplicateId++;
    }
    /**
     * Concats the active data with a given array.
     * This ensures no duplicate will be present in the result.
     * @param array defines the data to concatenate with.
     */ concatWithNoDuplicate(array) {
        if (array.length === 0) {
            return;
        }
        if (this.length + array.length > this.data.length) {
            this.data.length = (this.length + array.length) * 2;
        }
        for(let index = 0; index < array.length; index++){
            const item = (array.data || array)[index];
            this.pushNoDuplicate(item);
        }
    }
} //# sourceMappingURL=smartArray.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/stringDictionary.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * This class implement a typical dictionary using a string as key and the generic type T as value.
 * The underlying implementation relies on an associative array to ensure the best performances.
 * The value can be anything including 'null' but except 'undefined'
 */ __turbopack_context__.s([
    "StringDictionary",
    ()=>StringDictionary
]);
class StringDictionary {
    constructor(){
        this._count = 0;
        this._data = {};
    }
    /**
     * This will clear this dictionary and copy the content from the 'source' one.
     * If the T value is a custom object, it won't be copied/cloned, the same object will be used
     * @param source the dictionary to take the content from and copy to this dictionary
     */ copyFrom(source) {
        this.clear();
        source.forEach((t, v)=>this.add(t, v));
    }
    /**
     * Get a value based from its key
     * @param key the given key to get the matching value from
     * @returns the value if found, otherwise undefined is returned
     */ get(key) {
        const val = this._data[key];
        if (val !== undefined) {
            return val;
        }
        return undefined;
    }
    /**
     * Get a value from its key or add it if it doesn't exist.
     * This method will ensure you that a given key/data will be present in the dictionary.
     * @param key the given key to get the matching value from
     * @param factory the factory that will create the value if the key is not present in the dictionary.
     * The factory will only be invoked if there's no data for the given key.
     * @returns the value corresponding to the key.
     */ getOrAddWithFactory(key, factory) {
        let val = this.get(key);
        if (val !== undefined) {
            return val;
        }
        val = factory(key);
        if (val) {
            this.add(key, val);
        }
        return val;
    }
    /**
     * Get a value from its key if present in the dictionary otherwise add it
     * @param key the key to get the value from
     * @param val if there's no such key/value pair in the dictionary add it with this value
     * @returns the value corresponding to the key
     */ getOrAdd(key, val) {
        const curVal = this.get(key);
        if (curVal !== undefined) {
            return curVal;
        }
        this.add(key, val);
        return val;
    }
    /**
     * Check if there's a given key in the dictionary
     * @param key the key to check for
     * @returns true if the key is present, false otherwise
     */ contains(key) {
        return this._data[key] !== undefined;
    }
    /**
     * Add a new key and its corresponding value
     * @param key the key to add
     * @param value the value corresponding to the key
     * @returns true if the operation completed successfully, false if we couldn't insert the key/value because there was already this key in the dictionary
     */ add(key, value) {
        if (this._data[key] !== undefined) {
            return false;
        }
        this._data[key] = value;
        ++this._count;
        return true;
    }
    /**
     * Update a specific value associated to a key
     * @param key defines the key to use
     * @param value defines the value to store
     * @returns true if the value was updated (or false if the key was not found)
     */ set(key, value) {
        if (this._data[key] === undefined) {
            return false;
        }
        this._data[key] = value;
        return true;
    }
    /**
     * Get the element of the given key and remove it from the dictionary
     * @param key defines the key to search
     * @returns the value associated with the key or null if not found
     */ getAndRemove(key) {
        const val = this.get(key);
        if (val !== undefined) {
            delete this._data[key];
            --this._count;
            return val;
        }
        return null;
    }
    /**
     * Remove a key/value from the dictionary.
     * @param key the key to remove
     * @returns true if the item was successfully deleted, false if no item with such key exist in the dictionary
     */ remove(key) {
        if (this.contains(key)) {
            delete this._data[key];
            --this._count;
            return true;
        }
        return false;
    }
    /**
     * Clear the whole content of the dictionary
     */ clear() {
        this._data = {};
        this._count = 0;
    }
    /**
     * Gets the current count
     */ get count() {
        return this._count;
    }
    /**
     * Execute a callback on each key/val of the dictionary.
     * Note that you can remove any element in this dictionary in the callback implementation
     * @param callback the callback to execute on a given key/value pair
     */ forEach(callback) {
        for(const cur in this._data){
            const val = this._data[cur];
            callback(cur, val);
        }
    }
    /**
     * Execute a callback on every occurrence of the dictionary until it returns a valid TRes object.
     * If the callback returns null or undefined the method will iterate to the next key/value pair
     * Note that you can remove any element in this dictionary in the callback implementation
     * @param callback the callback to execute, if it return a valid T instanced object the enumeration will stop and the object will be returned
     * @returns the first item
     */ // eslint-disable-next-line @typescript-eslint/naming-convention
    first(callback) {
        for(const cur in this._data){
            const val = this._data[cur];
            const res = callback(cur, val);
            if (res) {
                return res;
            }
        }
        return null;
    }
} //# sourceMappingURL=stringDictionary.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/perfCounter.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PerfCounter",
    ()=>PerfCounter
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/precisionDate.js [app-ssr] (ecmascript)");
;
class PerfCounter {
    /**
     * Returns the smallest value ever
     */ get min() {
        return this._min;
    }
    /**
     * Returns the biggest value ever
     */ get max() {
        return this._max;
    }
    /**
     * Returns the average value since the performance counter is running
     */ get average() {
        return this._average;
    }
    /**
     * Returns the average value of the last second the counter was monitored
     */ get lastSecAverage() {
        return this._lastSecAverage;
    }
    /**
     * Returns the current value
     */ get current() {
        return this._current;
    }
    /**
     * Gets the accumulated total
     */ get total() {
        return this._totalAccumulated;
    }
    /**
     * Gets the total value count
     */ get count() {
        return this._totalValueCount;
    }
    /**
     * Creates a new counter
     */ constructor(){
        this._startMonitoringTime = 0;
        this._min = 0;
        this._max = 0;
        this._average = 0;
        this._lastSecAverage = 0;
        this._current = 0;
        this._totalValueCount = 0;
        this._totalAccumulated = 0;
        this._lastSecAccumulated = 0;
        this._lastSecTime = 0;
        this._lastSecValueCount = 0;
    }
    /**
     * Call this method to start monitoring a new frame.
     * This scenario is typically used when you accumulate monitoring time many times for a single frame, you call this method at the start of the frame, then beginMonitoring to start recording and endMonitoring(false) to accumulated the recorded time to the PerfCounter or addCount() to accumulate a monitored count.
     */ fetchNewFrame() {
        this._totalValueCount++;
        this._current = 0;
        this._lastSecValueCount++;
    }
    /**
     * Call this method to monitor a count of something (e.g. mesh drawn in viewport count)
     * @param newCount the count value to add to the monitored count
     * @param fetchResult true when it's the last time in the frame you add to the counter and you wish to update the statistics properties (min/max/average), false if you only want to update statistics.
     */ addCount(newCount, fetchResult) {
        if (!PerfCounter.Enabled) {
            return;
        }
        this._current += newCount;
        if (fetchResult) {
            this._fetchResult();
        }
    }
    /**
     * Start monitoring this performance counter
     */ beginMonitoring() {
        if (!PerfCounter.Enabled) {
            return;
        }
        this._startMonitoringTime = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now;
    }
    /**
     * Compute the time lapsed since the previous beginMonitoring() call.
     * @param newFrame true by default to fetch the result and monitor a new frame, if false the time monitored will be added to the current frame counter
     */ endMonitoring(newFrame = true) {
        if (!PerfCounter.Enabled) {
            return;
        }
        if (newFrame) {
            this.fetchNewFrame();
        }
        const currentTime = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now;
        this._current = currentTime - this._startMonitoringTime;
        if (newFrame) {
            this._fetchResult();
        }
    }
    /**
     * Call this method to end the monitoring of a frame.
     * This scenario is typically used when you accumulate monitoring time many times for a single frame, you call this method at the end of the frame, after beginMonitoring to start recording and endMonitoring(false) to accumulated the recorded time to the PerfCounter or addCount() to accumulate a monitored count.
     */ endFrame() {
        this._fetchResult();
    }
    /** @internal */ _fetchResult() {
        this._totalAccumulated += this._current;
        this._lastSecAccumulated += this._current;
        // Min/Max update
        this._min = Math.min(this._min, this._current);
        this._max = Math.max(this._max, this._current);
        this._average = this._totalAccumulated / this._totalValueCount;
        // Reset last sec?
        const now = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now;
        if (now - this._lastSecTime > 1000) {
            this._lastSecAverage = this._lastSecAccumulated / this._lastSecValueCount;
            this._lastSecTime = now;
            this._lastSecAccumulated = 0;
            this._lastSecValueCount = 0;
        }
    }
}
/**
 * Gets or sets a global boolean to turn on and off all the counters
 */ PerfCounter.Enabled = true; //# sourceMappingURL=perfCounter.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/uniqueIdGenerator.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Helper class used to generate session unique ID
 */ __turbopack_context__.s([
    "UniqueIdGenerator",
    ()=>UniqueIdGenerator
]);
class UniqueIdGenerator {
    /**
     * Gets an unique (relatively to the current scene) Id
     */ static get UniqueId() {
        const result = this._UniqueIdCounter;
        this._UniqueIdCounter++;
        return result;
    }
}
// Statics
UniqueIdGenerator._UniqueIdCounter = 1; //# sourceMappingURL=uniqueIdGenerator.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/copyTools.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Transform some pixel data to a base64 string
 * @param pixels defines the pixel data to transform to base64
 * @param size defines the width and height of the (texture) data
 * @param invertY true if the data must be inverted for the Y coordinate during the conversion
 * @returns The base64 encoded string or null
 */ __turbopack_context__.s([
    "CopyTools",
    ()=>CopyTools,
    "GenerateBase64StringFromPixelData",
    ()=>GenerateBase64StringFromPixelData,
    "GenerateBase64StringFromTexture",
    ()=>GenerateBase64StringFromTexture,
    "GenerateBase64StringFromTextureAsync",
    ()=>GenerateBase64StringFromTextureAsync
]);
function GenerateBase64StringFromPixelData(pixels, size, invertY = false) {
    const width = size.width;
    const height = size.height;
    if (pixels instanceof Float32Array) {
        let len = pixels.byteLength / pixels.BYTES_PER_ELEMENT;
        const npixels = new Uint8Array(len);
        while(--len >= 0){
            let val = pixels[len];
            if (val < 0) {
                val = 0;
            } else if (val > 1) {
                val = 1;
            }
            npixels[len] = val * 255;
        }
        pixels = npixels;
    }
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    if (!ctx) {
        return null;
    }
    const imageData = ctx.createImageData(width, height);
    const castData = imageData.data;
    castData.set(pixels);
    ctx.putImageData(imageData, 0, 0);
    if (invertY) {
        const canvas2 = document.createElement("canvas");
        canvas2.width = width;
        canvas2.height = height;
        const ctx2 = canvas2.getContext("2d");
        if (!ctx2) {
            return null;
        }
        ctx2.translate(0, height);
        ctx2.scale(1, -1);
        ctx2.drawImage(canvas, 0, 0);
        return canvas2.toDataURL("image/png");
    }
    return canvas.toDataURL("image/png");
}
function GenerateBase64StringFromTexture(texture, faceIndex = 0, level = 0) {
    const internalTexture = texture.getInternalTexture();
    if (!internalTexture) {
        return null;
    }
    const pixels = texture._readPixelsSync(faceIndex, level);
    if (!pixels) {
        return null;
    }
    return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);
}
async function GenerateBase64StringFromTextureAsync(texture, faceIndex = 0, level = 0) {
    const internalTexture = texture.getInternalTexture();
    if (!internalTexture) {
        return null;
    }
    const pixels = await texture.readPixels(faceIndex, level);
    if (!pixels) {
        return null;
    }
    return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);
}
const CopyTools = {
    /**
     * Transform some pixel data to a base64 string
     * @param pixels defines the pixel data to transform to base64
     * @param size defines the width and height of the (texture) data
     * @param invertY true if the data must be inverted for the Y coordinate during the conversion
     * @returns The base64 encoded string or null
     */ GenerateBase64StringFromPixelData,
    /**
     * Reads the pixels stored in the webgl texture and returns them as a base64 string
     * @param texture defines the texture to read pixels from
     * @param faceIndex defines the face of the texture to read (in case of cube texture)
     * @param level defines the LOD level of the texture to read (in case of Mip Maps)
     * @returns The base64 encoded string or null
     */ GenerateBase64StringFromTexture,
    /**
     * Reads the pixels stored in the webgl texture and returns them as a base64 string
     * @param texture defines the texture to read pixels from
     * @param faceIndex defines the face of the texture to read (in case of cube texture)
     * @param level defines the LOD level of the texture to read (in case of Mip Maps)
     * @returns The base64 encoded string or null wrapped in a promise
     */ GenerateBase64StringFromTextureAsync
}; //# sourceMappingURL=copyTools.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/performanceMonitor.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PerformanceMonitor",
    ()=>PerformanceMonitor,
    "RollingAverage",
    ()=>RollingAverage
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/precisionDate.js [app-ssr] (ecmascript)");
;
class PerformanceMonitor {
    /**
     * constructor
     * @param frameSampleSize The number of samples required to saturate the sliding window
     */ constructor(frameSampleSize = 30){
        this._enabled = true;
        this._rollingFrameTime = new RollingAverage(frameSampleSize);
    }
    /**
     * Samples current frame
     * @param timeMs A timestamp in milliseconds of the current frame to compare with other frames
     */ sampleFrame(timeMs = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now) {
        if (!this._enabled) {
            return;
        }
        if (this._lastFrameTimeMs != null) {
            const dt = timeMs - this._lastFrameTimeMs;
            this._rollingFrameTime.add(dt);
        }
        this._lastFrameTimeMs = timeMs;
    }
    /**
     * Returns the average frame time in milliseconds over the sliding window (or the subset of frames sampled so far)
     */ get averageFrameTime() {
        return this._rollingFrameTime.average;
    }
    /**
     * Returns the variance frame time in milliseconds over the sliding window (or the subset of frames sampled so far)
     */ get averageFrameTimeVariance() {
        return this._rollingFrameTime.variance;
    }
    /**
     * Returns the frame time of the most recent frame
     */ get instantaneousFrameTime() {
        return this._rollingFrameTime.history(0);
    }
    /**
     * Returns the average framerate in frames per second over the sliding window (or the subset of frames sampled so far)
     */ get averageFPS() {
        return 1000.0 / this._rollingFrameTime.average;
    }
    /**
     * Returns the average framerate in frames per second using the most recent frame time
     */ get instantaneousFPS() {
        const history = this._rollingFrameTime.history(0);
        if (history === 0) {
            return 0;
        }
        return 1000.0 / history;
    }
    /**
     * Returns true if enough samples have been taken to completely fill the sliding window
     */ get isSaturated() {
        return this._rollingFrameTime.isSaturated();
    }
    /**
     * Enables contributions to the sliding window sample set
     */ enable() {
        this._enabled = true;
    }
    /**
     * Disables contributions to the sliding window sample set
     * Samples will not be interpolated over the disabled period
     */ disable() {
        this._enabled = false;
        //clear last sample to avoid interpolating over the disabled period when next enabled
        this._lastFrameTimeMs = null;
    }
    /**
     * Returns true if sampling is enabled
     */ get isEnabled() {
        return this._enabled;
    }
    /**
     * Resets performance monitor
     */ reset() {
        //clear last sample to avoid interpolating over the disabled period when next enabled
        this._lastFrameTimeMs = null;
        //wipe record
        this._rollingFrameTime.reset();
    }
}
class RollingAverage {
    /**
     * constructor
     * @param length The number of samples required to saturate the sliding window
     */ constructor(length){
        this._samples = new Array(length);
        this.reset();
    }
    /**
     * Adds a sample to the sample set
     * @param v The sample value
     */ add(v) {
        //http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance
        let delta;
        //we need to check if we've already wrapped round
        if (this.isSaturated()) {
            //remove bottom of stack from mean
            const bottomValue = this._samples[this._pos];
            delta = bottomValue - this.average;
            this.average -= delta / (this._sampleCount - 1);
            this._m2 -= delta * (bottomValue - this.average);
        } else {
            this._sampleCount++;
        }
        //add new value to mean
        delta = v - this.average;
        this.average += delta / this._sampleCount;
        this._m2 += delta * (v - this.average);
        //set the new variance
        this.variance = this._m2 / (this._sampleCount - 1);
        this._samples[this._pos] = v;
        this._pos++;
        this._pos %= this._samples.length; //positive wrap around
    }
    /**
     * Returns previously added values or null if outside of history or outside the sliding window domain
     * @param i Index in history. For example, pass 0 for the most recent value and 1 for the value before that
     * @returns Value previously recorded with add() or null if outside of range
     */ history(i) {
        if (i >= this._sampleCount || i >= this._samples.length) {
            return 0;
        }
        const i0 = this._wrapPosition(this._pos - 1.0);
        return this._samples[this._wrapPosition(i0 - i)];
    }
    /**
     * Returns true if enough samples have been taken to completely fill the sliding window
     * @returns true if sample-set saturated
     */ isSaturated() {
        return this._sampleCount >= this._samples.length;
    }
    /**
     * Resets the rolling average (equivalent to 0 samples taken so far)
     */ reset() {
        this.average = 0;
        this.variance = 0;
        this._sampleCount = 0;
        this._pos = 0;
        this._m2 = 0;
    }
    /**
     * Wraps a value around the sample range boundaries
     * @param i Position in sample range, for example if the sample length is 5, and i is -3, then 2 will be returned.
     * @returns Wrapped position in sample range
     */ _wrapPosition(i) {
        const max = this._samples.length;
        return (i % max + max) % max;
    }
} //# sourceMappingURL=performanceMonitor.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/thinMinMaxReducer.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DepthTextureType",
    ()=>DepthTextureType,
    "ThinMinMaxReducer",
    ()=>ThinMinMaxReducer,
    "ThinMinMaxReducerPostProcess",
    ()=>ThinMinMaxReducerPostProcess
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/observable.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$effectRenderer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/effectRenderer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Engines/engine.js [app-ssr] (ecmascript)");
;
;
;
var DepthTextureType;
(function(DepthTextureType) {
    DepthTextureType[DepthTextureType["NormalizedViewDepth"] = 0] = "NormalizedViewDepth";
    DepthTextureType[DepthTextureType["ViewDepth"] = 1] = "ViewDepth";
    DepthTextureType[DepthTextureType["ScreenDepth"] = 2] = "ScreenDepth";
})(DepthTextureType || (DepthTextureType = {}));
class ThinMinMaxReducerPostProcess extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$effectRenderer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EffectWrapper"] {
    _gatherImports(useWebGPU, list) {
        if (useWebGPU) {
            this._webGPUReady = true;
            list.push(__turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/minmaxRedux.fragment.js [app-ssr] (ecmascript, async loader)"));
        } else {
            list.push(__turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/minmaxRedux.fragment.js [app-ssr] (ecmascript, async loader)"));
        }
    }
    constructor(name, engine = null, defines = "", options){
        super({
            ...options,
            name,
            engine: engine || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Engine"].LastCreatedEngine,
            useShaderStore: true,
            useAsPostProcess: true,
            fragmentShader: ThinMinMaxReducerPostProcess.FragmentUrl,
            uniforms: ThinMinMaxReducerPostProcess.Uniforms,
            defines
        });
        this.textureWidth = 0;
        this.textureHeight = 0;
    }
    bind(noDefaultBindings = false) {
        super.bind(noDefaultBindings);
        const effect = this.drawWrapper.effect;
        if (this.textureWidth === 1 || this.textureHeight === 1) {
            effect.setInt2("texSize", this.textureWidth, this.textureHeight);
        } else {
            effect.setFloat2("texSize", this.textureWidth, this.textureHeight);
        }
    }
}
ThinMinMaxReducerPostProcess.FragmentUrl = "minmaxRedux";
ThinMinMaxReducerPostProcess.Uniforms = [
    "texSize"
];
const BufferFloat = new Float32Array(4 * 1 * 1);
const BufferUint8 = new Uint8Array(4 * 1 * 1);
const MinMax = {
    min: 0,
    max: 0
};
class ThinMinMaxReducer {
    get depthRedux() {
        return this._depthRedux;
    }
    set depthRedux(value) {
        if (this._depthRedux === value) {
            return;
        }
        this._depthRedux = value;
        this._recreatePostProcesses();
    }
    get textureWidth() {
        return this._textureWidth;
    }
    get textureHeight() {
        return this._textureHeight;
    }
    constructor(scene, depthRedux = true){
        this.onAfterReductionPerformed = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Observable"]();
        this._textureWidth = 0;
        this._textureHeight = 0;
        this._scene = scene;
        this._depthRedux = depthRedux;
        this.reductionSteps = [];
    }
    setTextureDimensions(width, height, depthTextureType = 0 /* DepthTextureType.NormalizedViewDepth */ ) {
        if (width === this._textureWidth && height === this._textureHeight && depthTextureType === this._depthTextureType) {
            return false;
        }
        this._textureWidth = width;
        this._textureHeight = height;
        this._depthTextureType = depthTextureType;
        this._recreatePostProcesses();
        return true;
    }
    readMinMax(texture) {
        // Note that we should normally await the call to _readTexturePixels!
        // But because WebGL does the read synchronously, we know the values will be updated without waiting for the promise to be resolved, which will let us get the updated values
        // in the current frame, whereas in WebGPU, the read is asynchronous and we should normally wait for the promise to be resolved to get the updated values.
        // However, it's safe to avoid waiting for the promise to be resolved in WebGPU as well, because we will simply use the current values until "buffer" is updated later on.
        // Note that it means we can suffer some rendering artifacts in WebGPU because we may use previous min/max values for the current frame.
        const isFloat = texture.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Engine"].TEXTURETYPE_FLOAT || texture.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Engine"].TEXTURETYPE_HALF_FLOAT;
        const buffer = isFloat ? BufferFloat : BufferUint8;
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this._scene.getEngine()._readTexturePixels(texture, 1, 1, -1, 0, buffer, false);
        MinMax.min = buffer[0];
        MinMax.max = buffer[1];
        if (!isFloat) {
            MinMax.min = MinMax.min / 255.0;
            MinMax.max = MinMax.max / 255.0;
        }
        if (MinMax.min >= MinMax.max) {
            MinMax.min = 0;
            MinMax.max = 1;
        }
        this.onAfterReductionPerformed.notifyObservers(MinMax);
    }
    dispose(disposeAll = true) {
        if (disposeAll) {
            this.onAfterReductionPerformed.clear();
            this._textureWidth = 0;
            this._textureHeight = 0;
        }
        for(let i = 0; i < this.reductionSteps.length; ++i){
            this.reductionSteps[i].dispose();
        }
        this.reductionSteps.length = 0;
    }
    _recreatePostProcesses() {
        this.dispose(false);
        const scene = this._scene;
        let w = this.textureWidth, h = this.textureHeight;
        const reductionInitial = new ThinMinMaxReducerPostProcess("Initial reduction phase", scene.getEngine(), "#define INITIAL" + (this._depthRedux ? "\n#define DEPTH_REDUX" : "") + (this._depthTextureType === 1 /* DepthTextureType.ViewDepth */  ? "\n#define VIEW_DEPTH" : ""));
        reductionInitial.textureWidth = w;
        reductionInitial.textureHeight = h;
        this.reductionSteps.push(reductionInitial);
        let index = 1;
        // create the additional steps
        while(w > 1 || h > 1){
            w = Math.max(Math.round(w / 2), 1);
            h = Math.max(Math.round(h / 2), 1);
            const reduction = new ThinMinMaxReducerPostProcess("Reduction phase " + index, scene.getEngine(), "#define " + (w == 1 && h == 1 ? "LAST" : w == 1 || h == 1 ? "ONEBEFORELAST" : "MAIN"));
            reduction.textureWidth = w;
            reduction.textureHeight = h;
            this.reductionSteps.push(reduction);
            index++;
        }
    }
} //# sourceMappingURL=thinMinMaxReducer.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/minMaxReducer.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MinMaxReducer",
    ()=>MinMaxReducer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$PostProcesses$2f$postProcess$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/PostProcesses/postProcess.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$PostProcesses$2f$postProcessManager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/PostProcesses/postProcessManager.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$thinMinMaxReducer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/thinMinMaxReducer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$minmaxRedux$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/minmaxRedux.fragment.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$minmaxRedux$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/minmaxRedux.fragment.js [app-ssr] (ecmascript)");
;
;
;
;
;
class MinMaxReducer {
    /**
     * Observable triggered when the computation has been performed
     */ get onAfterReductionPerformed() {
        return this._thinMinMaxReducer.onAfterReductionPerformed;
    }
    /**
     * Creates a min/max reducer
     * @param camera The camera to use for the post processes
     */ constructor(camera){
        this._onAfterUnbindObserver = null;
        this._forceFullscreenViewport = true;
        this._activated = false;
        this._camera = camera;
        this._postProcessManager = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$PostProcesses$2f$postProcessManager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PostProcessManager"](camera.getScene());
        this._thinMinMaxReducer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$thinMinMaxReducer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ThinMinMaxReducer"](camera.getScene());
        this._reductionSteps = [];
        this._onContextRestoredObserver = camera.getEngine().onContextRestoredObservable.add(()=>{
            this._postProcessManager._rebuild();
        });
    }
    /**
     * Gets the texture used to read the values from.
     */ get sourceTexture() {
        return this._sourceTexture;
    }
    /**
     * Sets the source texture to read the values from.
     * One must indicate if the texture is a depth texture or not through the depthRedux parameter
     * because in such textures '1' value must not be taken into account to compute the maximum
     * as this value is used to clear the texture.
     * Note that the computation is not activated by calling this function, you must call activate() for that!
     * @param sourceTexture The texture to read the values from. The values should be in the red channel.
     * @param depthRedux Indicates if the texture is a depth texture or not
     * @param type The type of the textures created for the reduction (defaults to TEXTURETYPE_HALF_FLOAT)
     * @param forceFullscreenViewport Forces the post processes used for the reduction to be applied without taking into account viewport (defaults to true)
     */ setSourceTexture(sourceTexture, depthRedux, type = 2, forceFullscreenViewport = true) {
        if (sourceTexture === this._sourceTexture) {
            return;
        }
        this._thinMinMaxReducer.depthRedux = depthRedux;
        this.deactivate();
        this._sourceTexture = sourceTexture;
        this._forceFullscreenViewport = forceFullscreenViewport;
        if (this._thinMinMaxReducer.setTextureDimensions(sourceTexture.getRenderWidth(), sourceTexture.getRenderHeight())) {
            this._disposePostProcesses();
            const reductionSteps = this._thinMinMaxReducer.reductionSteps;
            for(let i = 0; i < reductionSteps.length; ++i){
                const reductionStep = reductionSteps[i];
                const postProcess = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$PostProcesses$2f$postProcess$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PostProcess"](reductionStep.name, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$thinMinMaxReducer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ThinMinMaxReducerPostProcess"].FragmentUrl, {
                    effectWrapper: reductionStep,
                    samplingMode: 1,
                    engine: this._camera.getScene().getEngine(),
                    textureType: type,
                    textureFormat: 7,
                    size: {
                        width: reductionStep.textureWidth,
                        height: reductionStep.textureHeight
                    }
                });
                this._reductionSteps.push(postProcess);
                postProcess.autoClear = false;
                postProcess.forceFullscreenViewport = forceFullscreenViewport;
                if (i === 0) {
                    postProcess.externalTextureSamplerBinding = true;
                    postProcess.onApplyObservable.add((effect)=>{
                        effect.setTexture("textureSampler", this._sourceTexture);
                    });
                }
                if (i === reductionSteps.length - 1) {
                    this._reductionSteps[i - 1].onAfterRenderObservable.add(()=>{
                        this._thinMinMaxReducer.readMinMax(postProcess.inputTexture.texture);
                    });
                }
            }
        }
    }
    /**
     * Defines the refresh rate of the computation.
     * Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...
     */ get refreshRate() {
        return this._sourceTexture ? this._sourceTexture.refreshRate : -1;
    }
    set refreshRate(value) {
        if (this._sourceTexture) {
            this._sourceTexture.refreshRate = value;
        }
    }
    /**
     * Gets the activation status of the reducer
     */ get activated() {
        return this._activated;
    }
    /**
     * Activates the reduction computation.
     * When activated, the observers registered in onAfterReductionPerformed are
     * called after the computation is performed
     */ activate() {
        if (this._onAfterUnbindObserver || !this._sourceTexture) {
            return;
        }
        this._onAfterUnbindObserver = this._sourceTexture.onAfterUnbindObservable.add(()=>{
            const engine = this._camera.getScene().getEngine();
            engine._debugPushGroup?.(`min max reduction`, 1);
            this._reductionSteps[0].activate(this._camera);
            this._postProcessManager.directRender(this._reductionSteps, this._reductionSteps[0].inputTexture, this._forceFullscreenViewport, 0, 0, true, this._reductionSteps.length - 1);
            engine.unBindFramebuffer(this._reductionSteps[this._reductionSteps.length - 1].inputTexture, false);
            engine._debugPopGroup?.(1);
        });
        this._activated = true;
    }
    /**
     * Deactivates the reduction computation.
     */ deactivate() {
        if (!this._onAfterUnbindObserver || !this._sourceTexture) {
            return;
        }
        this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);
        this._onAfterUnbindObserver = null;
        this._activated = false;
    }
    /**
     * Disposes the min/max reducer
     * @param disposeAll true to dispose all the resources. You should always call this function with true as the parameter (or without any parameter as it is the default one). This flag is meant to be used internally.
     */ dispose(disposeAll = true) {
        if (!disposeAll) {
            return;
        }
        this.onAfterReductionPerformed.clear();
        this._camera.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);
        this._onContextRestoredObserver = undefined;
        this._disposePostProcesses();
        this._postProcessManager.dispose();
        this._postProcessManager = undefined;
        this._thinMinMaxReducer.dispose();
        this._thinMinMaxReducer = undefined;
        this._sourceTexture = null;
    }
    _disposePostProcesses() {
        for(let i = 0; i < this._reductionSteps.length; ++i){
            this._reductionSteps[i].dispose();
        }
        this._reductionSteps.length = 0;
    }
} //# sourceMappingURL=minMaxReducer.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/depthReducer.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DepthReducer",
    ()=>DepthReducer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Rendering$2f$depthRenderer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Rendering/depthRenderer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$minMaxReducer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/minMaxReducer.js [app-ssr] (ecmascript)");
;
;
class DepthReducer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$minMaxReducer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MinMaxReducer"] {
    /**
     * Gets the depth renderer used for the computation.
     * Note that the result is null if you provide your own renderer when calling setDepthRenderer.
     */ get depthRenderer() {
        return this._depthRenderer;
    }
    /**
     * Creates a depth reducer
     * @param camera The camera used to render the depth texture
     */ constructor(camera){
        super(camera);
    }
    /**
     * Sets the depth renderer to use to generate the depth map
     * @param depthRenderer The depth renderer to use. If not provided, a new one will be created automatically
     * @param type The texture type of the depth map (default: TEXTURETYPE_HALF_FLOAT)
     * @param forceFullscreenViewport Forces the post processes used for the reduction to be applied without taking into account viewport (defaults to true)
     */ setDepthRenderer(depthRenderer = null, type = 2, forceFullscreenViewport = true) {
        const scene = this._camera.getScene();
        if (this._depthRenderer) {
            delete scene._depthRenderer[this._depthRendererId];
            this._depthRenderer.dispose();
            this._depthRenderer = null;
        }
        if (depthRenderer === null) {
            if (!scene._depthRenderer) {
                scene._depthRenderer = {};
            }
            this._depthRendererId = "minmax_" + this._camera.id;
            depthRenderer = this._depthRenderer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Rendering$2f$depthRenderer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DepthRenderer"](scene, type, this._camera, false, 1, false, `DepthRenderer ${this._depthRendererId}`);
            depthRenderer.enabled = false;
            scene._depthRenderer[this._depthRendererId] = depthRenderer;
        }
        super.setSourceTexture(depthRenderer.getDepthMap(), true, type, forceFullscreenViewport);
    }
    /**
     * @internal
     */ setSourceTexture(sourceTexture, depthRedux, type = 2, forceFullscreenViewport = true) {
        super.setSourceTexture(sourceTexture, depthRedux, type, forceFullscreenViewport);
    }
    /**
     * Activates the reduction computation.
     * When activated, the observers registered in onAfterReductionPerformed are
     * called after the computation is performed
     */ activate() {
        if (this._depthRenderer) {
            this._depthRenderer.enabled = true;
        }
        super.activate();
    }
    /**
     * Deactivates the reduction computation.
     */ deactivate() {
        super.deactivate();
        if (this._depthRenderer) {
            this._depthRenderer.enabled = false;
        }
    }
    /**
     * Disposes the depth reducer
     * @param disposeAll true to dispose all the resources. You should always call this function with true as the parameter (or without any parameter as it is the default one). This flag is meant to be used internally.
     */ dispose(disposeAll = true) {
        super.dispose(disposeAll);
        if (this._depthRenderer && disposeAll) {
            this._depthRenderer.dispose();
            this._depthRenderer = null;
        }
    }
} //# sourceMappingURL=depthReducer.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/coroutine.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint-disable @typescript-eslint/naming-convention */ // "Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by allowing execution to be suspended and resumed."
// https://en.wikipedia.org/wiki/Coroutine
// The inline scheduler simply steps the coroutine synchronously. This is useful for running a coroutine synchronously, and also as a helper function for other schedulers.
/**
 * @internal
 */ // eslint-disable-next-line @typescript-eslint/naming-convention
__turbopack_context__.s([
    "createYieldingScheduler",
    ()=>createYieldingScheduler,
    "inlineScheduler",
    ()=>inlineScheduler,
    "makeAsyncFunction",
    ()=>makeAsyncFunction,
    "makeSyncFunction",
    ()=>makeSyncFunction,
    "runCoroutine",
    ()=>runCoroutine,
    "runCoroutineAsync",
    ()=>runCoroutineAsync,
    "runCoroutineSync",
    ()=>runCoroutineSync
]);
function inlineScheduler(coroutine, onStep, onError) {
    try {
        const step = coroutine.next();
        if (step.done) {
            onStep(step);
        } else if (!step.value) {
            // NOTE: The properties of step have been narrowed, but the type of step itself is not narrowed, so the cast below is the most type safe way to deal with this without instantiating a new object to hold the values.
            onStep(step);
        } else {
            // eslint-disable-next-line github/no-then
            step.value.then(()=>{
                step.value = undefined;
                onStep(step);
            }, onError);
        }
    } catch (error) {
        onError(error);
    }
}
function createYieldingScheduler(yieldAfterMS = 25) {
    let startTime;
    return (coroutine, onStep, onError)=>{
        const currentTime = performance.now();
        if (startTime === undefined || currentTime - startTime > yieldAfterMS) {
            // If this is the first coroutine step, or if the time interval has elapsed, record a new start time, and schedule the coroutine step to happen later, effectively yielding control of the execution context.
            startTime = currentTime;
            setTimeout(()=>{
                inlineScheduler(coroutine, onStep, onError);
            }, 0);
        } else {
            // Otherwise it is not time to yield yet, so step the coroutine synchronously.
            inlineScheduler(coroutine, onStep, onError);
        }
    };
}
function runCoroutine(coroutine, scheduler, onSuccess, onError, abortSignal) {
    const resume = ()=>{
        let reschedule;
        const onStep = (stepResult)=>{
            if (stepResult.done) {
                // If the coroutine is done, report success.
                onSuccess(stepResult.value);
            } else {
                // If the coroutine is not done, resume the coroutine (via the scheduler).
                if (reschedule === undefined) {
                    // If reschedule is undefined at this point, then the coroutine must have stepped synchronously, so just flag another loop iteration.
                    reschedule = true;
                } else {
                    // If reschedule is defined at this point, then the coroutine must have stepped asynchronously, so call resume to restart the step loop.
                    resume();
                }
            }
        };
        do {
            reschedule = undefined;
            if (!abortSignal || !abortSignal.aborted) {
                scheduler(coroutine, onStep, onError);
            } else {
                onError(new Error("Aborted"));
            }
            if (reschedule === undefined) {
                // If reschedule is undefined at this point, then the coroutine must have stepped asynchronously, so stop looping and let the coroutine be resumed later.
                reschedule = false;
            }
        }while (reschedule)
    };
    resume();
}
function runCoroutineSync(coroutine, abortSignal) {
    // Run the coroutine with the inline scheduler, storing the returned value, or re-throwing the error (since the error callback will be called synchronously by the inline scheduler).
    let result;
    runCoroutine(coroutine, inlineScheduler, (r)=>result = r, (e)=>{
        throw e;
    }, abortSignal);
    // Synchronously return the result of the coroutine.
    return result;
}
async function runCoroutineAsync(coroutine, scheduler, abortSignal) {
    // Run the coroutine with a yielding scheduler, resolving or rejecting the result promise when the coroutine finishes.
    return await new Promise((resolve, reject)=>{
        runCoroutine(coroutine, scheduler, resolve, reject, abortSignal);
    });
}
function makeSyncFunction(coroutineFactory, abortSignal) {
    return (...params)=>{
        // Run the coroutine synchronously.
        return runCoroutineSync(coroutineFactory(...params), abortSignal);
    };
}
function makeAsyncFunction(coroutineFactory, scheduler, abortSignal) {
    // eslint-disable-next-line @typescript-eslint/promise-function-async
    return (...params)=>{
        // Run the coroutine asynchronously.
        return runCoroutineAsync(coroutineFactory(...params), scheduler, abortSignal);
    };
} //# sourceMappingURL=coroutine.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/textureTools.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ApplyPostProcess",
    ()=>ApplyPostProcess,
    "CreateResizedCopy",
    ()=>CreateResizedCopy,
    "FromHalfFloat",
    ()=>FromHalfFloat,
    "GetTextureDataAsync",
    ()=>GetTextureDataAsync,
    "TextureTools",
    ()=>TextureTools,
    "ToHalfFloat",
    ()=>ToHalfFloat,
    "WhenTextureReadyAsync",
    ()=>WhenTextureReadyAsync
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/Textures/texture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$renderTargetTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/Textures/renderTargetTexture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$PostProcesses$2f$passPostProcess$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/PostProcesses/passPostProcess.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$PostProcesses$2f$postProcess$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/PostProcesses/postProcess.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.scalar.functions.js [app-ssr] (ecmascript)");
;
;
;
;
;
function CreateResizedCopy(texture, width, height, useBilinearMode = true) {
    const scene = texture.getScene();
    const engine = scene.getEngine();
    const rtt = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$renderTargetTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RenderTargetTexture"]("resized" + texture.name, {
        width: width,
        height: height
    }, scene, !texture.noMipmap, true, texture._texture.type, false, texture.samplingMode, false);
    rtt.wrapU = texture.wrapU;
    rtt.wrapV = texture.wrapV;
    rtt.uOffset = texture.uOffset;
    rtt.vOffset = texture.vOffset;
    rtt.uScale = texture.uScale;
    rtt.vScale = texture.vScale;
    rtt.uAng = texture.uAng;
    rtt.vAng = texture.vAng;
    rtt.wAng = texture.wAng;
    rtt.coordinatesIndex = texture.coordinatesIndex;
    rtt.level = texture.level;
    rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;
    rtt._texture.isReady = false;
    texture.wrapU = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].CLAMP_ADDRESSMODE;
    texture.wrapV = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].CLAMP_ADDRESSMODE;
    const passPostProcess = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$PostProcesses$2f$passPostProcess$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PassPostProcess"]("pass", 1, null, useBilinearMode ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].BILINEAR_SAMPLINGMODE : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].NEAREST_SAMPLINGMODE, engine, false, 0);
    passPostProcess.externalTextureSamplerBinding = true;
    passPostProcess.onEffectCreatedObservable.addOnce((e)=>{
        e.executeWhenCompiled(()=>{
            passPostProcess.onApply = function(effect) {
                effect.setTexture("textureSampler", texture);
            };
            const internalTexture = rtt.renderTarget;
            if (internalTexture) {
                scene.postProcessManager.directRender([
                    passPostProcess
                ], internalTexture);
                engine.unBindFramebuffer(internalTexture);
                rtt.disposeFramebufferObjects();
                passPostProcess.dispose();
                rtt.getInternalTexture().isReady = true;
            }
        });
    });
    return rtt;
}
function ApplyPostProcess(postProcessName, internalTexture, scene, type, samplingMode, format, width, height) {
    // Gets everything ready.
    const engine = internalTexture.getEngine();
    internalTexture.isReady = false;
    samplingMode = samplingMode ?? internalTexture.samplingMode;
    type = type ?? internalTexture.type;
    format = format ?? internalTexture.format;
    width = width ?? internalTexture.width;
    height = height ?? internalTexture.height;
    if (type === -1) {
        type = 0;
    }
    return new Promise((resolve)=>{
        // Create the post process
        const postProcess = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$PostProcesses$2f$postProcess$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PostProcess"]("postprocess", postProcessName, null, null, 1, null, samplingMode, engine, false, undefined, type, undefined, null, false, format);
        postProcess.externalTextureSamplerBinding = true;
        // Hold the output of the decoding.
        const encodedTexture = engine.createRenderTargetTexture({
            width: width,
            height: height
        }, {
            generateDepthBuffer: false,
            generateMipMaps: false,
            generateStencilBuffer: false,
            samplingMode,
            type,
            format
        });
        postProcess.onEffectCreatedObservable.addOnce((e)=>{
            e.executeWhenCompiled(()=>{
                // PP Render Pass
                postProcess.onApply = (effect)=>{
                    effect._bindTexture("textureSampler", internalTexture);
                    effect.setFloat2("scale", 1, 1);
                };
                scene.postProcessManager.directRender([
                    postProcess
                ], encodedTexture, true);
                // Cleanup
                engine.restoreDefaultFramebuffer();
                engine._releaseTexture(internalTexture);
                if (postProcess) {
                    postProcess.dispose();
                }
                // Internal Swap
                encodedTexture._swapAndDie(internalTexture);
                // Ready to get rolling again.
                internalTexture.type = type;
                internalTexture.format = 5;
                internalTexture.isReady = true;
                resolve(internalTexture);
            });
        });
    });
}
// ref: http://stackoverflow.com/questions/32633585/how-do-you-convert-to-half-floats-in-javascript
let floatView;
let int32View;
function ToHalfFloat(value) {
    if (!floatView) {
        floatView = new Float32Array(1);
        int32View = new Int32Array(floatView.buffer);
    }
    floatView[0] = value;
    const x = int32View[0];
    let bits = x >> 16 & 0x8000; /* Get the sign */ 
    let m = x >> 12 & 0x07ff; /* Keep one extra bit for rounding */ 
    const e = x >> 23 & 0xff; /* Using int is faster here */ 
    /* If zero, or denormal, or exponent underflows too much for a denormal
     * half, return signed zero. */ if (e < 103) {
        return bits;
    }
    /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */ if (e > 142) {
        bits |= 0x7c00;
        /* If exponent was 0xff and one mantissa bit was set, it means NaN,
         * not Inf, so make sure we set one mantissa bit too. */ bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;
        return bits;
    }
    /* If exponent underflows but not too much, return a denormal */ if (e < 113) {
        m |= 0x0800;
        /* Extra rounding may overflow and set mantissa to 0 and exponent
         * to 1, which is OK. */ bits |= (m >> 114 - e) + (m >> 113 - e & 1);
        return bits;
    }
    bits |= e - 112 << 10 | m >> 1;
    bits += m & 1;
    return bits;
}
function FromHalfFloat(value) {
    const s = (value & 0x8000) >> 15;
    const e = (value & 0x7c00) >> 10;
    const f = value & 0x03ff;
    if (e === 0) {
        return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));
    } else if (e == 0x1f) {
        return f ? NaN : (s ? -1 : 1) * Infinity;
    }
    return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));
}
function IsCompressedTextureFormat(format) {
    switch(format){
        case 36492:
        case 36493:
        case 36495:
        case 36494:
        case 33779:
        case 35919:
        case 33778:
        case 35918:
        case 33777:
        case 33776:
        case 35917:
        case 35916:
        case 37808:
        case 37840:
        case 36196:
        case 37492:
        case 37493:
        case 37494:
        case 37495:
        case 37496:
        case 37497:
            return true;
        default:
            return false;
    }
}
async function WhenTextureReadyAsync(texture) {
    if (texture.isReady()) {
        return;
    }
    if (texture.loadingError) {
        throw new Error(texture.errorObject?.message || `Texture ${texture.name} errored while loading.`);
    }
    const onLoadObservable = texture.onLoadObservable;
    if (onLoadObservable) {
        return await new Promise((res)=>onLoadObservable.addOnce(()=>res()));
    }
    const onLoadedObservable = texture._texture?.onLoadedObservable;
    if (onLoadedObservable) {
        return await new Promise((res)=>onLoadedObservable.addOnce(()=>res()));
    }
    throw new Error(`Cannot determine readiness of texture ${texture.name}.`);
}
/**
 * Gets the data of the specified texture by rendering it to an intermediate RGBA texture and retrieving the bytes from it.
 * This is convienent to get 8-bit RGBA values for a texture in a GPU compressed format, which cannot be read using readPixels.
 * @internal
 */ async function ReadPixelsUsingRTT(texture, width, height, face, lod) {
    const scene = texture.getScene();
    const engine = scene.getEngine();
    if (!engine.isWebGPU) {
        if (texture.isCube) {
            await __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/lodCube.fragment.js [app-ssr] (ecmascript, async loader)");
        } else {
            await __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/lod.fragment.js [app-ssr] (ecmascript, async loader)");
        }
    } else {
        if (texture.isCube) {
            await __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/lodCube.fragment.js [app-ssr] (ecmascript, async loader)");
        } else {
            await __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/lod.fragment.js [app-ssr] (ecmascript, async loader)");
        }
    }
    let lodPostProcess;
    if (!texture.isCube) {
        lodPostProcess = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$PostProcesses$2f$postProcess$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PostProcess"]("lod", "lod", {
            uniforms: [
                "lod",
                "gamma"
            ],
            samplingMode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].NEAREST_NEAREST_MIPNEAREST,
            engine,
            shaderLanguage: engine.isWebGPU ? 1 /* ShaderLanguage.WGSL */  : 0 /* ShaderLanguage.GLSL */ 
        });
    } else {
        const faceDefines = [
            "#define POSITIVEX",
            "#define NEGATIVEX",
            "#define POSITIVEY",
            "#define NEGATIVEY",
            "#define POSITIVEZ",
            "#define NEGATIVEZ"
        ];
        lodPostProcess = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$PostProcesses$2f$postProcess$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PostProcess"]("lodCube", "lodCube", {
            uniforms: [
                "lod",
                "gamma"
            ],
            samplingMode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].NEAREST_NEAREST_MIPNEAREST,
            engine,
            defines: faceDefines[face],
            shaderLanguage: engine.isWebGPU ? 1 /* ShaderLanguage.WGSL */  : 0 /* ShaderLanguage.GLSL */ 
        });
    }
    await new Promise((resolve)=>{
        lodPostProcess.onEffectCreatedObservable.addOnce((e)=>{
            e.executeWhenCompiled(()=>{
                resolve(0);
            });
        });
    });
    const rtt = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$renderTargetTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RenderTargetTexture"]("temp", {
        width: width,
        height: height
    }, scene, false);
    lodPostProcess.onApply = function(effect) {
        effect.setTexture("textureSampler", texture);
        effect.setFloat("lod", lod);
        effect.setInt("gamma", texture.gammaSpace ? 1 : 0);
    };
    const internalTexture = texture.getInternalTexture();
    try {
        if (rtt.renderTarget && internalTexture) {
            const samplingMode = internalTexture.samplingMode;
            if (lod !== 0) {
                texture.updateSamplingMode(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].NEAREST_NEAREST_MIPNEAREST);
            } else {
                texture.updateSamplingMode(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].NEAREST_NEAREST);
            }
            scene.postProcessManager.directRender([
                lodPostProcess
            ], rtt.renderTarget, true);
            texture.updateSamplingMode(samplingMode);
            //Reading datas from WebGL
            const bufferView = await engine.readPixels(0, 0, width, height);
            const data = new Uint8Array(bufferView.buffer, 0, bufferView.byteLength);
            // Unbind
            engine.unBindFramebuffer(rtt.renderTarget);
            return data;
        } else {
            throw Error("Render to texture failed.");
        }
    } finally{
        rtt.dispose();
        lodPostProcess.dispose();
    }
}
async function GetTextureDataAsync(texture, width, height, face = 0, lod = 0) {
    await WhenTextureReadyAsync(texture);
    const { width: textureWidth, height: textureHeight } = texture.getSize();
    const targetWidth = width ?? textureWidth;
    const targetHeight = height ?? textureHeight;
    // If the internal texture format is compressed, we cannot read the pixels directly.
    // Or, if we're resizing the texture, we need to use a render target texture.
    if (IsCompressedTextureFormat(texture.textureFormat) || targetWidth !== textureWidth || targetHeight !== textureHeight) {
        return await ReadPixelsUsingRTT(texture, targetWidth, targetHeight, face, lod);
    }
    let data = await texture.readPixels(face, lod);
    if (!data) {
        throw new Error(`Failed to read pixels from texture ${texture.name}.`);
    }
    // Convert float RGBA values to uint8, if necessary.
    if (data instanceof Float32Array) {
        const data2 = new Uint8Array(data.length);
        let n = data.length;
        while(n--){
            const v = data[n];
            data2[n] = Math.round((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Clamp"])(v) * 255);
        }
        data = data2;
    }
    return data;
}
const TextureTools = {
    /**
     * Uses the GPU to create a copy texture rescaled at a given size
     * @param texture Texture to copy from
     * @param width defines the desired width
     * @param height defines the desired height
     * @param useBilinearMode defines if bilinear mode has to be used
     * @returns the generated texture
     */ CreateResizedCopy,
    /**
     * Apply a post process to a texture
     * @param postProcessName name of the fragment post process
     * @param internalTexture the texture to encode
     * @param scene the scene hosting the texture
     * @param type type of the output texture. If not provided, use the one from internalTexture
     * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture
     * @param format format of the output texture. If not provided, use the one from internalTexture
     * @returns a promise with the internalTexture having its texture replaced by the result of the processing
     */ ApplyPostProcess,
    /**
     * Converts a number to half float
     * @param value number to convert
     * @returns converted number
     */ ToHalfFloat,
    /**
     * Converts a half float to a number
     * @param value half float to convert
     * @returns converted half float
     */ FromHalfFloat,
    /**
     * Gets the data of the specified texture by rendering it to an intermediate RGBA texture and retrieving the bytes from it.
     * This is convienent to get 8-bit RGBA values for a texture in a GPU compressed format.
     * @param texture the source texture
     * @param width the width of the result, which does not have to match the source texture width
     * @param height the height of the result, which does not have to match the source texture height
     * @param face if the texture has multiple faces, the face index to use for the source
     * @param lod if the texture has multiple LODs, the lod index to use for the source
     * @returns the 8-bit texture data
     */ GetTextureDataAsync
}; //# sourceMappingURL=textureTools.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/pivotTools.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PivotTools",
    ()=>PivotTools
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-ssr] (ecmascript)");
;
class PivotTools {
    /**
     * @internal
     */ static _RemoveAndStorePivotPoint(mesh) {
        if (mesh && PivotTools._PivotCached === 0) {
            // Save old pivot and set pivot to 0,0,0
            mesh.getPivotPointToRef(PivotTools._OldPivotPoint);
            PivotTools._PivotPostMultiplyPivotMatrix = mesh._postMultiplyPivotMatrix;
            if (!PivotTools._OldPivotPoint.equalsToFloats(0, 0, 0)) {
                mesh.setPivotMatrix(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"].IdentityReadOnly);
                PivotTools._OldPivotPoint.subtractToRef(mesh.getPivotPoint(), PivotTools._PivotTranslation);
                PivotTools._PivotTmpVector.copyFromFloats(1, 1, 1);
                PivotTools._PivotTmpVector.subtractInPlace(mesh.scaling);
                PivotTools._PivotTmpVector.multiplyInPlace(PivotTools._PivotTranslation);
                mesh.position.addInPlace(PivotTools._PivotTmpVector);
            }
        }
        PivotTools._PivotCached++;
    }
    /**
     * @internal
     */ static _RestorePivotPoint(mesh) {
        if (mesh && !PivotTools._OldPivotPoint.equalsToFloats(0, 0, 0) && PivotTools._PivotCached === 1) {
            mesh.setPivotPoint(PivotTools._OldPivotPoint);
            mesh._postMultiplyPivotMatrix = PivotTools._PivotPostMultiplyPivotMatrix;
            PivotTools._PivotTmpVector.copyFromFloats(1, 1, 1);
            PivotTools._PivotTmpVector.subtractInPlace(mesh.scaling);
            PivotTools._PivotTmpVector.multiplyInPlace(PivotTools._PivotTranslation);
            mesh.position.subtractInPlace(PivotTools._PivotTmpVector);
        }
        this._PivotCached--;
    }
}
// Stores the state of the pivot cache (_oldPivotPoint, _pivotTranslation)
// store/remove pivot point should only be applied during their outermost calls
PivotTools._PivotCached = 0;
PivotTools._OldPivotPoint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"]();
PivotTools._PivotTranslation = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"]();
PivotTools._PivotTmpVector = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"]();
PivotTools._PivotPostMultiplyPivotMatrix = false; //# sourceMappingURL=pivotTools.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/virtualJoystick.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "JoystickAxis",
    ()=>JoystickAxis,
    "VirtualJoystick",
    ()=>VirtualJoystick
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$stringDictionary$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/stringDictionary.js [app-ssr] (ecmascript)");
;
;
var JoystickAxis;
(function(JoystickAxis) {
    /** X axis */ JoystickAxis[JoystickAxis["X"] = 0] = "X";
    /** Y axis */ JoystickAxis[JoystickAxis["Y"] = 1] = "Y";
    /** Z axis */ JoystickAxis[JoystickAxis["Z"] = 2] = "Z";
})(JoystickAxis || (JoystickAxis = {}));
class VirtualJoystick {
    static _GetDefaultOptions() {
        return {
            puckSize: 40,
            containerSize: 60,
            color: "cyan",
            puckImage: undefined,
            containerImage: undefined,
            position: undefined,
            alwaysVisible: false,
            limitToContainer: false
        };
    }
    /**
     * Creates a new virtual joystick
     * @param leftJoystick defines that the joystick is for left hand (false by default)
     * @param customizations Defines the options we want to customize the VirtualJoystick
     */ constructor(leftJoystick, customizations){
        this._released = false;
        const options = {
            ...VirtualJoystick._GetDefaultOptions(),
            ...customizations
        };
        if (leftJoystick) {
            this._leftJoystick = true;
        } else {
            this._leftJoystick = false;
        }
        VirtualJoystick._GlobalJoystickIndex++;
        // By default left & right arrow keys are moving the X
        // and up & down keys are moving the Y
        this._axisTargetedByLeftAndRight = 0 /* JoystickAxis.X */ ;
        this._axisTargetedByUpAndDown = 1 /* JoystickAxis.Y */ ;
        this.reverseLeftRight = false;
        this.reverseUpDown = false;
        // collections of pointers
        this._touches = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$stringDictionary$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["StringDictionary"]();
        this.deltaPosition = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"].Zero();
        this._joystickSensibility = 25;
        this._inversedSensibility = 1 / (this._joystickSensibility / 1000);
        this._onResize = ()=>{
            VirtualJoystick._VjCanvasWidth = window.innerWidth;
            VirtualJoystick._VjCanvasHeight = window.innerHeight;
            if (VirtualJoystick.Canvas) {
                VirtualJoystick.Canvas.width = VirtualJoystick._VjCanvasWidth;
                VirtualJoystick.Canvas.height = VirtualJoystick._VjCanvasHeight;
            }
            VirtualJoystick._HalfWidth = VirtualJoystick._VjCanvasWidth / 2;
        };
        // injecting a canvas element on top of the canvas 3D game
        if (!VirtualJoystick.Canvas) {
            window.addEventListener("resize", this._onResize, false);
            VirtualJoystick.Canvas = document.createElement("canvas");
            VirtualJoystick._VjCanvasWidth = window.innerWidth;
            VirtualJoystick._VjCanvasHeight = window.innerHeight;
            VirtualJoystick.Canvas.width = window.innerWidth;
            VirtualJoystick.Canvas.height = window.innerHeight;
            VirtualJoystick.Canvas.style.width = "100%";
            VirtualJoystick.Canvas.style.height = "100%";
            VirtualJoystick.Canvas.style.position = "absolute";
            VirtualJoystick.Canvas.style.backgroundColor = "transparent";
            VirtualJoystick.Canvas.style.top = "0px";
            VirtualJoystick.Canvas.style.left = "0px";
            VirtualJoystick.Canvas.style.zIndex = "5";
            VirtualJoystick.Canvas.style.touchAction = "none"; // fix https://forum.babylonjs.com/t/virtualjoystick-needs-to-set-style-touch-action-none-explicitly/9562
            // Support for jQuery PEP polyfill
            VirtualJoystick.Canvas.setAttribute("touch-action", "none");
            const context = VirtualJoystick.Canvas.getContext("2d");
            if (!context) {
                throw new Error("Unable to create canvas for virtual joystick");
            }
            VirtualJoystick._VjCanvasContext = context;
            VirtualJoystick._VjCanvasContext.strokeStyle = "#ffffff";
            VirtualJoystick._VjCanvasContext.lineWidth = 2;
            document.body.appendChild(VirtualJoystick.Canvas);
        }
        VirtualJoystick._HalfWidth = VirtualJoystick.Canvas.width / 2;
        this.pressed = false;
        this.limitToContainer = options.limitToContainer;
        // default joystick color
        this._joystickColor = options.color;
        // default joystick size
        this.containerSize = options.containerSize;
        this.puckSize = options.puckSize;
        if (options.position) {
            this.setPosition(options.position.x, options.position.y);
        }
        if (options.puckImage) {
            this.setPuckImage(options.puckImage);
        }
        if (options.containerImage) {
            this.setContainerImage(options.containerImage);
        }
        if (options.alwaysVisible) {
            VirtualJoystick._AlwaysVisibleSticks++;
        }
        // must come after position potentially set
        this.alwaysVisible = options.alwaysVisible;
        this._joystickPointerId = -1;
        // current joystick position
        this._joystickPointerPos = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"](0, 0);
        this._joystickPreviousPointerPos = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"](0, 0);
        // origin joystick position
        this._joystickPointerStartPos = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"](0, 0);
        this._deltaJoystickVector = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"](0, 0);
        this._onPointerDownHandlerRef = (evt)=>{
            this._onPointerDown(evt);
        };
        this._onPointerMoveHandlerRef = (evt)=>{
            this._onPointerMove(evt);
        };
        this._onPointerUpHandlerRef = (evt)=>{
            this._onPointerUp(evt);
        };
        VirtualJoystick.Canvas.addEventListener("pointerdown", this._onPointerDownHandlerRef, false);
        VirtualJoystick.Canvas.addEventListener("pointermove", this._onPointerMoveHandlerRef, false);
        VirtualJoystick.Canvas.addEventListener("pointerup", this._onPointerUpHandlerRef, false);
        VirtualJoystick.Canvas.addEventListener("pointerout", this._onPointerUpHandlerRef, false);
        VirtualJoystick.Canvas.addEventListener("pointercancel", this._onPointerUpHandlerRef, false);
        VirtualJoystick.Canvas.addEventListener("contextmenu", (evt)=>{
            evt.preventDefault(); // Disables system menu
        }, false);
        requestAnimationFrame(()=>{
            this._drawVirtualJoystick();
        });
    }
    /**
     * Defines joystick sensibility (ie. the ratio between a physical move and virtual joystick position change)
     * @param newJoystickSensibility defines the new sensibility
     */ setJoystickSensibility(newJoystickSensibility) {
        this._joystickSensibility = newJoystickSensibility;
        this._inversedSensibility = 1 / (this._joystickSensibility / 1000);
    }
    _onPointerDown(e) {
        let positionOnScreenCondition;
        e.preventDefault();
        if (this._leftJoystick === true) {
            positionOnScreenCondition = e.clientX < VirtualJoystick._HalfWidth;
        } else {
            positionOnScreenCondition = e.clientX > VirtualJoystick._HalfWidth;
        }
        if (positionOnScreenCondition && this._joystickPointerId < 0) {
            // First contact will be dedicated to the virtual joystick
            this._joystickPointerId = e.pointerId;
            if (this._joystickPosition) {
                this._joystickPointerStartPos = this._joystickPosition.clone();
                this._joystickPointerPos = this._joystickPosition.clone();
                this._joystickPreviousPointerPos = this._joystickPosition.clone();
                // in case the user only clicks down && doesn't move:
                // this ensures the delta is properly set
                this._onPointerMove(e);
            } else {
                this._joystickPointerStartPos.x = e.clientX;
                this._joystickPointerStartPos.y = e.clientY;
                this._joystickPointerPos = this._joystickPointerStartPos.clone();
                this._joystickPreviousPointerPos = this._joystickPointerStartPos.clone();
            }
            this._deltaJoystickVector.x = 0;
            this._deltaJoystickVector.y = 0;
            this.pressed = true;
            this._touches.add(e.pointerId.toString(), e);
        } else {
            // You can only trigger the action buttons with a joystick declared
            if (VirtualJoystick._GlobalJoystickIndex < 2 && this._action) {
                this._action();
                this._touches.add(e.pointerId.toString(), {
                    x: e.clientX,
                    y: e.clientY,
                    prevX: e.clientX,
                    prevY: e.clientY
                });
            }
        }
    }
    _onPointerMove(e) {
        // If the current pointer is the one associated to the joystick (first touch contact)
        if (this._joystickPointerId == e.pointerId) {
            // limit to container if need be
            if (this.limitToContainer) {
                const vector = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"](e.clientX - this._joystickPointerStartPos.x, e.clientY - this._joystickPointerStartPos.y);
                const distance = vector.length();
                if (distance > this.containerSize) {
                    vector.scaleInPlace(this.containerSize / distance);
                }
                this._joystickPointerPos.x = this._joystickPointerStartPos.x + vector.x;
                this._joystickPointerPos.y = this._joystickPointerStartPos.y + vector.y;
            } else {
                this._joystickPointerPos.x = e.clientX;
                this._joystickPointerPos.y = e.clientY;
            }
            // create delta vector
            this._deltaJoystickVector = this._joystickPointerPos.clone();
            this._deltaJoystickVector = this._deltaJoystickVector.subtract(this._joystickPointerStartPos);
            // if a joystick is always visible, there will be clipping issues if
            // you drag the puck from one over the container of the other
            if (0 < VirtualJoystick._AlwaysVisibleSticks) {
                if (this._leftJoystick) {
                    this._joystickPointerPos.x = Math.min(VirtualJoystick._HalfWidth, this._joystickPointerPos.x);
                } else {
                    this._joystickPointerPos.x = Math.max(VirtualJoystick._HalfWidth, this._joystickPointerPos.x);
                }
            }
            const directionLeftRight = this.reverseLeftRight ? -1 : 1;
            const deltaJoystickX = directionLeftRight * this._deltaJoystickVector.x / this._inversedSensibility;
            switch(this._axisTargetedByLeftAndRight){
                case 0 /* JoystickAxis.X */ :
                    this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickX));
                    break;
                case 1 /* JoystickAxis.Y */ :
                    this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickX));
                    break;
                case 2 /* JoystickAxis.Z */ :
                    this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickX));
                    break;
            }
            const directionUpDown = this.reverseUpDown ? 1 : -1;
            const deltaJoystickY = directionUpDown * this._deltaJoystickVector.y / this._inversedSensibility;
            switch(this._axisTargetedByUpAndDown){
                case 0 /* JoystickAxis.X */ :
                    this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickY));
                    break;
                case 1 /* JoystickAxis.Y */ :
                    this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickY));
                    break;
                case 2 /* JoystickAxis.Z */ :
                    this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickY));
                    break;
            }
        } else {
            const data = this._touches.get(e.pointerId.toString());
            if (data) {
                data.x = e.clientX;
                data.y = e.clientY;
            }
        }
    }
    _onPointerUp(e) {
        if (this._joystickPointerId == e.pointerId) {
            this._clearPreviousDraw();
            this._joystickPointerId = -1;
            this.pressed = false;
        } else {
            const touch = this._touches.get(e.pointerId.toString());
            if (touch) {
                VirtualJoystick._VjCanvasContext.clearRect(touch.prevX - 44, touch.prevY - 44, 88, 88);
            }
        }
        this._deltaJoystickVector.x = 0;
        this._deltaJoystickVector.y = 0;
        this._touches.remove(e.pointerId.toString());
    }
    /**
     * Change the color of the virtual joystick
     * @param newColor a string that must be a CSS color value (like "red") or the hexa value (like "#FF0000")
     */ setJoystickColor(newColor) {
        this._joystickColor = newColor;
    }
    /**
     * Size of the joystick's container
     */ set containerSize(newSize) {
        this._joystickContainerSize = newSize;
        this._clearContainerSize = ~~(this._joystickContainerSize * 2.1);
        this._clearContainerSizeOffset = ~~(this._clearContainerSize / 2);
    }
    get containerSize() {
        return this._joystickContainerSize;
    }
    /**
     * Size of the joystick's puck
     */ set puckSize(newSize) {
        this._joystickPuckSize = newSize;
        this._clearPuckSize = ~~(this._joystickPuckSize * 2.1);
        this._clearPuckSizeOffset = ~~(this._clearPuckSize / 2);
    }
    get puckSize() {
        return this._joystickPuckSize;
    }
    /**
     * Clears the set position of the joystick
     */ clearPosition() {
        this.alwaysVisible = false;
        this._joystickPosition = null;
    }
    /**
     * Defines whether or not the joystick container is always visible
     */ set alwaysVisible(value) {
        if (this._alwaysVisible === value) {
            return;
        }
        if (value && this._joystickPosition) {
            VirtualJoystick._AlwaysVisibleSticks++;
            this._alwaysVisible = true;
        } else {
            VirtualJoystick._AlwaysVisibleSticks--;
            this._alwaysVisible = false;
        }
    }
    get alwaysVisible() {
        return this._alwaysVisible;
    }
    /**
     * Sets the constant position of the Joystick container
     * @param x X axis coordinate
     * @param y Y axis coordinate
     */ setPosition(x, y) {
        // just in case position is moved while the container is visible
        if (this._joystickPointerStartPos) {
            this._clearPreviousDraw();
        }
        this._joystickPosition = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"](x, y);
    }
    /**
     * Defines a callback to call when the joystick is touched
     * @param action defines the callback
     */ setActionOnTouch(action) {
        this._action = action;
    }
    /**
     * Defines which axis you'd like to control for left & right
     * @param axis defines the axis to use
     */ setAxisForLeftRight(axis) {
        switch(axis){
            case 0 /* JoystickAxis.X */ :
            case 1 /* JoystickAxis.Y */ :
            case 2 /* JoystickAxis.Z */ :
                this._axisTargetedByLeftAndRight = axis;
                break;
            default:
                this._axisTargetedByLeftAndRight = 0 /* JoystickAxis.X */ ;
                break;
        }
    }
    /**
     * Defines which axis you'd like to control for up & down
     * @param axis defines the axis to use
     */ setAxisForUpDown(axis) {
        switch(axis){
            case 0 /* JoystickAxis.X */ :
            case 1 /* JoystickAxis.Y */ :
            case 2 /* JoystickAxis.Z */ :
                this._axisTargetedByUpAndDown = axis;
                break;
            default:
                this._axisTargetedByUpAndDown = 1 /* JoystickAxis.Y */ ;
                break;
        }
    }
    /**
     * Clears the canvas from the previous puck / container draw
     */ _clearPreviousDraw() {
        const jp = this._joystickPosition || this._joystickPointerStartPos;
        // clear container pixels
        VirtualJoystick._VjCanvasContext.clearRect(jp.x - this._clearContainerSizeOffset, jp.y - this._clearContainerSizeOffset, this._clearContainerSize, this._clearContainerSize);
        // clear puck pixels + 1 pixel for the change made before it moved
        VirtualJoystick._VjCanvasContext.clearRect(this._joystickPreviousPointerPos.x - this._clearPuckSizeOffset - 1, this._joystickPreviousPointerPos.y - this._clearPuckSizeOffset - 1, this._clearPuckSize + 2, this._clearPuckSize + 2);
    }
    /**
     * Loads `urlPath` to be used for the container's image
     * @param urlPath defines the urlPath of an image to use
     */ setContainerImage(urlPath) {
        const image = new Image();
        image.src = urlPath;
        image.onload = ()=>this._containerImage = image;
    }
    /**
     * Loads `urlPath` to be used for the puck's image
     * @param urlPath defines the urlPath of an image to use
     */ setPuckImage(urlPath) {
        const image = new Image();
        image.src = urlPath;
        image.onload = ()=>this._puckImage = image;
    }
    /**
     * Draws the Virtual Joystick's container
     */ _drawContainer() {
        const jp = this._joystickPosition || this._joystickPointerStartPos;
        this._clearPreviousDraw();
        if (this._containerImage) {
            VirtualJoystick._VjCanvasContext.drawImage(this._containerImage, jp.x - this.containerSize, jp.y - this.containerSize, this.containerSize * 2, this.containerSize * 2);
        } else {
            // outer container
            VirtualJoystick._VjCanvasContext.beginPath();
            VirtualJoystick._VjCanvasContext.strokeStyle = this._joystickColor;
            VirtualJoystick._VjCanvasContext.lineWidth = 2;
            VirtualJoystick._VjCanvasContext.arc(jp.x, jp.y, this.containerSize, 0, Math.PI * 2, true);
            VirtualJoystick._VjCanvasContext.stroke();
            VirtualJoystick._VjCanvasContext.closePath();
            // inner container
            VirtualJoystick._VjCanvasContext.beginPath();
            VirtualJoystick._VjCanvasContext.lineWidth = 6;
            VirtualJoystick._VjCanvasContext.strokeStyle = this._joystickColor;
            VirtualJoystick._VjCanvasContext.arc(jp.x, jp.y, this.puckSize, 0, Math.PI * 2, true);
            VirtualJoystick._VjCanvasContext.stroke();
            VirtualJoystick._VjCanvasContext.closePath();
        }
    }
    /**
     * Draws the Virtual Joystick's puck
     */ _drawPuck() {
        if (this._puckImage) {
            VirtualJoystick._VjCanvasContext.drawImage(this._puckImage, this._joystickPointerPos.x - this.puckSize, this._joystickPointerPos.y - this.puckSize, this.puckSize * 2, this.puckSize * 2);
        } else {
            VirtualJoystick._VjCanvasContext.beginPath();
            VirtualJoystick._VjCanvasContext.strokeStyle = this._joystickColor;
            VirtualJoystick._VjCanvasContext.lineWidth = 2;
            VirtualJoystick._VjCanvasContext.arc(this._joystickPointerPos.x, this._joystickPointerPos.y, this.puckSize, 0, Math.PI * 2, true);
            VirtualJoystick._VjCanvasContext.stroke();
            VirtualJoystick._VjCanvasContext.closePath();
        }
    }
    _drawVirtualJoystick() {
        // canvas released? don't continue iterating
        if (this._released) {
            return;
        }
        if (this.alwaysVisible) {
            this._drawContainer();
        }
        if (this.pressed) {
            this._touches.forEach((key, touch)=>{
                if (touch.pointerId === this._joystickPointerId) {
                    if (!this.alwaysVisible) {
                        this._drawContainer();
                    }
                    this._drawPuck();
                    // store current pointer for next clear
                    this._joystickPreviousPointerPos = this._joystickPointerPos.clone();
                } else {
                    VirtualJoystick._VjCanvasContext.clearRect(touch.prevX - 44, touch.prevY - 44, 88, 88);
                    VirtualJoystick._VjCanvasContext.beginPath();
                    VirtualJoystick._VjCanvasContext.fillStyle = "white";
                    VirtualJoystick._VjCanvasContext.beginPath();
                    VirtualJoystick._VjCanvasContext.strokeStyle = "red";
                    VirtualJoystick._VjCanvasContext.lineWidth = 6;
                    VirtualJoystick._VjCanvasContext.arc(touch.x, touch.y, 40, 0, Math.PI * 2, true);
                    VirtualJoystick._VjCanvasContext.stroke();
                    VirtualJoystick._VjCanvasContext.closePath();
                    touch.prevX = touch.x;
                    touch.prevY = touch.y;
                }
            });
        }
        requestAnimationFrame(()=>{
            this._drawVirtualJoystick();
        });
    }
    /**
     * Release internal HTML canvas
     */ releaseCanvas() {
        if (VirtualJoystick.Canvas) {
            VirtualJoystick.Canvas.removeEventListener("pointerdown", this._onPointerDownHandlerRef);
            VirtualJoystick.Canvas.removeEventListener("pointermove", this._onPointerMoveHandlerRef);
            VirtualJoystick.Canvas.removeEventListener("pointerup", this._onPointerUpHandlerRef);
            VirtualJoystick.Canvas.removeEventListener("pointerout", this._onPointerUpHandlerRef);
            VirtualJoystick.Canvas.removeEventListener("pointercancel", this._onPointerUpHandlerRef);
            window.removeEventListener("resize", this._onResize);
            document.body.removeChild(VirtualJoystick.Canvas);
            VirtualJoystick.Canvas = null;
        }
        this._released = true;
    }
}
// Used to draw the virtual joystick inside a 2D canvas on top of the WebGL rendering canvas
VirtualJoystick._GlobalJoystickIndex = 0;
VirtualJoystick._AlwaysVisibleSticks = 0; //# sourceMappingURL=virtualJoystick.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/urlTools.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Gets the file extension from a URL.
 * @param url The URL to get the file extension from.
 * @returns The file extension, or an empty string if no extension is found.
 */ __turbopack_context__.s([
    "GetExtensionFromUrl",
    ()=>GetExtensionFromUrl
]);
function GetExtensionFromUrl(url) {
    const urlWithoutUriParams = url.split("?")[0];
    const lastDot = urlWithoutUriParams.lastIndexOf(".");
    const extension = lastDot > -1 ? urlWithoutUriParams.substring(lastDot).toLowerCase() : "";
    return extension;
} //# sourceMappingURL=urlTools.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/rgbdTextureTools.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RGBDTextureTools",
    ()=>RGBDTextureTools
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$PostProcesses$2f$postProcess$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/PostProcesses/postProcess.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/textureTools.js [app-ssr] (ecmascript)");
;
;
class RGBDTextureTools {
    /**
     * Expand the RGBD Texture from RGBD to Half Float if possible.
     * @param texture the texture to expand.
     */ static ExpandRGBDTexture(texture) {
        const internalTexture = texture._texture;
        if (!internalTexture || !texture.isRGBD) {
            return;
        }
        // Gets everything ready.
        const engine = internalTexture.getEngine();
        const caps = engine.getCaps();
        const isReady = internalTexture.isReady;
        let expandTexture = false;
        // If half float available we can uncompress the texture
        if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
            expandTexture = true;
            internalTexture.type = 2;
        } else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
            expandTexture = true;
            internalTexture.type = 1;
        }
        if (expandTexture) {
            // Do not use during decode.
            internalTexture.isReady = false;
            internalTexture._isRGBD = false;
            internalTexture.invertY = false;
        }
        const expandRgbdTextureAsync = async ()=>{
            const isWebGpu = engine.isWebGPU;
            const shaderLanguage = isWebGpu ? 1 /* ShaderLanguage.WGSL */  : 0 /* ShaderLanguage.GLSL */ ;
            internalTexture.isReady = false;
            if (isWebGpu) {
                await __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/rgbdDecode.fragment.js [app-ssr] (ecmascript, async loader)");
            } else {
                await __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/rgbdDecode.fragment.js [app-ssr] (ecmascript, async loader)");
            }
            // Expand the texture if possible
            // Simply run through the decode PP.
            const rgbdPostProcess = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$PostProcesses$2f$postProcess$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PostProcess"]("rgbdDecode", "rgbdDecode", null, null, 1, null, 3, engine, false, undefined, internalTexture.type, undefined, null, false, undefined, shaderLanguage);
            rgbdPostProcess.externalTextureSamplerBinding = true;
            // Hold the output of the decoding.
            const expandedTexture = engine.createRenderTargetTexture(internalTexture.width, {
                generateDepthBuffer: false,
                generateMipMaps: false,
                generateStencilBuffer: false,
                samplingMode: internalTexture.samplingMode,
                type: internalTexture.type,
                format: 5
            });
            rgbdPostProcess.onEffectCreatedObservable.addOnce((e)=>{
                e.executeWhenCompiled(()=>{
                    // PP Render Pass
                    rgbdPostProcess.onApply = (effect)=>{
                        effect._bindTexture("textureSampler", internalTexture);
                        effect.setFloat2("scale", 1, 1);
                    };
                    texture.getScene().postProcessManager.directRender([
                        rgbdPostProcess
                    ], expandedTexture, true);
                    // Cleanup
                    engine.restoreDefaultFramebuffer();
                    engine._releaseTexture(internalTexture);
                    if (rgbdPostProcess) {
                        rgbdPostProcess.dispose();
                    }
                    // Internal Swap
                    expandedTexture._swapAndDie(internalTexture);
                    // Ready to get rolling again.
                    internalTexture.isReady = true;
                });
            });
        };
        if (expandTexture) {
            if (isReady) {
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                expandRgbdTextureAsync();
            } else {
                // eslint-disable-next-line @typescript-eslint/no-misused-promises
                texture.onLoadObservable.addOnce(expandRgbdTextureAsync);
            }
        }
    }
    /**
     * Encode the texture to RGBD if possible.
     * @param internalTexture the texture to encode
     * @param scene the scene hosting the texture
     * @param outputTextureType type of the texture in which the encoding is performed
     * @returns a promise with the internalTexture having its texture replaced by the result of the processing
     */ // Should have "Async" in the name but this is a breaking change.
    // eslint-disable-next-line no-restricted-syntax
    static async EncodeTextureToRGBD(internalTexture, scene, outputTextureType = 0) {
        if (!scene.getEngine().isWebGPU) {
            await __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/rgbdEncode.fragment.js [app-ssr] (ecmascript, async loader)");
        } else {
            await __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/rgbdEncode.fragment.js [app-ssr] (ecmascript, async loader)");
        }
        return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ApplyPostProcess"])("rgbdEncode", internalTexture, scene, outputTextureType, 1, 5);
    }
} //# sourceMappingURL=rgbdTextureTools.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/dumpTools.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Dispose",
    ()=>Dispose,
    "DumpData",
    ()=>DumpData,
    "DumpDataAsync",
    ()=>DumpDataAsync,
    "DumpFramebuffer",
    ()=>DumpFramebuffer,
    "DumpTools",
    ()=>DumpTools,
    "EncodeImageAsync",
    ()=>EncodeImageAsync
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$tslib$2e$es6$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/tslib.es6.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$effectRenderer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/effectRenderer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.scalar.functions.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engineStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Engines/engineStore.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/logger.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$stringTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/stringTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/decorators.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
let ResourcesPromise = null;
async function _CreateDumpResourcesAsync() {
    // Create a compatible canvas. Prefer an HTMLCanvasElement if possible to avoid alpha issues with OffscreenCanvas + WebGL in many browsers.
    const canvas = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engineStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EngineStore"].LastCreatedEngine?.createCanvas(100, 100) ?? new OffscreenCanvas(100, 100); // will be resized later
    if (canvas instanceof OffscreenCanvas) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Warn("DumpData: OffscreenCanvas will be used for dumping data. This may result in lossy alpha values.");
    }
    // If WebGL via ThinEngine is not available, we cannot encode the data.
    // If https://github.com/whatwg/html/issues/10142 is resolved, we can migrate to just BitmapRenderer and avoid an engine dependency altogether.
    const { ThinEngine: thinEngineClass } = await __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Engines/thinEngine.js [app-ssr] (ecmascript, async loader)");
    if (!thinEngineClass.IsSupported) {
        throw new Error("DumpData: No WebGL context available. Cannot dump data.");
    }
    const options = {
        preserveDrawingBuffer: true,
        depth: false,
        stencil: false,
        alpha: true,
        premultipliedAlpha: false,
        antialias: false,
        failIfMajorPerformanceCaveat: false
    };
    const engine = new thinEngineClass(canvas, false, options);
    // remove this engine from the list of instances to avoid using it for other purposes
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engineStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EngineStore"].Instances.pop();
    // However, make sure to dispose it when no other engines are left
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engineStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EngineStore"].OnEnginesDisposedObservable.add((e)=>{
        // guaranteed to run when no other instances are left
        // only dispose if it's not the current engine
        if (engine && e !== engine && !engine.isDisposed && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engineStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EngineStore"].Instances.length === 0) {
            // Dump the engine and the associated resources
            Dispose();
        }
    });
    engine.getCaps().parallelShaderCompile = undefined;
    const renderer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$effectRenderer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EffectRenderer"](engine);
    const { passPixelShader } = await __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/pass.fragment.js [app-ssr] (ecmascript, async loader)");
    const wrapper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$effectRenderer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EffectWrapper"]({
        engine,
        name: passPixelShader.name,
        fragmentShader: passPixelShader.shader,
        samplerNames: [
            "textureSampler"
        ]
    });
    return {
        canvas: canvas,
        dumpEngine: {
            engine,
            renderer,
            wrapper
        }
    };
}
async function _GetDumpResourcesAsync() {
    if (!ResourcesPromise) {
        ResourcesPromise = _CreateDumpResourcesAsync();
    }
    return await ResourcesPromise;
}
class EncodingHelper {
    /**
     * Encodes image data to the given mime type.
     * This is put into a helper class so we can apply the nativeOverride decorator to it.
     * @internal
     */ static async EncodeImageAsync(pixelData, width, height, mimeType, invertY, quality) {
        const resources = await _GetDumpResourcesAsync();
        const dumpEngine = resources.dumpEngine;
        dumpEngine.engine.setSize(width, height, true);
        // Create the image
        const texture = dumpEngine.engine.createRawTexture(pixelData, width, height, 5, false, !invertY, 1);
        dumpEngine.renderer.setViewport();
        dumpEngine.renderer.applyEffectWrapper(dumpEngine.wrapper);
        dumpEngine.wrapper.effect._bindTexture("textureSampler", texture);
        dumpEngine.renderer.draw();
        texture.dispose();
        return await new Promise((resolve, reject)=>{
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].ToBlob(resources.canvas, (blob)=>{
                if (!blob) {
                    reject(new Error("EncodeImageAsync: Failed to convert canvas to blob."));
                } else {
                    resolve(blob);
                }
            }, mimeType, quality);
        });
    }
}
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$tslib$2e$es6$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__decorate"])([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nativeOverride"]
], EncodingHelper, "EncodeImageAsync", null);
const EncodeImageAsync = EncodingHelper.EncodeImageAsync;
async function DumpFramebuffer(width, height, engine, successCallback, mimeType = "image/png", fileName, quality) {
    // Read the contents of the framebuffer
    const bufferView = await engine.readPixels(0, 0, width, height);
    const data = new Uint8Array(bufferView.buffer);
    DumpData(width, height, data, successCallback, mimeType, fileName, true, undefined, quality);
}
async function DumpDataAsync(width, height, data, mimeType = "image/png", fileName, invertY = false, toArrayBuffer = false, quality) {
    // Convert if data are float32
    if (data instanceof Float32Array) {
        const data2 = new Uint8Array(data.length);
        let n = data.length;
        while(n--){
            const v = data[n];
            data2[n] = Math.round((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Clamp"])(v) * 255);
        }
        data = data2;
    }
    const blob = await EncodingHelper.EncodeImageAsync(data, width, height, mimeType, invertY, quality);
    if (fileName !== undefined) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].DownloadBlob(blob, fileName);
    }
    if (blob.type !== mimeType) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Warn(`DumpData: The requested mimeType '${mimeType}' is not supported. The result has mimeType '${blob.type}' instead.`);
    }
    const buffer = await blob.arrayBuffer();
    if (toArrayBuffer) {
        return buffer;
    }
    return `data:${mimeType};base64,${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$stringTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EncodeArrayBufferToBase64"])(buffer)}`;
}
function DumpData(width, height, data, successCallback, mimeType = "image/png", fileName, invertY = false, toArrayBuffer = false, quality) {
    // For back-compat: if no fileName and no callback, force download the result
    if (fileName === undefined && !successCallback) {
        fileName = "";
    }
    // eslint-disable-next-line @typescript-eslint/no-floating-promises
    DumpDataAsync(width, height, data, mimeType, fileName, invertY, toArrayBuffer, quality)// eslint-disable-next-line github/no-then
    .then((result)=>{
        if (successCallback) {
            successCallback(result);
        }
    });
}
function Dispose() {
    if (!ResourcesPromise) {
        return;
    }
    // in cases where the engine is not yet created, we need to wait for it to dispose it
    // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then
    ResourcesPromise?.then((resources)=>{
        if (resources.canvas instanceof HTMLCanvasElement) {
            resources.canvas.remove();
        }
        if (resources.dumpEngine) {
            resources.dumpEngine.engine.dispose();
            resources.dumpEngine.renderer.dispose();
            resources.dumpEngine.wrapper.dispose();
        }
    });
    ResourcesPromise = null;
}
const DumpTools = {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    DumpData,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    DumpDataAsync,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    DumpFramebuffer,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    Dispose
};
/**
 * This will be executed automatically for UMD and es5.
 * If esm dev wants the side effects to execute they will have to run it manually
 * Once we build native modules those need to be exported.
 * @internal
 */ const InitSideEffects = ()=>{
    // References the dependencies.
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].DumpData = DumpData;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].DumpDataAsync = DumpDataAsync;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].DumpFramebuffer = DumpFramebuffer;
};
InitSideEffects(); //# sourceMappingURL=dumpTools.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/HighDynamicRange/cubemapToSphericalPolynomial.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CubeMapToSphericalPolynomialTools",
    ()=>CubeMapToSphericalPolynomialTools
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.scalar.functions.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$sphericalPolynomial$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/sphericalPolynomial.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.constants.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$color$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.color.js [app-ssr] (ecmascript)");
;
;
;
;
;
class FileFaceOrientation {
    constructor(name, worldAxisForNormal, worldAxisForFileX, worldAxisForFileY){
        this.name = name;
        this.worldAxisForNormal = worldAxisForNormal;
        this.worldAxisForFileX = worldAxisForFileX;
        this.worldAxisForFileY = worldAxisForFileY;
    }
}
class CubeMapToSphericalPolynomialTools {
    /**
     * Converts a texture to the according Spherical Polynomial data.
     * This extracts the first 3 orders only as they are the only one used in the lighting.
     *
     * @param texture The texture to extract the information from.
     * @returns The Spherical Polynomial data.
     */ static ConvertCubeMapTextureToSphericalPolynomial(texture) {
        if (!texture.isCube) {
            // Only supports cube Textures currently.
            return null;
        }
        texture.getScene()?.getEngine().flushFramebuffer();
        const size = texture.getSize().width;
        const rightPromise = texture.readPixels(0, undefined, undefined, false);
        const leftPromise = texture.readPixels(1, undefined, undefined, false);
        let upPromise;
        let downPromise;
        if (texture.isRenderTarget) {
            upPromise = texture.readPixels(3, undefined, undefined, false);
            downPromise = texture.readPixels(2, undefined, undefined, false);
        } else {
            upPromise = texture.readPixels(2, undefined, undefined, false);
            downPromise = texture.readPixels(3, undefined, undefined, false);
        }
        const frontPromise = texture.readPixels(4, undefined, undefined, false);
        const backPromise = texture.readPixels(5, undefined, undefined, false);
        const gammaSpace = texture.gammaSpace;
        // Always read as RGBA.
        const format = 5;
        let type = 0;
        if (texture.textureType == 1 || texture.textureType == 2) {
            type = 1;
        }
        return new Promise((resolve)=>{
            // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then
            Promise.all([
                leftPromise,
                rightPromise,
                upPromise,
                downPromise,
                frontPromise,
                backPromise
            ]).then(([left, right, up, down, front, back])=>{
                const cubeInfo = {
                    size,
                    right,
                    left,
                    up,
                    down,
                    front,
                    back,
                    format,
                    type,
                    gammaSpace
                };
                resolve(this.ConvertCubeMapToSphericalPolynomial(cubeInfo));
            });
        });
    }
    /**
     * Compute the area on the unit sphere of the rectangle defined by (x,y) and the origin
     * See https://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/
     * @param x
     * @param y
     * @returns the area
     */ static _AreaElement(x, y) {
        return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));
    }
    /**
     * Converts a cubemap to the according Spherical Polynomial data.
     * This extracts the first 3 orders only as they are the only one used in the lighting.
     *
     * @param cubeInfo The Cube map to extract the information from.
     * @returns The Spherical Polynomial data.
     */ static ConvertCubeMapToSphericalPolynomial(cubeInfo) {
        const sphericalHarmonics = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$sphericalPolynomial$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SphericalHarmonics"]();
        let totalSolidAngle = 0.0;
        // The (u,v) range is [-1,+1], so the distance between each texel is 2/Size.
        const du = 2.0 / cubeInfo.size;
        const dv = du;
        const halfTexel = 0.5 * du;
        // The (u,v) of the first texel is half a texel from the corner (-1,-1).
        const minUV = halfTexel - 1.0;
        for(let faceIndex = 0; faceIndex < 6; faceIndex++){
            const fileFace = this._FileFaces[faceIndex];
            const dataArray = cubeInfo[fileFace.name];
            let v = minUV;
            // TODO: we could perform the summation directly into a SphericalPolynomial (SP), which is more efficient than SphericalHarmonic (SH).
            // This is possible because during the summation we do not need the SH-specific properties, e.g. orthogonality.
            // Because SP is still linear, so summation is fine in that basis.
            const stride = cubeInfo.format === 5 ? 4 : 3;
            for(let y = 0; y < cubeInfo.size; y++){
                let u = minUV;
                for(let x = 0; x < cubeInfo.size; x++){
                    // World direction (not normalised)
                    const worldDirection = fileFace.worldAxisForFileX.scale(u).add(fileFace.worldAxisForFileY.scale(v)).add(fileFace.worldAxisForNormal);
                    worldDirection.normalize();
                    const deltaSolidAngle = this._AreaElement(u - halfTexel, v - halfTexel) - this._AreaElement(u - halfTexel, v + halfTexel) - this._AreaElement(u + halfTexel, v - halfTexel) + this._AreaElement(u + halfTexel, v + halfTexel);
                    let r = dataArray[y * cubeInfo.size * stride + x * stride + 0];
                    let g = dataArray[y * cubeInfo.size * stride + x * stride + 1];
                    let b = dataArray[y * cubeInfo.size * stride + x * stride + 2];
                    // Prevent NaN harmonics with extreme HDRI data.
                    if (isNaN(r)) {
                        r = 0;
                    }
                    if (isNaN(g)) {
                        g = 0;
                    }
                    if (isNaN(b)) {
                        b = 0;
                    }
                    // Handle Integer types.
                    if (cubeInfo.type === 0) {
                        r /= 255;
                        g /= 255;
                        b /= 255;
                    }
                    // Handle Gamma space textures.
                    if (cubeInfo.gammaSpace) {
                        r = Math.pow((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Clamp"])(r), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ToLinearSpace"]);
                        g = Math.pow((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Clamp"])(g), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ToLinearSpace"]);
                        b = Math.pow((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Clamp"])(b), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ToLinearSpace"]);
                    }
                    // Prevent to explode in case of really high dynamic ranges.
                    // sh 3 would not be enough to accurately represent it.
                    const max = this.MAX_HDRI_VALUE;
                    if (this.PRESERVE_CLAMPED_COLORS) {
                        const currentMax = Math.max(r, g, b);
                        if (currentMax > max) {
                            const factor = max / currentMax;
                            r *= factor;
                            g *= factor;
                            b *= factor;
                        }
                    } else {
                        r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Clamp"])(r, 0, max);
                        g = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Clamp"])(g, 0, max);
                        b = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Clamp"])(b, 0, max);
                    }
                    const color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$color$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color3"](r, g, b);
                    sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);
                    totalSolidAngle += deltaSolidAngle;
                    u += du;
                }
                v += dv;
            }
        }
        // Solid angle for entire sphere is 4*pi
        const sphereSolidAngle = 4.0 * Math.PI;
        // Adjust the solid angle to allow for how many faces we processed.
        const facesProcessed = 6.0;
        const expectedSolidAngle = sphereSolidAngle * facesProcessed / 6.0;
        // Adjust the harmonics so that the accumulated solid angle matches the expected solid angle.
        // This is needed because the numerical integration over the cube uses a
        // small angle approximation of solid angle for each texel (see deltaSolidAngle),
        // and also to compensate for accumulative error due to float precision in the summation.
        const correctionFactor = expectedSolidAngle / totalSolidAngle;
        sphericalHarmonics.scaleInPlace(correctionFactor);
        sphericalHarmonics.convertIncidentRadianceToIrradiance();
        sphericalHarmonics.convertIrradianceToLambertianRadiance();
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$sphericalPolynomial$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SphericalPolynomial"].FromHarmonics(sphericalHarmonics);
    }
}
CubeMapToSphericalPolynomialTools._FileFaces = [
    new FileFaceOrientation("right", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](1, 0, 0), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](0, 0, -1), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](0, -1, 0)),
    new FileFaceOrientation("left", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](-1, 0, 0), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](0, 0, 1), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](0, -1, 0)),
    new FileFaceOrientation("up", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](0, 1, 0), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](1, 0, 0), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](0, 0, 1)),
    new FileFaceOrientation("down", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](0, -1, 0), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](1, 0, 0), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](0, 0, -1)),
    new FileFaceOrientation("front", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](0, 0, 1), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](1, 0, 0), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](0, -1, 0)),
    new FileFaceOrientation("back", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](0, 0, -1), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](-1, 0, 0), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](0, -1, 0))
];
/** @internal */ CubeMapToSphericalPolynomialTools.MAX_HDRI_VALUE = 4096;
/** @internal */ CubeMapToSphericalPolynomialTools.PRESERVE_CLAMPED_COLORS = false; //# sourceMappingURL=cubemapToSphericalPolynomial.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/environmentTextureTools.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CreateEnvTextureAsync",
    ()=>CreateEnvTextureAsync,
    "CreateIrradianceImageDataArrayBufferViews",
    ()=>CreateIrradianceImageDataArrayBufferViews,
    "CreateRadianceImageDataArrayBufferViews",
    ()=>CreateRadianceImageDataArrayBufferViews,
    "EnvironmentTextureTools",
    ()=>EnvironmentTextureTools,
    "GetEnvInfo",
    ()=>GetEnvInfo,
    "UploadEnvLevelsAsync",
    ()=>UploadEnvLevelsAsync,
    "UploadEnvSpherical",
    ()=>UploadEnvSpherical,
    "UploadIrradianceLevelsAsync",
    ()=>UploadIrradianceLevelsAsync,
    "UploadRadianceLevelsAsync",
    ()=>UploadRadianceLevelsAsync,
    "_UpdateRGBDAsync",
    ()=>_UpdateRGBDAsync,
    "normalizeEnvInfo",
    ()=>normalizeEnvInfo
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.scalar.functions.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$sphericalPolynomial$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/sphericalPolynomial.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$internalTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/Textures/internalTexture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$baseTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/Textures/baseTexture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$scene$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/scene.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$PostProcesses$2f$postProcess$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/PostProcesses/postProcess.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/logger.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$rgbdTextureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/rgbdTextureTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$dumpTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/dumpTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$baseTexture$2e$polynomial$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/Textures/baseTexture.polynomial.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
const DefaultEnvironmentTextureImageType = "image/png";
const CurrentVersion = 2;
/**
 * Magic number identifying the env file.
 */ const MagicBytes = [
    0x86,
    0x16,
    0x87,
    0x96,
    0xf6,
    0xd6,
    0x96,
    0x36
];
function GetEnvInfo(data) {
    const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
    let pos = 0;
    for(let i = 0; i < MagicBytes.length; i++){
        if (dataView.getUint8(pos++) !== MagicBytes[i]) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Error("Not a babylon environment map");
            return null;
        }
    }
    // Read json manifest - collect characters up to null terminator
    let manifestString = "";
    let charCode = 0x00;
    while(charCode = dataView.getUint8(pos++)){
        manifestString += String.fromCharCode(charCode);
    }
    let manifest = JSON.parse(manifestString);
    manifest = normalizeEnvInfo(manifest);
    // Extend the header with the position of the payload.
    manifest.binaryDataPosition = pos;
    if (manifest.specular) {
        // Fallback to 0.8 exactly if lodGenerationScale is not defined for backward compatibility.
        manifest.specular.lodGenerationScale = manifest.specular.lodGenerationScale || 0.8;
    }
    return manifest;
}
function normalizeEnvInfo(info) {
    if (info.version > CurrentVersion) {
        throw new Error(`Unsupported babylon environment map version "${info.version}". Latest supported version is "${CurrentVersion}".`);
    }
    if (info.version === 2) {
        return info;
    }
    // Migrate a v1 info to v2
    info = {
        ...info,
        version: 2,
        imageType: DefaultEnvironmentTextureImageType
    };
    return info;
}
async function CreateEnvTextureAsync(texture, options = {}) {
    const internalTexture = texture.getInternalTexture();
    if (!internalTexture) {
        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
        return await Promise.reject("The cube texture is invalid.");
    }
    const engine = internalTexture.getEngine();
    if (texture.textureType !== 2 && texture.textureType !== 1 && texture.textureType !== 0 && texture.textureType !== 0 && texture.textureType !== 7 && texture.textureType !== -1) {
        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
        return await Promise.reject("The cube texture should allow HDR (Full Float or Half Float).");
    }
    let textureType = 1;
    if (!engine.getCaps().textureFloatRender) {
        textureType = 2;
        if (!engine.getCaps().textureHalfFloatRender) {
            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
            return await Promise.reject("Env texture can only be created when the browser supports half float or full float rendering.");
        }
    }
    // sphericalPolynomial is lazy loaded so simply accessing it should trigger the computation.
    // eslint-disable-next-line @typescript-eslint/no-unused-expressions
    texture.sphericalPolynomial;
    // Lets keep track of the polynomial promise so we can wait for it to be ready before generating the pixels.
    const sphericalPolynomialPromise = texture.getInternalTexture()?._sphericalPolynomialPromise;
    const cubeWidth = internalTexture.width;
    const hostingScene = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$scene$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Scene"](engine);
    const specularTextures = {};
    const diffuseTextures = {};
    // As we are going to readPixels the faces of the cube, make sure the drawing/update commands for the cube texture are fully sent to the GPU in case it is drawn for the first time in this very frame!
    engine.flushFramebuffer();
    const imageType = options.imageType ?? DefaultEnvironmentTextureImageType;
    // Read and collect all mipmaps data from the cube.
    const mipmapsCount = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ILog2"])(internalTexture.width);
    for(let i = 0; i <= mipmapsCount; i++){
        const faceWidth = Math.pow(2, mipmapsCount - i);
        // All faces of the cube.
        for(let face = 0; face < 6; face++){
            // eslint-disable-next-line no-await-in-loop
            specularTextures[i * 6 + face] = await _GetTextureEncodedDataAsync(hostingScene, texture, textureType, face, i, faceWidth, imageType, options.imageQuality);
        }
    }
    // Read and collect all irradiance data from the cube.
    const irradianceTexture = options.disableIrradianceTexture ? null : texture.irradianceTexture;
    if (irradianceTexture) {
        const faceWidth = irradianceTexture.getSize().width;
        // All faces of the cube.
        for(let face = 0; face < 6; face++){
            // eslint-disable-next-line no-await-in-loop
            diffuseTextures[face] = await _GetTextureEncodedDataAsync(hostingScene, irradianceTexture, textureType, face, 0, faceWidth, imageType, options.imageQuality);
        }
    }
    // We can delete the hosting scene keeping track of all the creation objects
    hostingScene.dispose();
    // Ensure completion of the polynomial creation promise.
    if (sphericalPolynomialPromise) {
        await sphericalPolynomialPromise;
    }
    // Creates the json header for the env texture
    const info = {
        version: CurrentVersion,
        width: cubeWidth,
        imageType,
        irradiance: CreateEnvTextureIrradiance(texture),
        specular: {
            mipmaps: [],
            lodGenerationScale: texture.lodGenerationScale
        }
    };
    // Sets the specular image data information
    let position = 0;
    for(let i = 0; i <= mipmapsCount; i++){
        for(let face = 0; face < 6; face++){
            const byteLength = specularTextures[i * 6 + face].byteLength;
            info.specular.mipmaps.push({
                length: byteLength,
                position: position
            });
            position += byteLength;
        }
    }
    // Sets the irradiance image data information
    if (irradianceTexture) {
        info.irradiance = info.irradiance || {
            x: [
                0,
                0,
                0
            ],
            xx: [
                0,
                0,
                0
            ],
            y: [
                0,
                0,
                0
            ],
            yy: [
                0,
                0,
                0
            ],
            z: [
                0,
                0,
                0
            ],
            zz: [
                0,
                0,
                0
            ],
            yz: [
                0,
                0,
                0
            ],
            zx: [
                0,
                0,
                0
            ],
            xy: [
                0,
                0,
                0
            ]
        };
        info.irradiance.irradianceTexture = {
            size: irradianceTexture.getSize().width,
            faces: [],
            dominantDirection: irradianceTexture._dominantDirection?.asArray()
        };
        for(let face = 0; face < 6; face++){
            const byteLength = diffuseTextures[face].byteLength;
            info.irradiance.irradianceTexture.faces.push({
                length: byteLength,
                position: position
            });
            position += byteLength;
        }
    }
    // Encode the JSON as an array buffer
    const infoString = JSON.stringify(info);
    const infoBuffer = new ArrayBuffer(infoString.length + 1);
    const infoView = new Uint8Array(infoBuffer); // Limited to ascii subset matching unicode.
    for(let i = 0, strLen = infoString.length; i < strLen; i++){
        infoView[i] = infoString.charCodeAt(i);
    }
    // Ends up with a null terminator for easier parsing
    infoView[infoString.length] = 0x00;
    // Computes the final required size and creates the storage
    const totalSize = MagicBytes.length + position + infoBuffer.byteLength;
    const finalBuffer = new ArrayBuffer(totalSize);
    const finalBufferView = new Uint8Array(finalBuffer);
    const dataView = new DataView(finalBuffer);
    // Copy the magic bytes identifying the file in
    let pos = 0;
    for(let i = 0; i < MagicBytes.length; i++){
        dataView.setUint8(pos++, MagicBytes[i]);
    }
    // Add the json info
    finalBufferView.set(new Uint8Array(infoBuffer), pos);
    pos += infoBuffer.byteLength;
    // Finally inserts the radiance texture data
    for(let i = 0; i <= mipmapsCount; i++){
        for(let face = 0; face < 6; face++){
            const dataBuffer = specularTextures[i * 6 + face];
            finalBufferView.set(new Uint8Array(dataBuffer), pos);
            pos += dataBuffer.byteLength;
        }
    }
    // Finally inserts the irradiance texture data
    if (irradianceTexture) {
        for(let face = 0; face < 6; face++){
            const dataBuffer = diffuseTextures[face];
            finalBufferView.set(new Uint8Array(dataBuffer), pos);
            pos += dataBuffer.byteLength;
        }
    }
    // Voila
    return finalBuffer;
}
/**
 * Get the texture encoded data from the current texture
 * @internal
 */ async function _GetTextureEncodedDataAsync(hostingScene, texture, textureType, face, i, size, imageType, imageQuality) {
    let faceData = await texture.readPixels(face, i, undefined, false);
    if (faceData && faceData.byteLength === faceData.length) {
        const faceDataFloat = new Float32Array(faceData.byteLength * 4);
        for(let i = 0; i < faceData.byteLength; i++){
            faceDataFloat[i] = faceData[i] / 255;
            // Gamma to linear
            faceDataFloat[i] = Math.pow(faceDataFloat[i], 2.2);
        }
        faceData = faceDataFloat;
    } else if (faceData && texture.gammaSpace) {
        const floatData = faceData;
        for(let i = 0; i < floatData.length; i++){
            // Gamma to linear
            floatData[i] = Math.pow(floatData[i], 2.2);
        }
    }
    const engine = hostingScene.getEngine();
    const tempTexture = engine.createRawTexture(faceData, size, size, 5, false, true, 1, null, textureType);
    await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$rgbdTextureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RGBDTextureTools"].EncodeTextureToRGBD(tempTexture, hostingScene, textureType);
    const rgbdEncodedData = await engine._readTexturePixels(tempTexture, size, size);
    const imageEncodedData = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$dumpTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DumpDataAsync"])(size, size, rgbdEncodedData, imageType, undefined, false, true, imageQuality);
    tempTexture.dispose();
    return imageEncodedData;
}
/**
 * Creates a JSON representation of the spherical data.
 * @param texture defines the texture containing the polynomials
 * @returns the JSON representation of the spherical info
 */ function CreateEnvTextureIrradiance(texture) {
    const polynmials = texture.sphericalPolynomial;
    if (polynmials == null) {
        return null;
    }
    return {
        x: [
            polynmials.x.x,
            polynmials.x.y,
            polynmials.x.z
        ],
        y: [
            polynmials.y.x,
            polynmials.y.y,
            polynmials.y.z
        ],
        z: [
            polynmials.z.x,
            polynmials.z.y,
            polynmials.z.z
        ],
        xx: [
            polynmials.xx.x,
            polynmials.xx.y,
            polynmials.xx.z
        ],
        yy: [
            polynmials.yy.x,
            polynmials.yy.y,
            polynmials.yy.z
        ],
        zz: [
            polynmials.zz.x,
            polynmials.zz.y,
            polynmials.zz.z
        ],
        yz: [
            polynmials.yz.x,
            polynmials.yz.y,
            polynmials.yz.z
        ],
        zx: [
            polynmials.zx.x,
            polynmials.zx.y,
            polynmials.zx.z
        ],
        xy: [
            polynmials.xy.x,
            polynmials.xy.y,
            polynmials.xy.z
        ]
    };
}
function CreateRadianceImageDataArrayBufferViews(data, info) {
    info = normalizeEnvInfo(info);
    const specularInfo = info.specular;
    // Double checks the enclosed info
    let mipmapsCount = Math.log2(info.width);
    mipmapsCount = Math.round(mipmapsCount) + 1;
    if (specularInfo.mipmaps.length !== 6 * mipmapsCount) {
        throw new Error(`Unsupported specular mipmaps number "${specularInfo.mipmaps.length}"`);
    }
    const imageData = new Array(mipmapsCount);
    for(let i = 0; i < mipmapsCount; i++){
        imageData[i] = new Array(6);
        for(let face = 0; face < 6; face++){
            const imageInfo = specularInfo.mipmaps[i * 6 + face];
            imageData[i][face] = new Uint8Array(data.buffer, data.byteOffset + info.binaryDataPosition + imageInfo.position, imageInfo.length);
        }
    }
    return imageData;
}
function CreateIrradianceImageDataArrayBufferViews(data, info) {
    info = normalizeEnvInfo(info);
    const imageData = new Array(6);
    const irradianceTexture = info.irradiance?.irradianceTexture;
    if (irradianceTexture) {
        if (irradianceTexture.faces.length !== 6) {
            throw new Error(`Incorrect irradiance texture faces number "${irradianceTexture.faces.length}"`);
        }
        for(let face = 0; face < 6; face++){
            const imageInfo = irradianceTexture.faces[face];
            imageData[face] = new Uint8Array(data.buffer, data.byteOffset + info.binaryDataPosition + imageInfo.position, imageInfo.length);
        }
    }
    return imageData;
}
function UploadEnvLevelsAsync(texture, data, info) {
    info = normalizeEnvInfo(info);
    const specularInfo = info.specular;
    if (!specularInfo) {
        // Nothing else parsed so far
        return Promise.resolve([]);
    }
    texture._lodGenerationScale = specularInfo.lodGenerationScale;
    const promises = [];
    const radianceImageData = CreateRadianceImageDataArrayBufferViews(data, info);
    promises.push(UploadRadianceLevelsAsync(texture, radianceImageData, info.imageType));
    const irradianceTexture = info.irradiance?.irradianceTexture;
    if (irradianceTexture) {
        const irradianceImageData = CreateIrradianceImageDataArrayBufferViews(data, info);
        let dominantDirection = null;
        if (info.irradiance?.irradianceTexture?.dominantDirection) {
            dominantDirection = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"].FromArray(info.irradiance.irradianceTexture.dominantDirection);
        }
        promises.push(UploadIrradianceLevelsAsync(texture, irradianceImageData, irradianceTexture.size, info.imageType, dominantDirection));
    }
    return Promise.all(promises);
}
async function _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture) {
    return await new Promise((resolve, reject)=>{
        if (expandTexture) {
            const tempTexture = engine.createTexture(null, true, true, null, 1, null, (message)=>{
                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
                reject(message);
            }, image);
            rgbdPostProcess?.onEffectCreatedObservable.addOnce((effect)=>{
                effect.executeWhenCompiled(()=>{
                    // Uncompress the data to a RTT
                    rgbdPostProcess.externalTextureSamplerBinding = true;
                    rgbdPostProcess.onApply = (effect)=>{
                        effect._bindTexture("textureSampler", tempTexture);
                        effect.setFloat2("scale", 1, engine._features.needsInvertingBitmap && image instanceof ImageBitmap ? -1 : 1);
                    };
                    if (!engine.scenes.length) {
                        return;
                    }
                    engine.scenes[0].postProcessManager.directRender([
                        rgbdPostProcess
                    ], cubeRtt, true, face, i);
                    // Cleanup
                    engine.restoreDefaultFramebuffer();
                    tempTexture.dispose();
                    URL.revokeObjectURL(url);
                    resolve();
                });
            });
        } else {
            engine._uploadImageToTexture(texture, image, face, i);
            // Upload the face to the non lod texture support
            if (generateNonLODTextures) {
                const lodTexture = lodTextures[i];
                if (lodTexture) {
                    engine._uploadImageToTexture(lodTexture._texture, image, face, 0);
                }
            }
            resolve();
        }
    });
}
async function UploadRadianceLevelsAsync(texture, imageData, imageType = DefaultEnvironmentTextureImageType) {
    const engine = texture.getEngine();
    texture.format = 5;
    texture.type = 0;
    texture.generateMipMaps = true;
    texture._cachedAnisotropicFilteringLevel = null;
    engine.updateTextureSamplingMode(3, texture);
    await _UploadLevelsAsync(texture, imageData, true, imageType);
    // Flag internal texture as ready in case they are in use.
    texture.isReady = true;
}
async function UploadIrradianceLevelsAsync(mainTexture, imageData, size, imageType = DefaultEnvironmentTextureImageType, dominantDirection = null) {
    // Gets everything ready.
    const engine = mainTexture.getEngine();
    const texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$internalTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InternalTexture"](engine, 5 /* InternalTextureSource.RenderTarget */ );
    const baseTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$baseTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseTexture"](engine, texture);
    mainTexture._irradianceTexture = baseTexture;
    baseTexture._dominantDirection = dominantDirection;
    texture.isCube = true;
    texture.format = 5;
    texture.type = 0;
    texture.generateMipMaps = true;
    texture._cachedAnisotropicFilteringLevel = null;
    texture.generateMipMaps = true;
    texture.width = size;
    texture.height = size;
    engine.updateTextureSamplingMode(3, texture);
    await _UploadLevelsAsync(texture, [
        imageData
    ], false, imageType);
    engine.generateMipMapsForCubemap(texture);
    // Flag internal texture as ready in case they are in use.
    texture.isReady = true;
}
/**
 * Uploads the levels of image data to the GPU.
 * @param texture defines the internal texture to upload to
 * @param imageData defines the array buffer views of image data [mipmap][face]
 * @param canGenerateNonLODTextures defines whether or not to generate non lod textures
 * @param imageType the mime type of the image data
 * @returns a promise
 */ async function _UploadLevelsAsync(texture, imageData, canGenerateNonLODTextures, imageType = DefaultEnvironmentTextureImageType) {
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].IsExponentOfTwo(texture.width)) {
        throw new Error("Texture size must be a power of two");
    }
    const mipmapsCount = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ILog2"])(texture.width) + 1;
    // Gets everything ready.
    const engine = texture.getEngine();
    let expandTexture = false;
    let generateNonLODTextures = false;
    let rgbdPostProcess = null;
    let cubeRtt = null;
    let lodTextures = null;
    const caps = engine.getCaps();
    if (!caps.textureLOD) {
        expandTexture = false;
        generateNonLODTextures = canGenerateNonLODTextures;
    } else if (!engine._features.supportRenderAndCopyToLodForFloatTextures) {
        expandTexture = false;
    } else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
        expandTexture = true;
        texture.type = 2;
    } else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
        expandTexture = true;
        texture.type = 1;
    }
    // Expand the texture if possible
    let shaderLanguage = 0 /* ShaderLanguage.GLSL */ ;
    if (expandTexture) {
        if (engine.isWebGPU) {
            shaderLanguage = 1 /* ShaderLanguage.WGSL */ ;
            await __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/rgbdDecode.fragment.js [app-ssr] (ecmascript, async loader)");
        } else {
            await __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/rgbdDecode.fragment.js [app-ssr] (ecmascript, async loader)");
        }
        // Simply run through the decode PP
        rgbdPostProcess = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$PostProcesses$2f$postProcess$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PostProcess"]("rgbdDecode", "rgbdDecode", null, null, 1, null, 3, engine, false, undefined, texture.type, undefined, null, false, undefined, shaderLanguage);
        texture._isRGBD = false;
        texture.invertY = false;
        cubeRtt = engine.createRenderTargetCubeTexture(texture.width, {
            generateDepthBuffer: false,
            generateMipMaps: true,
            generateStencilBuffer: false,
            samplingMode: 3,
            type: texture.type,
            format: 5
        });
    } else {
        texture._isRGBD = true;
        texture.invertY = true;
        // In case of missing support, applies the same patch than DDS files.
        if (generateNonLODTextures) {
            const mipSlices = 3;
            lodTextures = {};
            const scale = texture._lodGenerationScale;
            const offset = texture._lodGenerationOffset;
            for(let i = 0; i < mipSlices; i++){
                //compute LOD from even spacing in smoothness (matching shader calculation)
                const smoothness = i / (mipSlices - 1);
                const roughness = 1 - smoothness;
                const minLODIndex = offset; // roughness = 0
                const maxLODIndex = (mipmapsCount - 1) * scale + offset; // roughness = 1 (mipmaps start from 0)
                const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;
                const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));
                //compute LOD from even spacing in smoothness (matching shader calculation)
                const glTextureFromLod = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$internalTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InternalTexture"](engine, 2 /* InternalTextureSource.Temp */ );
                glTextureFromLod.isCube = true;
                glTextureFromLod.invertY = true;
                glTextureFromLod.generateMipMaps = false;
                engine.updateTextureSamplingMode(2, glTextureFromLod);
                // Wrap in a base texture for easy binding.
                const lodTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$baseTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseTexture"](null);
                lodTexture._isCube = true;
                lodTexture._texture = glTextureFromLod;
                lodTextures[mipmapIndex] = lodTexture;
                switch(i){
                    case 0:
                        texture._lodTextureLow = lodTexture;
                        break;
                    case 1:
                        texture._lodTextureMid = lodTexture;
                        break;
                    case 2:
                        texture._lodTextureHigh = lodTexture;
                        break;
                }
            }
        }
    }
    const promises = [];
    // All mipmaps up to provided number of images
    for(let i = 0; i < imageData.length; i++){
        // All faces
        for(let face = 0; face < 6; face++){
            // Constructs an image element from image data
            const bytes = imageData[i][face];
            const blob = new Blob([
                bytes
            ], {
                type: imageType
            });
            const url = URL.createObjectURL(blob);
            let promise;
            if (engine._features.forceBitmapOverHTMLImageElement) {
                // eslint-disable-next-line github/no-then
                promise = engine.createImageBitmap(blob, {
                    premultiplyAlpha: "none"
                }).then(async (img)=>{
                    return await _OnImageReadyAsync(img, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture);
                });
            } else {
                const image = new Image();
                image.src = url;
                // Enqueue promise to upload to the texture.
                promise = new Promise((resolve, reject)=>{
                    image.onload = ()=>{
                        _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture)// eslint-disable-next-line github/no-then
                        .then(()=>resolve())// eslint-disable-next-line github/no-then
                        .catch((reason)=>{
                            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
                            reject(reason);
                        });
                    };
                    image.onerror = (error)=>{
                        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
                        reject(error);
                    };
                });
            }
            promises.push(promise);
        }
    }
    await Promise.all(promises);
    // Fill remaining mipmaps with black textures.
    if (imageData.length < mipmapsCount) {
        let data;
        const size = Math.pow(2, mipmapsCount - 1 - imageData.length);
        const dataLength = size * size * 4;
        switch(texture.type){
            case 0:
                {
                    data = new Uint8Array(dataLength);
                    break;
                }
            case 2:
                {
                    data = new Uint16Array(dataLength);
                    break;
                }
            case 1:
                {
                    data = new Float32Array(dataLength);
                    break;
                }
        }
        for(let i = imageData.length; i < mipmapsCount; i++){
            for(let face = 0; face < 6; face++){
                engine._uploadArrayBufferViewToTexture(cubeRtt?.texture || texture, data, face, i);
            }
        }
    }
    // Release temp RTT.
    if (cubeRtt) {
        const irradiance = texture._irradianceTexture;
        texture._irradianceTexture = null;
        engine._releaseTexture(texture);
        cubeRtt._swapAndDie(texture);
        texture._irradianceTexture = irradiance;
    }
    // Release temp Post Process.
    if (rgbdPostProcess) {
        rgbdPostProcess.dispose();
    }
    // Flag internal texture as ready in case they are in use.
    if (generateNonLODTextures) {
        if (texture._lodTextureHigh && texture._lodTextureHigh._texture) {
            texture._lodTextureHigh._texture.isReady = true;
        }
        if (texture._lodTextureMid && texture._lodTextureMid._texture) {
            texture._lodTextureMid._texture.isReady = true;
        }
        if (texture._lodTextureLow && texture._lodTextureLow._texture) {
            texture._lodTextureLow._texture.isReady = true;
        }
    }
}
function UploadEnvSpherical(texture, info) {
    info = normalizeEnvInfo(info);
    const irradianceInfo = info.irradiance;
    if (!irradianceInfo) {
        return;
    }
    const sp = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$sphericalPolynomial$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SphericalPolynomial"]();
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"].FromArrayToRef(irradianceInfo.x, 0, sp.x);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"].FromArrayToRef(irradianceInfo.y, 0, sp.y);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"].FromArrayToRef(irradianceInfo.z, 0, sp.z);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"].FromArrayToRef(irradianceInfo.xx, 0, sp.xx);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"].FromArrayToRef(irradianceInfo.yy, 0, sp.yy);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"].FromArrayToRef(irradianceInfo.zz, 0, sp.zz);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"].FromArrayToRef(irradianceInfo.yz, 0, sp.yz);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"].FromArrayToRef(irradianceInfo.zx, 0, sp.zx);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"].FromArrayToRef(irradianceInfo.xy, 0, sp.xy);
    texture._sphericalPolynomial = sp;
}
function _UpdateRGBDAsync(internalTexture, data, sphericalPolynomial, lodScale, lodOffset) {
    const proxy = internalTexture.getEngine().createRawCubeTexture(null, internalTexture.width, internalTexture.format, internalTexture.type, internalTexture.generateMipMaps, internalTexture.invertY, internalTexture.samplingMode, internalTexture._compression);
    // eslint-disable-next-line github/no-then
    const proxyPromise = UploadRadianceLevelsAsync(proxy, data).then(()=>internalTexture);
    internalTexture.onRebuildCallback = (_internalTexture)=>{
        return {
            proxy: proxyPromise,
            isReady: true,
            isAsync: true
        };
    };
    internalTexture._source = 13 /* InternalTextureSource.CubeRawRGBD */ ;
    internalTexture._bufferViewArrayArray = data;
    internalTexture._lodGenerationScale = lodScale;
    internalTexture._lodGenerationOffset = lodOffset;
    internalTexture._sphericalPolynomial = sphericalPolynomial;
    // eslint-disable-next-line github/no-then
    return UploadRadianceLevelsAsync(internalTexture, data).then(()=>{
        internalTexture.isReady = true;
        return internalTexture;
    });
}
const EnvironmentTextureTools = {
    /**
     * Gets the environment info from an env file.
     * @param data The array buffer containing the .env bytes.
     * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.
     */ GetEnvInfo,
    /**
     * Creates an environment texture from a loaded cube texture.
     * @param texture defines the cube texture to convert in env file
     * @param options options for the conversion process
     * @param options.imageType the mime type for the encoded images, with support for "image/png" (default) and "image/webp"
     * @param options.imageQuality the image quality of encoded WebP images.
     * @returns a promise containing the environment data if successful.
     */ CreateEnvTextureAsync,
    /**
     * Creates the ArrayBufferViews used for initializing environment texture image data.
     * @param data the image data
     * @param info parameters that determine what views will be created for accessing the underlying buffer
     * @returns the views described by info providing access to the underlying buffer
     */ CreateRadianceImageDataArrayBufferViews,
    /**
     * Creates the ArrayBufferViews used for initializing environment texture image data.
     * @param data the image data
     * @param info parameters that determine what views will be created for accessing the underlying buffer
     * @returns the views described by info providing access to the underlying buffer
     */ CreateIrradianceImageDataArrayBufferViews,
    /**
     * Uploads the texture info contained in the env file to the GPU.
     * @param texture defines the internal texture to upload to
     * @param data defines the data to load
     * @param info defines the texture info retrieved through the GetEnvInfo method
     * @returns a promise
     */ UploadEnvLevelsAsync,
    /**
     * Uploads the levels of image data to the GPU.
     * @param texture defines the internal texture to upload to
     * @param imageData defines the array buffer views of image data [mipmap][face]
     * @param imageType the mime type of the image data
     * @returns a promise
     */ UploadRadianceLevelsAsync,
    /**
     * Uploads the levels of image data to the GPU.
     * @param texture defines the internal texture to upload to
     * @param imageData defines the array buffer views of image data [mipmap][face]
     * @param imageType the mime type of the image data
     * @param dominantDirection the dominant direction of light in the environment texture, if available
     * @returns a promise
     */ UploadIrradianceLevelsAsync,
    /**
     * Uploads spherical polynomials information to the texture.
     * @param texture defines the texture we are trying to upload the information to
     * @param info defines the environment texture info retrieved through the GetEnvInfo method
     */ UploadEnvSpherical
}; //# sourceMappingURL=environmentTextureTools.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/codeStringParsingTools.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Extracts the characters between two markers (for eg, between "(" and ")"). The function handles nested markers as well as markers inside strings (delimited by ", ' or `) and comments
 * @param markerOpen opening marker
 * @param markerClose closing marker
 * @param block code block to parse
 * @param startIndex starting index in block where the extraction must start. The character at block[startIndex] should be the markerOpen character!
 * @returns index of the last character for the extraction (or -1 if the string is invalid - no matching closing marker found). The string to extract (without the markers) is the string between startIndex + 1 and the returned value (exclusive)
 */ __turbopack_context__.s([
    "EscapeRegExp",
    ()=>EscapeRegExp,
    "ExtractBetweenMarkers",
    ()=>ExtractBetweenMarkers,
    "FindBackward",
    ()=>FindBackward,
    "InjectStartingAndEndingCode",
    ()=>InjectStartingAndEndingCode,
    "IsIdentifierChar",
    ()=>IsIdentifierChar,
    "RemoveComments",
    ()=>RemoveComments,
    "SkipWhitespaces",
    ()=>SkipWhitespaces
]);
function ExtractBetweenMarkers(markerOpen, markerClose, block, startIndex) {
    let currPos = startIndex, openMarkers = 0, waitForChar = "";
    while(currPos < block.length){
        const currChar = block.charAt(currPos);
        if (!waitForChar) {
            switch(currChar){
                case markerOpen:
                    openMarkers++;
                    break;
                case markerClose:
                    openMarkers--;
                    break;
                case '"':
                case "'":
                case "`":
                    waitForChar = currChar;
                    break;
                case "/":
                    if (currPos + 1 < block.length) {
                        const nextChar = block.charAt(currPos + 1);
                        if (nextChar === "/") {
                            waitForChar = "\n";
                        } else if (nextChar === "*") {
                            waitForChar = "*/";
                        }
                    }
                    break;
            }
        } else {
            if (currChar === waitForChar) {
                if (waitForChar === '"' || waitForChar === "'") {
                    block.charAt(currPos - 1) !== "\\" && (waitForChar = "");
                } else {
                    waitForChar = "";
                }
            } else if (waitForChar === "*/" && currChar === "*" && currPos + 1 < block.length) {
                block.charAt(currPos + 1) === "/" && (waitForChar = "");
                if (waitForChar === "") {
                    currPos++;
                }
            }
        }
        currPos++;
        if (openMarkers === 0) {
            break;
        }
    }
    return openMarkers === 0 ? currPos - 1 : -1;
}
function SkipWhitespaces(s, index) {
    while(index < s.length){
        const c = s[index];
        if (c !== " " && c !== "\n" && c !== "\r" && c !== "\t" && c !== "\u000a" && c !== "\u00a0") {
            break;
        }
        index++;
    }
    return index;
}
function IsIdentifierChar(c) {
    const v = c.charCodeAt(0);
    return v >= 48 && v <= 57 || v >= 65 && v <= 90 || v >= 97 && v <= 122 || // a-z
    v == 95; // _
}
function RemoveComments(block) {
    let currPos = 0, waitForChar = "", inComments = false;
    const s = [];
    while(currPos < block.length){
        const currChar = block.charAt(currPos);
        if (!waitForChar) {
            switch(currChar){
                case '"':
                case "'":
                case "`":
                    waitForChar = currChar;
                    break;
                case "/":
                    if (currPos + 1 < block.length) {
                        const nextChar = block.charAt(currPos + 1);
                        if (nextChar === "/") {
                            waitForChar = "\n";
                            inComments = true;
                        } else if (nextChar === "*") {
                            waitForChar = "*/";
                            inComments = true;
                        }
                    }
                    break;
            }
            if (!inComments) {
                s.push(currChar);
            }
        } else {
            if (currChar === waitForChar) {
                if (waitForChar === '"' || waitForChar === "'") {
                    block.charAt(currPos - 1) !== "\\" && (waitForChar = "");
                    s.push(currChar);
                } else {
                    waitForChar = "";
                    inComments = false;
                }
            } else if (waitForChar === "*/" && currChar === "*" && currPos + 1 < block.length) {
                block.charAt(currPos + 1) === "/" && (waitForChar = "");
                if (waitForChar === "") {
                    inComments = false;
                    currPos++;
                }
            } else {
                if (!inComments) {
                    s.push(currChar);
                }
            }
        }
        currPos++;
    }
    return s.join("");
}
function FindBackward(s, index, c, c2) {
    while(index >= 0 && s.charAt(index) !== c && (!c2 || s.charAt(index) !== c2)){
        index--;
    }
    return index;
}
function EscapeRegExp(s) {
    return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function InjectStartingAndEndingCode(code, mainFuncDecl, startingCode, endingCode) {
    let idx = code.indexOf(mainFuncDecl);
    if (idx < 0) {
        return code;
    }
    if (startingCode) {
        // eslint-disable-next-line no-empty
        while(idx++ < code.length && code.charAt(idx) != "{"){}
        if (idx < code.length) {
            const part1 = code.substring(0, idx + 1);
            const part2 = code.substring(idx + 1);
            code = part1 + startingCode + part2;
        }
    }
    if (endingCode) {
        const lastClosingCurly = code.lastIndexOf("}");
        code = code.substring(0, lastClosingCurly);
        code += endingCode + "\n}";
    }
    return code;
} //# sourceMappingURL=codeStringParsingTools.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/timer.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AdvancedTimer",
    ()=>AdvancedTimer,
    "TimerState",
    ()=>TimerState,
    "setAndStartTimer",
    ()=>setAndStartTimer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/observable.js [app-ssr] (ecmascript)");
;
var TimerState;
(function(TimerState) {
    /**
     * Timer initialized, not yet started
     */ TimerState[TimerState["INIT"] = 0] = "INIT";
    /**
     * Timer started and counting
     */ TimerState[TimerState["STARTED"] = 1] = "STARTED";
    /**
     * Timer ended (whether aborted or time reached)
     */ TimerState[TimerState["ENDED"] = 2] = "ENDED";
})(TimerState || (TimerState = {}));
function setAndStartTimer(options) {
    let timer = 0;
    const startTime = Date.now();
    options.observableParameters = options.observableParameters ?? {};
    const observer = options.contextObservable.add((payload)=>{
        const now = Date.now();
        timer = now - startTime;
        const data = {
            startTime,
            currentTime: now,
            deltaTime: timer,
            completeRate: timer / options.timeout,
            payload
        };
        options.onTick && options.onTick(data);
        if (options.breakCondition && options.breakCondition()) {
            options.contextObservable.remove(observer);
            options.onAborted && options.onAborted(data);
        }
        if (timer >= options.timeout) {
            options.contextObservable.remove(observer);
            options.onEnded && options.onEnded(data);
        }
    }, options.observableParameters.mask, options.observableParameters.insertFirst, options.observableParameters.scope);
    return observer;
}
class AdvancedTimer {
    /**
     * Will construct a new advanced timer based on the options provided. Timer will not start until start() is called.
     * @param options construction options for this advanced timer
     */ constructor(options){
        /**
         * Will notify each time the timer calculates the remaining time
         */ this.onEachCountObservable = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Observable"]();
        /**
         * Will trigger when the timer was aborted due to the break condition
         */ this.onTimerAbortedObservable = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Observable"]();
        /**
         * Will trigger when the timer ended successfully
         */ this.onTimerEndedObservable = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Observable"]();
        /**
         * Will trigger when the timer state has changed
         */ this.onStateChangedObservable = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Observable"]();
        this._observer = null;
        this._breakOnNextTick = false;
        this._tick = (payload)=>{
            const now = Date.now();
            this._timer = now - this._startTime;
            const data = {
                startTime: this._startTime,
                currentTime: now,
                deltaTime: this._timer,
                completeRate: this._timer / this._timeToEnd,
                payload
            };
            const shouldBreak = this._breakOnNextTick || this._breakCondition(data);
            if (shouldBreak || this._timer >= this._timeToEnd) {
                this._stop(data, shouldBreak);
            } else {
                this.onEachCountObservable.notifyObservers(data);
            }
        };
        this._setState(0 /* TimerState.INIT */ );
        this._contextObservable = options.contextObservable;
        this._observableParameters = options.observableParameters ?? {};
        this._breakCondition = options.breakCondition ?? (()=>false);
        this._timeToEnd = options.timeout;
        if (options.onEnded) {
            this.onTimerEndedObservable.add(options.onEnded);
        }
        if (options.onTick) {
            this.onEachCountObservable.add(options.onTick);
        }
        if (options.onAborted) {
            this.onTimerAbortedObservable.add(options.onAborted);
        }
    }
    /**
     * set a breaking condition for this timer. Default is to never break during count
     * @param predicate the new break condition. Returns true to break, false otherwise
     */ set breakCondition(predicate) {
        this._breakCondition = predicate;
    }
    /**
     * Reset ALL associated observables in this advanced timer
     */ clearObservables() {
        this.onEachCountObservable.clear();
        this.onTimerAbortedObservable.clear();
        this.onTimerEndedObservable.clear();
        this.onStateChangedObservable.clear();
    }
    /**
     * Will start a new iteration of this timer. Only one instance of this timer can run at a time.
     *
     * @param timeToEnd how much time to measure until timer ended
     */ start(timeToEnd = this._timeToEnd) {
        if (this._state === 1 /* TimerState.STARTED */ ) {
            throw new Error("Timer already started. Please stop it before starting again");
        }
        this._timeToEnd = timeToEnd;
        this._startTime = Date.now();
        this._timer = 0;
        this._observer = this._contextObservable.add(this._tick, this._observableParameters.mask, this._observableParameters.insertFirst, this._observableParameters.scope);
        this._setState(1 /* TimerState.STARTED */ );
    }
    /**
     * Will force a stop on the next tick.
     */ stop() {
        if (this._state !== 1 /* TimerState.STARTED */ ) {
            return;
        }
        this._breakOnNextTick = true;
    }
    /**
     * Dispose this timer, clearing all resources
     */ dispose() {
        if (this._observer) {
            this._contextObservable.remove(this._observer);
        }
        this.clearObservables();
    }
    _setState(newState) {
        this._state = newState;
        this.onStateChangedObservable.notifyObservers(this._state);
    }
    _stop(data, aborted = false) {
        this._contextObservable.remove(this._observer);
        this._setState(2 /* TimerState.ENDED */ );
        if (aborted) {
            this.onTimerAbortedObservable.notifyObservers(data);
        } else {
            this.onTimerEndedObservable.notifyObservers(data);
        }
    }
} //# sourceMappingURL=timer.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/copyTextureToTexture.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ConversionMode",
    ()=>ConversionMode,
    "CopyTextureToTexture",
    ()=>CopyTextureToTexture
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$effectRenderer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/effectRenderer.js [app-ssr] (ecmascript)");
;
var ConversionMode;
(function(ConversionMode) {
    ConversionMode[ConversionMode["None"] = 0] = "None";
    ConversionMode[ConversionMode["ToLinearSpace"] = 1] = "ToLinearSpace";
    ConversionMode[ConversionMode["ToGammaSpace"] = 2] = "ToGammaSpace";
})(ConversionMode || (ConversionMode = {}));
class CopyTextureToTexture {
    /**
     * Gets the shader language
     */ get shaderLanguage() {
        return this._shaderLanguage;
    }
    /**
     * Gets the effect wrapper used for the copy
     */ get effectWrapper() {
        return this._effectWrapper;
    }
    /**
     * Gets or sets the source texture
     */ get source() {
        return this._source;
    }
    set source(texture) {
        this._source = texture;
    }
    /**
     * Gets or sets the LOD level to copy from the source texture
     */ get lodLevel() {
        return this._lodLevel;
    }
    set lodLevel(level) {
        this._lodLevel = level;
    }
    _textureIsInternal(texture) {
        return texture.getInternalTexture === undefined;
    }
    /**
     * Constructs a new instance of the class
     * @param engine The engine to use for the copy
     * @param isDepthTexture True means that we should write (using gl_FragDepth) into the depth texture attached to the destination (default: false)
     * @param sameSizeCopy True means that the copy will be done without any sampling (more efficient, but requires the source and destination to be of the same size) (default: false)
     */ constructor(engine, isDepthTexture = false, sameSizeCopy = false){
        /** Shader language used */ this._shaderLanguage = 0 /* ShaderLanguage.GLSL */ ;
        this._shadersLoaded = false;
        this._engine = engine;
        this._isDepthTexture = isDepthTexture;
        this._lodLevel = 0;
        this._conversion = 0 /* ConversionMode.None */ ;
        this._renderer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$effectRenderer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EffectRenderer"](engine);
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this._initShaderSourceAsync(isDepthTexture, sameSizeCopy);
    }
    async _initShaderSourceAsync(isDepthTexture, sameSizeCopy) {
        const engine = this._engine;
        if (engine.isWebGPU) {
            this._shaderLanguage = 1 /* ShaderLanguage.WGSL */ ;
            await __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/copyTextureToTexture.fragment.js [app-ssr] (ecmascript, async loader)");
        } else {
            await __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/copyTextureToTexture.fragment.js [app-ssr] (ecmascript, async loader)");
        }
        this._shadersLoaded = true;
        const defines = [];
        if (isDepthTexture) {
            defines.push("#define DEPTH_TEXTURE");
        }
        if (sameSizeCopy) {
            defines.push("#define NO_SAMPLER");
        }
        this._effectWrapper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$effectRenderer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EffectWrapper"]({
            engine: engine,
            name: "CopyTextureToTexture",
            fragmentShader: "copyTextureToTexture",
            useShaderStore: true,
            uniformNames: [
                "conversion",
                "lodLevel"
            ],
            samplerNames: [
                "textureSampler"
            ],
            defines,
            shaderLanguage: this._shaderLanguage
        });
        this._effectWrapper.onApplyObservable.add(()=>{
            if (isDepthTexture) {
                engine.setState(false);
                engine.setDepthBuffer(true);
                engine.depthCullingState.depthMask = true;
                engine.depthCullingState.depthFunc = 519;
            } else {
                engine.depthCullingState.depthMask = false;
            // other states are already set by EffectRenderer.applyEffectWrapper
            }
            if (this._textureIsInternal(this._source)) {
                this._effectWrapper.effect._bindTexture("textureSampler", this._source);
            } else {
                this._effectWrapper.effect.setTexture("textureSampler", this._source);
            }
            this._effectWrapper.effect.setFloat("conversion", this._conversion);
            this._effectWrapper.effect.setFloat("lodLevel", this._lodLevel);
        });
    }
    /**
     * Indicates if the effect is ready to be used for the copy
     * @returns true if "copy" can be called without delay, else false
     */ isReady() {
        return this._shadersLoaded && !!this._effectWrapper?.effect?.isReady();
    }
    /**
     * Copy one texture into another
     * @param source The source texture
     * @param destination The destination texture. If null, copy the source to the currently bound framebuffer
     * @param conversion The conversion mode that should be applied when copying
     * @param lod The LOD level to copy from the source texture
     * @returns
     */ copy(source, destination = null, conversion = 0 /* ConversionMode.None */ , lod = 0) {
        if (!this.isReady()) {
            return false;
        }
        this._source = source;
        this._conversion = conversion;
        this._lodLevel = lod;
        const engineDepthFunc = this._engine.getDepthFunction();
        const engineDepthMask = this._engine.getDepthWrite(); // for some reasons, depthWrite is not restored by EffectRenderer.restoreStates
        this._renderer.render(this._effectWrapper, destination);
        this._engine.setDepthWrite(engineDepthMask);
        if (this._isDepthTexture && engineDepthFunc) {
            this._engine.setDepthFunction(engineDepthFunc);
        }
        return true;
    }
    /**
     * Releases all the resources used by the class
     */ dispose() {
        this._effectWrapper?.dispose();
        this._renderer.dispose();
    }
} //# sourceMappingURL=copyTextureToTexture.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/brdfTextureTools.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BRDFTextureTools",
    ()=>BRDFTextureTools,
    "GetEnvironmentBRDFTexture",
    ()=>GetEnvironmentBRDFTexture,
    "GetEnvironmentFuzzBRDFTexture",
    ()=>GetEnvironmentFuzzBRDFTexture
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/Textures/texture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$rgbdTextureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/rgbdTextureTools.js [app-ssr] (ecmascript)");
;
;
// eslint-disable-next-line @typescript-eslint/naming-convention
const _environmentBRDFBase64Texture = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAgAElEQVR42u29yY5tWXIlZnbuiSaTbZFUkZRKrCKhElASQA0EoQABgn6hJvoXzfUP+gP9hWb6Bg00IgRoQJaKqUxmZmTEe8/v0uB2u7Fm2T7HIyIrnz88uPvt3f2a2WrMbOvf/u3PvvzP/sUf/N6//i8vf/lv/3v5H//d//Sb//Uq/5u8yf8hV/m/5Cp/L1f5hVzlG7nKJ7mKyJuIXN/hPwqXI/g++zq6rPI5u8z+WqfLre+zy7PrVv9L8brsMiGvk8XLmM/sdfHXal4e3ad6GXPdyu2ij8u/+uv/5cuf/OSLfdtEfvUr+dnf/d0X//t3H/7bf/hP//N/928h/0Yg/4VA/kogfyGQP5Wr/IFAvhbIlwK5CGQTPP+9z5uPeePJSW+yo2+s/GtN30Rnv1E+f5zxof9R/lSXv/nr//mrr3+i+5dfyX7ZZQP07Tffys//8R/l/9TtX7790T/7r/8G8pdy+/8XAvnnAvkzgfwzgfyxQP5AIL8vkJ8K5KsmMVzu1U7p5PA5AXxOAJ8TwPf7sX/51ZeXfcemqnp9w/W77/S7X/6T/vzf/7383RWCX3/z05/9i3/13/0PX//eX/2FyP8tIv+PiPy9iPy/IvIzEfm5iPxCRH4lIt/c/393//9BRD6KyKf7f488fP74/PH544dJAF9cLl98IZfLBZtuqterXr/7Dt9982v95S9+Lv+gF/3i7Spv/8lf/vnf/vGf/dF/JfKnIvLnIvLvReQ/NEngn0TklyLy6/v/34jIt00iGJOBlxAsdvv54/PH5493SQCXy9t2ueh2ueimKorrFbjq9eNH+fDtb+TXv/ol/vHyhX4Fxfbx7euPf/Lnf/PfiPyeiPyhiPxxkwB+fk8AvxzQgJcIrGTwFsiAEXH4/PH54/PHUgLY7whgu2C7bLqpQgHB2xvePn6SDx8+6G9+84384vKF/IPu8iVU9Y/+7C/+jWxffiHytYj8VER+X0T+oEEBvxqQwCMJeIngo5EI3goIwVMIPn98/vj8ESaAbbtu2ybbvl8u2ybbdtluSECA65u8ffqIDx8+6G++/VZ/efkV/sO261dQXP7wT/7kX8vl8qXIFyLylbySwe/dE0CLAr65B/9vGn0gQwRMMqgmhM/J4fPH548eAezbZd/lsm3YtssNAYiqiogAAkCvb5/k46cP8u2HD/rrb7+R/2/b9Wu9yJe//8d/9Ney6S5yEZFdRL68/38khG/uKOCnAwoYkcCoEXwkEgGDDq7CeQfyOTl8/vhd1QCum26ybZtu2yabbrKpQvXue1yvuF6v+vbpTT5+/CDffviAX1++1V9sO77WXb/66R/+4V/dgkbllQi+aBLBV/dE8LWRALwkYCWCNyMZXElkwLTMeMkga/P4/PH547ccAVwuctkvdxSw6bbdtYDbTfSZBN7e8PHTR/3u4wf55vKd/nL7DX6mu3791U9//5+/gkNFZGuSgZUQvnKowKgLWLTAQgRtEniTuEfwaELw0MJvf3LQzynud+53uG+X6y3gN9kul+2y6XVT1U27JCDAFVc8ksAn/e7jR/nN5YP+avtWfq6Xy9f7Vz/9w1dgRYngiyYhfNkkgzYBWHTg44AEMmqQUYQKOmDaiCIa8TmsfmzB+DnZDQjgcpGLbti2y3bZHjRAdRMVvb/dcYU8kcDbPQlsH/CrbddfbF98+RPZfvLFnAQeieCRDC5DMvju/vmD4JkEvjRQgKULeGggowdHkAHTYxihg89vu88I5UeGAPSOAFTlrgPopiqbKPSmCKreUoAAkCcSePukHz590m8vH+WbD9/JP335k6/+tA86KxFchv8jMvhiogE4JQm8XhfKqOAqx5qRPyeGzx8/cgSwbXcUoLJtim27C4Oi93+4v6VxQwKAvl2v+Hj9pB8+fZJvt4/yzfbF9lPdv/wJnsE2BogmyeCRED40tGFvksIXiSbgiYSRRpDNDZ6BDI6ghM+J4fPHeyKAO+zX7cb9t4tedMMNAQju5V+f1uAtBSiu1zsduMrHy5t8ePsk3376KN98sX/xE5FPAnm7/782o0DiUINXMkCXCB7/P94/e87AWUmARQWVvgMuKej9t1RLBp+Tw+ePgwngsutFFdu26WXbbl+rSvdfbnqAiuA23QcBgCugV1zl7e1NPm5v+LC96XfbJ/1W9y++fgXjA3bDYXV+MuhRwSPwL3JLMFYC+HS/LU8HYrGwIhwyNOF12SvgM4SgztdifP85MXz+KGsA2C6X7aJ6bXSAOwrY5OYIqGy3d5uq4P5GhABXuV6veLvRAf10fZMPb2/y3b7vX7+g+9v98/WOBq7GG7RNAlYy+Dgkhhb+Xxp0sE8IAC4SGAP/TbgVJK/PoJPBnAiwPKxsXfbbnRg+i3s/JAK4Q/4b9NfLtomBAqCickMBjy7BuywAUVyv8na94tMjCVzf9KNcLl/0SeA6oAEYb1i9g+FtSALb/bKL8/+t+wxXFMyswqiHoK4ToIgKqslgpg1qUC0QoYbvJZg/B/q5v4szHmPX7YEAsD0CX25OwEUVm9xag1+agKg+nxQArnKjAtDr9U0+Xd/k4/UqH7bL5YsewrcBBiMJZPRAp6TwQgWfjM9vgRbgUYGL8AvLWH2gqhesCokeUmCSwPsnhs8fP2YNYMO2XeSmAWxy2VQaXeDmDIhApf33rD4PTUCuV+DtCn27XuXT5ir8VmCJ2G5BpBM8/r/dEcJb8/0lEQMtJHA5TAlqNuLRhJChhEpSqFabH3di+G1AGj+W1/dyAR4IYJNNnuLf6+tWC9CHHiAtFhAIFLjK2/Uqn65X+SS67aK+3QeTDoy/IG2ogQ7fb/dAtz5vBgrYGqrwNtCHsVfgIvwK07OTQBURVNCBFpKCOjqCHn5L/67TgTN+fpySAC56nwSUi256kXsSuFGAVyLoUIDo8/Pz7fdoErr/v17lk162HbgHvFpIYDfoAJJfW4sGPjkU4VNAF8ZEcLmLhdc7kljdY1y1Dq9yLiI4IiRqcLujb138KIPn80ejATwRwIbtBvn1cqv+2J78/5EI5N4cJA8qIPcmwRsKAHDF9WYP6mV7VmrgLuTpxYTcMEW0LAmoQxFsuvAI8tv/a/C5fV2ZMMiKg++FCM7RDPRu8ebWY7VG6VJi+Bzk35MI2LsAckMAgwvQ0gC5DQjd3ABg2HQLAPpEAlZ1Bu7VV7MGHDFRAbo3VKsTbAY9sPWC/uvx86gBbDK3D1eEQS8pbAeSgSwmhepnJb6uBv/o/PzHLzxWA/X7TH77De5j6AGQi6o0CUGfCOD2X7cXAlCFQABtEsGLDtxuOyQB2UTQBKZe5GUPXgkUYCUAbZJRhBDeuq8xBf+bgwbehDm+BFQi2IJksOocvA8ysIMfxluVcRsY/eB3JzH8GFDAXQO48X/dcIf9jyDHptIigDsFkEe066tBSETQUYF7ElDdYEBytN4+rk9UcBPfrKaZqFHWcw3i4J8/X4ev2//bSXqAhwTay6OEIPLD2Ipt8OtAGzxkwLw9WVFRjTc/qC6H3+YK/b1oAA0KuOizHfieCLaHHiAb5NYTIC9EMEbZrVEQt1xwhVy1UfBh8PUOquMizwaap3tQXfY5B//tea/NZdfhsvbz+PURQTDSGWB87VX/7WSd4KxjUqrIgE0IUkoKGnhIvwvawpGf6eECXJ7tv4qbA7DJgwpsKthEmmYgfaAAffYF3HLxo0vwNjJ0SwRWMG4db4eh1gPNm18vQ+us/0eGmxDemu/fnM/X4evq/8342ksGHgLY5LyT/zg0wM8lcMjgGFXwqIOVFJBQw99eCvF9oZL9Mfl3QwAvIXDsBRC9R+fz8x0FPBLB0xJEpwUobrfAkARgIAF41h3wQgP6QAmX5E/7eI43IxGwwf/moIkRyWRJQIPgt9CA9b39nzt4bYUWjAlCjWDPgv8IEjgLJfzuaAsrv9VdVG4OwOXW/fdoA35qAdL0BDwvf6AAUVHd8LIEu94A3K+Q+2YxaB84MOH62P//qoo38fCRDERE2zf0JfmDa+MieElAjcDPKz+mRKCOtdgGtXaBjgNJ4H2owSpNeAW/rRH4CaHSpMwnBYYycjgSJwfie9CR6mPu20Uv8kABF206AvXlBMiIBPSlB9wjBW1fwEuSb94296VCqgMaGCt/G1BbExi3IG+r3a3J6P48Gv/J0YmEYoiGY7V/SxwFCwGoE/xa0AJ0CEiV9QPCJb1OJ5F1VTjEY2/MO9AEJvj1BJTQpqLfTlGwjABuzT962e4IoKnyrdh3+/6mzDVJ4PHOxj0JqGKoy20+wBMN6D1gLWi9NQHfVP5MEEPzjGYy8BMAOnTAJgEr8HUIejRo5xrA5xkR5AngmiSHs+zDDAmMgWzTg55GSJEmHE8IvWPAoYTfhWak/Wn/bQ0CGLSAjv83SUEfKp5q24LXuQICpzrjrgWoza8xVE00CQCORdhMJuTUT/rjuls0gO4Iby8BIEgK6gS7BsGuTtDrScH/fR68biUHNVGBnxjeNyHEvQe/ve3LZQqgG3rof6cEclsNflG9J4KtaQ8WHcVBHS1BtHE4QP9OBMS98mpbKTeDW7dJwRsnHpMBTFJpV4I+b0kY/NqInVFSyBLANbnMSgBM8F+Fqfxq/h657/Up+GaBnwV9hRqc9bZ/vA6vu+T9E8KPJWns94UfTeCj2QXwCHS9dNL8Xf3Ho/rfewSeFODGDV69AU0y6NFAE1DP3qK++rdB7/1HRxf86gT376zOr99T/h/ioBiXWQkgQgVeIrCC/WomhDmQK+hASI2ARQZKooHMLdCJwGEBBXC3+uERwg+VOHZ9ioAt9H80AI06wGgJ3nQA3BoCut6AhxYwgcPOFnxuFnrphk+NIKIGrWPQtgz3b0i7Y6D5rs1GKqTop0nQX52vmQC4BkjA+r4a7Kx9WLENGeegkhSETBCrNXIMdi/444Rw1n6E96ry7OPuj8UfLxtQ78NA2iSBbg7gIiIbdDLsb5agPhLC3RkYKv8NDbS2YGsatNRAG2oQwf9ZIOydgy1MAzBkAw8UwEEIDzSAqdPQ6za0PkeJAMH3Z0wXniUSZoHvBXU2mcjQgv56TedIKglCpIoQfgwCIjOytd8WgN0bfxoR8Fn9Gx0Aj5Zgq0lIZbsH/ibSJoFnS+C98g9ooHEELI3gliy25yONIiE6pb0NfBlyNEYyENoodkKwgl6I6s8kARgJ4ZoEfuYWHLEJa0LhSBXm7kImGeSfVdoJ1DO2G7WXsehAptupSOoyrCSF904k+6vt98X/ZcM98Hsd4JYIXhQAIg3/f9AAUYhsLQKAtkHVBnzjCKhOoYl2ym+iBtvzDzQ2DLXJ4PUmbJHAVnBQX4jkxfvHhNDqAdHXGQJgv0aSDGItgOseHIU+K9hXnIJzkoGlEKzNHagTdJ6VWEUH4iCKH4fd2AwDPaYBm4Wgng4gQ9V/CoGiuNmD04AQtNGMGzSAAQ2I2pzfogY9LRh7BrbOh4+D30sAencljFu2CUFrwY8UAWRfWwGvVOVfbx2uIILM0pwDv082dUTw8hYs8L+uIWiHGpWgClnAa1lMPJogovvvbePPs/q3Xr++kgCsfgB5oQF9WYKPJqEn6G+OE3i5AqouF59FQOmahQC8rlPLj38kg1c2f30vw+XaoIX24/pMGIgSBoZqoH3wo0sIIGlA9PWcCPrAtpPB8eBf6x1o6cHra+2+tpIFP4PgBfxZtZUJfo4qxELT948D9ucK8Mt9+ccjIQw6QJcEbrD/1g340ATuDgDkFfx6twSf1f9xvuBECYxq/7ythQQGm+5JDx6Brw4CkMGT3wgscCUoQ4sU2t6DR2ciBjTgtcpenQoZVX9NuL4Owc+dVaDursYVkVALX+shjSBKBuvCYDUZjE5BdNkxdHAUBexyHwB6NP7Iyw7sxUDViwge1t+mz8B/LAvVx/c3PeBBCToB8IUGOgqA3iV4yUg6UAOxaUFHDx6CYS8SorMOue0CCJGAf5YfRhoAI+A1CvwxqNkAY5yAIx2EQmkFfeWOXi+nEdSQQA0ZHMEItiagJArQxDXIrj8nCfQi4HZPAttrIahso9oPQ/2/JwV5JQU8zw+7I4D7/sBn4EO6rjw0FR+i3Z9fHtahzsFvJgM0X+tmVH5vaYiNDGAigewAz+gyNLThnjCURQFR1b9d3lZvnVqmj9mEPDKIUIC4KCCjBXywS4N+otp/Hk3QVthOkwEKlV9PQwXjT7s/zwF4Qf9toAAzFdjuaEB6S7D1//U5FIQu2MevO0rQQH8ZmoXE6B/IkgE60XCjVoq8gt2iCG0S8L5GdxkM1cGsfsCMArSCAnrr7dzAZxCEEpepvB8tqHJ/q+bmJGGts/AcAXFOMMeTwC7Pw0B6CtCtA2vWgonqBQJFSwH0JQK29OB2kvgj2HHXAoyeAIsCQO0kMNECAhFMqCBf8mElAkyBbX1tJQP2RJ/ha0gpAfS9l+/5n00CkrQpq0MZbOdAuxmMvHswog62jZj7BnYQe19b14kxNq2D/ehX/p68HEcF+x3yP7z/V/A/q/5DA3i5A/dzA5pdgbKp3v3/wQF4Bb70WkCTHGRAA6+KL0bFl6FJaFw0ImZwm6igSwbbwPn9RMBWf3sN2JgA/BVh/Rg0kQBgePf6HglAHLFQwqQQOwDjbdVxNZjR4iM6Qa3WxwvNxh0JFb3g/WzFQQS8b/ttKcDWoABtUMAd8j9hf0MB2uDXhzX4CHj03L9DBU3Qjz0C0l4mLSLQPicOOwZoVCB6P6dA7nDbGkVuxcNr8PU2JQO4wX5trEqmccZaHU4q8oCDFOpzAnOwqyMIMktNNNAHouDGxO37DgArQZzlmp/14W1QlqHTMaIIx7SCx0+5yza7AKJ3IXBrNAHVDcMZAU/BT/vgv/ULPOA+XiLggAREDF2g0ci6xNDRglegd7P7TWWH5oJfayliEg7bScQRBVgI4Ookg/F6rvpLWP29swREqA3CaG8/FpKqS8DTAV4TiBqIqtxfzaQRLys5I0XEFIFrPbZRQb+16Fgi2LvJv8EFUPW1gGfQv1T/F/d/HBnccP7rAwnIIyHI4ArgWeGbU4eHy6Tx/EeTZIb5bo/BsMBjmjBE08f/RB0PHYBd9eVRAGY7cHRwiBf8WeCPHY1bgBTa9xKTELzEkQX9CPtl0gJiqsAmCT7I8xbjivh3JGFI+D2nBcSJQJ8agDX+O9iBL7UfG4bzAkcaICrbtYHz1ycSmGmAjJfL3CMgT3tQpmrfB7gxSzC1DnvdhQMieG47u75+kTouKNkM8c/+vq/Q7ZYjO/hhVvRq8F/9gGfhP8aqE9EIdR6LTwJ1h0BItyDqB8iFwuNqASscRnYioxOg9ApvnYA35f8e9Ohbfe8J4rknoFkO0lmA2gmAG0YK0DkB4ieEjiLoMD8wBzom27ANZkzIoU8EMHk/uo1mzeVoEoRWKn8L/62EYAX/lsB7D/LXg74uAMr9oGivJ0CNJCGD6i9DhZdQF+gtOp4S+NODRzsDVbhdgv4BqTMNyIL9SCKwL9/FGPp5oQKxIf8A/UX6r231H7YIqLML0Ae2GtrADOvRQH5b/MPE9dt9BGLNG8jVTAQvIaK5TtvvvWQgDvyXIClUA78S9Nfg7VtIBlO7cbsEYkQDMot+ygQ7QwmOawTHnAM2XUSnJvPIYRYMmYPS+sv3J+cfP3d04JYIXsF/EwMbBKB9Q9AY+BiSwFj9mzrSXmcJhFPVHySTbgHJCPvRQ/z7G/SVUETsg0ZF+i3CRoCjhf7y1A9mOiDD7TwdwEoEXjLwAv+avLE2B7Jnb+OqDpBoAchoQJskxKnss0vu7Q2YhcDv4ySeLOg9GsCKiUIihP7yfW7zbTsBh0TQfN0iAWn9f72Z56/Ax9P7j5OAH/Qvv3/QxKfk0DgDuP+R3USg3bzBC7bO/QT9Eeh9QvDPG7glBQzJwK740lAFFgFk8P88CqDGAa223YckWYhr+c0BPdwetl2ocnsfzePAWcVnnAIp6gDVhDLyfV4nqFEDPxHsbWD3k4BDkN+pARqKMLYBPzYEvxp9xmCHQQdgWH/9EtH2TIFpu3AH/cdGydv1j0TQbRrq+D/mLcX3ZACZ15bF378CG0My6Kq/zoGOQwhASDFwFbxyNGBuSxbCEhQ/uEPe/6gAERWQObCVVfjPpQX+rexxYhYFxIkgpgX7Y/vPs+Pvxf9vwt8kAs7i32t3QCP+3SPaTwIytQXP38u0PESm+YER+o9B3vr8mETAUfDrEkPI80ck0FZ0dXh9U+HRbhey0cAc2H7A4y4egoD6y8JfkBiigLdFP8v2W00E8deT2IeAKujZ/QAVKpAtKI20gLWksHedfgPcb+0+NEHefd9vB9rayi8h7J91gBbaw20MsnWAF5xHkyDUCOoXp+yrOwwxcKj0aL6fFppaaKDv6OpHR5sgx5BAlK/+fYhuP1D196o8e7lFBaKqv5YIMnFQpd0FGVR35RJCnCDaABaXBtgbiSwtICMtalKC+1JQ6bx/PLcDPQL91QFodQNKpwOgF/9eqcBxBBqRcKAAVk+ArQOMx1RYGgB6naDhlK+uQQwJYx4meQbxtNnYQwMjt/d4f3M9ZE4UOld1LAh99fbfzOxiEkKFCkTJIUIMUeVnJ/9sDt8/e1NEJOi9oVHDGYhgnSLss9DX2IAqw1zALUncKcDr0FB5NP+0cBQNrEezDiyiADPkt9qGpwoPdL0AGPx/NOKeyf3b9WJNdfcFv6bKd2cLMJVfJ6Y3B6wB9WFUfWWEwKMfGiQL+3bz9XGQz2EHKhF41GCtZyDi/gUCsNhYoAr3UNJ58YidHKqnMb/6AB5J4N73/4L+t7mAkeeP3P+1LNSB/l0SkMEd8DcEuUlguEw6t2AU/PCE/q++Akw6QFf1u6SBrj1ZnnhG50AfkoGIdf7gJv1KcSfgzWWkQ9U33Z3tHXYASKJ9e/YhU90rvD+q9Ej69/wxYJVs506Eg/r3DkMDzEdDBRGgcZay49XihLA30P+l8N+hf1f57/0AoxbQbwYaan/rBMirE9Dk+sBzTkC8JNDEUlv5McB8PP19Y01Gayep+hC/2zvQ/2HGLAurowsNGlA1cnqGGzeH5weiYLZm7h3QQC4O2tXdhvMMk1ZS5ebpgI8eMrPvPGkwaxayk8Yc6PMOBPEdC1XZ+2UfbfOPtxLMQQAG9BcZFoF0gp/RKjxe7+oAw9T7ZPWhgedodgz0gf5KBtrtIZhQAZpAV1Bi36w6t98qVfH7hqGI318lLCjLCUFlxRHwqYEH9a2qb4XjWvDT7kBwfbZA5P0+PNuRuW1yf4yNQH3zzwv6b70QOJ0G9OT/dhoYRUGT15uQH/71MjQLtQlxfDuiCXrtM+SkA+icQdH6sU/xz7Ze7FlubV4TpoTQ2osdpaEjtqADmEU7OkBEFoLeC3IWFFeswJXKXzkboNL+wzcFHU8hTGKIboO7CLi1/P+5F+gydQhuvRbwEgxvtACmANikhLTbj0gCYk8KdlYgmj+4Ymaod7TwahwadICuX0Cm2fE5iNHPK0x/CDV66Kyg1MnqjNFBnhBoLQCgUULfaVe5nq/6EQWY67bXCszUb+7232fVPz51iGB12owK9peyP1T4raMFF/OEYJP792mgXYfZ04GHMAhBkCSmSj+dKqRPgVFGHbpLEGMiGFeQWfSgrY52VxaeDUPSNJI0P7NoisG729HHl78z6hxfs9rV3m4JjgM/lsui2qmThjCfDFSb+I9vwUqG5wwL55U7C+6ot8B+7N2o6r3q37T9trfpjgmTvv7PSQATLLeRAOZhIJHBQfDQQJPBdUwEbVW3+L08EcEE/9G4ANrCeWcnPKRHDupbNynMx5AA9IRYLmrc/YLSiD5EaEBS/s/TgnU9ILcH19n+CpHwegLejx7Mn/d25fdN+e9U/1vgb7bqf08MOtf8EXxaoh+GY8L6gDfhvs4i6HQ7seYI2sv1GchdMsBIG3xlvxcCRzdgCPTn+6q/TW00VE8Q9FaFv+R2VlOM1vm/hhjhDCdgNflVKME5B47I9xT8z0YgPAJ8myb/LqHy36j/Mwqw9AALxuO1JVjiuQAYLcFzIhiEPe05fk8tRjGw7yWQbsfuLAT2VqOId1osnr0F49VM8INACPHDoBz4B5mqqSnUgyh3ArjXxfQH5BbgUS8gP7aU+w0zHD9GGD0CGHf+P1p/DeivlhU4BbxR9a2kYFR58YaDZCUR2P0DMmgED2eg77puegy6PgDphEB0CwlG/i9d+/Hs34pBEQrBn0W51mqGnJAk3ACCHeiqkQ1XFQA5AlKH7Lk8yJKWY3/nym14h2C3JvxeMwD9ZVMz0BPMi1n1RbKl1cYhIVblF3G0ATsRiCMUvoK9//OgcwYMoe+ZKOLlC6/Xk50br9NFz9fanqA8UIYSpCwlBO4kHc4WLLBfBHVaKwKgLQjmP4Un61Vq+3s7Bsyi0WztmLjJwJwFeE0I2vD/1Q6MVwefxfUf32skCPbCnxQqf+QMPEUDHZ7vGeyj020JgkPXXwsldA7SYR1RE3h94NvNtugswcgxXEkIcBPCGZ1rmrgDC0A4K88nm2fn/eTnpQtWyZfybRoK8Dro4zYDIMGsf7saTBzvX0SMbkAD6o9CYbsfMK38cJKD9l2FJt9/VGs0h5Gib33pxMKWNsigFUh3G2un+/N1WUglI/EEx8fq27vUNnwsiOoKecL7kQS8VnWAGCFUgn6dBtQhv40CmIYggwK0uwDHRGAuBXVdfwzHUjZzATLMAoyJ4FmBhzaWBlrHld9CCWpPHRqofBqMReMGTJ78q9rDes1Tv7/0m0v0AFHXNR6P6g30SHivin7V1BOhh3iWPwvps/yE836L2XiwnUT8x2iHgfqhnwn667QHEE8oLQjEvtEW7GYBZDrDVkwNIO4G5GiBDf9fGoFM6n+vbEtzXwP6u9AduaWnGYSLAlVdl/AU+ikrSeEIKgwdaZ4AACAASURBVKj4/wtgHcHtdO2nWKcBkPfxcvnNQvsj2Me9f02r76T8q0IBn9OLKfz1HX8yVXQYGoAB/2UeBQ5/5kCL6+H/OGGoRnLSwdd3oH8r7KkGTbgIxEwVWvnF8KOpHnyzfF9Jod5Px+IF1h8owyitDw/XEgRb5bPqbt1uvn7qBIQ16vtS/u+DP3cR7CH0WWJgd5mTJKYgNzoGjQrfvu99NDBC+bnyW1x/qhTatv2OaMKgJWPvv5kwnMgxHYGFRtJW8VMl3uP+MgoqSZyWFKr7+KIDw1d6+IiOgZI4+d5iYL3imzbgyO+tph9t2oSBxOM3ugHtPoFZ1LM0hF4kXNEBssvVgPdjdXZWK7uKvyS3q1Xb1WQwtVDqSUggq+Vw3t56JA2cz7PXOwGNW1ecwxPhfe3QEUsDsFaAz8jg0nf+iZMAHNg/XSazDuC18Iq1HBRrOsAQ8NLB+16g614jmuSgs3bROxE55D+WDDQNA4ivdMJ9M1b309UqknaDU8ObV9/PwmMPATvTMAxpABLBzugUtV9bLdhNDQA+7B9tQJ06/7QNDHGSwtgZOCIA47InIoDdROQGtt0U1HI3GaoUnCnC/rzBMQJteN17+VaAzYNA7e+PFqHQUyXPUYB7iQYa5ZFjq1Zqpx8Uqu/XT7+6BWC1Xaj0GlBIwMoHu7UzcI/6/Acb8KIq+hzmGWmAYnADrIpvKP7TZeLaf0LAeQkGgebbq9FToI44p654F47tekKkI0L5PQNZPsDwPBpy/ni+wKMN76Vav4+2cFZFf8+JwAraMt0DFB7beA/u4Zz/a+RXx0M/ct4/jwaNAS8G17eSwmta0Fhx0VRxJkHMivso+onMXr+YwdWKbgioy1jp4x4AzIKg5lEA7wvHEYCRmdx11TAuT6lDLVl4KvXkAET9P4RT8H2u+lg9EPQIpw+/NpJ7RwE8HaDv/Mu4f3OdNkq/EfAiEiOANjEALvcWL9gfFV4NZbgbQc6qPky4Pm35QZxtH1f4j+P/jXuaYPcWwIEH/fmEPBoAO4m4LGxV3txOQqDU+dXgey+UwSzuqP++uImO/u/6ogCb7wTc1n61sL+vZi87rxnrNas+giTg6QLzaUCjIp6JfhwtGI7AjBBB9JjDY4ePYVR6ZPgN4owVv6Q2N5hhVHwNeYrM+w6dN6K1sMHZm/Ce7bHe3dzKr1xw1w4JrSQMZtgnoQHlr18fzunAszD4qurNUg/TDqzx/lfCaO6t4tACMUQ6P6htWjDPC1hCoZ8kpODzJ70MUR9AODcgwyqyPhmE+wfHYB/hvSqt6qeXUShhXH+d9SR8DzrDaZZdpSp/HxqLMQuATgDU/qDPRgOIeT8cvz/h/XC6BtE7ACLOWPE0KIS4UUjmZaJ2grBphiWgT41BUVWZfP3AnEIT6OrfoF122l2rMycBoU5i/OXoUZ4/aglsXwLzHNU++FVF3qikOj5HXm2PBitT1WuvJRAB+6O//W0/PY8vQH5IrAsMs/WuVmAdHBrQgrbOxJShXwRSsu08h8JMBpo0+aDTALwV4tbswgzHrftG/dJKIAQb5h9KCssWIMeto+GYqG12/HWGjx8kzqNJaa0noMWOr2KwW01AMwJoNvhMQda2/RKQP/3ecABM3g9uD6BY68Ntz9+nDOMb5iV+hIE+dP/Zs/wwJhJ9mgBnohBuStABUXjugF3hkXF9ZZJAjefKdHZCc389LoStKvIl7QIEb1d9RyciQgFDI9Cjyccc/23Aam7/PZJBhgDgin5CtQvbCzX8ip9YgIFtOAt+w0owp/hOiCWgEGbVHuYjRigPGR/YOnEoqPDoV5z5YqB3mRq2ox5ICmSSgAP1Ne+XV2NE+/vuFbCTRADxtS70VRBCjgBk2OyDUQiUgfl77b7DwaHm2rAZ7osRSOOUoHgKfNBSLI767+oDYrfwZvqChSpGfj3pFwZFsCJg2jeIQQBUiyI4WgD68ww4qO8khuWkkIuDrxWv2nv+UTBpJYiPd0KemTA8qqFiuUF1jWS3BoG6pADJq751JqBI0wvAVPyMQvjcX1zbELltKK+zBiXRFiRxG+b7q3M9xuLdzR8g0gCGNzSM5gNYfqGO9CBT8OHct6oB3KsSDBisUnwsFuISQaRHxDSv0vptt2oeLHMERfRn/FG/Cx01EpgIQG8LP+/i37PKw53xn6sYCM4/JwSRrCnIeB1ZkLsawDhaPKv/njU3wnZ/dBdGE8+YTHSG8+ofGgIjsC19YnwdM/KAnTSsqj6ig7uGgIPw3nYFzhhIIvriAxFP9CQd4HSlnzgxONIdrE7A8ZDPx9fjib8ifgegNIliRgdx95+E1T7+3nQVNNhEzDgGA3T2rEDLduwtPpuuouPcs8swwXFjdTaMKt+jA5gUAQPcf95KJQxYU0cYxEDvsBSmYuukp7AwnqniC9Afa5z8vboI68ImT0t26CvwBzSggkj447r9IojvCn7U92J/Hw0QSdwZKNNjxPCfSxRqnATkdwpOwh88oc4J8KTSm/wdbZjrc+4iFP8YO0/5JJDCfaijK5xVXevqfg6zGRrQf83chvX4aRfAE//6vv5+6490U4ADdO7QgM/5bcHP/n4OtCQhBEFeDWSvos8DPq8/IwzLzjpa8/U6MMSkBklDm8e0mn3QIY7XG1Om8wzN48y7HwhOK3P0/ZwUQHHv4psbdoVeb9VlAjChBCdtDDpOKTh9ZfcagOYq31RFjN4/gwBYzp8lAwYNwBELhZoxECeZxMlAzWGdCRV0fQWGHo8+8Kx+AAxnCIzowAxy9KvNepWfsfp4RR9kUrD88CPVTuXRybhqqTHcnxEGndsgub1Gdug8yz9fHt3Hpl57x/mfCOC29FOSQ7/noAZR5W3Ob24UMpuPYAYiQrQgk1gnFoUIKr4vKFpV15pHUJO3Y5rfH3UFHU4bGkU+NKJ9f2hJyOMxDBDpjAgwiYqvk5TqNl9EH2Arb6fA3yaA4cBtPWewhkEcIQJBlGzYp6zRmr1v+e3Fv27xpzvyI44NGDkCIi7CGNV9Dw0M8NtHC2vUwHINumCGNG8erxOwtQINsW88Tlwdoc+F85nI559ngEDpt2F/Uu3hiXYrkN/pBFS26hYDAkFgErMK67y9mGBA3L5ore5izf8b3n805MOq/t7XU4WHv1DUF/5gugCSOAIW/59uMwl6CHWAib8bvfxWl9/rBGEMTTwDfG+ezEYG4yk6FvRPuPwE+wvc39IRjENWM+/cm5b0W4Pf4WuKUnw/vD6eDbB1ETs5vl77Dhnm/51g6wPWwQAqxnivgQaeS3gy/u/1H4hpTPrIgHAN0mSgXUX13YP5PMIuQAfBr/f70cdeE+QoCX3i8nFMLcAjInBoAIYqt1LhC1WdtvmSab28AYffaeivCB+ohdYQgfUa/WS4ToMsNLHLc9nnvPZLwn1/EefPVf+U/xvnCVSEQEkEQEnEQJO7S7RvYDxNeNYKrG7DKMhtsQ8cMmhgPKKKj+F7CiHYFR5KIIPxOmg5IVAtu3ACQSPh7CzUQOgAej5CWEkIe3vgxz0ROGO//qYfz/dnLT+ZxDr4QW0eNCJBorCFOVC312Ec2TiY5Bk0cAaQmiA1VH1MOwDHQ0kHdEDDf+2UTWhS4Z8diQMicLx8MLBfverLcP/jQzF0P8EJj5+NGK9RCz755S6F/f1+X/gxeP+Wsedv+vF8/54aSPJYFjIQd624MDz/UDLQnr8HU3ztKHRf8Qeno1vyAQJBaLcMtTV3cvgP56COCqd/QP9xLgBkH4BxO13n4hNUDtACC6G1S3zqooZ6Ba4lp/zcAFb7iERKQwQcF39IFJjdXECGADw0IE4gg674pYAnk4HoHPx54tD5daO5vxrugSkMjgiiqc7TVKAT6AT8R4ckbHEQCYR/IZBxJgA+XZjsR7vaoRpIxWqeqfXuGC2CxwudicwePEB1kNkaZCuwyF0DuKv/4sz9mzP/Qxdg3BDkBTMC8Q+loD6UGBzx0Kz6eAX/KArOQTlPHFoI4vVtf4rNuLrca9edRn4xBP7k8w+9AgZCgBfEUZWfEs8iFNZ3UO7TqmkjCO/rWdgco/yIqHcQWaC2EGTzgz5y/iXQAvyx3riyxxV/JeBriaGB9OrTA5g9/eokM+37GszqfA/UZk9iW5UnCtBqBl3XoNN6Ag/+zy6A5evPAp+TIFDn15gQw9rjrOzFX0s2JBVAxa/nP1a6AsNWYGjPNGPLTQgBsNUFvOA3Ht9o/rGDN0tWOCcxJGp+f7++kkP7PxcGv1+GjkaLt/fawpwwerQxBJNW4b+PJsYEgiAYYdEAGIlDNaAbRkIgK3ut0jKByp+8yz23X6GttmBmjwDvChgiYLP5V/zhH6/110sGcKo5CkggCngxnIPoPja0j2B+1BRkiYJiviaLJqghDI63G2nAgAxMCuDdnoD0wIQm+urMB3VuAwbBrFGgGgnhAFqg9+ujKsLxB3qGCQNEEtPinIQlAj4WgIw7/iXc9V/x/yUWFs2KH504bAh4aYWf4TrTLGTy9YbftyLeVOWNfYNyt/ji29mQnqMAltU3ioTtbX343yv/1u0YPUBz6zB702tQucnX0gWaFh6DgPdmhXaapGotw0SFz1qDiTMdd8h45HfcqCPRUhA3+NmKz1l9teCPaMd4urGaewRitNBDdahR5c3AfQmDCFT9vmtQEwqAYXX4XI2n23Z9B/Yb1FL+LWox6wHGbZSo6FR1LzyG+3hriSZvWT6jfXhl2cmQZJDrAbuYAqAHo1GA/EOgD8eGcU7A8eDvH4fQBuAhBL/Zp/vamPTrRENDGLTV/7E1WEPLDlP/PwzU4YhusIMUgfIPAr6Dhv5R4y2r8ldFwiFoYHnmr8TAHbhRQSZOctH598ZYhqt6wP7q/ouqe77RJxvzFYaji/z4vna4v5cUMDXqDAJ5ytktqtBDckyjvJg04hl16LB0xFfyMfD77PZjErGQRRjYIfSvoAXntks0ok8MsUC4KARWnYPlJBeIgLeFrUgDOHYCag0/XNAbWgRwQuLAsaQwIhC1g7+jCNKuT38JfnYSyTi+QQEwwHeT4/dWHYxJPxfOj5oAnRQqgU3YgGZSOaDyK3n/qkDYBKptzR3oD6B4fyRKjp2AzSl80YR/3P+/1vBjX18Jbu+YsrMRgbqPP8zrDLTAaupphfeZtyPs9BPztpLSBZjowF3woYRwBwOWaqbev15b7X4RWsiqYiY6ZkFEIoUwUA2OrkeEQE8HYNyD/rl3m88jCGgO/nPW3xy8x4Q/HBcM1dYg5q8N+B/SBSYhtD0EY1PRGLDoKIBHF3yLz4H/gSYQJRETgqeB2d4vC8L2NVnQn4PoVJJAcP0inahAfdXVI8CFszjRagCTtRdV7Sr895NBpRKXIT64RMFw/iw5eChhEvmmyUIH+k+Qu3cLzOAN6ILlFvgWnx3YWFDz0f38ze9GlfP6UQ3ojEY0gtqRIEbA5/WgQFhsEuIeL75uTzvqHktAWfj/OD6sQXssROcGiRgFn0QVkld7OznMDT7CJKzhMIqxW9B+LCOQdH4uyxIcE49VTSeLj0wKjzcp2oDXQA8YoDEGBLMW0BJw+eAxXejPV/IXd59/tp5rVyYXDw5BlRetSpQAcvgfOwVM8ObzBq/AQ2wX4lwkQV3vNhYFfn2LFgaoDU1ogqsfqGkJYmrj9Tr22KQwBLzbLuzDeA9yzyJjVRfwegWq0H+FThDPA6ZhZwX2M2Kh4waovCzAWJTzD/qY00c+6PM8coz08VNqglzx54LfHuTJK7z2rwX35ABLg1DzsZ7Qv7l/f2yXDlbf4C/irg0MJ0aCuD0wP74MrxfdFlX7tq+vtRdCpvt599EG9Yz3V+P+Oj/n4zLruZHcJ7oMt/MNp9eD6HEeFb6/TMfbWo85Pb79HJo8t3371/PuIAZqMvjPC34nVV6ZB4hEuA7AzA5cfU0y2n6ux89D/35/n2/vWY5Bf0qwf3tPLISO1Tap9qzFB6eap/beqI94NCCbGwgqOItY3CGl446CaQ8i2Q9g0AvmgJOnBoAA0gu17tsKtKS7D4udgCYERy2QIceCX/P7mBW+g/7D9S6Mn50CS0eAoQPDcBjopIA5+EcxEjLweRjXq0UbLIjcBxsGx2IZvlf0ATjz/6qypAmY7bhrk4ahsIis6ccXKHdueAfUgk+RWPCLh42c6zEeKyJpRTdRAOqBbl/Wq/uT+q+Fx3FoTIuCzc6+hN8j4veGjuAnhSE5gKnco3A3XwYlq2sq+lmP4yEOpqEoG0M+mGDYuYT0pKCFHgLHKt3T7T9p8GcWH+n1UwGa8X6kQt2x4CeqPexegT6o/Z4Cr313PHdgrsS2ZReLfpKIf+IMFnmVmwxQ9AhithYT73+p2s+JIVfrjwiHnpAZrSsr9CMstQXP1+1+510N/q8E/YoekMN9OMFvi5LvkRDsy9rgFCOoPdpgaQIWBZjf5KCSQszZJ1ivTvLokpen6tsJAVND0NFqb6GUGg2Im4Dyx9Pn7/0dm4pADAslJzTv+dKNrAPQ0wyySm7bj1RQgbAXsRa4R+mBJzpaQmHLmy0BLoL+Nh2ZRca8uUc6P37k97n451fvTieAE8BdZ2ItqFEK6oOJIYPsiU4woo140Oh+H/UC++gatHYcOFT+2y3AYvD1rM/fpxdUcsAi70c0OxAEP45X/hymE9XeoC0zfYhbcqfbhs09HpwnKMDR6g0mmYyKth/UcLl9ITGQ8N1S6s+gA1HvQCc2pluPvN2Br8SyZyfyxPP/VhCi1L1HWX2CQCuAE8TIq/sBYdANZmTIwqq0sb0HIzhhugBeUpBZLFyA8y+EErsBUYDZHYN9QAAooQwOws+uQlhdESSSqk5Qsh8LSYI6LDS1AbmOvLlRBqQIeITvM36+TP63VfE5hFClCTr9zEyVFwS3STQBy66DMHB+PJWIrfgGnYBx2dTboPa2X49GaBVlePA7CFx4iaGi4ns0aLVjMGvtPTDtmO4XEE8E5Kb/8qYai+NHl60LgAICcUCoJPVeiYG6Pxw/X9VFNVbFn9FNPzXoIRDTyzcpREYB5Fm1EQQn3KRi9wKApR8Tz48SwxnV3qM0q7ZhpdKvr0zfY+gO4oQf+EGPFYW/Xf5hwWsUgxiBbShGoGIx+D2eH1h2EeR3UQMH4zMaUKr4033nzkSkfQADelFbLOQCalxdxvN8mInhPas9bxtGJw29Fx3Y8429MAS0fL33Oeo7qFZeiToCC3B/VSNYuU0fgDnkhxGgMFdxiYEY7MYel+OHPH30IMeVFK1C79l+QdXVpFqHlMAXEf3EYDyfkkGdNvJ8f3RAXU0jpgM7jMNA5yCrtfzOicKG/M9bgEkEjqqPPDEcDfqVwGZv6zcO9avDfOhf4OmLFd9OLBHHdxp51HvOBlnAoQksYjASA1xnIhPsapTCPjbsGB2YevpPpgM73EYeSYIftgPgte6CWesVBB9QEgfnWYMgoeC8ql69bWoRIqYHvSIv/u26bj/jdqZ9KSGk74JRo6QS9PuTiSHm6Z62kLUGH0UO4rwWrhtRETkR4iKRdI8giJ2D2nUCMjsA0TXiVDb98NAf/rCMlajA9wesWHZrAe1dlwRyVI2jx4KkyUHSx7YDe6YD4tOC6XW01puEdAJwaEJzf1uATHi6ZlSCpBQscsh6C1xRcWEG4bCFeKcAVhVlDu54JQIkTT21hptIT/Afk0kMcS9BKfjBJozcDXCrtgbWXxbMAw3INQIxtQJPAGwXmYaBbYh4SCsuKwLOAQ5awKskCMmRg8P3xwlBfbosQaDqyZqBkyQe1CLQACoTgN4qbyHsPwkTiF2pYaj6MAXBmUosQHnUEYCsBL3MW39SNKMJ5PfoBsT33DVJCEbFnBCMOkHfvj6Xq8uw+dgRIhGgAiUqf5QgKDFyhe8nnYrlqn9sG1GoAfirubygX4H+8IM1CmQrMFAJ5ExzKIp54nPoVU2Auh6eBShDlTV4u5c4HE/fVvjFrsII0Ik6QX+Iq68jB19ziLoKC27FYe0gC+j1RSS+BgB7AvAM3m8HLdy5fV60C8RMVuhD1ieQB32MCCq0QPJuvuw5IHF/geMKwOPdpmsxBwVEfGEOgeincJqNmuSFIPhPq/xM81CWIIi+gCFBqDX3QPYd2OcCRo6GZBoA3AM+00aesAOQ7/2Pe/vBCXoguD4OBD1WfPwClzcui12AuH+gC0gEwW72KfjBCQRBr05D0IQc7N8PzOCMehPWK384MPVDJQim7yDdoiRTItzzFV/ZOX9sYFetP0fsQzb6O7wOoFjxk89YoQXv+BmSN+yYHYO+BsDRAXHhuJXsEFbdIEGZQWUkNVNzGA9NZUVBIQL7jASR0AclE4Pb7JN3BO72mG92+o8UG3nybj+mASh0FsLKn9GPxDrEcS2Au35BzHO1BksriIJdpqWjKR1wlpR4fN977rZqI+XbYjYDgVDpcYQalOYKMiuQbB3G6Pu/HlMbi9a0EMkksXtjvvXTfgMKAEZRN/i/O7yD8Da2S2Bdh3ICWfp8yuMkYl5a4df4vVWt4UF0yyqEnaT6swYyWB8/j111Y1ERS9oB0SLMtBGDEBD1PEHwtdjUEAHnqmoHU4wCDAoAS+lHwtu9eQLUAgmxVvAuMB9cELMV3m8EUtcBYYI9nkNIEEJYrQeUHfnzzRyC39j8CgSkir/E0P2odnAmAqDnDIhqrtV9BDNS2POjv/0pwKr6z1h/PMz3uf9ykFYq9TtoAXSwpz0HljdvBCVAPY6t7osv6gFhMpkX13rcfXQMIpuTsfTibkfOPRAC2meLRipI4mDPwMD5x+v3+Ey+qEfACwoUEkKQSMZxYJDz9R68PyP43yvo2aYf881rNQbZgRU/jp80QnW/hdXqJxMvCFxXQSNHpE8QiF4XI+wFfQcw7VL2Md7RRajsKgh2D+6SLAKPF356+/7yXYBTUgFy/38StUjFHweD+iiHh8/LV/i/TSvGk4L5x7F6AsIKbgb4C0YjgdGRIToGUx7cgS3JKP8pRcgak95BJGQbjaJdBYQ1qHYnYHL8F45QgHx2gLMQ2cDxBD/4SeR0LSDi5XzPQNjM4ySE/HGG6g+ugltLNSARn281BPtNO72eJLjdX4ITSEgpQvJYFEUg24f1qAYQNQdxx6Q/RcB85j9f+03zf2QV33IDPHegNgPABTfqFR8cZK9TA7/ll0EQbUUHW8Gr1d+MSadia+LRHwhunv87yWoJ3h/pRDwJAbDNQQFd2P2mH4kP/wDT/ZeN3CK3+ZjvgVpw4r20AMafb58j4N1UMknuj6iCx883PU9g2VHVH5JX2eEcPghSgRBCKPzK0Q3fknwPN0Hk0CyC0zBkz//7duEetgFjVtypASDI4CsknYJgYDhqsBxxy29+eyxrAZX75EEf8f+CkOcijMDDHx4ASYGGu8WHgPwpHJc0qOG8FgFTuVk0cRZVePFwHEIUEu8xSHoL5qWg4I7/HgOKXe2dcnu2SSdCGIDTA+AcxY1zYL6Q6AAFu+/1GvjKPSeEoJV3NiM4Dz9C6oWkEav+NWjPWXNOIkKgNTi2I8LeBgaZHJxqrC4oNXoB9pzzMws/OW3ghSyQJgjbygOVEDhoj4nHLld8HPD6UUMFVLIgKrTL7cFoBRLQgEdXIseZ2/HhFPKbk4d5tYWwwR0nIFQSD2P5gQhs6meVfB+Bkyz2fOIvX/zxqsSODuAGIOLtPNnmIPCrv6Kqvgz3q4tCwNl9lWYfnsdHj2HTgQw5IBHwULmfSu1jEV3gDFSxTBmqSEVqiYK2IkWcRiAkwV/cyW9YhqHXDw9dkNQAcO6HFNJT7oChfrPUYc3KY17zAd+evAwF2w5SCKLV4EuCEKsKfjBVWHu9Q9Arh4CoBqEMWYBsNX7YgKP/69uC3M7/mOOz232QT+ox4iCyJGEFP4oBHd+GVvXBwX35nqp7qeIbV6L6tdZub3ueJ+gBIKgC6S5gOQFxDoGr+Bv2nzqbknd7ph/EmXzO0o+kZdc/wqvQkAOUffVMzKtYgx5Vob1/+HAfCdzHSiXHenX35/2JTr3KZ9Ruj2lYiMhLIFoNyMq9hFroeYMTE0bSLbhb4l3YlFPa6hMd2jk8dmrDgdQCnC4/+ANFlYTB6ATlx2GDGXP1rvL+SnWHw+cJes5/rRWt4H2pw9GklD4uSMpwasIQiaYR92gIyFX5S8dtRZt/nCAH48VXW3hRE/HKOsGquj8EM85Q9cfeAV4XwNGAlmIFIwPYrfLKuxV476RRetzcdeAsRSZhiHizCKEIOHn3EMOWy5X4uIJnXX6sFiBFLaBm/THOQAkVJK9j6TKwiSDTBWpwHkSPQJX7U959uAkoaTUuug6oQCBz1Zlxm0OJSIoIw04M+7zCGuYiznCfHww9AN6Ir+HXA7lfn2oBSJ2FOOh8SzINfmcAyITq8JX/sOMPx6A9LeYtVfwgCBZhdu25OB9/XmWWNPUEPD5dUuJ68wd1AqD2+w1PI9KxE9BW5t3z/igdYGWiL7L+wPv9jgVY8f0ZcbCKCuLAHN+c5wa69Zpr0J9t2KnpAGzyiAIPiFalJ8/xXrrA6Y+/8NoDnWCPNwFJzf5DpVkHte8hx76P+HU1+HEytEeSEIzAsu5r6wPJGu6oLz8VrKofXLce+ywIHhNa/Dmw8LrptWXZ4NKZm4pr/QQ7Qk8ehMrPtAF7PQCD309QgRgRZMKgAbFREAfBBXNalbHA9cEHMo4IgIUuPjjBWEUFEQpYTkhVO43eRiynJw9Jjj8TOUIlJExK+0wA4gWgQvcFBHAc7P4/u78/Ff4CC5ATB3P3oUwFClYgcALcxzp/B9Ez4DUV8RjBbsCBrMH4dLNwIDaCGhA6o3pXksdBvYBsktrXDgNJKAFy1Z+ZGIy5NXgXoBT8a3ZgVSPIUAMV6DjLxhsV8wX4n4ibbONObHNyCr8Z4FinNFjg8ziiF5zSV8A99u7Zdf5OisvVaAAAG3VJREFU/kIPAJLWX3hUIFD6o7MD4WkHIMXBk4IftSrPNBJVk0OoC7ice8HGS8XBKDoz/YFBLaQi392lGpCMJfhD9xVkx5Xbj73P9V4m1j0v73x9FjDDPlYvATkgFAVWcdNvJBamliOjAwRV0EpeRymAe717kMYRyy/j5FwFBX0fP7Dyx8gq8wn2ZXi8GfGYR+lFcGJSxa3Y84WgzBHetlU4cvKY44Ps4iP9fsgsPGEhQTAcHqwwGCj61SoPexKwasXFqtxq8qhD9SixoBBYcJEDNzmIoi3J7QkoJActVHocTVpPBCDhElAvMDK1PT/Sq3DwB/ygmyB9GNhYDH4so4Foy48kkPtZfZEv1PQTxYpyX0EI3Bu+/5krcN8fgwVdwWu2JNVNWAk+PcOOPMNdGFyAZ5Aj6gicgzNfwuHZg0HrLxBWfjSRl88fVCo/apX/IBrIvf65ZxtEoK9Bec4KZIPLe76osQns46NwW0pUPCPAyMc4A/KXOwZzFLGbAqD5xhhbgBcWfoJBAlarcCSQgdQJ+Movnih4gjZQTw51rz588y/ZgxVUEAQ8soCfX8OR26JwujCLGFAMsOjnwGrlPuQw9D/PPv8BYVR7pG/eeFtQpsLzR2KFI8SwKj9KlX++HeLOPuSBKrKeHBi7L4b+Kx184+ptAp4Trcscv69oARVYzWgaK01H1X0K3zNSmARKtxXYHvwJuT+8gLGGWgpHcWOmBeljFB2Ckg6wiAYOqfxEK3GMCAj6kIiTWdCBCXhkjUKMgJcLk271N9uLSbtvvK0S69OXAvoA5z94VsFubbmZvx4QAnXgBnJxENyQjy38wef81uPhxMpPJIQzr5ckuUTKe0wZyN57iFTWga8GvCwlh5UqvYgmaNV9XSxEVWs40kkosFwA70RgNOu8mLZfR6wDiwRa35y7j08NksqPQhcfkRBK/J8R75Iz+9C8gJpqzwiIeZII3QnYOkJWbVEI5jNuA+o2BwK82ifwnpSgHwaC+GNAdmW2VXfC+vPu6wR6lBj84C9WfvivZyUhZMJlJhjSukDlFJ3g4AvGJfC1iEpQJ/CaEd7G9wds7p71+odruKrHip/C7RdsxeVjzIxhoNkFGOW/+sk/YVAGtltfzZAIfzix8gcHhZCXpcGN2u69qWqD9OlRFAy7x2fQBhHUiETB+DocqvArYt98f+AEAXApsEmEcNLC0t2uPHCqPQIXwHYDfI4/9+8LMpchqr5HK39MJSrBXwnutNqjovjHFdq+fcHLp7YLR4mGgduW5hFpAXUoL4cTTuW5HJSkB5PC0S7A+8c+837DyoM1J9iv/po/o3BunlDqPjOSO/YbLFd+FGy9sxKFeT8b+nLNPrkAyD53FtT27yUS32yqUaEGTMBiASGcZ0FmK8nWxbvjC1q6WQC4VdWdAcBY8eFoAzIrC0b7Wt8wlPcIdE1FhUWeKU1Igv8Q/0dl4k/NnYSxdlDon8diUDeuQB4c8XVzcahRgyyZmNC+LAgeCfSVALde8/t1DCYawNoePGT83wlOpFUdOZKwxn89OsMEf0X8CxJCBN/dwKbFwkSMgx0ACJJDJD4iC1JEYh6XcEqVHpx4+J4I4UiAl26r5x64sttvSlAn3LBuQCz6edU8C+J5epBrC4YP52EFDgHrCw1B0eU9bOaTgh3wmYvQV3Oqqcf53XnVNXUBELX1xtSgFrirlII5d3HFulxBCNEfZx0h7K2f34XwdHpuYQcguN189Ow/nPXclaUcqMH5leCXjKOjbv3F0a7i2ZaRHmBe5zwnhA9S736ZC8AH8LHkg/T5znYgmES1dtuzGo92qwHIquiWX+4KgVLd8utv9Ml1BQNhEJW/FOgweiTguCUoQHkEwYhjfQIgm8eAzPKzHqAG5xGiiPyxeGRRaYetUpDVpHVC1T9bHGyaknb/TQTnuG7rDYwYCUT7/cMjtILzA+Go/FPw581F/mWeTkDuBsBCAK8ki+A29nMzPn4Rzjv6QV7xWW4fzQFUxb9jQQ1qc28kMi4mDl1NBr4usIsz5ltZqNm7AeJXfuTHd7nioLEyPBISU+8/tP1AC4Il/n+YGmjg2NiBRdl6yCw//zG5ph7bqaBuz8B4VMU/TqSsNPbwCeZA1cdxyG9SgKzRZPL+GXFOiH1/SFZ9wX8M3zUgvH8a4rMBjZj/h1W9MrwTiN6MlsCKiI4gycBzgV/xUaQGjGDHwHiYi0VIzeEAasCpNuL76AC7BIEl7i4AIxnAfoMxk35eJbZ68wWEUChs8IPz/EEE9BkUoNA4RCWSLJkY1h0Y/dG9bVCtUVPe7QRhtStXG4nOECDfUxc4Uw/Ik8JkA9o9+a83IrfHH11EdFUWc4phNgVFWkPsIHBnCvCCYBSgqEN9qtoXuwHhByYoJJA7BxIkkRwpDGgAHo+vQ3ZGOwCFJCJKUAx4MBpFZWvReeLgtBBkDDQu2OJxXa7SE/P4ZiUPHABjY1DsFIhPAaygWewiXK72hHjow/k8gCL6gKES8qcDZ7A+EhYlWCPGCX1wXIwzkQEKt8cP6iqkC0FEhFj/ZYtvXCtwuBLcDT5wXN+9H6ZEIkTwV/x/s78fXFX3siWHEKrC3tw7EFZ31Ll7ttknQyEMGgAqCaVe1bGk8r8nFWCQQR0h7CY0dsU/mIeIuA1AGCo02Q0YVXxub36sG1Qgfo0CBBUXxap+ECFEycQVyViBEBFPt14TK9rZHB9EwMG7DPXOv0OVHkdtx7OSCXfb3av4CFZGTwQBwT7/hKPHE4PzpJ4L4+FM9r1n8B+B+9R9I4Fu9brYUZgCunZWNxdQgIs8mASBQ4F8hJpEiaf4GPihk8FdAxin/kybjZjTj+mAQy6ihZ9whDvHAWB6BKrBXQr+5SBfqPaINwiz12UIwoTmbPACZY/fshBBBKNlW8ZCHwH/cVKSOZMm4Mxk4OwE9JeB+EFkn1IzcPQoiSB4vGgNeJSoik1A7m0TCmE/HrggB+/1M12C1Z18ACGoIeH1pH2IhAqFWgBq+kDFEWAvA3X8tpW0cnSD5WAOriOHhnYraF1eLTkS8P/QsHUBdtMPnOrMaANJE9AZiaKWII5Ue/8PTHn/UcCSTgIF2xN4zdmAQYIAKeBFl6FiO0aKfq5jcImHfPwTxcEdRmD3LcFoAva1Hdjm9UgGggI9YOoPkOBYLsT8HlG3nucMDGkOOJ8CkNOELdSO7D5qqAeJYBb2GpABgRi2gxLITgrOQ9C937HgB+0i7MeRx3gfPWCXLtgbLJAu/gCFBPzRX8eADJqCvA3FViC/BlOQC4LZyrBq8BdQAOUKoKjqR7v7EFfVFMojPgEoSlJesNIePyLHwW9NRgq7E6HvUN8A0yj0wyWDHRZ3J2A1jHdMyu3hCGwSDwdRir7h9VP7AKLgPoMCgKziOFLtrUm8aIFHlgxYfz8WBYUU55iAXauo+evJaIK/NTgRJM9sUcZRzcCnMdNKMJc7usnAyrpxHYkTRHK+n1HxS01LheAHqRWwKIDqLvQC0+PupHZgBawfVGsiniTVHwZHRqbUI/D4Cd+ftgyLAR1ehkIiqaKFw7MJEwUIuK5zsu4svoFYCFKgBJZACBuppOId2RDkPZas8H9kULcA9a0KTCQDGtpnzT+RMJiOGseHl4BQ1C29AWUXIIf/OIwwqoNEK3SCuA7FRiBrE9B4/PcrGJ1OQNj83F4Xbol/TgVHfMiIZLAdcaVkgh8sLrd+liNQH/FqsNTfj15m1J0X+ffZuq/gTY7QnvIfJz6UzBJLs83ItQpt3RfZz5iuGfNPajpngUm0R8DoA5jDlzsOTAwZjzsC3Jjxg7H914PjlcskGdghgx9HG4OOQH34uwQyzz61/0qiYNQjXxECuWYbGM/DrjtPH/Mw/K+gBLLSA+cEfPr4MroArzcDuybbr8Zc72i2UnzeHnTgzD4Ug78SzIvCoARVOQxaFFR3TzWnkkHUVFShEuqKxZnKz4p4YYcf8ZhYhuu8wFgSHcuuwCJagI4bgchJQK/qe9c/RT6nGcg6KGREJpb+MI0EY/b0jcsni3AJBeCQNsBOFVYoApcM2Aom4VFgIRdHpeIG8D3YaxBD+qCiQ+rBOSVnci8hzkAG1t/pgHA4uwDzmu8xFKkkkIqCfkIRs204r/hiDgutoAAcowBMZ9+KS0CcXVBOHCvJw2jMQSJyeoeExF2DuTuRcuWAo9sefyUQ6/oBaIjPtiRH1KvQKvygAHb171d+vc4GRMDPoxN/kL5pwlVh1mBQ1quQJAJ5j0TgOAis+h8d3mnC8xTKE34+8sDNjyVXE6nFMN+H39TQDmocHScENvN74LoGScGU4f7g6IG3n3C3qnG6JBS+Z5tHOOzRYQx+u7MZmAl0OSsRLAS/VIKfRAWU92+12aaVPksGDBWQuCMvgNy2M2Mt8EwqbjosZAec5xLEAmXmcFTHiOWARWglpNpjdEtBQRxJJU5VL5/7F1X86XntXgUK4q+KggsUoIIK8oA+kgy4+zLaACqQGTVOX6MBWdehL6BxHn+tlyBMDGAqufd7WOX5WTJwKYDfXJJP2GXDPk7Tj5Ed7BOG7DMFaBRAJgI/+H2Ngeb2SKb0zkoGlQBHkefDr7xMA5HZeJPtKIzyApI9gmnPgf1c3mulfhe0gFekDCdNFnrOwi4Gs6eTACNjB+Uegcgojog4V25P8bctRYY6RL8AJklE9ACFAGZdBEahd4d4CmghFhbzcwaXYH5qTlS6DY+KfNH5Avzjo2JJ0poDkSCMxLn73H/eB+ifvgvyIFCWAji7BWC8hd0qj0FziMdrS70BlVbgamIgcmotGZDNPwm0L9l5iHv7WRoAFx57ScFS2r2iwot8oKu8l+TOCOg2mZ2nFdjTgOFQENzKkJ8OjEnsE8f6AzyXwT6MNF3RDRnuj0Lwo6wTlBMDIyqaz6G+RiLJMg/KUrQV/rh9uH0tWduwoxmky0kSMQ+rnXxZsGadgnxfgk1pCnsIsGYltvfdzTOBIclIsN8MLAGcz5gBwj94AE8DuC9Molip/JGwB57nRyJiyD3pyk6q5ij+3TzRLohcqyqCEQBTepF15+WVmW8SEr5jMUUkx3oMIsrH3ndwAQganKzyMpOJNxMQooGBYwcByw7axIhgPRGEr6GSGJhkAELoQ1YRg+dPeD5IIRDIqq5PA2Jh0Rq0YcS8XBi0ghGRFpCtWTdum5+yLOsQf2EuYY8AfnbQZDgCjHxBSKwTGpt8QCIDVH3/4H5OwEvldhliINwAFLsEyyIfGKV+vm3eEehVqKTdNxtDiPoLHCRiuwTJxCECxMDqDjTvZ63KaPKvRgV2i/F3ohm88V8LN8hgJcXD5pVGIPPNn9EBqSQC0I4AMxBUcQNCkarkFgSn/oCs9GCVep4eUG5BRAOcQOCWlGSc3If0IFqRfURQGRrKewPKEJ9sLnIowKCcw+f48N6UHjqYtgInaCCkBbPSj8VEkCr2g8U43wY1xX/BNkwreQrzg+oaJghOCGTU8RBxuIp6VFOGoEXgEsBLIgV6gBgxoLSI5CgiYNT+GBHsU01GthrceiMUtv9KgAYktgVNeGrBbtiOQVi9x8WjiAW7UNUnm4Vet7WtsFgDCDYEwQ/EVL1PnQf/xCDLTowTh4c4HPRDoQaiwhKIAae4B7xgCBydI/CDPOrevK0FR4p6w3VfoXgQiB3T1N8Y1PCD0X19JqcHGfzB5WkQE4p/kdeXBcEVUXEIFqSij82lMyrWq/7c+LFHA7z5/dwOHHg8s/Y8C2CmhbmALtare+4UWLfb25BmXABKABTniC8gRAP2yvDAiUAsElnrxFzITQa/sAFecAOY7zPV/8jMQHSbWAiUPGkQNABhw85xrSCv+mMSzFR8+7mjw01A8f4F8S/td4jnDHYxpT8/OEyV3gz2+GTfdAeAszswfJNGlQhEIjB0Bls0BKn4Iw7WKu9f1gmSagmvqleEwJwnZwjO7npz1HdCJ1hS/mlBcRXyF3i/M7NxqJFoeH27z7nnJaBmpUZKHsTbGUc1ALEoIGsGYl9ixS50gjAT/VhB8IzvGTrBVfWEz1MzAkRFTtecW731VdjNQPukVdhdn0Y8d/a7WYH6i/TBPBzUFwAlHwtGHOQISrgb1AMUgDETTA3+THAdeRJhg59V/Ektofa9I8wxVICkC7QQSAd2O3cftzPzdMK6aA4iZI4ILfYRbb9RgqICt2AxVnYZ4kkBvHOBxT/zN9ybHx/f5Ql2fkGCX6ANm6F8WCfqAS+Eq5AGcHJd2IFHagTMHAAj+mWBnDXuc81CjhsAi5dL2K8QCYI1aJ/PJtSSxEFXASv7C2I3ZB9/a0j/7nDn/j1pHsz9Jr8fNpxPBUAUUYD4wz5GBlmyAiORjtAIGDFwzSUwqiNZ1d1tPiB7/Q9VeI9KeJU16/knkEeQJEALjY4rkp74fCZiMDSA/PgvT/aT2gYgp5E/P29AKBQAo6TRth5T4VesQFb0i4K7RA2MZpgyFXCEQHCOixuYMPgy2L7+45ezSSKt2oUkURlpXkEMOLSiXPuDQZjk63N5bmzOSxQdLHX7AhwUEA0BAeQPJIQzkAuFlOK/GtyLdiGDKEBdllQ7YouxV2Xdwza9So4Kp5Z0yAgUhTlJgFzSFrznIHYIwKcCu2/L3LsCg6UI1b1/CA+ApIV5/32HqOIjdQusE4azip5Wc1b0q/QGIAlaWEJbXP3r/L+AEipw/+BtkQVY9fIM2i/ZhgVEgJO6DZ1ksVtlYdoQAPhVO0oKmYBmnAYco4DRCRB3TwCziptaE0auER9/VzRqKNOEYINOQg2m1l9GpGNQAhh1v6UmxNQh2M4+LmlUzll0OTjYQOaGlZAEMCrdhmBphaMBwBADrSQQc3//He8KgFETT7p6BHnjj2X9EXsDjrgBS6ihoAmcSQVYmE4JgYWFpp1waAQRoqDzxDhU+HxSnZHz/9JEY6Y5MJA+cwoWrt99+U3Mc/9g/NQTFaigAEtwB1yBzwzucZSX7RZEILhR1d5GDCsBLVUdIQvsldZfEJt5i/MHx2hGJZFkVVyK242iFeh58oBUFqIQbkfp2DV2X0CkAYgv1sU+P+I/HmBu8nErugdRnUWhfp+A/ddlbEH3uQlBsNobUEMHasK1HOYn8BEEvCUaiuigXRIKj+sGOPA4KAWz9/s7WxcgB4+a6/fI2osEwv4yOENAiPf+wQhbc/5f0gGisWuQaRFmGoIqguARWsBQgTTocDLMT5OJUQnhqdCEig+/EShKSEgTVV0MBMnz04BcshPnLk/+OaV0/dwKzB4QUt1NB6uTDfGOP+cNm9mEsBAFiM7AQh9AKVEU75vy68jeOxrUC4mDEuYO0oLqoSdHaEF2eXYYSm0V+oEOwpLmYFOF3Z4CmAeBTIGueiIw2xoKPzDBJVBXQ5g5O8/twwA+QguIjJt3+g0NQEcDfUXgO5gsqlTBLkQLdl86K3CWneitQ8sg/5oWAUJP2C3V3RoEyji5n4b9lB4t9pz2CA+cAFn1Z9I/uzYsU/ELtEBOCHYQQqGcFejV+yeuRJX31zsKV5IGjway9z6PLDxKwNEPsBuOEiqw57jGgOtZ1Y++T50AuMFl7hPIbhskiOwsATtRoc7rS7dXrpcgrMCGJca6ELJo+Y0be0BW5ZKGcFz4y8W9BduwcDnK9iO5fagsKpp9ANnvDPxeP8THNyIVFo1AMas8Qk5v2Ytm0LCCYAXqn+wQsPTBh/5Bcnne14Os3uCQt28vsK1WUESJFviBgAW//3u9PLxusXchcCR2WsNzv/ImvgZzzkUByDUAIrjTvmSHAowpJBQE4SUlxMxnARlQbIqkArVAJ6pBBvELCCKlkyCDAP45BYfEPfcUpfMch3Vn4bheYK4E66BxAxHSVd5INgEPgU/NBCDfNQ8Ho1CoINAPQAW/QT8OCIZlNFCB84XhoDChFByHGjx35v9BLgyhmojqHYb5QYXnuAecvua0hZe6BV9f7v4ibvgvamrmAc1TmaEir0LQ9h97eYAYVoM/nWA60i8Q3Ifezha9BqaaL3zvqd6IAuwwLSCCuCLuJWch4h30giPtyiAphKEBcCu9BV5wwzkMxID8rhMwdwMhcSFgrBT3RUTQboAUg3+p+Qe1IGarOioVnazmefV3lHpwA0AcLWCahUiXwePHWJsP+GH1gnp/we5KfOhJAbsj0H/BIEb04TbrTPsAyb2LLu93KwfCvn5PLAwrOXAa72eEQRo1CNdw5IprsAZ3hApy9zlcITG2vpCihsRSYxNS+J4vdBZ6B52eqRcQ/QXmSjAWSfa/5GA5qEg4iJFtm624AqXLrSA2gx8p1Mdqcghv41S0lSp/xAYs9gakQc4Ie2RTUYwYgt748mV+FU1Xgp14eW3XYZ6cdqGTNHwHICTwEeTPl0jEZwIgP9gDEaogeg5IHWCF+1eoAhvEKPB/EAeTRsM/pSAP5wjWEUMM1/NJRhwJbpJSgK7S7zF3EOsI5jBQBK9DV80Z8Y0COzvmWzJXgDl40KEC6cqvqgi4OB5cpgLFYK/1CvDiItXqC6/S87wfAUfPtxqfGNzlYaOjlf1IsHPPvffHgDAoEeEST4ZLZUd/RSo91/BjXY5ggWgQ4In3fyj4mUqPrInHOCLKO3wUwRsfyXpt1nEIRLrqcWeTuk7bigsbid1zD4iDRQtnIdQsyIXnFCn1I9D7ADgxEhOvR5AJosoUbu1FkJyYCi9OhQERoIx+4AX/YqUXQhtYEwKN4Cy1HntLMmtaAQpqfrT/UCoLSxeswjA5UWPPi0mjajUWxMTdVusNvt/ChMdmILK5IRMFu90BMEzFYHdg2GAgeYVHMMJIBTA7EFTx/5fpgTFXz9w/en0ZjD8kCDoKPNGwlB01BmoWQbh+AxR689mBponGJOr9OwmMu3dtJ/ylW1Tik4ElUPmR9RqII+pVhD9ychABMQ51gOIZg+/G+5mGIzLB1JJC5WhzYjhJ7IWmLDpA8jzsAafUPkB2WnFBF4iSxkq1ty7f25rv/+EQLOxs2oUdTSA9HIR9swdBlCcFe9owPC3XWDDC0ISVzsEVbSCF/sWdA5Fu4HJqankp2SeQCYYrImNalfmhpVxYrGkUS4LeSUjg8dD7+D7w/ybIfy7vlB9/HJ978zr7/45Qgajzj+4EjIK/ULHPRAOlKr/aG0AFcqCyu0GcW45Igh6JMJmhA49/U+cEssHNJhtXDC1MOya3j/sAiAGcrEtqtgjBD6wEzSDc7D8o6C8rIqAZyPk+NQoNLAZ1hR64Yl1FBY648smUYKnSg1Xwk/0DyRyArByMUobyByhCcPnOaPyoegREFS4jNfYAw+IHCjdC1J2WDZBke/OyN85J24WiXwDYPoJyYuCD238ulvuzwt6KgHf0shWKsqCFFGjB/w8HU8eeTED9wAAAAABJRU5ErkJggg==";
// Multiple-Scattering Sheen BRDF LUT from https://github.com/tizian/ltc-sheen
// eslint-disable-next-line @typescript-eslint/naming-convention
const _environmentFuzzBRDFBase64Texture = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAF9UlEQVR4nGWVy64eVxGF16X27u7/HMcyuZGYAINwmTBigngBXoc34El4B0ZMGDJjFCExQUIKiRKZYBITHdvn/L1rF4P+c+yEUqmH9WmtrrWLkdB4C1/91h/9yn947D8+8CfdlBeGGAMtqwNd6K7VWAJrw9qwLtw2nDaernh6wKuHPD3S1Vs6vaPT97W9r/Wx1seKUWj7Uzz6vX79T//wF/Gbx/7rw/jsFB/39nlrX7q99LKrp5bJZXAtrqW1uJIncbNOXafBU+o0tZW28got0AJ3KACsE4OfYvmzfvDMb/+4//Td9snD9rfr9vHWnyz9361/1fpNLLde0mt5pTZ7a9pCm32SrqQTfZI3aqNXHAwvcAB4BPwnk/oMEcqX8eaz1t9cHjxs7133f5z6p2v/Ylme9eWmLbexjlhnrPBirz3WxWv30rw0L/Yi96PpDrcDcPMEfq+qvQCfsFF1blcv2js3vb2xLNd9O/XT1p8u/Vlfnvd+25bResXC6BFLj2WJpUdv7uEe0exGByPoOAC//BH+cgNqUjfkU4mOEetde+O2vf+y8br71Nva+9q/XpYXvZ97z9ardUXrra3RerQWrUU4myLk4AzYiADwJ+NRQ41i7MSNEBIcM5YR1+f21rnlXcPWtbVYW1/a7dL21mZvbK211lv01lpEtIi0MxTmFGzMAABAN6gF1CTPxI1gkXa5Z5xGPNrbfo6xB/bQubW9nXvkHtXDPfqIJd2bI+1mpZjmNK17QFuxDzhBJued8Fy0KLvcp7fpNzJuM3JE7daIWGKMqAylW0bLiHQ0e1ppTXEK8Qrwkzv8fUIua6oG553wQpRIme7lbfpBxm3GnoEMZ+wZlYGMlu6pNh1pT3nqALCEugCeAB2ohKqYk9hZd4JFS5ThDm/lB9N305nGtKfnNKZiqk23qZhySZOcYhHFewXfI54UMCBDOYlU3TMkSaYWaCtdwXu5yprOKUxrqk9FyUWXNKXiBfCNgucGboGAUBwUJzFYO3G+MCwFtdAn6K6UZZSyXCXBAUVdGCoS5IVxAcQNujAHKCiLLHJqDtWZh1GHV0Et8EYNqOABTUhglKJoyKBBgSwCBC6Ajz7Azz+GiJbwhFTkZCXnEM6EJcuHDmmlztCkBE2IkMGAAhQoSCBBvgYA0G6xN4DgLE5IU5iqZA1hJ8zDqCY2qktJHfEnZSpIk6bE++kEXwHUEBMCmBBBFzE5UzNZuyBRshlSSF0aEg6MaDHIgyFCPAqvA/YdIjTgQ3WBLNZkpWoQPnRIUljdGiIkHd9jumgeO0ESEI97cNTPJj6Z4ISOZh1JUSVLwiAs7pRp02aTypRUhwIzjvhfPCKF1wH/BTqwA5pQlnYyipgs6dDBQVncZatZaZUlsUxZYVq0jyfm8kNeBzz/Gu0ETrjABAURAoTJOVVJpDAoM3ZOc5olfmMK42CYMrRTAr6tIK6QiSA84VtIIEosslSTNYUkUxyS5aEDQ6tMmQ7YDMOmjziYx8E56oPEl8DdDgM2/BLeIJVw9CRSTClZg97ZrDl0BF6m49V0GTIZQL4CvNuxFj47w4ASmqUkAalYU+DBoIbK8hAG506aZTLonWFG0IMa1AAHXlegW9wFGuAJG97hhFkqiuCxUZyqSSWR5GCZHKxB7nSwDcZADHiACQ4eJ/Oot9+BvsaLQD2Hby9RUEEs1cUlcdKpmWKSQ2VyqAY56J0RiEEPOqHxXYv2W4yJuANWxBkBOKEGFcwyjlhMYdLJSjLJpA8FAxqMwXZRQA0wgdQ94Hcf4nqDFnQhBDcY5YJUIqSSpnxpRqone6ol+2Af7Il2MJJxnN/8lgIA8yWQUKItaBMRsGEdDIrQoYNTnGSyBqdZQSY16IEYaANOOKn/A+htXH+OdgLOiB1BBOEGCz5ejmO6JpGEeexVJTmohJNORqIlnVDyO4CvvsT2AGm0BVEHo0IMHeEooeQipzDFY5eSNcigLgwoGYlIKHF/ky9Z+xD/WrCfoQUuRCGAKBhlwIBRQvmSuykkMYHkqx7EAPK+/wdqEbWmfB0bfwAAAABJRU5ErkJggg==";
let InstanceNumber = 0;
/**
 * Internal function to load and setup BRDF textures
 * @param scene defines the hosting scene
 * @param textureData defines the base64 texture data
 * @param textureProperty defines the scene property name to store the texture
 * @param textureName defines the name for the texture
 * @returns the environment BRDF texture
 */ // eslint-disable-next-line @typescript-eslint/naming-convention
const loadBRDFTexture = (scene, textureData, textureProperty, textureName)=>{
    if (!scene[textureProperty]) {
        // Forces Delayed Texture Loading to prevent undefined error whilst setting RGBD values.
        const useDelayedTextureLoading = scene.useDelayedTextureLoading;
        scene.useDelayedTextureLoading = false;
        const previousState = scene._blockEntityCollection;
        scene._blockEntityCollection = false;
        const texture = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].CreateFromBase64String(textureData, textureName + InstanceNumber++, scene, true, false, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].BILINEAR_SAMPLINGMODE);
        scene._blockEntityCollection = previousState;
        // BRDF Texture should not be cached here due to pre processing and redundant scene caches.
        const texturesCache = scene.getEngine().getLoadedTexturesCache();
        const index = texturesCache.indexOf(texture.getInternalTexture());
        if (index !== -1) {
            texturesCache.splice(index, 1);
        }
        texture.isRGBD = true;
        texture.wrapU = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].CLAMP_ADDRESSMODE;
        texture.wrapV = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].CLAMP_ADDRESSMODE;
        scene[textureProperty] = texture;
        scene.useDelayedTextureLoading = useDelayedTextureLoading;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$rgbdTextureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RGBDTextureTools"].ExpandRGBDTexture(texture);
        const observer = scene.getEngine().onContextRestoredObservable.add(()=>{
            texture.isRGBD = true;
            /**
             * Using scene.onBeforeRenderObservable instead of Tools.SetImmediate to check the texture's state of readiness allows us to check before any rendering occurs.
             * When a context restore occurs, it gives ExpandRGBDTexture the ability to reset the state to false, preventing the texture from being used in any rendering.
             * In WebGPU, not doing so would generate an error because ExpandRGBDTexture performs a _swapAndDie on the texture, which causes WebGPU caches to fail if the texture has already been used for rendering.
             * Only when ExpandRGBDTexture has finished its work, the texture is ready to be used again.
             */ const oo = scene.onBeforeRenderObservable.add(()=>{
                if (texture.isReady()) {
                    scene.onBeforeRenderObservable.remove(oo);
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$rgbdTextureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RGBDTextureTools"].ExpandRGBDTexture(texture);
                }
            });
        });
        scene.onDisposeObservable.add(()=>{
            scene.getEngine().onContextRestoredObservable.remove(observer);
        });
    }
    return scene[textureProperty];
};
const GetEnvironmentBRDFTexture = (scene)=>{
    return loadBRDFTexture(scene, _environmentBRDFBase64Texture, "environmentBRDFTexture", "EnvironmentBRDFTexture");
};
const GetEnvironmentFuzzBRDFTexture = (scene)=>{
    return loadBRDFTexture(scene, _environmentFuzzBRDFBase64Texture, "environmentFuzzBRDFTexture", "EnvironmentFuzzBRDFTexture");
};
const BRDFTextureTools = {
    /**
     * Gets a default environment BRDF for MS-BRDF Height Correlated BRDF
     * @param scene defines the hosting scene
     * @returns the environment BRDF texture
     */ // eslint-disable-next-line @typescript-eslint/naming-convention
    GetEnvironmentBRDFTexture,
    /**
     * Gets a default environment fuzz BRDF texture
     * @param scene defines the hosting scene
     * @returns the environment fuzz BRDF texture
     */ // eslint-disable-next-line @typescript-eslint/naming-convention
    GetEnvironmentFuzzBRDFTexture
}; //# sourceMappingURL=brdfTextureTools.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/dds.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint-disable @typescript-eslint/naming-convention */ __turbopack_context__.s([
    "DDSTools",
    ()=>DDSTools
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.scalar.functions.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/logger.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$HighDynamicRange$2f$cubemapToSphericalPolynomial$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/HighDynamicRange/cubemapToSphericalPolynomial.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/textureTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$AbstractEngine$2f$abstractEngine$2e$cubeTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.cubeTexture.js [app-ssr] (ecmascript)");
;
;
;
;
;
// Based on demo done by Brandon Jones - http://media.tojicode.com/webgl-samples/dds.html
// All values and structures referenced from:
// http://msdn.microsoft.com/en-us/library/bb943991.aspx/
const DDS_MAGIC = 0x20534444;
const //DDSD_HEIGHT = 0x2,
//DDSD_WIDTH = 0x4,
//DDSD_PITCH = 0x8,
//DDSD_PIXELFORMAT = 0x1000,
DDSD_MIPMAPCOUNT = 0x20000;
//DDSD_LINEARSIZE = 0x80000,
//DDSD_DEPTH = 0x800000;
// var DDSCAPS_COMPLEX = 0x8,
//     DDSCAPS_MIPMAP = 0x400000,
//     DDSCAPS_TEXTURE = 0x1000;
const DDSCAPS2_CUBEMAP = 0x200;
// DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,
// DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,
// DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,
// DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,
// DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,
// DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,
// DDSCAPS2_VOLUME = 0x200000;
const //DDPF_ALPHA = 0x2,
DDPF_FOURCC = 0x4, DDPF_RGB = 0x40, //DDPF_YUV = 0x200,
DDPF_LUMINANCE = 0x20000;
function FourCCToInt32(value) {
    return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);
}
function Int32ToFourCC(value) {
    return String.fromCharCode(value & 0xff, value >> 8 & 0xff, value >> 16 & 0xff, value >> 24 & 0xff);
}
const FOURCC_DXT1 = FourCCToInt32("DXT1");
const FOURCC_DXT3 = FourCCToInt32("DXT3");
const FOURCC_DXT5 = FourCCToInt32("DXT5");
const FOURCC_DX10 = FourCCToInt32("DX10");
const FOURCC_D3DFMT_R16G16B16A16F = 113;
const FOURCC_D3DFMT_R32G32B32A32F = 116;
const DXGI_FORMAT_R32G32B32A32_FLOAT = 2;
const DXGI_FORMAT_R16G16B16A16_FLOAT = 10;
const DXGI_FORMAT_B8G8R8X8_UNORM = 88;
const headerLengthInt = 31; // The header length in 32 bit ints
// Offsets into the header array
const off_magic = 0;
const off_size = 1;
const off_flags = 2;
const off_height = 3;
const off_width = 4;
const off_mipmapCount = 7;
const off_pfFlags = 20;
const off_pfFourCC = 21;
const off_RGBbpp = 22;
const off_RMask = 23;
const off_GMask = 24;
const off_BMask = 25;
const off_AMask = 26;
// var off_caps1 = 27;
const off_caps2 = 28;
// var off_caps3 = 29;
// var off_caps4 = 30;
const off_dxgiFormat = 32;
class DDSTools {
    /**
     * Gets DDS information from an array buffer
     * @param data defines the array buffer view to read data from
     * @returns the DDS information
     */ static GetDDSInfo(data) {
        const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);
        const extendedHeader = new Int32Array(data.buffer, data.byteOffset, headerLengthInt + 4);
        let mipmapCount = 1;
        if (header[off_flags] & DDSD_MIPMAPCOUNT) {
            mipmapCount = Math.max(1, header[off_mipmapCount]);
        }
        const fourCC = header[off_pfFourCC];
        const dxgiFormat = fourCC === FOURCC_DX10 ? extendedHeader[off_dxgiFormat] : 0;
        let textureType = 0;
        switch(fourCC){
            case FOURCC_D3DFMT_R16G16B16A16F:
                textureType = 2;
                break;
            case FOURCC_D3DFMT_R32G32B32A32F:
                textureType = 1;
                break;
            case FOURCC_DX10:
                if (dxgiFormat === DXGI_FORMAT_R16G16B16A16_FLOAT) {
                    textureType = 2;
                    break;
                }
                if (dxgiFormat === DXGI_FORMAT_R32G32B32A32_FLOAT) {
                    textureType = 1;
                    break;
                }
        }
        return {
            width: header[off_width],
            height: header[off_height],
            mipmapCount: mipmapCount,
            isFourCC: (header[off_pfFlags] & DDPF_FOURCC) === DDPF_FOURCC,
            isRGB: (header[off_pfFlags] & DDPF_RGB) === DDPF_RGB,
            isLuminance: (header[off_pfFlags] & DDPF_LUMINANCE) === DDPF_LUMINANCE,
            isCube: (header[off_caps2] & DDSCAPS2_CUBEMAP) === DDSCAPS2_CUBEMAP,
            isCompressed: fourCC === FOURCC_DXT1 || fourCC === FOURCC_DXT3 || fourCC === FOURCC_DXT5,
            dxgiFormat: dxgiFormat,
            textureType: textureType
        };
    }
    static _GetHalfFloatAsFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
        const destArray = new Float32Array(dataLength);
        const srcData = new Uint16Array(arrayBuffer, dataOffset);
        let index = 0;
        for(let y = 0; y < height; y++){
            for(let x = 0; x < width; x++){
                const srcPos = (x + y * width) * 4;
                destArray[index] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FromHalfFloat"])(srcData[srcPos]);
                destArray[index + 1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FromHalfFloat"])(srcData[srcPos + 1]);
                destArray[index + 2] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FromHalfFloat"])(srcData[srcPos + 2]);
                if (DDSTools.StoreLODInAlphaChannel) {
                    destArray[index + 3] = lod;
                } else {
                    destArray[index + 3] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FromHalfFloat"])(srcData[srcPos + 3]);
                }
                index += 4;
            }
        }
        return destArray;
    }
    static _GetHalfFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
        if (DDSTools.StoreLODInAlphaChannel) {
            const destArray = new Uint16Array(dataLength);
            const srcData = new Uint16Array(arrayBuffer, dataOffset);
            let index = 0;
            for(let y = 0; y < height; y++){
                for(let x = 0; x < width; x++){
                    const srcPos = (x + y * width) * 4;
                    destArray[index] = srcData[srcPos];
                    destArray[index + 1] = srcData[srcPos + 1];
                    destArray[index + 2] = srcData[srcPos + 2];
                    destArray[index + 3] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ToHalfFloat"])(lod);
                    index += 4;
                }
            }
            return destArray;
        }
        return new Uint16Array(arrayBuffer, dataOffset, dataLength);
    }
    static _GetFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
        if (DDSTools.StoreLODInAlphaChannel) {
            const destArray = new Float32Array(dataLength);
            const srcData = new Float32Array(arrayBuffer, dataOffset);
            let index = 0;
            for(let y = 0; y < height; y++){
                for(let x = 0; x < width; x++){
                    const srcPos = (x + y * width) * 4;
                    destArray[index] = srcData[srcPos];
                    destArray[index + 1] = srcData[srcPos + 1];
                    destArray[index + 2] = srcData[srcPos + 2];
                    destArray[index + 3] = lod;
                    index += 4;
                }
            }
            return destArray;
        }
        return new Float32Array(arrayBuffer, dataOffset, dataLength);
    }
    static _GetFloatAsHalfFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
        const destArray = new Uint16Array(dataLength);
        const srcData = new Float32Array(arrayBuffer, dataOffset);
        let index = 0;
        for(let y = 0; y < height; y++){
            for(let x = 0; x < width; x++){
                destArray[index] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ToHalfFloat"])(srcData[index]);
                destArray[index + 1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ToHalfFloat"])(srcData[index + 1]);
                destArray[index + 2] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ToHalfFloat"])(srcData[index + 2]);
                if (DDSTools.StoreLODInAlphaChannel) {
                    destArray[index + 3] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ToHalfFloat"])(lod);
                } else {
                    destArray[index + 3] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ToHalfFloat"])(srcData[index + 3]);
                }
                index += 4;
            }
        }
        return destArray;
    }
    static _GetFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
        const destArray = new Uint8Array(dataLength);
        const srcData = new Float32Array(arrayBuffer, dataOffset);
        let index = 0;
        for(let y = 0; y < height; y++){
            for(let x = 0; x < width; x++){
                const srcPos = (x + y * width) * 4;
                destArray[index] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Clamp"])(srcData[srcPos]) * 255;
                destArray[index + 1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Clamp"])(srcData[srcPos + 1]) * 255;
                destArray[index + 2] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Clamp"])(srcData[srcPos + 2]) * 255;
                if (DDSTools.StoreLODInAlphaChannel) {
                    destArray[index + 3] = lod;
                } else {
                    destArray[index + 3] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Clamp"])(srcData[srcPos + 3]) * 255;
                }
                index += 4;
            }
        }
        return destArray;
    }
    static _GetHalfFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
        const destArray = new Uint8Array(dataLength);
        const srcData = new Uint16Array(arrayBuffer, dataOffset);
        let index = 0;
        for(let y = 0; y < height; y++){
            for(let x = 0; x < width; x++){
                const srcPos = (x + y * width) * 4;
                destArray[index] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Clamp"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FromHalfFloat"])(srcData[srcPos])) * 255;
                destArray[index + 1] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Clamp"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FromHalfFloat"])(srcData[srcPos + 1])) * 255;
                destArray[index + 2] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Clamp"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FromHalfFloat"])(srcData[srcPos + 2])) * 255;
                if (DDSTools.StoreLODInAlphaChannel) {
                    destArray[index + 3] = lod;
                } else {
                    destArray[index + 3] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$scalar$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Clamp"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FromHalfFloat"])(srcData[srcPos + 3])) * 255;
                }
                index += 4;
            }
        }
        return destArray;
    }
    static _GetRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset, aOffset) {
        const byteArray = new Uint8Array(dataLength);
        const srcData = new Uint8Array(arrayBuffer, dataOffset);
        let index = 0;
        for(let y = 0; y < height; y++){
            for(let x = 0; x < width; x++){
                const srcPos = (x + y * width) * 4;
                byteArray[index] = srcData[srcPos + rOffset];
                byteArray[index + 1] = srcData[srcPos + gOffset];
                byteArray[index + 2] = srcData[srcPos + bOffset];
                byteArray[index + 3] = srcData[srcPos + aOffset];
                index += 4;
            }
        }
        return byteArray;
    }
    static _ExtractLongWordOrder(value) {
        if (value === 0 || value === 255 || value === -16777216) {
            return 0;
        }
        return 1 + DDSTools._ExtractLongWordOrder(value >> 8);
    }
    static _GetRGBArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset) {
        const byteArray = new Uint8Array(dataLength);
        const srcData = new Uint8Array(arrayBuffer, dataOffset);
        let index = 0;
        for(let y = 0; y < height; y++){
            for(let x = 0; x < width; x++){
                const srcPos = (x + y * width) * 3;
                byteArray[index] = srcData[srcPos + rOffset];
                byteArray[index + 1] = srcData[srcPos + gOffset];
                byteArray[index + 2] = srcData[srcPos + bOffset];
                index += 3;
            }
        }
        return byteArray;
    }
    static _GetLuminanceArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer) {
        const byteArray = new Uint8Array(dataLength);
        const srcData = new Uint8Array(arrayBuffer, dataOffset);
        let index = 0;
        for(let y = 0; y < height; y++){
            for(let x = 0; x < width; x++){
                const srcPos = x + y * width;
                byteArray[index] = srcData[srcPos];
                index++;
            }
        }
        return byteArray;
    }
    /**
     * Uploads DDS Levels to a Babylon Texture
     * @internal
     */ static UploadDDSLevels(engine, texture, data, info, loadMipmaps, faces, lodIndex = -1, currentFace, destTypeMustBeFilterable = true) {
        let sphericalPolynomialFaces = null;
        if (info.sphericalPolynomial) {
            sphericalPolynomialFaces = [];
        }
        const ext = !!engine.getCaps().s3tc;
        // TODO WEBGPU Once generateMipMaps is split into generateMipMaps + hasMipMaps in InternalTexture this line can be removed
        texture.generateMipMaps = loadMipmaps;
        const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);
        let fourCC, width, height, dataLength = 0, dataOffset;
        let byteArray, mipmapCount, mip;
        let internalCompressedFormat = 0;
        let blockBytes = 1;
        if (header[off_magic] !== DDS_MAGIC) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Error("Invalid magic number in DDS header");
            return;
        }
        if (!info.isFourCC && !info.isRGB && !info.isLuminance) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");
            return;
        }
        if (info.isCompressed && !ext) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Error("Compressed textures are not supported on this platform.");
            return;
        }
        let bpp = header[off_RGBbpp];
        dataOffset = header[off_size] + 4;
        let computeFormats = false;
        if (info.isFourCC) {
            fourCC = header[off_pfFourCC];
            switch(fourCC){
                case FOURCC_DXT1:
                    blockBytes = 8;
                    internalCompressedFormat = 33777;
                    break;
                case FOURCC_DXT3:
                    blockBytes = 16;
                    internalCompressedFormat = 33778;
                    break;
                case FOURCC_DXT5:
                    blockBytes = 16;
                    internalCompressedFormat = 33779;
                    break;
                case FOURCC_D3DFMT_R16G16B16A16F:
                    computeFormats = true;
                    bpp = 64;
                    break;
                case FOURCC_D3DFMT_R32G32B32A32F:
                    computeFormats = true;
                    bpp = 128;
                    break;
                case FOURCC_DX10:
                    {
                        // There is an additionnal header so dataOffset need to be changed
                        dataOffset += 5 * 4; // 5 uints
                        let supported = false;
                        switch(info.dxgiFormat){
                            case DXGI_FORMAT_R16G16B16A16_FLOAT:
                                computeFormats = true;
                                bpp = 64;
                                supported = true;
                                break;
                            case DXGI_FORMAT_R32G32B32A32_FLOAT:
                                computeFormats = true;
                                bpp = 128;
                                supported = true;
                                break;
                            case DXGI_FORMAT_B8G8R8X8_UNORM:
                                info.isRGB = true;
                                info.isFourCC = false;
                                bpp = 32;
                                supported = true;
                                break;
                        }
                        if (supported) {
                            break;
                        }
                    }
                // eslint-disable-next-line no-fallthrough
                default:
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Error([
                        "Unsupported FourCC code:",
                        Int32ToFourCC(fourCC)
                    ]);
                    return;
            }
        }
        const rOffset = DDSTools._ExtractLongWordOrder(header[off_RMask]);
        const gOffset = DDSTools._ExtractLongWordOrder(header[off_GMask]);
        const bOffset = DDSTools._ExtractLongWordOrder(header[off_BMask]);
        const aOffset = DDSTools._ExtractLongWordOrder(header[off_AMask]);
        if (computeFormats) {
            internalCompressedFormat = engine._getRGBABufferInternalSizedFormat(info.textureType);
        }
        mipmapCount = 1;
        if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {
            mipmapCount = Math.max(1, header[off_mipmapCount]);
        }
        const startFace = currentFace || 0;
        const caps = engine.getCaps();
        for(let face = startFace; face < faces; face++){
            width = header[off_width];
            height = header[off_height];
            for(mip = 0; mip < mipmapCount; ++mip){
                if (lodIndex === -1 || lodIndex === mip) {
                    // In case of fixed LOD, if the lod has just been uploaded, early exit.
                    const i = lodIndex === -1 ? mip : 0;
                    if (!info.isCompressed && info.isFourCC) {
                        texture.format = 5;
                        dataLength = width * height * 4;
                        let floatArray = null;
                        if (engine._badOS || engine._badDesktopOS || !caps.textureHalfFloat && !caps.textureFloat) {
                            // Required because iOS has many issues with float and half float generation
                            if (bpp === 128) {
                                floatArray = DDSTools._GetFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);
                                if (sphericalPolynomialFaces && i == 0) {
                                    sphericalPolynomialFaces.push(DDSTools._GetFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));
                                }
                            } else if (bpp === 64) {
                                floatArray = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);
                                if (sphericalPolynomialFaces && i == 0) {
                                    sphericalPolynomialFaces.push(DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));
                                }
                            }
                            texture.type = 0;
                        } else {
                            const floatAvailable = caps.textureFloat && (destTypeMustBeFilterable && caps.textureFloatLinearFiltering || !destTypeMustBeFilterable);
                            const halfFloatAvailable = caps.textureHalfFloat && (destTypeMustBeFilterable && caps.textureHalfFloatLinearFiltering || !destTypeMustBeFilterable);
                            const destType = (bpp === 128 || bpp === 64 && !halfFloatAvailable) && floatAvailable ? 1 : (bpp === 64 || bpp === 128 && !floatAvailable) && halfFloatAvailable ? 2 : 0;
                            let dataGetter;
                            let dataGetterPolynomial = null;
                            switch(bpp){
                                case 128:
                                    {
                                        switch(destType){
                                            case 1:
                                                dataGetter = DDSTools._GetFloatRGBAArrayBuffer;
                                                dataGetterPolynomial = null;
                                                break;
                                            case 2:
                                                dataGetter = DDSTools._GetFloatAsHalfFloatRGBAArrayBuffer;
                                                dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;
                                                break;
                                            case 0:
                                                dataGetter = DDSTools._GetFloatAsUIntRGBAArrayBuffer;
                                                dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;
                                                break;
                                        }
                                        break;
                                    }
                                default:
                                    {
                                        // 64 bpp
                                        switch(destType){
                                            case 1:
                                                dataGetter = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;
                                                dataGetterPolynomial = null;
                                                break;
                                            case 2:
                                                dataGetter = DDSTools._GetHalfFloatRGBAArrayBuffer;
                                                dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;
                                                break;
                                            case 0:
                                                dataGetter = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer;
                                                dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;
                                                break;
                                        }
                                        break;
                                    }
                            }
                            texture.type = destType;
                            floatArray = dataGetter(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);
                            if (sphericalPolynomialFaces && i == 0) {
                                sphericalPolynomialFaces.push(dataGetterPolynomial ? dataGetterPolynomial(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i) : floatArray);
                            }
                        }
                        if (floatArray) {
                            engine._uploadDataToTextureDirectly(texture, floatArray, face, i);
                        }
                    } else if (info.isRGB) {
                        texture.type = 0;
                        if (bpp === 24) {
                            texture.format = 4;
                            dataLength = width * height * 3;
                            byteArray = DDSTools._GetRGBArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset);
                            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);
                        } else {
                            // 32
                            texture.format = 5;
                            dataLength = width * height * 4;
                            byteArray = DDSTools._GetRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset, aOffset);
                            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);
                        }
                    } else if (info.isLuminance) {
                        const unpackAlignment = engine._getUnpackAlignement();
                        const unpaddedRowSize = width;
                        const paddedRowSize = Math.floor((width + unpackAlignment - 1) / unpackAlignment) * unpackAlignment;
                        dataLength = paddedRowSize * (height - 1) + unpaddedRowSize;
                        byteArray = DDSTools._GetLuminanceArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer);
                        texture.format = 1;
                        texture.type = 0;
                        engine._uploadDataToTextureDirectly(texture, byteArray, face, i);
                    } else {
                        dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;
                        byteArray = new Uint8Array(data.buffer, data.byteOffset + dataOffset, dataLength);
                        texture.type = 0;
                        engine._uploadCompressedDataToTextureDirectly(texture, internalCompressedFormat, width, height, byteArray, face, i);
                    }
                }
                dataOffset += bpp ? width * height * (bpp / 8) : dataLength;
                width *= 0.5;
                height *= 0.5;
                width = Math.max(1.0, width);
                height = Math.max(1.0, height);
            }
            if (currentFace !== undefined) {
                break;
            }
        }
        if (sphericalPolynomialFaces && sphericalPolynomialFaces.length > 0) {
            info.sphericalPolynomial = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$HighDynamicRange$2f$cubemapToSphericalPolynomial$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CubeMapToSphericalPolynomialTools"].ConvertCubeMapToSphericalPolynomial({
                size: header[off_width],
                right: sphericalPolynomialFaces[0],
                left: sphericalPolynomialFaces[1],
                up: sphericalPolynomialFaces[2],
                down: sphericalPolynomialFaces[3],
                front: sphericalPolynomialFaces[4],
                back: sphericalPolynomialFaces[5],
                format: 5,
                type: 1,
                gammaSpace: false
            });
        } else {
            info.sphericalPolynomial = undefined;
        }
    }
}
/**
 * Gets or sets a boolean indicating that LOD info is stored in alpha channel (false by default)
 */ DDSTools.StoreLODInAlphaChannel = false; //# sourceMappingURL=dds.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/khronosTextureContainer.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint-disable @typescript-eslint/naming-convention */ __turbopack_context__.s([
    "KhronosTextureContainer",
    ()=>KhronosTextureContainer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/logger.js [app-ssr] (ecmascript)");
;
class KhronosTextureContainer {
    /**
     * Creates a new KhronosTextureContainer
     * @param data contents of the KTX container file
     * @param facesExpected should be either 1 or 6, based whether a cube texture or or
     */ constructor(/** contents of the KTX container file */ data, facesExpected){
        this.data = data;
        /**
         * If the container has been made invalid (eg. constructor failed to correctly load array buffer)
         */ this.isInvalid = false;
        if (!KhronosTextureContainer.IsValid(data)) {
            this.isInvalid = true;
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Error("texture missing KTX identifier");
            return;
        }
        // load the reset of the header in native 32 bit uint
        const dataSize = Uint32Array.BYTES_PER_ELEMENT;
        const headerDataView = new DataView(this.data.buffer, this.data.byteOffset + 12, 13 * dataSize);
        const endianness = headerDataView.getUint32(0, true);
        const littleEndian = endianness === 0x04030201;
        this.glType = headerDataView.getUint32(1 * dataSize, littleEndian); // must be 0 for compressed textures
        this.glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian); // must be 1 for compressed textures
        this.glFormat = headerDataView.getUint32(3 * dataSize, littleEndian); // must be 0 for compressed textures
        this.glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian); // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)
        this.glBaseInternalFormat = headerDataView.getUint32(5 * dataSize, littleEndian); // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)
        this.pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)
        this.pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)
        this.pixelDepth = headerDataView.getUint32(8 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)
        this.numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian); // used for texture arrays
        this.numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian); // used for cubemap textures, should either be 1 or 6
        this.numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian); // number of levels; disregard possibility of 0 for compressed textures
        this.bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian); // the amount of space after the header for meta-data
        // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.
        if (this.glType !== 0) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Error("only compressed formats currently supported");
            this.isInvalid = true;
            return;
        } else {
            // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.
            this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels);
        }
        if (this.pixelHeight === 0 || this.pixelDepth !== 0) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Error("only 2D textures currently supported");
            this.isInvalid = true;
            return;
        }
        if (this.numberOfArrayElements !== 0) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Error("texture arrays not currently supported");
            this.isInvalid = true;
            return;
        }
        if (this.numberOfFaces !== facesExpected) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Error("number of faces expected" + facesExpected + ", but found " + this.numberOfFaces);
            this.isInvalid = true;
            return;
        }
        // we now have a completely validated file, so could use existence of loadType as success
        // would need to make this more elaborate & adjust checks above to support more than one load type
        this.loadType = KhronosTextureContainer.COMPRESSED_2D;
    }
    /**
     * Uploads KTX content to a Babylon Texture.
     * It is assumed that the texture has already been created & is currently bound
     * @internal
     */ uploadLevels(texture, loadMipmaps) {
        switch(this.loadType){
            case KhronosTextureContainer.COMPRESSED_2D:
                this._upload2DCompressedLevels(texture, loadMipmaps);
                break;
            case KhronosTextureContainer.TEX_2D:
            case KhronosTextureContainer.COMPRESSED_3D:
            case KhronosTextureContainer.TEX_3D:
        }
    }
    _upload2DCompressedLevels(texture, loadMipmaps) {
        // initialize width & height for level 1
        let dataOffset = KhronosTextureContainer.HEADER_LEN + this.bytesOfKeyValueData;
        let width = this.pixelWidth;
        let height = this.pixelHeight;
        const mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;
        for(let level = 0; level < mipmapCount; level++){
            const imageSize = new Int32Array(this.data.buffer, this.data.byteOffset + dataOffset, 1)[0]; // size per face, since not supporting array cubemaps
            dataOffset += 4; //image data starts from next multiple of 4 offset. Each face refers to same imagesize field above.
            for(let face = 0; face < this.numberOfFaces; face++){
                const byteArray = new Uint8Array(this.data.buffer, this.data.byteOffset + dataOffset, imageSize);
                const engine = texture.getEngine();
                engine._uploadCompressedDataToTextureDirectly(texture, texture.format, width, height, byteArray, face, level);
                dataOffset += imageSize; // add size of the image for the next face/mipmap
                dataOffset += 3 - (imageSize + 3) % 4; // add padding for odd sized image
            }
            width = Math.max(1.0, width * 0.5);
            height = Math.max(1.0, height * 0.5);
        }
    }
    /**
     * Checks if the given data starts with a KTX file identifier.
     * @param data the data to check
     * @returns true if the data is a KTX file or false otherwise
     */ static IsValid(data) {
        if (data.byteLength >= 12) {
            // '', 'K', 'T', 'X', ' ', '1', '1', '', '\r', '\n', '\x1A', '\n'
            const identifier = new Uint8Array(data.buffer, data.byteOffset, 12);
            if (identifier[0] === 0xab && identifier[1] === 0x4b && identifier[2] === 0x54 && identifier[3] === 0x58 && identifier[4] === 0x20 && identifier[5] === 0x31 && identifier[6] === 0x31 && identifier[7] === 0xbb && identifier[8] === 0x0d && identifier[9] === 0x0a && identifier[10] === 0x1a && identifier[11] === 0x0a) {
                return true;
            }
        }
        return false;
    }
}
KhronosTextureContainer.HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)
// load types
KhronosTextureContainer.COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()
KhronosTextureContainer.COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()
KhronosTextureContainer.TEX_2D = 2; // uses a gl.texImage2D()
KhronosTextureContainer.TEX_3D = 3; // uses a gl.texImage3D()
 //# sourceMappingURL=khronosTextureContainer.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/workerPool.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Helper class to push actions to a pool of workers.
 */ __turbopack_context__.s([
    "AutoReleaseWorkerPool",
    ()=>AutoReleaseWorkerPool,
    "WorkerPool",
    ()=>WorkerPool
]);
class WorkerPool {
    /**
     * Constructor
     * @param workers Array of workers to use for actions
     */ constructor(workers){
        this._pendingActions = new Array();
        this._workerInfos = workers.map((worker)=>({
                workerPromise: Promise.resolve(worker),
                idle: true
            }));
    }
    /**
     * Terminates all workers and clears any pending actions.
     */ dispose() {
        for (const workerInfo of this._workerInfos){
            // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then
            workerInfo.workerPromise.then((worker)=>{
                worker.terminate();
            });
        }
        this._workerInfos.length = 0;
        this._pendingActions.length = 0;
    }
    /**
     * Pushes an action to the worker pool. If all the workers are active, the action will be
     * pended until a worker has completed its action.
     * @param action The action to perform. Call onComplete when the action is complete.
     */ push(action) {
        if (!this._executeOnIdleWorker(action)) {
            this._pendingActions.push(action);
        }
    }
    _executeOnIdleWorker(action) {
        for (const workerInfo of this._workerInfos){
            if (workerInfo.idle) {
                this._execute(workerInfo, action);
                return true;
            }
        }
        return false;
    }
    _execute(workerInfo, action) {
        workerInfo.idle = false;
        // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then
        workerInfo.workerPromise.then((worker)=>{
            action(worker, ()=>{
                const nextAction = this._pendingActions.shift();
                if (nextAction) {
                    this._execute(workerInfo, nextAction);
                } else {
                    workerInfo.idle = true;
                }
            });
        });
    }
}
class AutoReleaseWorkerPool extends WorkerPool {
    constructor(maxWorkers, createWorkerAsync, options = AutoReleaseWorkerPool.DefaultOptions){
        super([]);
        this._maxWorkers = maxWorkers;
        this._createWorkerAsync = createWorkerAsync;
        this._options = options;
    }
    push(action) {
        if (!this._executeOnIdleWorker(action)) {
            if (this._workerInfos.length < this._maxWorkers) {
                const workerInfo = {
                    workerPromise: this._createWorkerAsync(),
                    idle: false
                };
                this._workerInfos.push(workerInfo);
                this._execute(workerInfo, action);
            } else {
                this._pendingActions.push(action);
            }
        }
    }
    _execute(workerInfo, action) {
        // Reset the idle timeout.
        if (workerInfo.timeoutId) {
            clearTimeout(workerInfo.timeoutId);
            delete workerInfo.timeoutId;
        }
        super._execute(workerInfo, (worker, onComplete)=>{
            action(worker, ()=>{
                onComplete();
                if (workerInfo.idle) {
                    // Schedule the worker to be terminated after the elapsed time.
                    workerInfo.timeoutId = setTimeout(()=>{
                        // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then
                        workerInfo.workerPromise.then((worker)=>{
                            worker.terminate();
                        });
                        const indexOf = this._workerInfos.indexOf(workerInfo);
                        if (indexOf !== -1) {
                            this._workerInfos.splice(indexOf, 1);
                        }
                    }, this._options.idleTimeElapsedBeforeRelease);
                }
            });
        });
    }
}
/**
 * Default options for the constructor.
 * Override to change the defaults.
 */ AutoReleaseWorkerPool.DefaultOptions = {
    idleTimeElapsedBeforeRelease: 1000
}; //# sourceMappingURL=workerPool.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/khronosTextureContainer2Worker.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "applyConfig",
    ()=>applyConfig,
    "initializeWebWorker",
    ()=>initializeWebWorker,
    "workerFunction",
    ()=>workerFunction
]);
function applyConfig(urls, binariesAndModulesContainer) {
    const KTX2DecoderModule = binariesAndModulesContainer?.jsDecoderModule || KTX2DECODER;
    if (urls) {
        if (urls.wasmBaseUrl) {
            KTX2DecoderModule.Transcoder.WasmBaseUrl = urls.wasmBaseUrl;
        }
        if (urls.wasmUASTCToASTC) {
            KTX2DecoderModule.LiteTranscoder_UASTC_ASTC.WasmModuleURL = urls.wasmUASTCToASTC;
        }
        if (urls.wasmUASTCToBC7) {
            KTX2DecoderModule.LiteTranscoder_UASTC_BC7.WasmModuleURL = urls.wasmUASTCToBC7;
        }
        if (urls.wasmUASTCToRGBA_UNORM) {
            KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_UNORM.WasmModuleURL = urls.wasmUASTCToRGBA_UNORM;
        }
        if (urls.wasmUASTCToRGBA_SRGB) {
            KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_SRGB.WasmModuleURL = urls.wasmUASTCToRGBA_SRGB;
        }
        if (urls.wasmUASTCToR8_UNORM) {
            KTX2DecoderModule.LiteTranscoder_UASTC_R8_UNORM.WasmModuleURL = urls.wasmUASTCToR8_UNORM;
        }
        if (urls.wasmUASTCToRG8_UNORM) {
            KTX2DecoderModule.LiteTranscoder_UASTC_RG8_UNORM.WasmModuleURL = urls.wasmUASTCToRG8_UNORM;
        }
        if (urls.jsMSCTranscoder) {
            KTX2DecoderModule.MSCTranscoder.JSModuleURL = urls.jsMSCTranscoder;
        }
        if (urls.wasmMSCTranscoder) {
            KTX2DecoderModule.MSCTranscoder.WasmModuleURL = urls.wasmMSCTranscoder;
        }
        if (urls.wasmZSTDDecoder) {
            KTX2DecoderModule.ZSTDDecoder.WasmModuleURL = urls.wasmZSTDDecoder;
        }
    }
    if (binariesAndModulesContainer) {
        if (binariesAndModulesContainer.wasmUASTCToASTC) {
            KTX2DecoderModule.LiteTranscoder_UASTC_ASTC.WasmBinary = binariesAndModulesContainer.wasmUASTCToASTC;
        }
        if (binariesAndModulesContainer.wasmUASTCToBC7) {
            KTX2DecoderModule.LiteTranscoder_UASTC_BC7.WasmBinary = binariesAndModulesContainer.wasmUASTCToBC7;
        }
        if (binariesAndModulesContainer.wasmUASTCToRGBA_UNORM) {
            KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_UNORM.WasmBinary = binariesAndModulesContainer.wasmUASTCToRGBA_UNORM;
        }
        if (binariesAndModulesContainer.wasmUASTCToRGBA_SRGB) {
            KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_SRGB.WasmBinary = binariesAndModulesContainer.wasmUASTCToRGBA_SRGB;
        }
        if (binariesAndModulesContainer.wasmUASTCToR8_UNORM) {
            KTX2DecoderModule.LiteTranscoder_UASTC_R8_UNORM.WasmBinary = binariesAndModulesContainer.wasmUASTCToR8_UNORM;
        }
        if (binariesAndModulesContainer.wasmUASTCToRG8_UNORM) {
            KTX2DecoderModule.LiteTranscoder_UASTC_RG8_UNORM.WasmBinary = binariesAndModulesContainer.wasmUASTCToRG8_UNORM;
        }
        if (binariesAndModulesContainer.jsMSCTranscoder) {
            KTX2DecoderModule.MSCTranscoder.JSModule = binariesAndModulesContainer.jsMSCTranscoder;
        }
        if (binariesAndModulesContainer.wasmMSCTranscoder) {
            KTX2DecoderModule.MSCTranscoder.WasmBinary = binariesAndModulesContainer.wasmMSCTranscoder;
        }
        if (binariesAndModulesContainer.wasmZSTDDecoder) {
            KTX2DecoderModule.ZSTDDecoder.WasmBinary = binariesAndModulesContainer.wasmZSTDDecoder;
        }
    }
}
function workerFunction(KTX2DecoderModule) {
    if (typeof KTX2DecoderModule === "undefined" && typeof KTX2DECODER !== "undefined") {
        KTX2DecoderModule = KTX2DECODER;
    }
    let ktx2Decoder;
    onmessage = (event)=>{
        if (!event.data) {
            return;
        }
        switch(event.data.action){
            case "init":
                {
                    const urls = event.data.urls;
                    if (urls) {
                        if (urls.jsDecoderModule && typeof KTX2DecoderModule === "undefined") {
                            importScripts(urls.jsDecoderModule);
                            // assuming global namespace populated by the script (UMD pattern)
                            KTX2DecoderModule = KTX2DECODER;
                        }
                        applyConfig(urls);
                    }
                    if (event.data.wasmBinaries) {
                        applyConfig(undefined, {
                            ...event.data.wasmBinaries,
                            jsDecoderModule: KTX2DecoderModule
                        });
                    }
                    ktx2Decoder = new KTX2DecoderModule.KTX2Decoder();
                    postMessage({
                        action: "init"
                    });
                    break;
                }
            case "setDefaultDecoderOptions":
                {
                    KTX2DecoderModule.KTX2Decoder.DefaultDecoderOptions = event.data.options;
                    break;
                }
            case "decode":
                ktx2Decoder.decode(event.data.data, event.data.caps, event.data.options)// eslint-disable-next-line github/no-then
                .then((data)=>{
                    const buffers = [];
                    for(let mip = 0; mip < data.mipmaps.length; ++mip){
                        const mipmap = data.mipmaps[mip];
                        if (mipmap && mipmap.data) {
                            buffers.push(mipmap.data.buffer);
                        }
                    }
                    postMessage({
                        action: "decoded",
                        success: true,
                        decodedData: data
                    }, buffers);
                })// eslint-disable-next-line github/no-then
                .catch((reason)=>{
                    postMessage({
                        action: "decoded",
                        success: false,
                        msg: reason
                    });
                });
                break;
        }
    };
}
async function initializeWebWorker(worker, wasmBinaries, urls) {
    return await new Promise((resolve, reject)=>{
        const onError = (error)=>{
            worker.removeEventListener("error", onError);
            worker.removeEventListener("message", onMessage);
            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
            reject(error);
        };
        const onMessage = (message)=>{
            if (message.data.action === "init") {
                worker.removeEventListener("error", onError);
                worker.removeEventListener("message", onMessage);
                resolve(worker);
            }
        };
        worker.addEventListener("error", onError);
        worker.addEventListener("message", onMessage);
        worker.postMessage({
            action: "init",
            urls,
            wasmBinaries
        });
    });
} //# sourceMappingURL=khronosTextureContainer2Worker.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/khronosTextureContainer2.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DefaultKTX2DecoderOptions",
    ()=>DefaultKTX2DecoderOptions,
    "KhronosTextureContainer2",
    ()=>KhronosTextureContainer2
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$workerPool$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/workerPool.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$ktx2decoderTypes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/Textures/ktx2decoderTypes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$khronosTextureContainer2Worker$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/khronosTextureContainer2Worker.js [app-ssr] (ecmascript)");
;
;
;
;
class DefaultKTX2DecoderOptions {
    constructor(){
        this._isDirty = true;
        this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC = true;
        this._ktx2DecoderOptions = {};
    }
    /**
     * Gets the dirty flag
     */ get isDirty() {
        return this._isDirty;
    }
    /**
     * force a (uncompressed) RGBA transcoded format if transcoding a UASTC source format and ASTC + BC7 are not available as a compressed transcoded format
     */ get useRGBAIfASTCBC7NotAvailableWhenUASTC() {
        return this._useRGBAIfASTCBC7NotAvailableWhenUASTC;
    }
    set useRGBAIfASTCBC7NotAvailableWhenUASTC(value) {
        if (this._useRGBAIfASTCBC7NotAvailableWhenUASTC === value) {
            return;
        }
        this._useRGBAIfASTCBC7NotAvailableWhenUASTC = value;
        this._isDirty = true;
    }
    /**
     * force a (uncompressed) RGBA transcoded format if transcoding a UASTC source format and only BC1 or BC3 are available as a compressed transcoded format.
     * This property is true by default to favor speed over memory, because currently transcoding from UASTC to BC1/3 is slow because the transcoder transcodes
     * to uncompressed and then recompresses the texture
     */ get useRGBAIfOnlyBC1BC3AvailableWhenUASTC() {
        return this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC;
    }
    set useRGBAIfOnlyBC1BC3AvailableWhenUASTC(value) {
        if (this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC === value) {
            return;
        }
        this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC = value;
        this._isDirty = true;
    }
    /**
     * force to always use (uncompressed) RGBA for transcoded format
     */ get forceRGBA() {
        return this._forceRGBA;
    }
    set forceRGBA(value) {
        if (this._forceRGBA === value) {
            return;
        }
        this._forceRGBA = value;
        this._isDirty = true;
    }
    /**
     * force to always use (uncompressed) R8 for transcoded format
     */ get forceR8() {
        return this._forceR8;
    }
    set forceR8(value) {
        if (this._forceR8 === value) {
            return;
        }
        this._forceR8 = value;
        this._isDirty = true;
    }
    /**
     * force to always use (uncompressed) RG8 for transcoded format
     */ get forceRG8() {
        return this._forceRG8;
    }
    set forceRG8(value) {
        if (this._forceRG8 === value) {
            return;
        }
        this._forceRG8 = value;
        this._isDirty = true;
    }
    /**
     * list of transcoders to bypass when looking for a suitable transcoder. The available transcoders are:
     *      UniversalTranscoder_UASTC_ASTC
     *      UniversalTranscoder_UASTC_BC7
     *      UniversalTranscoder_UASTC_RGBA_UNORM
     *      UniversalTranscoder_UASTC_RGBA_SRGB
     *      UniversalTranscoder_UASTC_R8_UNORM
     *      UniversalTranscoder_UASTC_RG8_UNORM
     *      MSCTranscoder
     */ get bypassTranscoders() {
        return this._bypassTranscoders;
    }
    set bypassTranscoders(value) {
        if (this._bypassTranscoders === value) {
            return;
        }
        this._bypassTranscoders = value;
        this._isDirty = true;
    }
    /** @internal */ _getKTX2DecoderOptions() {
        if (!this._isDirty) {
            return this._ktx2DecoderOptions;
        }
        this._isDirty = false;
        const options = {};
        if (this._useRGBAIfASTCBC7NotAvailableWhenUASTC !== undefined) {
            options.useRGBAIfASTCBC7NotAvailableWhenUASTC = this._useRGBAIfASTCBC7NotAvailableWhenUASTC;
        }
        if (this._forceRGBA !== undefined) {
            options.forceRGBA = this._forceRGBA;
        }
        if (this._forceR8 !== undefined) {
            options.forceR8 = this._forceR8;
        }
        if (this._forceRG8 !== undefined) {
            options.forceRG8 = this._forceRG8;
        }
        if (this._bypassTranscoders !== undefined) {
            options.bypassTranscoders = this._bypassTranscoders;
        }
        if (this.useRGBAIfOnlyBC1BC3AvailableWhenUASTC) {
            options.transcodeFormatDecisionTree = {
                UASTC: {
                    transcodeFormat: [
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$ktx2decoderTypes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TranscodeTarget"].BC1_RGB,
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$ktx2decoderTypes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TranscodeTarget"].BC3_RGBA
                    ],
                    yes: {
                        transcodeFormat: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$ktx2decoderTypes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TranscodeTarget"].RGBA32,
                        engineFormat: 32856 /* EngineFormat.RGBA8Format */ ,
                        roundToMultiple4: false
                    }
                }
            };
        }
        this._ktx2DecoderOptions = options;
        return options;
    }
}
class KhronosTextureContainer2 {
    static GetDefaultNumWorkers() {
        if (typeof navigator !== "object" || !navigator.hardwareConcurrency) {
            return 1;
        }
        // Use 50% of the available logical processors but capped at 4.
        return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);
    }
    static _Initialize(numWorkers) {
        if (KhronosTextureContainer2._WorkerPoolPromise || KhronosTextureContainer2._DecoderModulePromise) {
            return;
        }
        const urls = {
            wasmBaseUrl: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].ScriptBaseUrl,
            jsDecoderModule: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].GetBabylonScriptURL(this.URLConfig.jsDecoderModule, true),
            wasmUASTCToASTC: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].GetBabylonScriptURL(this.URLConfig.wasmUASTCToASTC, true),
            wasmUASTCToBC7: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].GetBabylonScriptURL(this.URLConfig.wasmUASTCToBC7, true),
            wasmUASTCToRGBA_UNORM: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].GetBabylonScriptURL(this.URLConfig.wasmUASTCToRGBA_UNORM, true),
            wasmUASTCToRGBA_SRGB: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].GetBabylonScriptURL(this.URLConfig.wasmUASTCToRGBA_SRGB, true),
            wasmUASTCToR8_UNORM: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].GetBabylonScriptURL(this.URLConfig.wasmUASTCToR8_UNORM, true),
            wasmUASTCToRG8_UNORM: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].GetBabylonScriptURL(this.URLConfig.wasmUASTCToRG8_UNORM, true),
            jsMSCTranscoder: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].GetBabylonScriptURL(this.URLConfig.jsMSCTranscoder, true),
            wasmMSCTranscoder: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].GetBabylonScriptURL(this.URLConfig.wasmMSCTranscoder, true),
            wasmZSTDDecoder: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].GetBabylonScriptURL(this.URLConfig.wasmZSTDDecoder, true)
        };
        if (numWorkers && typeof Worker === "function" && typeof URL !== "undefined") {
            KhronosTextureContainer2._WorkerPoolPromise = new Promise((resolve)=>{
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                const workerContent = `${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$khronosTextureContainer2Worker$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["applyConfig"]}(${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$khronosTextureContainer2Worker$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["workerFunction"]})()`;
                const workerBlobUrl = URL.createObjectURL(new Blob([
                    workerContent
                ], {
                    type: "application/javascript"
                }));
                resolve(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$workerPool$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AutoReleaseWorkerPool"](numWorkers, async ()=>await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$khronosTextureContainer2Worker$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["initializeWebWorker"])(new Worker(workerBlobUrl), undefined, urls)));
            });
        } else {
            if (typeof KhronosTextureContainer2._KTX2DecoderModule === "undefined") {
                // eslint-disable-next-line github/no-then
                KhronosTextureContainer2._DecoderModulePromise = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].LoadBabylonScriptAsync(urls.jsDecoderModule).then(()=>{
                    KhronosTextureContainer2._KTX2DecoderModule = KTX2DECODER;
                    KhronosTextureContainer2._KTX2DecoderModule.MSCTranscoder.UseFromWorkerThread = false;
                    KhronosTextureContainer2._KTX2DecoderModule.WASMMemoryManager.LoadBinariesFromCurrentThread = true;
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$khronosTextureContainer2Worker$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["applyConfig"])(urls, KhronosTextureContainer2._KTX2DecoderModule);
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                    return new KhronosTextureContainer2._KTX2DecoderModule.KTX2Decoder();
                });
            } else {
                KhronosTextureContainer2._KTX2DecoderModule.MSCTranscoder.UseFromWorkerThread = false;
                KhronosTextureContainer2._KTX2DecoderModule.WASMMemoryManager.LoadBinariesFromCurrentThread = true;
                KhronosTextureContainer2._DecoderModulePromise = Promise.resolve(new KhronosTextureContainer2._KTX2DecoderModule.KTX2Decoder());
            }
        }
    }
    /**
     * Constructor
     * @param engine The engine to use
     * @param numWorkersOrOptions The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.
     */ constructor(engine, numWorkersOrOptions = KhronosTextureContainer2.DefaultNumWorkers){
        this._engine = engine;
        const workerPoolOption = typeof numWorkersOrOptions === "object" && numWorkersOrOptions.workerPool || KhronosTextureContainer2.WorkerPool;
        if (workerPoolOption) {
            KhronosTextureContainer2._WorkerPoolPromise = Promise.resolve(workerPoolOption);
        } else {
            // set the KTX2 decoder module
            if (typeof numWorkersOrOptions === "object") {
                KhronosTextureContainer2._KTX2DecoderModule = numWorkersOrOptions?.binariesAndModulesContainer?.jsDecoderModule;
            } else if (typeof KTX2DECODER !== "undefined") {
                KhronosTextureContainer2._KTX2DecoderModule = KTX2DECODER;
            }
            const numberOfWorkers = typeof numWorkersOrOptions === "number" ? numWorkersOrOptions : numWorkersOrOptions.numWorkers ?? KhronosTextureContainer2.DefaultNumWorkers;
            KhronosTextureContainer2._Initialize(numberOfWorkers);
        }
    }
    /**
     * @internal
     */ async _uploadAsync(data, internalTexture, options) {
        const caps = this._engine.getCaps();
        const compressedTexturesCaps = {
            astc: !!caps.astc,
            bptc: !!caps.bptc,
            s3tc: !!caps.s3tc,
            pvrtc: !!caps.pvrtc,
            etc2: !!caps.etc2,
            etc1: !!caps.etc1
        };
        if (KhronosTextureContainer2._WorkerPoolPromise) {
            const workerPool = await KhronosTextureContainer2._WorkerPoolPromise;
            return await new Promise((resolve, reject)=>{
                workerPool.push((worker, onComplete)=>{
                    const onError = (error)=>{
                        worker.removeEventListener("error", onError);
                        worker.removeEventListener("message", onMessage);
                        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
                        reject(error);
                        onComplete();
                    };
                    const onMessage = (message)=>{
                        if (message.data.action === "decoded") {
                            worker.removeEventListener("error", onError);
                            worker.removeEventListener("message", onMessage);
                            if (!message.data.success) {
                                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
                                reject({
                                    message: message.data.msg
                                });
                            } else {
                                try {
                                    this._createTexture(message.data.decodedData, internalTexture, options);
                                    resolve();
                                } catch (err) {
                                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
                                    reject({
                                        message: err
                                    });
                                }
                            }
                            onComplete();
                        }
                    };
                    worker.addEventListener("error", onError);
                    worker.addEventListener("message", onMessage);
                    worker.postMessage({
                        action: "setDefaultDecoderOptions",
                        options: KhronosTextureContainer2.DefaultDecoderOptions._getKTX2DecoderOptions()
                    });
                    const dataCopy = new Uint8Array(data.byteLength);
                    dataCopy.set(new Uint8Array(data.buffer, data.byteOffset, data.byteLength));
                    worker.postMessage({
                        action: "decode",
                        data: dataCopy,
                        caps: compressedTexturesCaps,
                        options
                    }, [
                        dataCopy.buffer
                    ]);
                });
            });
        } else if (KhronosTextureContainer2._DecoderModulePromise) {
            const decoder = await KhronosTextureContainer2._DecoderModulePromise;
            if (KhronosTextureContainer2.DefaultDecoderOptions.isDirty) {
                KhronosTextureContainer2._KTX2DecoderModule.KTX2Decoder.DefaultDecoderOptions = KhronosTextureContainer2.DefaultDecoderOptions._getKTX2DecoderOptions();
            }
            return await new Promise((resolve, reject)=>{
                decoder.decode(data, caps)// eslint-disable-next-line github/no-then
                .then((data)=>{
                    this._createTexture(data, internalTexture);
                    resolve();
                })// eslint-disable-next-line github/no-then
                .catch((reason)=>{
                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
                    reject({
                        message: reason
                    });
                });
            });
        }
        throw new Error("KTX2 decoder module is not available");
    }
    _createTexture(data, internalTexture, options) {
        const oglTexture2D = 3553; // gl.TEXTURE_2D
        this._engine._bindTextureDirectly(oglTexture2D, internalTexture);
        if (options) {
            // return back some information about the decoded data
            options.transcodedFormat = data.transcodedFormat;
            options.isInGammaSpace = data.isInGammaSpace;
            options.hasAlpha = data.hasAlpha;
            options.transcoderName = data.transcoderName;
        }
        let isUncompressedFormat = true;
        switch(data.transcodedFormat){
            case 0x8058 /* RGBA8 */ :
                internalTexture.type = 0;
                internalTexture.format = 5;
                break;
            case 0x8229 /* R8 */ :
                internalTexture.type = 0;
                internalTexture.format = 6;
                break;
            case 0x822b /* RG8 */ :
                internalTexture.type = 0;
                internalTexture.format = 7;
                break;
            default:
                internalTexture.format = data.transcodedFormat;
                isUncompressedFormat = false;
                break;
        }
        internalTexture._gammaSpace = data.isInGammaSpace;
        internalTexture.generateMipMaps = data.mipmaps.length > 1;
        internalTexture.width = data.mipmaps[0].width;
        internalTexture.height = data.mipmaps[0].height;
        if (data.errors) {
            throw new Error("KTX2 container - could not transcode the data. " + data.errors);
        }
        for(let t = 0; t < data.mipmaps.length; ++t){
            const mipmap = data.mipmaps[t];
            if (!mipmap || !mipmap.data) {
                throw new Error("KTX2 container - could not transcode one of the image");
            }
            if (isUncompressedFormat) {
                // uncompressed RGBA / R8 / RG8
                internalTexture.width = mipmap.width; // need to set width/height so that the call to _uploadDataToTextureDirectly uses the right dimensions
                internalTexture.height = mipmap.height;
                this._engine._uploadDataToTextureDirectly(internalTexture, mipmap.data, 0, t, undefined, true);
            } else {
                this._engine._uploadCompressedDataToTextureDirectly(internalTexture, data.transcodedFormat, mipmap.width, mipmap.height, mipmap.data, 0, t);
            }
        }
        internalTexture._extension = ".ktx2";
        internalTexture.isReady = true;
        this._engine._bindTextureDirectly(oglTexture2D, null);
    }
    /**
     * Checks if the given data starts with a KTX2 file identifier.
     * @param data the data to check
     * @returns true if the data is a KTX2 file or false otherwise
     */ static IsValid(data) {
        if (data.byteLength >= 12) {
            // '', 'K', 'T', 'X', ' ', '2', '0', '', '\r', '\n', '\x1A', '\n'
            const identifier = new Uint8Array(data.buffer, data.byteOffset, 12);
            if (identifier[0] === 0xab && identifier[1] === 0x4b && identifier[2] === 0x54 && identifier[3] === 0x58 && identifier[4] === 0x20 && identifier[5] === 0x32 && identifier[6] === 0x30 && identifier[7] === 0xbb && identifier[8] === 0x0d && identifier[9] === 0x0a && identifier[10] === 0x1a && identifier[11] === 0x0a) {
                return true;
            }
        }
        return false;
    }
}
/**
 * URLs to use when loading the KTX2 decoder module as well as its dependencies
 * If a url is null, the default url is used (pointing to https://preview.babylonjs.com)
 * Note that jsDecoderModule can't be null and that the other dependencies will only be loaded if necessary
 * Urls you can change:
 *     URLConfig.jsDecoderModule
 *     URLConfig.wasmUASTCToASTC
 *     URLConfig.wasmUASTCToBC7
 *     URLConfig.wasmUASTCToRGBA_UNORM
 *     URLConfig.wasmUASTCToRGBA_SRGB
 *     URLConfig.wasmUASTCToR8_UNORM
 *     URLConfig.wasmUASTCToRG8_UNORM
 *     URLConfig.jsMSCTranscoder
 *     URLConfig.wasmMSCTranscoder
 *     URLConfig.wasmZSTDDecoder
 * You can see their default values in this PG: https://playground.babylonjs.com/#EIJH8L#29
 */ KhronosTextureContainer2.URLConfig = {
    jsDecoderModule: "https://cdn.babylonjs.com/babylon.ktx2Decoder.js",
    wasmUASTCToASTC: null,
    wasmUASTCToBC7: null,
    wasmUASTCToRGBA_UNORM: null,
    wasmUASTCToRGBA_SRGB: null,
    wasmUASTCToR8_UNORM: null,
    wasmUASTCToRG8_UNORM: null,
    jsMSCTranscoder: null,
    wasmMSCTranscoder: null,
    wasmZSTDDecoder: null
};
/**
 * Default number of workers used to handle data decoding
 */ KhronosTextureContainer2.DefaultNumWorkers = KhronosTextureContainer2.GetDefaultNumWorkers();
/**
 * Default configuration for the KTX2 decoder.
 * The options defined in this way have priority over those passed when creating a KTX2 texture with new Texture(...).
 */ KhronosTextureContainer2.DefaultDecoderOptions = new DefaultKTX2DecoderOptions(); //# sourceMappingURL=khronosTextureContainer2.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/webRequest.fetch.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_FetchAsync",
    ()=>_FetchAsync
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$webRequest$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/webRequest.js [app-ssr] (ecmascript)");
;
async function _FetchAsync(url, options) {
    const method = options.method || "GET";
    return await new Promise((resolve, reject)=>{
        const request = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$webRequest$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WebRequest"]();
        request.addEventListener("readystatechange", ()=>{
            if (request.readyState == 4) {
                if (request.status == 200) {
                    const headerValues = {};
                    if (options.responseHeaders) {
                        for (const header of options.responseHeaders){
                            headerValues[header] = request.getResponseHeader(header) || "";
                        }
                    }
                    resolve({
                        response: request.response,
                        headerValues: headerValues
                    });
                } else {
                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
                    reject(`Unable to fetch data from ${url}. Error code: ${request.status}`);
                }
            }
        });
        request.open(method, url);
        request.send();
    });
} //# sourceMappingURL=webRequest.fetch.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/HighDynamicRange/panoramaToCubemap.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PanoramaToCubeMapTools",
    ()=>PanoramaToCubeMapTools
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-ssr] (ecmascript)");
;
class PanoramaToCubeMapTools {
    /**
     * Converts a panorama stored in RGB right to left up to down format into a cubemap (6 faces).
     *
     * @param float32Array The source data.
     * @param inputWidth The width of the input panorama.
     * @param inputHeight The height of the input panorama.
     * @param size The willing size of the generated cubemap (each faces will be size * size pixels)
     * @param supersample enable supersampling the cubemap
     * @param invertY defines if the Y axis must be inverted
     * @returns The cubemap data
     */ static ConvertPanoramaToCubemap(float32Array, inputWidth, inputHeight, size, supersample = false, invertY = true) {
        if (!float32Array) {
            // eslint-disable-next-line no-throw-literal
            throw "ConvertPanoramaToCubemap: input cannot be null";
        }
        let stride = 0;
        if (float32Array.length != inputWidth * inputHeight * 3) {
            if (float32Array.length != inputWidth * inputHeight * 4) {
                // eslint-disable-next-line no-throw-literal
                throw "ConvertPanoramaToCubemap: input size is wrong";
            } else {
                stride = 4;
            }
        } else {
            stride = 3;
        }
        const textureFront = this.CreateCubemapTexture(size, this.FACE_FRONT, float32Array, inputWidth, inputHeight, supersample, invertY, stride);
        const textureBack = this.CreateCubemapTexture(size, this.FACE_BACK, float32Array, inputWidth, inputHeight, supersample, invertY, stride);
        const textureLeft = this.CreateCubemapTexture(size, this.FACE_LEFT, float32Array, inputWidth, inputHeight, supersample, invertY, stride);
        const textureRight = this.CreateCubemapTexture(size, this.FACE_RIGHT, float32Array, inputWidth, inputHeight, supersample, invertY, stride);
        const textureUp = this.CreateCubemapTexture(size, this.FACE_UP, float32Array, inputWidth, inputHeight, supersample, invertY, stride);
        const textureDown = this.CreateCubemapTexture(size, this.FACE_DOWN, float32Array, inputWidth, inputHeight, supersample, invertY, stride);
        return {
            front: textureFront,
            back: textureBack,
            left: textureLeft,
            right: textureRight,
            up: textureUp,
            down: textureDown,
            size: size,
            type: 1,
            format: 4,
            gammaSpace: false
        };
    }
    static CreateCubemapTexture(texSize, faceData, float32Array, inputWidth, inputHeight, supersample, invertY, stride) {
        const buffer = new ArrayBuffer(texSize * texSize * 4 * 3);
        const textureArray = new Float32Array(buffer);
        // If supersampling, determine number of samples needed when source texture width is divided for 4 cube faces
        const samples = supersample ? Math.max(1, Math.round(inputWidth / 4 / texSize)) : 1;
        const sampleFactor = 1 / samples;
        const sampleFactorSqr = sampleFactor * sampleFactor;
        const rotDX1 = faceData[1].subtract(faceData[0]).scale(sampleFactor / texSize);
        const rotDX2 = faceData[3].subtract(faceData[2]).scale(sampleFactor / texSize);
        const dy = 1 / texSize;
        let fy = 0;
        for(let y = 0; y < texSize; y++){
            for(let sy = 0; sy < samples; sy++){
                let xv1 = faceData[0];
                let xv2 = faceData[2];
                for(let x = 0; x < texSize; x++){
                    for(let sx = 0; sx < samples; sx++){
                        const v = xv2.subtract(xv1).scale(fy).add(xv1);
                        v.normalize();
                        const color = this.CalcProjectionSpherical(v, float32Array, inputWidth, inputHeight, stride, invertY);
                        // 3 channels per pixels
                        textureArray[y * texSize * 3 + x * 3 + 0] += color.r * sampleFactorSqr;
                        textureArray[y * texSize * 3 + x * 3 + 1] += color.g * sampleFactorSqr;
                        textureArray[y * texSize * 3 + x * 3 + 2] += color.b * sampleFactorSqr;
                        xv1 = xv1.add(rotDX1);
                        xv2 = xv2.add(rotDX2);
                    }
                }
                fy += dy * sampleFactor;
            }
        }
        return textureArray;
    }
    static CalcProjectionSpherical(vDir, float32Array, inputWidth, inputHeight, stride, invertY) {
        let theta = Math.atan2(vDir.z, vDir.x);
        const phi = Math.acos(vDir.y);
        while(theta < -Math.PI){
            theta += 2 * Math.PI;
        }
        while(theta > Math.PI){
            theta -= 2 * Math.PI;
        }
        let dx = theta / Math.PI;
        const dy = phi / Math.PI;
        // recenter.
        dx = dx * 0.5 + 0.5;
        let px = Math.round(dx * inputWidth);
        if (px < 0) {
            px = 0;
        } else if (px >= inputWidth) {
            px = inputWidth - 1;
        }
        let py = Math.round(dy * inputHeight);
        if (py < 0) {
            py = 0;
        } else if (py >= inputHeight) {
            py = inputHeight - 1;
        }
        const inputY = invertY ? inputHeight - py - 1 : py;
        const r = float32Array[inputY * inputWidth * stride + px * stride + 0];
        const g = float32Array[inputY * inputWidth * stride + px * stride + 1];
        const b = float32Array[inputY * inputWidth * stride + px * stride + 2];
        return {
            r: r,
            g: g,
            b: b
        };
    }
}
PanoramaToCubeMapTools.FACE_LEFT = [
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](-1.0, -1.0, -1.0),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](1.0, -1.0, -1.0),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](-1.0, 1.0, -1.0),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](1.0, 1.0, -1.0)
];
PanoramaToCubeMapTools.FACE_RIGHT = [
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](1.0, -1.0, 1.0),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](-1.0, -1.0, 1.0),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](1.0, 1.0, 1.0),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](-1.0, 1.0, 1.0)
];
PanoramaToCubeMapTools.FACE_FRONT = [
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](1.0, -1.0, -1.0),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](1.0, -1.0, 1.0),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](1.0, 1.0, -1.0),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](1.0, 1.0, 1.0)
];
PanoramaToCubeMapTools.FACE_BACK = [
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](-1.0, -1.0, 1.0),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](-1.0, -1.0, -1.0),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](-1.0, 1.0, 1.0),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](-1.0, 1.0, -1.0)
];
PanoramaToCubeMapTools.FACE_DOWN = [
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](1.0, 1.0, -1.0),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](1.0, 1.0, 1.0),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](-1.0, 1.0, -1.0),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](-1.0, 1.0, 1.0)
];
PanoramaToCubeMapTools.FACE_UP = [
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](-1.0, -1.0, -1.0),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](-1.0, -1.0, 1.0),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](1.0, -1.0, -1.0),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](1.0, -1.0, 1.0)
]; //# sourceMappingURL=panoramaToCubemap.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/HighDynamicRange/hdr.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GetCubeMapTextureData",
    ()=>GetCubeMapTextureData,
    "HDRTools",
    ()=>HDRTools,
    "RGBE_ReadHeader",
    ()=>RGBE_ReadHeader,
    "RGBE_ReadPixels",
    ()=>RGBE_ReadPixels
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$HighDynamicRange$2f$panoramaToCubemap$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/HighDynamicRange/panoramaToCubemap.js [app-ssr] (ecmascript)");
;
/* This groups tools to convert HDR texture to native colors array. */ function Ldexp(mantissa, exponent) {
    if (exponent > 1023) {
        return mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023);
    }
    if (exponent < -1074) {
        return mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074);
    }
    return mantissa * Math.pow(2, exponent);
}
function Rgbe2float(float32array, red, green, blue, exponent, index) {
    if (exponent > 0) {
        /*nonzero pixel*/ exponent = Ldexp(1.0, exponent - (128 + 8));
        float32array[index + 0] = red * exponent;
        float32array[index + 1] = green * exponent;
        float32array[index + 2] = blue * exponent;
    } else {
        float32array[index + 0] = 0;
        float32array[index + 1] = 0;
        float32array[index + 2] = 0;
    }
}
function ReadStringLine(uint8array, startIndex) {
    let line = "";
    let character = "";
    for(let i = startIndex; i < uint8array.length - startIndex; i++){
        character = String.fromCharCode(uint8array[i]);
        if (character == "\n") {
            break;
        }
        line += character;
    }
    return line;
}
function RGBE_ReadHeader(uint8array) {
    let height = 0;
    let width = 0;
    let line = ReadStringLine(uint8array, 0);
    if (line[0] != "#" || line[1] != "?") {
        // eslint-disable-next-line no-throw-literal
        throw "Bad HDR Format.";
    }
    let endOfHeader = false;
    let findFormat = false;
    let lineIndex = 0;
    do {
        lineIndex += line.length + 1;
        line = ReadStringLine(uint8array, lineIndex);
        if (line == "FORMAT=32-bit_rle_rgbe") {
            findFormat = true;
        } else if (line.length == 0) {
            endOfHeader = true;
        }
    }while (!endOfHeader)
    if (!findFormat) {
        // eslint-disable-next-line no-throw-literal
        throw "HDR Bad header format, unsupported FORMAT";
    }
    lineIndex += line.length + 1;
    line = ReadStringLine(uint8array, lineIndex);
    const sizeRegexp = /^-Y (.*) \+X (.*)$/g;
    const match = sizeRegexp.exec(line);
    // TODO. Support +Y and -X if needed.
    if (!match || match.length < 3) {
        // eslint-disable-next-line no-throw-literal
        throw "HDR Bad header format, no size";
    }
    width = parseInt(match[2]);
    height = parseInt(match[1]);
    if (width < 8 || width > 0x7fff) {
        // eslint-disable-next-line no-throw-literal
        throw "HDR Bad header format, unsupported size";
    }
    lineIndex += line.length + 1;
    return {
        height: height,
        width: width,
        dataPosition: lineIndex
    };
}
function GetCubeMapTextureData(buffer, size, supersample = false) {
    const uint8array = new Uint8Array(buffer);
    const hdrInfo = RGBE_ReadHeader(uint8array);
    const data = RGBE_ReadPixels(uint8array, hdrInfo);
    const cubeMapData = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$HighDynamicRange$2f$panoramaToCubemap$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PanoramaToCubeMapTools"].ConvertPanoramaToCubemap(data, hdrInfo.width, hdrInfo.height, size, supersample);
    return cubeMapData;
}
function RGBE_ReadPixels(uint8array, hdrInfo) {
    return ReadRGBEPixelsRLE(uint8array, hdrInfo);
}
// eslint-disable-next-line @typescript-eslint/naming-convention
function ReadRGBEPixelsRLE(uint8array, hdrInfo) {
    let numScanlines = hdrInfo.height;
    const scanlineWidth = hdrInfo.width;
    let a, b, c, d, count;
    let dataIndex = hdrInfo.dataPosition;
    let index = 0, endIndex = 0, i = 0;
    const scanLineArrayBuffer = new ArrayBuffer(scanlineWidth * 4); // four channel R G B E
    const scanLineArray = new Uint8Array(scanLineArrayBuffer);
    // 3 channels of 4 bytes per pixel in float.
    const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);
    const resultArray = new Float32Array(resultBuffer);
    // read in each successive scanline
    while(numScanlines > 0){
        a = uint8array[dataIndex++];
        b = uint8array[dataIndex++];
        c = uint8array[dataIndex++];
        d = uint8array[dataIndex++];
        if (a != 2 || b != 2 || c & 0x80 || hdrInfo.width < 8 || hdrInfo.width > 32767) {
            return ReadRGBEPixelsNotRLE(uint8array, hdrInfo);
        }
        if ((c << 8 | d) != scanlineWidth) {
            // eslint-disable-next-line no-throw-literal
            throw "HDR Bad header format, wrong scan line width";
        }
        index = 0;
        // read each of the four channels for the scanline into the buffer
        for(i = 0; i < 4; i++){
            endIndex = (i + 1) * scanlineWidth;
            while(index < endIndex){
                a = uint8array[dataIndex++];
                b = uint8array[dataIndex++];
                if (a > 128) {
                    // a run of the same value
                    count = a - 128;
                    if (count == 0 || count > endIndex - index) {
                        // eslint-disable-next-line no-throw-literal
                        throw "HDR Bad Format, bad scanline data (run)";
                    }
                    while(count-- > 0){
                        scanLineArray[index++] = b;
                    }
                } else {
                    // a non-run
                    count = a;
                    if (count == 0 || count > endIndex - index) {
                        // eslint-disable-next-line no-throw-literal
                        throw "HDR Bad Format, bad scanline data (non-run)";
                    }
                    scanLineArray[index++] = b;
                    if (--count > 0) {
                        for(let j = 0; j < count; j++){
                            scanLineArray[index++] = uint8array[dataIndex++];
                        }
                    }
                }
            }
        }
        // now convert data from buffer into floats
        for(i = 0; i < scanlineWidth; i++){
            a = scanLineArray[i];
            b = scanLineArray[i + scanlineWidth];
            c = scanLineArray[i + 2 * scanlineWidth];
            d = scanLineArray[i + 3 * scanlineWidth];
            Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - numScanlines) * scanlineWidth * 3 + i * 3);
        }
        numScanlines--;
    }
    return resultArray;
}
// eslint-disable-next-line @typescript-eslint/naming-convention
function ReadRGBEPixelsNotRLE(uint8array, hdrInfo) {
    // this file is not run length encoded
    // read values sequentially
    let numScanlines = hdrInfo.height;
    const scanlineWidth = hdrInfo.width;
    let a, b, c, d, i;
    let dataIndex = hdrInfo.dataPosition;
    // 3 channels of 4 bytes per pixel in float.
    const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);
    const resultArray = new Float32Array(resultBuffer);
    // read in each successive scanline
    while(numScanlines > 0){
        for(i = 0; i < hdrInfo.width; i++){
            a = uint8array[dataIndex++];
            b = uint8array[dataIndex++];
            c = uint8array[dataIndex++];
            d = uint8array[dataIndex++];
            Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - numScanlines) * scanlineWidth * 3 + i * 3);
        }
        numScanlines--;
    }
    return resultArray;
}
const HDRTools = {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    RGBE_ReadHeader,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    GetCubeMapTextureData,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    RGBE_ReadPixels
}; //# sourceMappingURL=hdr.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tga.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GetTGAHeader",
    ()=>GetTGAHeader,
    "TGATools",
    ()=>TGATools,
    "UploadContent",
    ()=>UploadContent
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/logger.js [app-ssr] (ecmascript)");
;
//private static _TYPE_NO_DATA = 0;
const _TYPE_INDEXED = 1;
const _TYPE_RGB = 2;
const _TYPE_GREY = 3;
const _TYPE_RLE_INDEXED = 9;
const _TYPE_RLE_RGB = 10;
const _TYPE_RLE_GREY = 11;
const _ORIGIN_MASK = 0x30;
const _ORIGIN_SHIFT = 0x04;
const _ORIGIN_BL = 0x00;
const _ORIGIN_BR = 0x01;
const _ORIGIN_UL = 0x02;
const _ORIGIN_UR = 0x03;
function GetTGAHeader(data) {
    let offset = 0;
    const header = {
        id_length: data[offset++],
        colormap_type: data[offset++],
        image_type: data[offset++],
        colormap_index: data[offset++] | data[offset++] << 8,
        colormap_length: data[offset++] | data[offset++] << 8,
        colormap_size: data[offset++],
        origin: [
            data[offset++] | data[offset++] << 8,
            data[offset++] | data[offset++] << 8
        ],
        width: data[offset++] | data[offset++] << 8,
        height: data[offset++] | data[offset++] << 8,
        pixel_size: data[offset++],
        flags: data[offset++]
    };
    return header;
}
function UploadContent(texture, data) {
    // Not enough data to contain header ?
    if (data.length < 19) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Error("Unable to load TGA file - Not enough data to contain header");
        return;
    }
    // Read Header
    let offset = 18;
    const header = GetTGAHeader(data);
    // Assume it's a valid Targa file.
    if (header.id_length + offset > data.length) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Error("Unable to load TGA file - Not enough data");
        return;
    }
    // Skip not needed data
    offset += header.id_length;
    let use_rle = false;
    let use_pal = false;
    let use_grey = false;
    // Get some informations.
    switch(header.image_type){
        case _TYPE_RLE_INDEXED:
            use_rle = true;
        // eslint-disable-next-line no-fallthrough
        case _TYPE_INDEXED:
            use_pal = true;
            break;
        case _TYPE_RLE_RGB:
            use_rle = true;
        // eslint-disable-next-line no-fallthrough
        case _TYPE_RGB:
            break;
        case _TYPE_RLE_GREY:
            use_rle = true;
        // eslint-disable-next-line no-fallthrough
        case _TYPE_GREY:
            use_grey = true;
            break;
    }
    let pixel_data;
    // var numAlphaBits = header.flags & 0xf;
    const pixel_size = header.pixel_size >> 3;
    const pixel_total = header.width * header.height * pixel_size;
    // Read palettes
    let palettes;
    if (use_pal) {
        palettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));
    }
    // Read LRE
    if (use_rle) {
        pixel_data = new Uint8Array(pixel_total);
        let c, count, i;
        let localOffset = 0;
        const pixels = new Uint8Array(pixel_size);
        while(offset < pixel_total && localOffset < pixel_total){
            c = data[offset++];
            count = (c & 0x7f) + 1;
            // RLE pixels
            if (c & 0x80) {
                // Bind pixel tmp array
                for(i = 0; i < pixel_size; ++i){
                    pixels[i] = data[offset++];
                }
                // Copy pixel array
                for(i = 0; i < count; ++i){
                    pixel_data.set(pixels, localOffset + i * pixel_size);
                }
                localOffset += pixel_size * count;
            } else {
                count *= pixel_size;
                for(i = 0; i < count; ++i){
                    pixel_data[localOffset + i] = data[offset++];
                }
                localOffset += count;
            }
        }
    } else {
        pixel_data = data.subarray(offset, offset += use_pal ? header.width * header.height : pixel_total);
    }
    // Load to texture
    let x_start, y_start, x_step, y_step, y_end, x_end;
    switch((header.flags & _ORIGIN_MASK) >> _ORIGIN_SHIFT){
        default:
        case _ORIGIN_UL:
            x_start = 0;
            x_step = 1;
            x_end = header.width;
            y_start = 0;
            y_step = 1;
            y_end = header.height;
            break;
        case _ORIGIN_BL:
            x_start = 0;
            x_step = 1;
            x_end = header.width;
            y_start = header.height - 1;
            y_step = -1;
            y_end = -1;
            break;
        case _ORIGIN_UR:
            x_start = header.width - 1;
            x_step = -1;
            x_end = -1;
            y_start = 0;
            y_step = 1;
            y_end = header.height;
            break;
        case _ORIGIN_BR:
            x_start = header.width - 1;
            x_step = -1;
            x_end = -1;
            y_start = header.height - 1;
            y_step = -1;
            y_end = -1;
            break;
    }
    // Load the specify method
    const func = "_getImageData" + (use_grey ? "Grey" : "") + header.pixel_size + "bits";
    const imageData = TGATools[func](header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end);
    const engine = texture.getEngine();
    engine._uploadDataToTextureDirectly(texture, imageData);
}
/**
 * @internal
 */ function GetImageData8bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
    const image = pixel_data, colormap = palettes;
    const width = header.width, height = header.height;
    let color, i = 0, x, y;
    const imageData = new Uint8Array(width * height * 4);
    for(y = y_start; y !== y_end; y += y_step){
        for(x = x_start; x !== x_end; x += x_step, i++){
            color = image[i];
            imageData[(x + width * y) * 4 + 3] = 255;
            imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];
            imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];
            imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];
        }
    }
    return imageData;
}
/**
 * @internal
 */ function GetImageData16bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
    const image = pixel_data;
    const width = header.width, height = header.height;
    let color, i = 0, x, y;
    const imageData = new Uint8Array(width * height * 4);
    for(y = y_start; y !== y_end; y += y_step){
        for(x = x_start; x !== x_end; x += x_step, i += 2){
            color = image[i + 0] + (image[i + 1] << 8); // Inversed ?
            const r = ((color & 0x7c00) >> 10) * 255 / 0x1f | 0;
            const g = ((color & 0x03e0) >> 5) * 255 / 0x1f | 0;
            const b = (color & 0x001f) * 255 / 0x1f | 0;
            imageData[(x + width * y) * 4 + 0] = r;
            imageData[(x + width * y) * 4 + 1] = g;
            imageData[(x + width * y) * 4 + 2] = b;
            imageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255;
        }
    }
    return imageData;
}
/**
 * @internal
 */ function GetImageData24bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
    const image = pixel_data;
    const width = header.width, height = header.height;
    let i = 0, x, y;
    const imageData = new Uint8Array(width * height * 4);
    for(y = y_start; y !== y_end; y += y_step){
        for(x = x_start; x !== x_end; x += x_step, i += 3){
            imageData[(x + width * y) * 4 + 3] = 255;
            imageData[(x + width * y) * 4 + 2] = image[i + 0];
            imageData[(x + width * y) * 4 + 1] = image[i + 1];
            imageData[(x + width * y) * 4 + 0] = image[i + 2];
        }
    }
    return imageData;
}
/**
 * @internal
 */ function GetImageData32bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
    const image = pixel_data;
    const width = header.width, height = header.height;
    let i = 0, x, y;
    const imageData = new Uint8Array(width * height * 4);
    for(y = y_start; y !== y_end; y += y_step){
        for(x = x_start; x !== x_end; x += x_step, i += 4){
            imageData[(x + width * y) * 4 + 2] = image[i + 0];
            imageData[(x + width * y) * 4 + 1] = image[i + 1];
            imageData[(x + width * y) * 4 + 0] = image[i + 2];
            imageData[(x + width * y) * 4 + 3] = image[i + 3];
        }
    }
    return imageData;
}
/**
 * @internal
 */ function GetImageDataGrey8bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
    const image = pixel_data;
    const width = header.width, height = header.height;
    let color, i = 0, x, y;
    const imageData = new Uint8Array(width * height * 4);
    for(y = y_start; y !== y_end; y += y_step){
        for(x = x_start; x !== x_end; x += x_step, i++){
            color = image[i];
            imageData[(x + width * y) * 4 + 0] = color;
            imageData[(x + width * y) * 4 + 1] = color;
            imageData[(x + width * y) * 4 + 2] = color;
            imageData[(x + width * y) * 4 + 3] = 255;
        }
    }
    return imageData;
}
/**
 * @internal
 */ function GetImageDataGrey16bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {
    const image = pixel_data;
    const width = header.width, height = header.height;
    let i = 0, x, y;
    const imageData = new Uint8Array(width * height * 4);
    for(y = y_start; y !== y_end; y += y_step){
        for(x = x_start; x !== x_end; x += x_step, i += 2){
            imageData[(x + width * y) * 4 + 0] = image[i + 0];
            imageData[(x + width * y) * 4 + 1] = image[i + 0];
            imageData[(x + width * y) * 4 + 2] = image[i + 0];
            imageData[(x + width * y) * 4 + 3] = image[i + 1];
        }
    }
    return imageData;
}
const TGATools = {
    /**
     * Gets the header of a TGA file
     * @param data defines the TGA data
     * @returns the header
     */ GetTGAHeader,
    /**
     * Uploads TGA content to a Babylon Texture
     * @internal
     */ UploadContent,
    /** @internal */ _getImageData8bits: GetImageData8bits,
    /** @internal */ _getImageData16bits: GetImageData16bits,
    /** @internal */ _getImageData24bits: GetImageData24bits,
    /** @internal */ _getImageData32bits: GetImageData32bits,
    /** @internal */ _getImageDataGrey8bits: GetImageDataGrey8bits,
    /** @internal */ _getImageDataGrey16bits: GetImageDataGrey16bits
}; //# sourceMappingURL=tga.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/basisWorker.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "initializeWebWorker",
    ()=>initializeWebWorker,
    "workerFunction",
    ()=>workerFunction
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tools.js [app-ssr] (ecmascript)");
;
function workerFunction() {
    const _BASIS_FORMAT = {
        cTFETC1: 0,
        cTFETC2: 1,
        cTFBC1: 2,
        cTFBC3: 3,
        cTFBC4: 4,
        cTFBC5: 5,
        cTFBC7: 6,
        cTFPVRTC1_4_RGB: 8,
        cTFPVRTC1_4_RGBA: 9,
        cTFASTC_4x4: 10,
        cTFATC_RGB: 11,
        cTFATC_RGBA_INTERPOLATED_ALPHA: 12,
        cTFRGBA32: 13,
        cTFRGB565: 14,
        cTFBGR565: 15,
        cTFRGBA4444: 16,
        cTFFXT1_RGB: 17,
        cTFPVRTC2_4_RGB: 18,
        cTFPVRTC2_4_RGBA: 19,
        cTFETC2_EAC_R11: 20,
        cTFETC2_EAC_RG11: 21
    };
    let transcoderModulePromise = null;
    onmessage = (event)=>{
        if (event.data.action === "init") {
            // Load the transcoder if it hasn't been yet
            if (event.data.url) {
                // make sure we loaded the script correctly
                try {
                    importScripts(event.data.url);
                } catch (e) {
                    postMessage({
                        action: "error",
                        error: e
                    });
                }
            }
            if (!transcoderModulePromise) {
                transcoderModulePromise = BASIS({
                    // Override wasm binary
                    wasmBinary: event.data.wasmBinary
                });
            }
            if (transcoderModulePromise !== null) {
                // eslint-disable-next-line github/no-then
                transcoderModulePromise.then((m)=>{
                    BASIS = m;
                    m.initializeBasis();
                    postMessage({
                        action: "init"
                    });
                });
            }
        } else if (event.data.action === "transcode") {
            // Transcode the basis image and return the resulting pixels
            const config = event.data.config;
            const imgData = event.data.imageData;
            const loadedFile = new BASIS.BasisFile(imgData);
            const fileInfo = GetFileInfo(loadedFile);
            let format = event.data.ignoreSupportedFormats ? null : GetSupportedTranscodeFormat(event.data.config, fileInfo);
            let needsConversion = false;
            if (format === null) {
                needsConversion = true;
                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;
            }
            // Begin transcode
            let success = true;
            if (!loadedFile.startTranscoding()) {
                success = false;
            }
            const buffers = [];
            for(let imageIndex = 0; imageIndex < fileInfo.images.length; imageIndex++){
                if (!success) {
                    break;
                }
                const image = fileInfo.images[imageIndex];
                if (config.loadSingleImage === undefined || config.loadSingleImage === imageIndex) {
                    let mipCount = image.levels.length;
                    if (config.loadMipmapLevels === false) {
                        mipCount = 1;
                    }
                    for(let levelIndex = 0; levelIndex < mipCount; levelIndex++){
                        const levelInfo = image.levels[levelIndex];
                        const pixels = TranscodeLevel(loadedFile, imageIndex, levelIndex, format, needsConversion);
                        if (!pixels) {
                            success = false;
                            break;
                        }
                        levelInfo.transcodedPixels = pixels;
                        buffers.push(levelInfo.transcodedPixels.buffer);
                    }
                }
            }
            // Close file
            loadedFile.close();
            loadedFile.delete();
            if (needsConversion) {
                format = -1;
            }
            if (!success) {
                postMessage({
                    action: "transcode",
                    success: success,
                    id: event.data.id
                });
            } else {
                postMessage({
                    action: "transcode",
                    success: success,
                    id: event.data.id,
                    fileInfo: fileInfo,
                    format: format
                }, buffers);
            }
        }
    };
    /**
     * Detects the supported transcode format for the file
     * @param config transcode config
     * @param fileInfo info about the file
     * @returns the chosed format or null if none are supported
     */ function GetSupportedTranscodeFormat(config, fileInfo) {
        let format = null;
        if (config.supportedCompressionFormats) {
            if (config.supportedCompressionFormats.astc) {
                format = _BASIS_FORMAT.cTFASTC_4x4;
            } else if (config.supportedCompressionFormats.bc7) {
                format = _BASIS_FORMAT.cTFBC7;
            } else if (config.supportedCompressionFormats.s3tc) {
                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;
            } else if (config.supportedCompressionFormats.pvrtc) {
                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFPVRTC1_4_RGBA : _BASIS_FORMAT.cTFPVRTC1_4_RGB;
            } else if (config.supportedCompressionFormats.etc2) {
                format = _BASIS_FORMAT.cTFETC2;
            } else if (config.supportedCompressionFormats.etc1) {
                format = _BASIS_FORMAT.cTFETC1;
            } else {
                format = _BASIS_FORMAT.cTFRGB565;
            }
        }
        return format;
    }
    /**
     * Retrieves information about the basis file eg. dimensions
     * @param basisFile the basis file to get the info from
     * @returns information about the basis file
     */ function GetFileInfo(basisFile) {
        const hasAlpha = basisFile.getHasAlpha();
        const imageCount = basisFile.getNumImages();
        const images = [];
        for(let i = 0; i < imageCount; i++){
            const imageInfo = {
                levels: []
            };
            const levelCount = basisFile.getNumLevels(i);
            for(let level = 0; level < levelCount; level++){
                const levelInfo = {
                    width: basisFile.getImageWidth(i, level),
                    height: basisFile.getImageHeight(i, level)
                };
                imageInfo.levels.push(levelInfo);
            }
            images.push(imageInfo);
        }
        const info = {
            hasAlpha,
            images
        };
        return info;
    }
    function TranscodeLevel(loadedFile, imageIndex, levelIndex, format, convertToRgb565) {
        const dstSize = loadedFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, format);
        let dst = new Uint8Array(dstSize);
        if (!loadedFile.transcodeImage(dst, imageIndex, levelIndex, format, 1, 0)) {
            return null;
        }
        // If no supported format is found, load as dxt and convert to rgb565
        if (convertToRgb565) {
            const alignedWidth = loadedFile.getImageWidth(imageIndex, levelIndex) + 3 & ~3;
            const alignedHeight = loadedFile.getImageHeight(imageIndex, levelIndex) + 3 & ~3;
            dst = ConvertDxtToRgb565(dst, 0, alignedWidth, alignedHeight);
        }
        return dst;
    }
    /**
     * From https://github.com/BinomialLLC/basis_universal/blob/master/webgl/texture/dxt-to-rgb565.js
     * An unoptimized version of dxtToRgb565.  Also, the floating
     * point math used to compute the colors actually results in
     * slightly different colors compared to hardware DXT decoders.
     * @param src dxt src pixels
     * @param srcByteOffset offset for the start of src
     * @param  width aligned width of the image
     * @param  height aligned height of the image
     * @returns the converted pixels
     */ function ConvertDxtToRgb565(src, srcByteOffset, width, height) {
        const c = new Uint16Array(4);
        const dst = new Uint16Array(width * height);
        const blockWidth = width / 4;
        const blockHeight = height / 4;
        for(let blockY = 0; blockY < blockHeight; blockY++){
            for(let blockX = 0; blockX < blockWidth; blockX++){
                const i = srcByteOffset + 8 * (blockY * blockWidth + blockX);
                c[0] = src[i] | src[i + 1] << 8;
                c[1] = src[i + 2] | src[i + 3] << 8;
                c[2] = (2 * (c[0] & 0x1f) + 1 * (c[1] & 0x1f)) / 3 | (2 * (c[0] & 0x7e0) + 1 * (c[1] & 0x7e0)) / 3 & 0x7e0 | (2 * (c[0] & 0xf800) + 1 * (c[1] & 0xf800)) / 3 & 0xf800;
                c[3] = (2 * (c[1] & 0x1f) + 1 * (c[0] & 0x1f)) / 3 | (2 * (c[1] & 0x7e0) + 1 * (c[0] & 0x7e0)) / 3 & 0x7e0 | (2 * (c[1] & 0xf800) + 1 * (c[0] & 0xf800)) / 3 & 0xf800;
                for(let row = 0; row < 4; row++){
                    const m = src[i + 4 + row];
                    let dstI = (blockY * 4 + row) * width + blockX * 4;
                    dst[dstI++] = c[m & 0x3];
                    dst[dstI++] = c[m >> 2 & 0x3];
                    dst[dstI++] = c[m >> 4 & 0x3];
                    dst[dstI++] = c[m >> 6 & 0x3];
                }
            }
        }
        return dst;
    }
}
async function initializeWebWorker(worker, wasmBinary, moduleUrl) {
    return await new Promise((res, reject)=>{
        const initHandler = (msg)=>{
            if (msg.data.action === "init") {
                worker.removeEventListener("message", initHandler);
                res(worker);
            } else if (msg.data.action === "error") {
                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
                reject(msg.data.error || "error initializing worker");
            }
        };
        worker.addEventListener("message", initHandler);
        // we can use transferable objects here because the worker will own the ArrayBuffer
        worker.postMessage({
            action: "init",
            url: moduleUrl ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].GetBabylonScriptURL(moduleUrl) : undefined,
            wasmBinary
        }, [
            wasmBinary
        ]);
    });
} //# sourceMappingURL=basisWorker.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/basis.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BasisFileInfo",
    ()=>BasisFileInfo,
    "BasisTools",
    ()=>BasisTools,
    "BasisToolsOptions",
    ()=>BasisToolsOptions,
    "BasisTranscodeConfiguration",
    ()=>BasisTranscodeConfiguration,
    "GetInternalFormatFromBasisFormat",
    ()=>GetInternalFormatFromBasisFormat,
    "LoadTextureFromTranscodeResult",
    ()=>LoadTextureFromTranscodeResult,
    "SetBasisTranscoderWorker",
    ()=>SetBasisTranscoderWorker,
    "TranscodeAsync",
    ()=>TranscodeAsync
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/Textures/texture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$internalTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/Textures/internalTexture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$basisWorker$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/basisWorker.js [app-ssr] (ecmascript)");
;
;
;
;
class BasisFileInfo {
}
/**
 * Result of transcoding a basis file
 */ class TranscodeResult {
}
class BasisTranscodeConfiguration {
}
/**
 * @internal
 * Enum of basis transcoder formats
 */ var BASIS_FORMATS;
(function(BASIS_FORMATS) {
    BASIS_FORMATS[BASIS_FORMATS["cTFETC1"] = 0] = "cTFETC1";
    BASIS_FORMATS[BASIS_FORMATS["cTFETC2"] = 1] = "cTFETC2";
    BASIS_FORMATS[BASIS_FORMATS["cTFBC1"] = 2] = "cTFBC1";
    BASIS_FORMATS[BASIS_FORMATS["cTFBC3"] = 3] = "cTFBC3";
    BASIS_FORMATS[BASIS_FORMATS["cTFBC4"] = 4] = "cTFBC4";
    BASIS_FORMATS[BASIS_FORMATS["cTFBC5"] = 5] = "cTFBC5";
    BASIS_FORMATS[BASIS_FORMATS["cTFBC7"] = 6] = "cTFBC7";
    BASIS_FORMATS[BASIS_FORMATS["cTFPVRTC1_4_RGB"] = 8] = "cTFPVRTC1_4_RGB";
    BASIS_FORMATS[BASIS_FORMATS["cTFPVRTC1_4_RGBA"] = 9] = "cTFPVRTC1_4_RGBA";
    BASIS_FORMATS[BASIS_FORMATS["cTFASTC_4x4"] = 10] = "cTFASTC_4x4";
    BASIS_FORMATS[BASIS_FORMATS["cTFATC_RGB"] = 11] = "cTFATC_RGB";
    BASIS_FORMATS[BASIS_FORMATS["cTFATC_RGBA_INTERPOLATED_ALPHA"] = 12] = "cTFATC_RGBA_INTERPOLATED_ALPHA";
    BASIS_FORMATS[BASIS_FORMATS["cTFRGBA32"] = 13] = "cTFRGBA32";
    BASIS_FORMATS[BASIS_FORMATS["cTFRGB565"] = 14] = "cTFRGB565";
    BASIS_FORMATS[BASIS_FORMATS["cTFBGR565"] = 15] = "cTFBGR565";
    BASIS_FORMATS[BASIS_FORMATS["cTFRGBA4444"] = 16] = "cTFRGBA4444";
    BASIS_FORMATS[BASIS_FORMATS["cTFFXT1_RGB"] = 17] = "cTFFXT1_RGB";
    BASIS_FORMATS[BASIS_FORMATS["cTFPVRTC2_4_RGB"] = 18] = "cTFPVRTC2_4_RGB";
    BASIS_FORMATS[BASIS_FORMATS["cTFPVRTC2_4_RGBA"] = 19] = "cTFPVRTC2_4_RGBA";
    BASIS_FORMATS[BASIS_FORMATS["cTFETC2_EAC_R11"] = 20] = "cTFETC2_EAC_R11";
    BASIS_FORMATS[BASIS_FORMATS["cTFETC2_EAC_RG11"] = 21] = "cTFETC2_EAC_RG11";
})(BASIS_FORMATS || (BASIS_FORMATS = {}));
const BasisToolsOptions = {
    /**
     * URL to use when loading the basis transcoder
     */ JSModuleURL: `${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"]._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,
    /**
     * URL to use when loading the wasm module for the transcoder
     */ WasmModuleURL: `${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"]._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`
};
const GetInternalFormatFromBasisFormat = (basisFormat, engine)=>{
    let format;
    switch(basisFormat){
        case BASIS_FORMATS.cTFETC1:
            format = 36196;
            break;
        case BASIS_FORMATS.cTFBC1:
            format = 33776;
            break;
        case BASIS_FORMATS.cTFBC4:
            format = 33779;
            break;
        case BASIS_FORMATS.cTFASTC_4x4:
            format = 37808;
            break;
        case BASIS_FORMATS.cTFETC2:
            format = 37496;
            break;
        case BASIS_FORMATS.cTFBC7:
            format = 36492;
            break;
    }
    if (format === undefined) {
        // eslint-disable-next-line no-throw-literal
        throw "The chosen Basis transcoder format is not currently supported";
    }
    return format;
};
let WorkerPromise = null;
let LocalWorker = null;
let ActionId = 0;
const IgnoreSupportedFormats = false;
const CreateWorkerAsync = async ()=>{
    if (!WorkerPromise) {
        WorkerPromise = new Promise((res, reject)=>{
            if (LocalWorker) {
                res(LocalWorker);
            } else {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].LoadFileAsync(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].GetBabylonScriptURL(BasisToolsOptions.WasmModuleURL))// eslint-disable-next-line github/no-then
                .then((wasmBinary)=>{
                    if (typeof URL !== "function") {
                        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
                        return reject("Basis transcoder requires an environment with a URL constructor");
                    }
                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                    const workerBlobUrl = URL.createObjectURL(new Blob([
                        `(${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$basisWorker$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["workerFunction"]})()`
                    ], {
                        type: "application/javascript"
                    }));
                    LocalWorker = new Worker(workerBlobUrl);
                    // eslint-disable-next-line github/no-then
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$basisWorker$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["initializeWebWorker"])(LocalWorker, wasmBinary, BasisToolsOptions.JSModuleURL).then(res, reject);
                })// eslint-disable-next-line github/no-then
                .catch(reject);
            }
        });
    }
    return await WorkerPromise;
};
const SetBasisTranscoderWorker = (worker)=>{
    LocalWorker = worker;
};
const TranscodeAsync = async (data, config)=>{
    const dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;
    return await new Promise((res, rej)=>{
        // eslint-disable-next-line github/no-then
        CreateWorkerAsync().then(()=>{
            const actionId = ActionId++;
            const messageHandler = (msg)=>{
                if (msg.data.action === "transcode" && msg.data.id === actionId) {
                    LocalWorker.removeEventListener("message", messageHandler);
                    if (!msg.data.success) {
                        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
                        rej("Transcode is not supported on this device");
                    } else {
                        res(msg.data);
                    }
                }
            };
            LocalWorker.addEventListener("message", messageHandler);
            const dataViewCopy = new Uint8Array(dataView.byteLength);
            dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));
            LocalWorker.postMessage({
                action: "transcode",
                id: actionId,
                imageData: dataViewCopy,
                config: config,
                ignoreSupportedFormats: IgnoreSupportedFormats
            }, [
                dataViewCopy.buffer
            ]);
        }, (error)=>{
            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
            rej(error);
        });
    });
};
/**
 * Binds a texture according to its underlying target.
 * @param texture texture to bind
 * @param engine the engine to bind the texture in
 */ const BindTexture = (texture, engine)=>{
    let target = engine._gl?.TEXTURE_2D;
    if (texture.isCube) {
        target = engine._gl?.TEXTURE_CUBE_MAP;
    }
    engine._bindTextureDirectly(target, texture, true);
};
const LoadTextureFromTranscodeResult = (texture, transcodeResult)=>{
    const engine = texture.getEngine();
    for(let i = 0; i < transcodeResult.fileInfo.images.length; i++){
        const rootImage = transcodeResult.fileInfo.images[i].levels[0];
        texture._invertVScale = texture.invertY;
        if (transcodeResult.format === -1 || transcodeResult.format === BASIS_FORMATS.cTFRGB565) {
            // No compatable compressed format found, fallback to RGB
            texture.type = 10;
            texture.format = 4;
            if (engine._features.basisNeedsPOT && (Math.log2(rootImage.width) % 1 !== 0 || Math.log2(rootImage.height) % 1 !== 0)) {
                // Create non power of two texture
                const source = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$internalTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InternalTexture"](engine, 2 /* InternalTextureSource.Temp */ );
                texture._invertVScale = texture.invertY;
                source.type = 10;
                source.format = 4;
                // Fallback requires aligned width/height
                source.width = rootImage.width + 3 & ~3;
                source.height = rootImage.height + 3 & ~3;
                BindTexture(source, engine);
                engine._uploadDataToTextureDirectly(source, new Uint16Array(rootImage.transcodedPixels.buffer), i, 0, 4, true);
                // Resize to power of two
                engine._rescaleTexture(source, texture, engine.scenes[0], engine._getInternalFormat(4), ()=>{
                    engine._releaseTexture(source);
                    BindTexture(texture, engine);
                });
            } else {
                // Fallback is already inverted
                texture._invertVScale = !texture.invertY;
                // Upload directly
                texture.width = rootImage.width + 3 & ~3;
                texture.height = rootImage.height + 3 & ~3;
                texture.samplingMode = 2;
                BindTexture(texture, engine);
                engine._uploadDataToTextureDirectly(texture, new Uint16Array(rootImage.transcodedPixels.buffer), i, 0, 4, true);
            }
        } else {
            texture.width = rootImage.width;
            texture.height = rootImage.height;
            texture.generateMipMaps = transcodeResult.fileInfo.images[i].levels.length > 1;
            const format = BasisTools.GetInternalFormatFromBasisFormat(transcodeResult.format, engine);
            texture.format = format;
            BindTexture(texture, engine);
            // Upload all mip levels in the file
            const levels = transcodeResult.fileInfo.images[i].levels;
            for(let index = 0; index < levels.length; index++){
                const level = levels[index];
                engine._uploadCompressedDataToTextureDirectly(texture, format, level.width, level.height, level.transcodedPixels, i, index);
            }
            if (engine._features.basisNeedsPOT && (Math.log2(texture.width) % 1 !== 0 || Math.log2(texture.height) % 1 !== 0)) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1.");
                texture._cachedWrapU = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].CLAMP_ADDRESSMODE;
                texture._cachedWrapV = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].CLAMP_ADDRESSMODE;
            }
        }
    }
};
const BasisTools = {
    /**
     * URL to use when loading the basis transcoder
     */ JSModuleURL: BasisToolsOptions.JSModuleURL,
    /**
     * URL to use when loading the wasm module for the transcoder
     */ WasmModuleURL: BasisToolsOptions.WasmModuleURL,
    /**
     * Get the internal format to be passed to texImage2D corresponding to the .basis format value
     * @param basisFormat format chosen from GetSupportedTranscodeFormat
     * @returns internal format corresponding to the Basis format
     */ GetInternalFormatFromBasisFormat,
    /**
     * Transcodes a loaded image file to compressed pixel data
     * @param data image data to transcode
     * @param config configuration options for the transcoding
     * @returns a promise resulting in the transcoded image
     */ TranscodeAsync,
    /**
     * Loads a texture from the transcode result
     * @param texture texture load to
     * @param transcodeResult the result of transcoding the basis file to load from
     */ LoadTextureFromTranscodeResult
};
Object.defineProperty(BasisTools, "JSModuleURL", {
    get: function() {
        return BasisToolsOptions.JSModuleURL;
    },
    set: function(value) {
        BasisToolsOptions.JSModuleURL = value;
    }
});
Object.defineProperty(BasisTools, "WasmModuleURL", {
    get: function() {
        return BasisToolsOptions.WasmModuleURL;
    },
    set: function(value) {
        BasisToolsOptions.WasmModuleURL = value;
    }
}); //# sourceMappingURL=basis.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/greasedLineTools.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GreasedLineTools",
    ()=>GreasedLineTools
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$path$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.path.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Buffers/buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$textBuilder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/Builders/textBuilder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$rawTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/Textures/rawTexture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Engines/engine.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$GreasedLine$2f$greasedLineMaterialDefaults$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/GreasedLine/greasedLineMaterialDefaults.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
class GreasedLineTools {
    /**
     * Converts GreasedLinePoints to number[][]
     * @param points GreasedLinePoints
     * @param options GreasedLineToolsConvertPointsOptions
     * @returns number[][] with x, y, z coordinates of the points, like [[x, y, z, x, y, z, ...], [x, y, z, ...]]
     */ static ConvertPoints(points, options) {
        if (points.length && Array.isArray(points) && typeof points[0] === "number") {
            return [
                points
            ];
        } else if (points.length && Array.isArray(points[0]) && typeof points[0][0] === "number") {
            return points;
        } else if (points.length && !Array.isArray(points[0]) && points[0] instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"]) {
            const positions = [];
            for(let j = 0; j < points.length; j++){
                const p = points[j];
                positions.push(p.x, p.y, p.z);
            }
            return [
                positions
            ];
        } else if (points.length > 0 && Array.isArray(points[0]) && points[0].length > 0 && points[0][0] instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"]) {
            const positions = [];
            const vectorPoints = points;
            for (const p of vectorPoints){
                positions.push(p.flatMap((p2)=>[
                        p2.x,
                        p2.y,
                        p2.z
                    ]));
            }
            return positions;
        } else if (points instanceof Float32Array) {
            if (options?.floatArrayStride) {
                const positions = [];
                const stride = options.floatArrayStride * 3;
                for(let i = 0; i < points.length; i += stride){
                    const linePoints = new Array(stride); // Pre-allocate memory for the line
                    for(let j = 0; j < stride; j++){
                        linePoints[j] = points[i + j];
                    }
                    positions.push(linePoints);
                }
                return positions;
            } else {
                return [
                    Array.from(points)
                ];
            }
        } else if (points.length && points[0] instanceof Float32Array) {
            const positions = [];
            for (const p of points){
                positions.push(Array.from(p));
            }
            return positions;
        }
        return [];
    }
    /**
     * Omit zero length lines predicate for the MeshesToLines function
     * @param p1 point1 position of the face
     * @param p2 point2 position of the face
     * @param p3 point3 position of the face
     * @returns original points or null if any edge length is zero
     */ static OmitZeroLengthPredicate(p1, p2, p3) {
        const fileredPoints = [];
        // edge1
        if (p2.subtract(p1).lengthSquared() > 0) {
            fileredPoints.push([
                p1,
                p2
            ]);
        }
        // edge2
        if (p3.subtract(p2).lengthSquared() > 0) {
            fileredPoints.push([
                p2,
                p3
            ]);
        }
        // edge3
        if (p1.subtract(p3).lengthSquared() > 0) {
            fileredPoints.push([
                p3,
                p1
            ]);
        }
        return fileredPoints.length === 0 ? null : fileredPoints;
    }
    /**
     * Omit duplicate lines predicate for the MeshesToLines function
     * @param p1 point1 position of the face
     * @param p2 point2 position of the face
     * @param p3 point3 position of the face
     * @param points array of points to search in
     * @returns original points or null if any edge length is zero
     */ static OmitDuplicatesPredicate(p1, p2, p3, points) {
        const fileredPoints = [];
        // edge1
        if (!GreasedLineTools._SearchInPoints(p1, p2, points)) {
            fileredPoints.push([
                p1,
                p2
            ]);
        }
        // edge2
        if (!GreasedLineTools._SearchInPoints(p2, p3, points)) {
            fileredPoints.push([
                p2,
                p3
            ]);
        }
        // edge3
        if (!GreasedLineTools._SearchInPoints(p3, p1, points)) {
            fileredPoints.push([
                p3,
                p1
            ]);
        }
        return fileredPoints.length === 0 ? null : fileredPoints;
    }
    static _SearchInPoints(p1, p2, points) {
        for (const ps of points){
            for(let i = 0; i < ps.length; i++){
                if (ps[i]?.equals(p1)) {
                    // find the first point
                    // if it has a sibling of p2 the line already exists
                    if (ps[i + 1]?.equals(p2) || ps[i - 1]?.equals(p2)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    /**
     * Gets mesh triangles as line positions
     * @param meshes array of meshes
     * @param predicate predicate function which decides whether to include the mesh triangle/face in the ouput
     * @returns array of arrays of points
     */ static MeshesToLines(meshes, predicate) {
        const points = [];
        for(let meshIndex = 0; meshIndex < meshes.length; meshIndex++){
            const mesh = meshes[meshIndex];
            const vertices = mesh.getVerticesData(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Buffers$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VertexBuffer"].PositionKind);
            const indices = mesh.getIndices();
            if (vertices && indices) {
                for(let i = 0, ii = 0; i < indices.length; i++){
                    const vi1 = indices[ii++] * 3;
                    const vi2 = indices[ii++] * 3;
                    const vi3 = indices[ii++] * 3;
                    const p1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](vertices[vi1], vertices[vi1 + 1], vertices[vi1 + 2]);
                    const p2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](vertices[vi2], vertices[vi2 + 1], vertices[vi2 + 2]);
                    const p3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](vertices[vi3], vertices[vi3 + 1], vertices[vi3 + 2]);
                    if (predicate) {
                        const pointsFromPredicate = predicate(p1, p2, p3, points, i, vi1, mesh, meshIndex, vertices, indices);
                        if (pointsFromPredicate) {
                            for (const p of pointsFromPredicate){
                                points.push(p);
                            }
                        }
                    } else {
                        points.push([
                            p1,
                            p2
                        ], [
                            p2,
                            p3
                        ], [
                            p3,
                            p1
                        ]);
                    }
                }
            }
        }
        return points;
    }
    /**
     * Converts number coordinates to Vector3s
     * @param points number array of x, y, z, x, y z, ... coordinates
     * @returns Vector3 array
     */ static ToVector3Array(points) {
        if (Array.isArray(points[0])) {
            const array = [];
            const inputArray = points;
            for (const subInputArray of inputArray){
                const subArray = [];
                for(let i = 0; i < subInputArray.length; i += 3){
                    subArray.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](subInputArray[i], subInputArray[i + 1], subInputArray[i + 2]));
                }
                array.push(subArray);
            }
            return array;
        }
        const inputArray = points;
        const array = [];
        for(let i = 0; i < inputArray.length; i += 3){
            array.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](inputArray[i], inputArray[i + 1], inputArray[i + 2]));
        }
        return array;
    }
    /**
     * Gets a number array from a Vector3 array.
     * You can you for example to convert your Vector3[] offsets to the required number[] for the offsets option.
     * @param points Vector3 array
     * @returns an array of x, y, z coordinates as numbers [x, y, z, x, y, z, x, y, z, ....]
     */ static ToNumberArray(points) {
        return points.flatMap((v)=>[
                v.x,
                v.y,
                v.z
            ]);
    }
    /**
     * Calculates the sum of points of every line and the number of points in each line.
     * This function is useful when you are drawing multiple lines in one mesh and you want
     * to know the counts. For example for creating an offsets table.
     * @param points point array
     * @returns points count info
     */ static GetPointsCountInfo(points) {
        const counts = new Array(points.length);
        let total = 0;
        for(let n = points.length; n--;){
            counts[n] = points[n].length / 3;
            total += counts[n];
        }
        return {
            total,
            counts
        };
    }
    /**
     * Gets the length of the line counting all it's segments length
     * @param data array of line points
     * @returns length of the line
     */ static GetLineLength(data) {
        if (data.length === 0) {
            return 0;
        }
        let points;
        if (typeof data[0] === "number") {
            points = GreasedLineTools.ToVector3Array(data);
        } else {
            points = data;
        }
        const tmp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[0];
        let length = 0;
        for(let index = 0; index < points.length - 1; index++){
            const point1 = points[index];
            const point2 = points[index + 1];
            length += point2.subtractToRef(point1, tmp).length();
        }
        return length;
    }
    /**
     * Gets the length from the beginning to each point of the line as array.
     * @param data array of line points
     * @param buf optional pre-allocated buffer to reduce memory pressure, should be at least `data.length * 4 / 3` bytes
     * @returns length array of the line
     */ static GetLineLengthArray(data, buf) {
        const out = buf ? new Float32Array(buf, 0, data.length / 3) : new Float32Array(data.length / 3);
        let length = 0;
        for(let index = 0, pointsLength = data.length / 3 - 1; index < pointsLength; index++){
            let x = data[index * 3 + 0];
            let y = data[index * 3 + 1];
            let z = data[index * 3 + 2];
            x -= data[index * 3 + 3];
            y -= data[index * 3 + 4];
            z -= data[index * 3 + 5];
            const currentLength = Math.sqrt(x * x + y * y + z * z);
            length += currentLength;
            out[index + 1] = length;
        }
        return out;
    }
    /**
     * Divides a segment into smaller segments.
     * A segment is a part of the line between it's two points.
     * @param point1 first point of the line
     * @param point2 second point of the line
     * @param segmentCount number of segments we want to have in the divided line
     * @returns
     */ static SegmentizeSegmentByCount(point1, point2, segmentCount) {
        const dividedLinePoints = [];
        const diff = point2.subtract(point1);
        const divisor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[0];
        divisor.setAll(segmentCount);
        const segmentVector = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[1];
        diff.divideToRef(divisor, segmentVector);
        let nextPoint = point1.clone();
        dividedLinePoints.push(nextPoint);
        for(let index = 0; index < segmentCount; index++){
            nextPoint = nextPoint.clone();
            dividedLinePoints.push(nextPoint.addInPlace(segmentVector));
        }
        return dividedLinePoints;
    }
    /**
     * Divides a line into segments.
     * A segment is a part of the line between it's two points.
     * @param what line points
     * @param segmentLength length of each segment of the resulting line (distance between two line points)
     * @returns line point
     */ static SegmentizeLineBySegmentLength(what, segmentLength) {
        const subLines = what[0] instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"] ? GreasedLineTools.GetLineSegments(what) : typeof what[0] === "number" ? GreasedLineTools.GetLineSegments(GreasedLineTools.ToVector3Array(what)) : what;
        const points = [];
        for (const s of subLines){
            if (s.length > segmentLength) {
                const segments = GreasedLineTools.SegmentizeSegmentByCount(s.point1, s.point2, Math.ceil(s.length / segmentLength));
                for (const seg of segments){
                    points.push(seg);
                }
            } else {
                points.push(s.point1);
                points.push(s.point2);
            }
        }
        return points;
    }
    /**
     * Divides a line into segments.
     * A segment is a part of the line between it's two points.
     * @param what line points
     * @param segmentCount number of segments
     * @returns line point
     */ static SegmentizeLineBySegmentCount(what, segmentCount) {
        const points = typeof what[0] === "number" ? GreasedLineTools.ToVector3Array(what) : what;
        const segmentLength = GreasedLineTools.GetLineLength(points) / segmentCount;
        return GreasedLineTools.SegmentizeLineBySegmentLength(points, segmentLength);
    }
    /**
     * Gets line segments.
     * A segment is a part of the line between it's two points.
     * @param points line points
     * @returns segments information of the line segment including starting point, ending point and the distance between them
     */ static GetLineSegments(points) {
        const segments = [];
        for(let index = 0; index < points.length - 1; index++){
            const point1 = points[index];
            const point2 = points[index + 1];
            const length = point2.subtract(point1).length();
            segments.push({
                point1,
                point2,
                length
            });
        }
        return segments;
    }
    /**
     * Gets the minimum and the maximum length of a line segment in the line.
     * A segment is a part of the line between it's two points.
     * @param points line points
     * @returns
     */ static GetMinMaxSegmentLength(points) {
        const subLines = GreasedLineTools.GetLineSegments(points);
        const sorted = subLines.sort((s)=>s.length);
        return {
            min: sorted[0].length,
            max: sorted[sorted.length - 1].length
        };
    }
    /**
     * Finds the last visible position in world space of the line according to the visibility parameter
     * @param lineSegments segments of the line
     * @param lineLength total length of the line
     * @param visbility normalized value of visibility
     * @param localSpace if true the result will be in local space (default is false)
     * @returns world space coordinate of the last visible piece of the line
     */ static GetPositionOnLineByVisibility(lineSegments, lineLength, visbility, localSpace = false) {
        const lengthVisibilityRatio = lineLength * visbility;
        let sumSegmentLengths = 0;
        let segmentIndex = 0;
        const lineSegmentsLength = lineSegments.length;
        for(let i = 0; i < lineSegmentsLength; i++){
            if (lengthVisibilityRatio <= sumSegmentLengths + lineSegments[i].length) {
                segmentIndex = i;
                break;
            }
            sumSegmentLengths += lineSegments[i].length;
        }
        const s = (lengthVisibilityRatio - sumSegmentLengths) / lineSegments[segmentIndex].length;
        lineSegments[segmentIndex].point2.subtractToRef(lineSegments[segmentIndex].point1, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[0]);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[1] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[0].multiplyByFloats(s, s, s);
        if (!localSpace) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[1].addInPlace(lineSegments[segmentIndex].point1);
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TmpVectors"].Vector3[1].clone();
    }
    /**
     * Creates lines in a shape of circle/arc.
     * A segment is a part of the line between it's two points.
     * @param radiusX radiusX of the circle
     * @param segments number of segments in the circle
     * @param z z coordinate of the points. Defaults to 0.
     * @param radiusY radiusY of the circle - you can draw an oval if using different values
     * @param segmentAngle angle offset of the segments. Defaults to Math.PI * 2 / segments. Change this value to draw a part of the circle.
     * @returns line points
     */ static GetCircleLinePoints(radiusX, segments, z = 0, radiusY = radiusX, segmentAngle = Math.PI * 2 / segments) {
        const points = [];
        for(let i = 0; i <= segments; i++){
            points.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](Math.cos(i * segmentAngle) * radiusX, Math.sin(i * segmentAngle) * radiusY, z));
        }
        return points;
    }
    /**
     * Gets line points in a shape of a bezier curve
     * @param p0 bezier point0
     * @param p1 bezier point1
     * @param p2 bezier point2
     * @param segments number of segments in the curve
     * @returns
     */ static GetBezierLinePoints(p0, p1, p2, segments) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$path$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Curve3"].CreateQuadraticBezier(p0, p1, p2, segments).getPoints().flatMap((v)=>[
                v.x,
                v.y,
                v.z
            ]);
    }
    /**
     *
     * @param position position of the arrow cap (mainly you want to create a triangle, set widthUp and widthDown to the same value and omit widthStartUp and widthStartDown)
     * @param direction direction which the arrow points to
     * @param length length (size) of the arrow cap itself
     * @param widthUp the arrow width above the line
     * @param widthDown the arrow width belove the line
     * @param widthStartUp the arrow width at the start of the arrow above the line. In most scenarios this is 0.
     * @param widthStartDown the arrow width at the start of the arrow below the line. In most scenarios this is 0.
     * @returns
     */ static GetArrowCap(position, direction, length, widthUp, widthDown, widthStartUp = 0, widthStartDown = 0) {
        const points = [
            position.clone(),
            position.add(direction.multiplyByFloats(length, length, length))
        ];
        const widths = [
            widthUp,
            widthDown,
            widthStartUp,
            widthStartDown
        ];
        return {
            points,
            widths
        };
    }
    /**
     * Gets 3D positions of points from a text and font
     * @param text Text
     * @param size Size of the font
     * @param resolution Resolution of the font
     * @param fontData defines the font data (can be generated with http://gero3.github.io/facetype.js/)
     * @param z z coordinate
     * @param includeInner include the inner parts of the font in the result. Default true. If false, only the outlines will be returned.
     * @returns number[][] of 3D positions
     */ static GetPointsFromText(text, size, resolution, fontData, z = 0, includeInner = true) {
        const allPoints = [];
        const shapePaths = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$Builders$2f$textBuilder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CreateTextShapePaths"])(text, size, resolution, fontData);
        for (const sp of shapePaths){
            for (const p of sp.paths){
                const points = [];
                const points2d = p.getPoints();
                for (const p2d of points2d){
                    points.push(p2d.x, p2d.y, z);
                }
                allPoints.push(points);
            }
            if (includeInner) {
                for (const h of sp.holes){
                    const holes = [];
                    const points2d = h.getPoints();
                    for (const p2d of points2d){
                        holes.push(p2d.x, p2d.y, z);
                    }
                    allPoints.push(holes);
                }
            }
        }
        return allPoints;
    }
    /**
     * Converts an array of Color3 to Uint8Array
     * @param colors Arrray of Color3
     * @returns Uin8Array of colors [r, g, b, a, r, g, b, a, ...]
     */ static Color3toRGBAUint8(colors) {
        const colorTable = new Uint8Array(colors.length * 4);
        for(let i = 0, j = 0; i < colors.length; i++){
            colorTable[j++] = colors[i].r * 255;
            colorTable[j++] = colors[i].g * 255;
            colorTable[j++] = colors[i].b * 255;
            colorTable[j++] = 255;
        }
        return colorTable;
    }
    /**
     * Creates a RawTexture from an RGBA color array and sets it on the plugin material instance.
     * @param name name of the texture
     * @param colors Uint8Array of colors
     * @param colorsSampling sampling mode of the created texture
     * @param scene Scene
     * @returns the colors texture
     */ static CreateColorsTexture(name, colors, colorsSampling, scene) {
        const maxTextureSize = scene.getEngine().getCaps().maxTextureSize ?? 1;
        const width = colors.length > maxTextureSize ? maxTextureSize : colors.length;
        const height = Math.ceil(colors.length / maxTextureSize);
        if (height > 1) {
            colors = [
                ...colors,
                ...Array(width * height - colors.length).fill(colors[0])
            ];
        }
        const colorsArray = GreasedLineTools.Color3toRGBAUint8(colors);
        const colorsTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$rawTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RawTexture"](colorsArray, width, height, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Engine"].TEXTUREFORMAT_RGBA, scene, false, true, colorsSampling);
        colorsTexture.name = name;
        return colorsTexture;
    }
    /**
     * A minimum size texture for the colors sampler2D when there is no colors texture defined yet.
     * For fast switching using the useColors property without the need to use defines.
     * @param scene Scene
     * @returns empty colors texture
     */ static PrepareEmptyColorsTexture(scene) {
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$GreasedLine$2f$greasedLineMaterialDefaults$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GreasedLineMaterialDefaults"].EmptyColorsTexture) {
            const colorsArray = new Uint8Array(4);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$GreasedLine$2f$greasedLineMaterialDefaults$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GreasedLineMaterialDefaults"].EmptyColorsTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$rawTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RawTexture"](colorsArray, 1, 1, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Engine"].TEXTUREFORMAT_RGBA, scene, false, false, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$rawTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RawTexture"].NEAREST_NEAREST);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$GreasedLine$2f$greasedLineMaterialDefaults$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GreasedLineMaterialDefaults"].EmptyColorsTexture.name = "grlEmptyColorsTexture";
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$GreasedLine$2f$greasedLineMaterialDefaults$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GreasedLineMaterialDefaults"].EmptyColorsTexture;
    }
    /**
     * Diposes the shared empty colors texture
     */ static DisposeEmptyColorsTexture() {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$GreasedLine$2f$greasedLineMaterialDefaults$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GreasedLineMaterialDefaults"].EmptyColorsTexture?.dispose();
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$GreasedLine$2f$greasedLineMaterialDefaults$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GreasedLineMaterialDefaults"].EmptyColorsTexture = null;
    }
    /**
     * Converts boolean to number.
     * @param bool the bool value
     * @returns 1 if true, 0 if false.
     */ static BooleanToNumber(bool) {
        return bool ? 1 : 0;
    }
} //# sourceMappingURL=greasedLineTools.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/deepMerger.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// https://stackoverflow.com/a/48218209
/**
 * Merges a series of objects into a single object, deeply.
 * @param objects The objects to merge (objects later in the list take precedence).
 * @returns The merged object.
 */ // eslint-disable-next-line @typescript-eslint/naming-convention
__turbopack_context__.s([
    "deepMerge",
    ()=>deepMerge
]);
function deepMerge(...objects) {
    const isRecord = (obj)=>!!obj && typeof obj === "object";
    return objects.reduce((prev, obj)=>{
        const keys = Object.keys(obj);
        for (const key of keys){
            const pVal = prev[key];
            const oVal = obj[key];
            if (Array.isArray(pVal) && Array.isArray(oVal)) {
                prev[key] = pVal.concat(...oVal);
            } else if (isRecord(pVal) && isRecord(oVal)) {
                prev[key] = deepMerge(pVal, oVal);
            } else {
                prev[key] = oVal;
            }
        }
        return prev;
    }, {});
} //# sourceMappingURL=deepMerger.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tools.internals.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint-disable @typescript-eslint/naming-convention */ /**
 * This file is only for internal use only and should not be used in your code
 */ __turbopack_context__.s([
    "_LoadScriptModuleAsync",
    ()=>_LoadScriptModuleAsync
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$domManagement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/domManagement.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tools.js [app-ssr] (ecmascript)");
;
;
let UniqueResolveID = 0;
async function _LoadScriptModuleAsync(scriptUrl, scriptId) {
    return await new Promise((resolve, reject)=>{
        // Need a relay
        let windowAsAny;
        let windowString;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$domManagement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["IsWindowObjectExist"])()) {
            windowAsAny = window;
            windowString = "window";
        } else if (typeof self !== "undefined") {
            windowAsAny = self;
            windowString = "self";
        } else {
            reject(new Error("Cannot load script module outside of a window or a worker"));
            return;
        }
        if (!windowAsAny._LoadScriptModuleResolve) {
            windowAsAny._LoadScriptModuleResolve = {};
        }
        windowAsAny._LoadScriptModuleResolve[UniqueResolveID] = resolve;
        scriptUrl += `
            ${windowString}._LoadScriptModuleResolve[${UniqueResolveID}](returnedValue);
            ${windowString}._LoadScriptModuleResolve[${UniqueResolveID}] = undefined;
        `;
        UniqueResolveID++;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].LoadScript(scriptUrl, undefined, (message, exception)=>{
            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
            reject(exception || new Error(message));
        }, scriptId, true);
    });
} //# sourceMappingURL=tools.internals.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/bitArray.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BitArray",
    ()=>BitArray
]);
function GetByteIndex(bitIndex) {
    return Math.floor(bitIndex / 8);
}
function GetBitMask(bitIndex) {
    return 1 << bitIndex % 8;
}
class BitArray {
    /**
     * Creates a new bit array with a fixed size.
     * @param size The number of bits to store.
     */ constructor(size){
        this.size = size;
        this._byteArray = new Uint8Array(Math.ceil(this.size / 8));
    }
    /**
     * Gets the current value at the specified index.
     * @param bitIndex The index to get the value from.
     * @returns The value at the specified index.
     */ get(bitIndex) {
        if (bitIndex >= this.size) {
            throw new RangeError("Bit index out of range");
        }
        const byteIndex = GetByteIndex(bitIndex);
        const bitMask = GetBitMask(bitIndex);
        return (this._byteArray[byteIndex] & bitMask) !== 0;
    }
    /**
     * Sets the value at the specified index.
     * @param bitIndex The index to set the value at.
     * @param value The value to set.
     */ set(bitIndex, value) {
        if (bitIndex >= this.size) {
            throw new RangeError("Bit index out of range");
        }
        const byteIndex = GetByteIndex(bitIndex);
        const bitMask = GetBitMask(bitIndex);
        if (value) {
            this._byteArray[byteIndex] |= bitMask;
        } else {
            this._byteArray[byteIndex] &= ~bitMask;
        }
    }
} //# sourceMappingURL=bitArray.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/assetsManager.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AbstractAssetTask",
    ()=>AbstractAssetTask,
    "AnimationAssetTask",
    ()=>AnimationAssetTask,
    "AssetTaskState",
    ()=>AssetTaskState,
    "AssetsManager",
    ()=>AssetsManager,
    "AssetsProgressEvent",
    ()=>AssetsProgressEvent,
    "BinaryFileAssetTask",
    ()=>BinaryFileAssetTask,
    "ContainerAssetTask",
    ()=>ContainerAssetTask,
    "CubeTextureAssetTask",
    ()=>CubeTextureAssetTask,
    "EquiRectangularCubeTextureAssetTask",
    ()=>EquiRectangularCubeTextureAssetTask,
    "HDRCubeTextureAssetTask",
    ()=>HDRCubeTextureAssetTask,
    "ImageAssetTask",
    ()=>ImageAssetTask,
    "MeshAssetTask",
    ()=>MeshAssetTask,
    "TextFileAssetTask",
    ()=>TextFileAssetTask,
    "TextureAssetTask",
    ()=>TextureAssetTask
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Loading$2f$sceneLoader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Loading/sceneLoader.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/observable.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/Textures/texture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$cubeTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/Textures/cubeTexture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$hdrCubeTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/Textures/hdrCubeTexture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$equiRectangularCubeTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/Textures/equiRectangularCubeTexture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/logger.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engineStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Engines/engineStore.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
var AssetTaskState;
(function(AssetTaskState) {
    /**
     * Initialization
     */ AssetTaskState[AssetTaskState["INIT"] = 0] = "INIT";
    /**
     * Running
     */ AssetTaskState[AssetTaskState["RUNNING"] = 1] = "RUNNING";
    /**
     * Done
     */ AssetTaskState[AssetTaskState["DONE"] = 2] = "DONE";
    /**
     * Error
     */ AssetTaskState[AssetTaskState["ERROR"] = 3] = "ERROR";
})(AssetTaskState || (AssetTaskState = {}));
class AbstractAssetTask {
    /**
     * Creates a new AssetsManager
     * @param name defines the name of the task
     */ constructor(/**
     * Task name
     */ name){
        this.name = name;
        this._isCompleted = false;
        this._taskState = 0 /* AssetTaskState.INIT */ ;
    }
    /**
     * Get if the task is completed
     */ get isCompleted() {
        return this._isCompleted;
    }
    /**
     * Gets the current state of the task
     */ get taskState() {
        return this._taskState;
    }
    /**
     * Gets the current error object (if task is in error)
     */ get errorObject() {
        return this._errorObject;
    }
    /**
     * Internal only
     * @internal
     */ _setErrorObject(message, exception) {
        if (this._errorObject) {
            return;
        }
        this._errorObject = {
            message: message,
            exception: exception
        };
    }
    /**
     * Execute the current task
     * @param scene defines the scene where you want your assets to be loaded
     * @param onSuccess is a callback called when the task is successfully executed
     * @param onError is a callback called if an error occurs
     */ run(scene, onSuccess, onError) {
        this._taskState = 1 /* AssetTaskState.RUNNING */ ;
        this.runTask(scene, ()=>{
            this._onDoneCallback(onSuccess, onError);
        }, (msg, exception)=>{
            this._onErrorCallback(onError, msg, exception);
        });
    }
    /**
     * Execute the current task
     * @param scene defines the scene where you want your assets to be loaded
     * @param onSuccess is a callback called when the task is successfully executed
     * @param onError is a callback called if an error occurs
     */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    runTask(scene, onSuccess, onError) {
        throw new Error("runTask is not implemented");
    }
    /**
     * Reset will set the task state back to INIT, so the next load call of the assets manager will execute this task again.
     * This can be used with failed tasks that have the reason for failure fixed.
     */ reset() {
        this._taskState = 0 /* AssetTaskState.INIT */ ;
    }
    _onErrorCallback(onError, message, exception) {
        this._taskState = 3 /* AssetTaskState.ERROR */ ;
        this._errorObject = {
            message: message,
            exception: exception
        };
        if (this.onError) {
            this.onError(this, message, exception);
        }
        onError();
    }
    _onDoneCallback(onSuccess, onError) {
        try {
            this._taskState = 2 /* AssetTaskState.DONE */ ;
            this._isCompleted = true;
            if (this.onSuccess) {
                this.onSuccess(this);
            }
            onSuccess();
        } catch (e) {
            this._onErrorCallback(onError, "Task is done, error executing success callback(s)", e);
        }
    }
}
class AssetsProgressEvent {
    /**
     * Creates a AssetsProgressEvent
     * @param remainingCount defines the number of remaining tasks to process
     * @param totalCount defines the total number of tasks
     * @param task defines the task that was just processed
     */ constructor(remainingCount, totalCount, task){
        this.remainingCount = remainingCount;
        this.totalCount = totalCount;
        this.task = task;
    }
}
class ContainerAssetTask extends AbstractAssetTask {
    /**
     * Creates a new ContainerAssetTask
     * @param name defines the name of the task
     * @param meshesNames defines the list of mesh's names you want to load
     * @param rootUrl defines the root url to use as a base to load your meshes and associated resources
     * @param sceneFilename defines the filename or File of the scene to load from
     * @param extension defines the extension to use to load the scene (if not defined, ".babylon" will be used)
     */ constructor(/**
     * Defines the name of the task
     */ name, /**
     * Defines the list of mesh's names you want to load
     */ meshesNames, /**
     * Defines the root url to use as a base to load your meshes and associated resources
     */ rootUrl, /**
     * Defines the filename or File of the scene to load from
     */ sceneFilename, /**
     * Defines the extension to use to load the scene (if not defined, ".babylon" will be used)
     */ extension){
        super(name);
        this.name = name;
        this.meshesNames = meshesNames;
        this.rootUrl = rootUrl;
        this.sceneFilename = sceneFilename;
        this.extension = extension;
    }
    /**
     * Execute the current task
     * @param scene defines the scene where you want your assets to be loaded
     * @param onSuccess is a callback called when the task is successfully executed
     * @param onError is a callback called if an error occurs
     */ runTask(scene, onSuccess, onError) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Loading$2f$sceneLoader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SceneLoader"].LoadAssetContainer(this.rootUrl, this.sceneFilename, scene, (container)=>{
            this.loadedContainer = container;
            this.loadedMeshes = container.meshes;
            this.loadedTransformNodes = container.transformNodes;
            this.loadedParticleSystems = container.particleSystems;
            this.loadedSkeletons = container.skeletons;
            this.loadedAnimationGroups = container.animationGroups;
            onSuccess();
        }, null, (scene, message, exception)=>{
            onError(message, exception);
        }, this.extension);
    }
}
class MeshAssetTask extends AbstractAssetTask {
    /**
     * Creates a new MeshAssetTask
     * @param name defines the name of the task
     * @param meshesNames defines the list of mesh's names you want to load
     * @param rootUrl defines the root url to use as a base to load your meshes and associated resources
     * @param sceneFilename defines the filename or File of the scene to load from
     * @param extension defines the extension to use to load the scene (if not defined, ".babylon" will be used)
     * @param fileName defines the name of the file, if the data is binary
     * @param pluginOptions defines the options to use with the plugin
     */ constructor(/**
     * Defines the name of the task
     */ name, /**
     * Defines the list of mesh's names you want to load
     */ meshesNames, /**
     * Defines the root url to use as a base to load your meshes and associated resources
     */ rootUrl, /**
     * Defines the filename or File of the scene to load from
     */ sceneFilename, /**
     * Defines the extension to use to load the scene (if not defined, ".babylon" will be used)
     */ extension, /**
     * defines the name of the file, if the data is binary
     */ fileName, /**
     * defines the options to use with the plugin
     */ pluginOptions){
        super(name);
        this.name = name;
        this.meshesNames = meshesNames;
        this.rootUrl = rootUrl;
        this.sceneFilename = sceneFilename;
        this.extension = extension;
        this.fileName = fileName;
        this.pluginOptions = pluginOptions;
    }
    /**
     * Execute the current task
     * @param scene defines the scene where you want your assets to be loaded
     * @param onSuccess is a callback called when the task is successfully executed
     * @param onError is a callback called if an error occurs
     */ runTask(scene, onSuccess, onError) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Loading$2f$sceneLoader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SceneLoader"].ImportMesh(this.meshesNames, this.rootUrl, this.sceneFilename, scene, (meshes, particleSystems, skeletons, animationGroups, transformNodes)=>{
            this.loadedMeshes = meshes;
            this.loadedTransformNodes = transformNodes;
            this.loadedParticleSystems = particleSystems;
            this.loadedSkeletons = skeletons;
            this.loadedAnimationGroups = animationGroups;
            onSuccess();
        }, null, (scene, message, exception)=>{
            onError(message, exception);
        }, this.extension, this.fileName, this.pluginOptions);
    }
}
class AnimationAssetTask extends AbstractAssetTask {
    /**
     * Creates a new AnimationAssetTask
     * @param name defines the name of the task
     * @param rootUrl defines the root url to use as a base to load your meshes and associated resources
     * @param filename defines the filename or File of the scene to load from
     * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)
     * @param extension defines the extension to use to load the scene (if not defined, ".babylon" will be used)
     */ constructor(/**
     * Defines the name of the task
     */ name, /**
     * Defines the root url to use as a base to load your meshes and associated resources
     */ rootUrl, /**
     * Defines the filename to load from
     */ filename, /**
     * Defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)
     */ targetConverter, /**
     * Defines the extension to use to load the scene (if not defined, ".babylon" will be used)
     */ extension){
        super(name);
        this.name = name;
        this.rootUrl = rootUrl;
        this.filename = filename;
        this.targetConverter = targetConverter;
        this.extension = extension;
    }
    /**
     * Execute the current task
     * @param scene defines the scene where you want your assets to be loaded
     * @param onSuccess is a callback called when the task is successfully executed
     * @param onError is a callback called if an error occurs
     */ runTask(scene, onSuccess, onError) {
        const startingIndexForNewAnimatables = scene.animatables.length;
        const startingIndexForNewAnimationGroups = scene.animationGroups.length;
        this.loadedAnimatables = [];
        this.loadedAnimationGroups = [];
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Loading$2f$sceneLoader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SceneLoader"].ImportAnimations(this.rootUrl, this.filename, scene, false, 3 /* SceneLoaderAnimationGroupLoadingMode.NoSync */ , this.targetConverter, ()=>{
            this.loadedAnimatables = scene.animatables.slice(startingIndexForNewAnimatables);
            this.loadedAnimationGroups = scene.animationGroups.slice(startingIndexForNewAnimationGroups);
            onSuccess();
        }, null, (scene, message, exception)=>{
            onError(message, exception);
        }, this.extension);
    }
}
class TextFileAssetTask extends AbstractAssetTask {
    /**
     * Creates a new TextFileAssetTask object
     * @param name defines the name of the task
     * @param url defines the location of the file to load
     */ constructor(/**
     * Defines the name of the task
     */ name, /**
     * Defines the location of the file to load
     */ url){
        super(name);
        this.name = name;
        this.url = url;
    }
    /**
     * Execute the current task
     * @param scene defines the scene where you want your assets to be loaded
     * @param onSuccess is a callback called when the task is successfully executed
     * @param onError is a callback called if an error occurs
     */ runTask(scene, onSuccess, onError) {
        scene._loadFile(this.url, (data)=>{
            this.text = data;
            onSuccess();
        }, undefined, false, false, (request, exception)=>{
            if (request) {
                onError(request.status + " " + request.statusText, exception);
            }
        });
    }
}
class BinaryFileAssetTask extends AbstractAssetTask {
    /**
     * Creates a new BinaryFileAssetTask object
     * @param name defines the name of the new task
     * @param url defines the location of the file to load
     */ constructor(/**
     * Defines the name of the task
     */ name, /**
     * Defines the location of the file to load
     */ url){
        super(name);
        this.name = name;
        this.url = url;
    }
    /**
     * Execute the current task
     * @param scene defines the scene where you want your assets to be loaded
     * @param onSuccess is a callback called when the task is successfully executed
     * @param onError is a callback called if an error occurs
     */ runTask(scene, onSuccess, onError) {
        scene._loadFile(this.url, (data)=>{
            this.data = data;
            onSuccess();
        }, undefined, true, true, (request, exception)=>{
            if (request) {
                onError(request.status + " " + request.statusText, exception);
            }
        });
    }
}
class ImageAssetTask extends AbstractAssetTask {
    /**
     * Creates a new ImageAssetTask
     * @param name defines the name of the task
     * @param url defines the location of the image to load
     */ constructor(/**
     * Defines the name of the task
     */ name, /**
     * Defines the location of the image to load
     */ url){
        super(name);
        this.name = name;
        this.url = url;
    }
    /**
     * Execute the current task
     * @param scene defines the scene where you want your assets to be loaded
     * @param onSuccess is a callback called when the task is successfully executed
     * @param onError is a callback called if an error occurs
     */ runTask(scene, onSuccess, onError) {
        const img = new Image();
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].SetCorsBehavior(this.url, img);
        img.onload = ()=>{
            this.image = img;
            onSuccess();
        };
        img.onerror = (err)=>{
            onError("Error loading image", err);
        };
        img.src = this.url;
    }
}
class TextureAssetTask extends AbstractAssetTask {
    /**
     * Creates a new TextureAssetTask object
     * @param name defines the name of the task
     * @param url defines the location of the file to load
     * @param noMipmapOrOptions defines if mipmap should not be generated (default is false) or the creation options to use
     * @param invertY defines if texture must be inverted on Y axis (default is true)
     * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)
     */ constructor(/**
     * Defines the name of the task
     */ name, /**
     * Defines the location of the file to load
     */ url, /**
     * Defines if mipmap should not be generated (default is false) or the creation options to use
     */ noMipmapOrOptions, /**
     * [true] Defines if texture must be inverted on Y axis (default is true)
     */ invertY = true, /**
     * [3] Defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)
     */ samplingMode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].TRILINEAR_SAMPLINGMODE){
        super(name);
        this.name = name;
        this.url = url;
        this.noMipmapOrOptions = noMipmapOrOptions;
        this.invertY = invertY;
        this.samplingMode = samplingMode;
    }
    /**
     * Execute the current task
     * @param scene defines the scene where you want your assets to be loaded
     * @param onSuccess is a callback called when the task is successfully executed
     * @param onError is a callback called if an error occurs
     */ runTask(scene, onSuccess, onError) {
        const onload = ()=>{
            onSuccess();
        };
        const onerror = (message, exception)=>{
            onError(message, exception);
        };
        this.texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"](this.url, scene, this.noMipmapOrOptions, this.invertY, this.samplingMode, onload, onerror);
    }
}
class CubeTextureAssetTask extends AbstractAssetTask {
    /**
     * Creates a new CubeTextureAssetTask
     * @param name defines the name of the task
     * @param url defines the location of the files to load (You have to specify the folder where the files are + filename with no extension)
     * @param extensionsOrOptions defines the suffixes add to the picture name in case six images are in use like _px.jpg or set of all options to create the cube texture
     * @param noMipmap defines if mipmaps should not be generated (default is false)
     * @param files defines the explicit list of files (undefined by default)
     * @param prefiltered
     */ constructor(/**
     * Defines the name of the task
     */ name, /**
     * Defines the location of the files to load (You have to specify the folder where the files are + filename with no extension)
     */ url, /**
     * Defines the suffixes add to the picture name in case six images are in use like _px.jpg or set of all options to create the cube texture
     */ extensionsOrOptions = null, /**
     * Defines if mipmaps should not be generated (default is false)
     */ noMipmap, /**
     * Defines the explicit list of files (undefined by default)
     */ files, /**
     * Defines the prefiltered texture option (default is false)
     */ prefiltered){
        super(name);
        this.name = name;
        this.url = url;
        this.extensionsOrOptions = extensionsOrOptions;
        this.noMipmap = noMipmap;
        this.files = files;
        this.prefiltered = prefiltered;
    }
    /**
     * Execute the current task
     * @param scene defines the scene where you want your assets to be loaded
     * @param onSuccess is a callback called when the task is successfully executed
     * @param onError is a callback called if an error occurs
     */ runTask(scene, onSuccess, onError) {
        const onload = ()=>{
            onSuccess();
        };
        const onerror = (message, exception)=>{
            onError(message, exception);
        };
        this.texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$cubeTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CubeTexture"](this.url, scene, this.extensionsOrOptions, this.noMipmap, this.files, onload, onerror, undefined, this.prefiltered);
    }
}
class HDRCubeTextureAssetTask extends AbstractAssetTask {
    /**
     * Creates a new HDRCubeTextureAssetTask object
     * @param name defines the name of the task
     * @param url defines the location of the file to load
     * @param size defines the desired size (the more it increases the longer the generation will be) If the size is omitted this implies you are using a preprocessed cubemap.
     * @param noMipmap defines if mipmaps should not be generated (default is false)
     * @param generateHarmonics specifies whether you want to extract the polynomial harmonics during the generation process (default is true)
     * @param gammaSpace specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)
     * @param prefilterOnLoad specifies if the texture should be prefiltered on load (default is false)
     * @param supersample specifies if the texture will be generated with super sampling (default is false)
     * @param prefilterIrradianceOnLoad specifies if the irradiance should be prefiltered on load (default is false)
     * @param prefilterUsingCdf specifies if the texture should be prefiltered using CDF (default is false)
     */ constructor(/**
     * Defines the name of the task
     */ name, /**
     * Defines the location of the file to load
     */ url, /**
     * Defines the desired size (the more it increases the longer the generation will be)
     */ size, /**
     * [false] Defines if mipmaps should not be generated (default is false)
     */ noMipmap = false, /**
     * [true] Specifies whether you want to extract the polynomial harmonics during the generation process (default is true)
     */ generateHarmonics = true, /**
     * [false] Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)
     */ gammaSpace = false, /**
     * [false] Specifies if the texture should be prefiltered on load (default is false)
     */ prefilterOnLoad = false, /**
     * [false] Specifies if the texture will be generated with super sampling (default is false)
     */ supersample = false, /**
     * [false] Specifies if the irradiance should be prefiltered on load (default is false)
     */ prefilterIrradianceOnLoad = false, /**
     * [false] Specifies if the texture should be prefiltered using CDF (default is false)
     */ prefilterUsingCdf = false){
        super(name);
        this.name = name;
        this.url = url;
        this.size = size;
        this.noMipmap = noMipmap;
        this.generateHarmonics = generateHarmonics;
        this.gammaSpace = gammaSpace;
        this.prefilterOnLoad = prefilterOnLoad;
        this.supersample = supersample;
        this.prefilterIrradianceOnLoad = prefilterIrradianceOnLoad;
        this.prefilterUsingCdf = prefilterUsingCdf;
    }
    /**
     * Execute the current task
     * @param scene defines the scene where you want your assets to be loaded
     * @param onSuccess is a callback called when the task is successfully executed
     * @param onError is a callback called if an error occurs
     */ runTask(scene, onSuccess, onError) {
        const onload = ()=>{
            onSuccess();
        };
        const onerror = (message, exception)=>{
            onError(message, exception);
        };
        this.texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$hdrCubeTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HDRCubeTexture"](this.url, scene, this.size, this.noMipmap, this.generateHarmonics, this.gammaSpace, this.prefilterOnLoad, onload, onerror, this.supersample, this.prefilterIrradianceOnLoad, this.prefilterUsingCdf);
    }
}
class EquiRectangularCubeTextureAssetTask extends AbstractAssetTask {
    /**
     * Creates a new EquiRectangularCubeTextureAssetTask object
     * @param name defines the name of the task
     * @param url defines the location of the file to load
     * @param size defines the desired size (the more it increases the longer the generation will be)
     * If the size is omitted this implies you are using a preprocessed cubemap.
     * @param noMipmap defines if mipmaps should not be generated (default is false)
     * @param gammaSpace specifies if the texture will be used in gamma or linear space
     * @param superSample specifies if the texture will be generated with super sampling (default is false)
     * (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space)
     * (default is true)
     */ constructor(/**
     * Defines the name of the task
     */ name, /**
     * Defines the location of the file to load
     */ url, /**
     * Defines the desired size (the more it increases the longer the generation will be)
     */ size, /**
     * [false] Defines if mipmaps should not be generated (default is false)
     */ noMipmap = false, /**
     * [true] Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space,
     * but the standard material would require them in Gamma space) (default is true)
     */ gammaSpace = true, superSample = false){
        super(name);
        this.name = name;
        this.url = url;
        this.size = size;
        this.noMipmap = noMipmap;
        this.gammaSpace = gammaSpace;
        this.superSample = superSample;
    }
    /**
     * Execute the current task
     * @param scene defines the scene where you want your assets to be loaded
     * @param onSuccess is a callback called when the task is successfully executed
     * @param onError is a callback called if an error occurs
     */ runTask(scene, onSuccess, onError) {
        const onload = ()=>{
            onSuccess();
        };
        const onerror = (message, exception)=>{
            onError(message, exception);
        };
        this.texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$equiRectangularCubeTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EquiRectangularCubeTexture"](this.url, scene, this.size, this.noMipmap, this.gammaSpace, onload, onerror, this.superSample);
    }
}
class AssetsManager {
    /**
     * Creates a new AssetsManager
     * @param scene defines the scene to work on
     */ constructor(scene){
        this._isLoading = false;
        this._tasks = new Array();
        this._waitingTasksCount = 0;
        this._totalTasksCount = 0;
        /**
         * Observable called when all tasks are processed
         */ this.onTaskSuccessObservable = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Observable"]();
        /**
         * Observable called when a task had an error
         */ this.onTaskErrorObservable = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Observable"]();
        /**
         * Observable called when all tasks were executed
         */ this.onTasksDoneObservable = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Observable"]();
        /**
         * Observable called when a task is done (whatever the result is)
         */ this.onProgressObservable = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Observable"]();
        /**
         * Gets or sets a boolean defining if the AssetsManager should use the default loading screen
         * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/customLoadingScreen
         */ this.useDefaultLoadingScreen = true;
        /**
         * Gets or sets a boolean defining if the AssetsManager should automatically hide the loading screen
         * when all assets have been downloaded.
         * If set to false, you need to manually call in hideLoadingUI() once your scene is ready.
         */ this.autoHideLoadingUI = true;
        this._scene = scene || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engineStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EngineStore"].LastCreatedScene;
    }
    /**
     * Add a ContainerAssetTask to the list of active tasks
     * @param taskName defines the name of the new task
     * @param meshesNames defines the name of meshes to load
     * @param rootUrl defines the root url to use to locate files
     * @param sceneFilename defines the filename of the scene file or the File itself
     * @param extension defines the extension to use to load the file
     * @returns a new ContainerAssetTask object
     */ addContainerTask(taskName, meshesNames, rootUrl, sceneFilename, extension) {
        const task = new ContainerAssetTask(taskName, meshesNames, rootUrl, sceneFilename, extension);
        this._tasks.push(task);
        return task;
    }
    /**
     * Add a MeshAssetTask to the list of active tasks
     * @param taskName defines the name of the new task
     * @param meshesNames defines the name of meshes to load
     * @param rootUrl defines the root url to use to locate files
     * @param sceneFilename defines the filename of the scene file or the File itself
     * @param extension defines the extension to use to load the file
     * @param filename defines the name of the file, if the data is binary
     * @param pluginOptions defines the options to use with the plugin
     * @returns a new MeshAssetTask object
     */ addMeshTask(taskName, meshesNames, rootUrl, sceneFilename, extension, filename, pluginOptions) {
        const task = new MeshAssetTask(taskName, meshesNames, rootUrl, sceneFilename, extension, filename, pluginOptions);
        this._tasks.push(task);
        return task;
    }
    /**
     * Add a TextFileAssetTask to the list of active tasks
     * @param taskName defines the name of the new task
     * @param url defines the url of the file to load
     * @returns a new TextFileAssetTask object
     */ addTextFileTask(taskName, url) {
        const task = new TextFileAssetTask(taskName, url);
        this._tasks.push(task);
        return task;
    }
    /**
     * Add a BinaryFileAssetTask to the list of active tasks
     * @param taskName defines the name of the new task
     * @param url defines the url of the file to load
     * @returns a new BinaryFileAssetTask object
     */ addBinaryFileTask(taskName, url) {
        const task = new BinaryFileAssetTask(taskName, url);
        this._tasks.push(task);
        return task;
    }
    /**
     * Add a ImageAssetTask to the list of active tasks
     * @param taskName defines the name of the new task
     * @param url defines the url of the file to load
     * @returns a new ImageAssetTask object
     */ addImageTask(taskName, url) {
        const task = new ImageAssetTask(taskName, url);
        this._tasks.push(task);
        return task;
    }
    /**
     * Add a TextureAssetTask to the list of active tasks
     * @param taskName defines the name of the new task
     * @param url defines the url of the file to load
     * @param noMipmapOrOptions defines if mipmap should not be generated (default is false) or the creation options to use
     * @param invertY defines if you want to invert Y axis of the loaded texture (true by default)
     * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)
     * @returns a new TextureAssetTask object
     */ addTextureTask(taskName, url, noMipmapOrOptions, invertY, samplingMode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].TRILINEAR_SAMPLINGMODE) {
        const task = new TextureAssetTask(taskName, url, noMipmapOrOptions, invertY, samplingMode);
        this._tasks.push(task);
        return task;
    }
    /**
     * Add a CubeTextureAssetTask to the list of active tasks
     * @param taskName defines the name of the new task
     * @param url defines the url of the file to load
     * @param extensionsOrOptions defines the extension to use to load the cube map (can be null) or the options to use for the cube texture
     * @param noMipmap defines if the texture must not receive mipmaps (false by default)
     * @param files defines the list of files to load (can be null)
     * @param prefiltered defines the prefiltered texture option (default is false)
     * @returns a new CubeTextureAssetTask object
     */ addCubeTextureTask(taskName, url, extensionsOrOptions, noMipmap, files, prefiltered) {
        const task = new CubeTextureAssetTask(taskName, url, extensionsOrOptions, noMipmap, files, prefiltered);
        this._tasks.push(task);
        return task;
    }
    /**
     *
     * Add a HDRCubeTextureAssetTask to the list of active tasks
     * @param taskName defines the name of the new task
     * @param url defines the url of the file to load
     * @param size defines the size you want for the cubemap (can be null)
     * @param noMipmap defines if the texture must not receive mipmaps (false by default)
     * @param generateHarmonics defines if you want to automatically generate (true by default)
     * @param gammaSpace specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)
     * @param prefilterOnLoad specifies if the texture should be prefiltered on load (default is false)
     * @param supersample specifies if the texture will be generated with super sampling (default is false)
     * @param prefilterIrradianceOnLoad specifies if the irradiance should be prefiltered on load (default is false)
     * @param prefilterUsingCdf specifies if the texture should be prefiltered using CDF (default is false)
     * @returns a new HDRCubeTextureAssetTask object
     */ addHDRCubeTextureTask(taskName, url, size, noMipmap = false, generateHarmonics = true, gammaSpace = false, prefilterOnLoad = false, supersample = false, prefilterIrradianceOnLoad = false, prefilterUsingCdf = false) {
        const task = new HDRCubeTextureAssetTask(taskName, url, size, noMipmap, generateHarmonics, gammaSpace, prefilterOnLoad, supersample, prefilterIrradianceOnLoad, prefilterUsingCdf);
        this._tasks.push(task);
        return task;
    }
    /**
     *
     * Add a EquiRectangularCubeTextureAssetTask to the list of active tasks
     * @param taskName defines the name of the new task
     * @param url defines the url of the file to load
     * @param size defines the size you want for the cubemap (can be null)
     * @param noMipmap defines if the texture must not receive mipmaps (false by default)
     * @param gammaSpace Specifies if the texture will be used in gamma or linear space
     * @param superSample specifies if the texture will be generated with super sampling (default is false)
     * (the PBR material requires those textures in linear space, but the standard material would require them in Gamma space)
     * @returns a new EquiRectangularCubeTextureAssetTask object
     */ addEquiRectangularCubeTextureAssetTask(taskName, url, size, noMipmap = false, gammaSpace = true, superSample = false) {
        const task = new EquiRectangularCubeTextureAssetTask(taskName, url, size, noMipmap, gammaSpace, superSample);
        this._tasks.push(task);
        return task;
    }
    /**
     * Remove a task from the assets manager.
     * @param task the task to remove
     */ removeTask(task) {
        const index = this._tasks.indexOf(task);
        if (index > -1) {
            this._tasks.splice(index, 1);
        }
    }
    _decreaseWaitingTasksCount(task) {
        this._waitingTasksCount--;
        try {
            if (this.onProgress) {
                this.onProgress(this._waitingTasksCount, this._totalTasksCount, task);
            }
            this.onProgressObservable.notifyObservers(new AssetsProgressEvent(this._waitingTasksCount, this._totalTasksCount, task));
        } catch (e) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Error("Error running progress callbacks.");
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Log(e);
        }
        if (this._waitingTasksCount === 0) {
            try {
                const currentTasks = this._tasks.slice();
                if (this.onFinish) {
                    // Calling onFinish with immutable array of tasks
                    this.onFinish(currentTasks);
                }
                // Let's remove successful tasks
                for (const task of currentTasks){
                    if (task.taskState === 2 /* AssetTaskState.DONE */ ) {
                        const index = this._tasks.indexOf(task);
                        if (index > -1) {
                            this._tasks.splice(index, 1);
                        }
                    }
                }
                this.onTasksDoneObservable.notifyObservers(this._tasks);
            } catch (e) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Error("Error running tasks-done callbacks.");
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Log(e);
            }
            this._isLoading = false;
            if (this.autoHideLoadingUI) {
                this._scene.getEngine().hideLoadingUI();
            }
        }
    }
    _runTask(task) {
        const done = ()=>{
            try {
                if (this.onTaskSuccess) {
                    this.onTaskSuccess(task);
                }
                this.onTaskSuccessObservable.notifyObservers(task);
                this._decreaseWaitingTasksCount(task);
            } catch (e) {
                error("Error executing task success callbacks", e);
            }
        };
        const error = (message, exception)=>{
            task._setErrorObject(message, exception);
            if (this.onTaskError) {
                this.onTaskError(task);
            } else if (!task.onError) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Error(this._formatTaskErrorMessage(task));
            }
            this.onTaskErrorObservable.notifyObservers(task);
            this._decreaseWaitingTasksCount(task);
        };
        task.run(this._scene, done, error);
    }
    _formatTaskErrorMessage(task) {
        let errorMessage = "Unable to complete task " + task.name;
        if (task.errorObject.message) {
            errorMessage += `: ${task.errorObject.message}`;
        }
        if (task.errorObject.exception) {
            errorMessage += `: ${task.errorObject.exception}`;
        }
        return errorMessage;
    }
    /**
     * Reset the AssetsManager and remove all tasks
     * @returns the current instance of the AssetsManager
     */ reset() {
        this._isLoading = false;
        this._tasks = new Array();
        return this;
    }
    /**
     * Start the loading process
     * @returns the current instance of the AssetsManager
     */ load() {
        if (this._isLoading) {
            return this;
        }
        this._isLoading = true;
        this._waitingTasksCount = this._tasks.length;
        this._totalTasksCount = this._tasks.length;
        if (this._waitingTasksCount === 0) {
            this._isLoading = false;
            if (this.onFinish) {
                this.onFinish(this._tasks);
            }
            this.onTasksDoneObservable.notifyObservers(this._tasks);
            return this;
        }
        if (this.useDefaultLoadingScreen) {
            this._scene.getEngine().displayLoadingUI();
        }
        for(let index = 0; index < this._tasks.length; index++){
            const task = this._tasks[index];
            if (task.taskState === 0 /* AssetTaskState.INIT */ ) {
                this._runTask(task);
            }
        }
        return this;
    }
    /**
     * Start the loading process as an async operation
     * @returns a promise returning the list of failed tasks
     */ async loadAsync() {
        return await new Promise((resolve, reject)=>{
            if (this._isLoading) {
                resolve();
                return;
            }
            this.onTasksDoneObservable.addOnce((remainingTasks)=>{
                if (remainingTasks && remainingTasks.length) {
                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
                    reject(remainingTasks);
                } else {
                    resolve();
                }
            });
            this.load();
        });
    }
} //# sourceMappingURL=assetsManager.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/deferred.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Wrapper class for promise with external resolve and reject.
 */ __turbopack_context__.s([
    "Deferred",
    ()=>Deferred
]);
class Deferred {
    /**
     * The resolve method of the promise associated with this deferred object.
     */ get resolve() {
        return this._resolve;
    }
    /**
     * The reject method of the promise associated with this deferred object.
     */ get reject() {
        return this._reject;
    }
    /**
     * Constructor for this deferred object.
     */ constructor(){
        this.promise = new Promise((resolve, reject)=>{
            this._resolve = resolve;
            this._reject = reject;
        });
    }
} //# sourceMappingURL=deferred.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/meshExploder.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MeshExploder",
    ()=>MeshExploder
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-ssr] (ecmascript)");
;
class MeshExploder {
    /**
     * Explodes meshes from a center mesh.
     * @param meshes The meshes to explode.
     * @param centerMesh The mesh to be center of explosion.
     */ constructor(meshes, centerMesh){
        this._meshesOrigins = [];
        this._toCenterVectors = [];
        this._scaledDirection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](1, 1, 1);
        this._newPosition = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"].Zero();
        this._centerPosition = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"].Zero();
        this._meshes = meshes.slice();
        if (centerMesh) {
            this._centerMesh = centerMesh;
        } else {
            this._setCenterMesh();
        }
        this._centerMesh.computeWorldMatrix(true);
        const centerMeshIndex = this._meshes.indexOf(this._centerMesh);
        if (centerMeshIndex >= 0) {
            this._meshes.splice(centerMeshIndex, 1);
        }
        this._centerPosition = this._centerMesh.getAbsolutePosition().clone();
        for(let index = 0; index < this._meshes.length; index++){
            if (this._meshes[index]) {
                const mesh = this._meshes[index];
                this._meshesOrigins[index] = mesh.getAbsolutePosition().clone();
                this._toCenterVectors[index] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"].Zero();
                if (mesh.hasBoundingInfo && this._centerMesh.hasBoundingInfo) {
                    mesh.computeWorldMatrix(true);
                    mesh.getBoundingInfo().boundingBox.centerWorld.subtractToRef(this._centerMesh.getBoundingInfo().boundingBox.centerWorld, this._toCenterVectors[index]);
                }
            }
        }
    }
    _setCenterMesh() {
        let averageCenter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"].Zero();
        const totalCenters = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"].Zero();
        let shortestToCenter = Number.MAX_VALUE;
        for(let index = 0; index < this._meshes.length; index++){
            if (this._meshes[index]) {
                const mesh = this._meshes[index];
                const boundingInfo = mesh.getBoundingInfo();
                if (boundingInfo) {
                    totalCenters.addInPlace(boundingInfo.boundingBox.centerWorld);
                }
            }
        }
        averageCenter = totalCenters.scale(1 / this._meshes.length);
        for(let index = 0; index < this._meshes.length; index++){
            if (this._meshes[index]) {
                const mesh = this._meshes[index];
                const boundingInfo = mesh.getBoundingInfo();
                if (boundingInfo) {
                    const distanceToCenter = boundingInfo.boundingBox.centerWorld.subtract(averageCenter).lengthSquared();
                    if (distanceToCenter < shortestToCenter) {
                        this._centerMesh = mesh;
                        shortestToCenter = distanceToCenter;
                    }
                }
            }
        }
    }
    /**
     * Get class name
     * @returns "MeshExploder"
     */ getClassName() {
        return "MeshExploder";
    }
    /**
     * "Exploded meshes"
     * @returns Array of meshes with the centerMesh at index 0.
     */ getMeshes() {
        const meshArray = this._meshes.slice();
        meshArray.unshift(this._centerMesh);
        return meshArray;
    }
    /**
     * Explodes meshes giving a specific direction
     * @param direction Number to multiply distance of each mesh's origin from center. Use a negative number to implode, or zero to reset.
     */ explode(direction = 1.0) {
        for(let index = 0; index < this._meshes.length; index++){
            if (this._meshes[index] && this._meshesOrigins[index] && this._toCenterVectors[index]) {
                this._toCenterVectors[index].scaleToRef(direction, this._scaledDirection);
                this._meshesOrigins[index].addToRef(this._scaledDirection, this._newPosition);
                this._meshes[index].setAbsolutePosition(this._newPosition);
            }
        }
        this._centerMesh.setAbsolutePosition(this._centerPosition);
    }
} //# sourceMappingURL=meshExploder.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/filesInput.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FilesInput",
    ()=>FilesInput
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Loading$2f$sceneLoader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Loading/sceneLoader.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/logger.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$filesInputStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/filesInputStore.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Loading$2f$sceneLoaderFlags$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Loading/sceneLoaderFlags.js [app-ssr] (ecmascript)");
;
;
;
;
class FilesInput {
    /**
     * List of files ready to be loaded
     */ static get FilesToLoad() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$filesInputStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FilesInputStore"].FilesToLoad;
    }
    /**
     * Creates a new FilesInput
     * @param engine defines the rendering engine
     * @param scene defines the hosting scene
     * @param sceneLoadedCallback callback called when scene (files provided) is loaded
     * @param progressCallback callback called to track progress
     * @param additionalRenderLoopLogicCallback callback called to add user logic to the rendering loop
     * @param textureLoadingCallback callback called when a texture is loading
     * @param startingProcessingFilesCallback callback called when the system is about to process all files
     * @param onReloadCallback callback called when a reload is requested
     * @param errorCallback callback call if an error occurs
     * @param useAppend defines if the file loaded must be appended (true) or have the scene replaced (false, default behavior)
     * @param dontInjectRenderLoop defines if the render loop mustn't be injected into engine (default is false). Used only if useAppend is false.
     */ constructor(engine, scene, sceneLoadedCallback, progressCallback, additionalRenderLoopLogicCallback, textureLoadingCallback, startingProcessingFilesCallback, onReloadCallback, errorCallback, useAppend = false, dontInjectRenderLoop = false){
        this.useAppend = useAppend;
        this.dontInjectRenderLoop = dontInjectRenderLoop;
        /**
         * Callback called when a file is processed
         * @returns false to abort the process
         */ this.onProcessFileCallback = ()=>{
            return true;
        };
        /**
         * If a loading UI should be displayed while loading a file
         */ this.displayLoadingUI = true;
        /**
         * Function used when loading the scene file
         * @param sceneFile defines the file to load
         * @param onProgress onProgress callback called while loading the file
         * @returns a promise completing when the load is complete
         */ this.loadAsync = async (sceneFile, onProgress)=>this.useAppend ? await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Loading$2f$sceneLoader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SceneLoader"].AppendAsync("file:", sceneFile, this._currentScene, onProgress) : await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Loading$2f$sceneLoader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SceneLoader"].LoadAsync("file:", sceneFile, this._engine, onProgress);
        this._engine = engine;
        this._currentScene = scene;
        this._sceneLoadedCallback = sceneLoadedCallback;
        this._progressCallback = progressCallback;
        this._additionalRenderLoopLogicCallback = additionalRenderLoopLogicCallback;
        this._textureLoadingCallback = textureLoadingCallback;
        this._startingProcessingFilesCallback = startingProcessingFilesCallback;
        this._onReloadCallback = onReloadCallback;
        this._errorCallback = errorCallback;
    }
    /**
     * Calls this function to listen to drag'n'drop events on a specific DOM element
     * @param elementToMonitor defines the DOM element to track
     */ // should probably be DragAndDrop
    // eslint-disable-next-line @typescript-eslint/naming-convention
    monitorElementForDragNDrop(elementToMonitor) {
        if (elementToMonitor) {
            this._elementToMonitor = elementToMonitor;
            this._dragEnterHandler = (e)=>{
                this._drag(e);
            };
            this._dragOverHandler = (e)=>{
                this._drag(e);
            };
            this._dropHandler = (e)=>{
                this._drop(e);
            };
            this._elementToMonitor.addEventListener("dragenter", this._dragEnterHandler, false);
            this._elementToMonitor.addEventListener("dragover", this._dragOverHandler, false);
            this._elementToMonitor.addEventListener("drop", this._dropHandler, false);
        }
    }
    /** Gets the current list of files to load */ get filesToLoad() {
        return this._filesToLoad;
    }
    /**
     * Release all associated resources
     */ dispose() {
        if (!this._elementToMonitor) {
            return;
        }
        this._elementToMonitor.removeEventListener("dragenter", this._dragEnterHandler);
        this._elementToMonitor.removeEventListener("dragover", this._dragOverHandler);
        this._elementToMonitor.removeEventListener("drop", this._dropHandler);
    }
    _renderFunction() {
        if (this._additionalRenderLoopLogicCallback) {
            this._additionalRenderLoopLogicCallback();
        }
        if (this._currentScene) {
            if (this._textureLoadingCallback) {
                const remaining = this._currentScene.getWaitingItemsCount();
                if (remaining > 0) {
                    this._textureLoadingCallback(remaining);
                }
            }
            this._currentScene.render();
        }
    }
    _drag(e) {
        e.stopPropagation();
        e.preventDefault();
    }
    _drop(eventDrop) {
        eventDrop.stopPropagation();
        eventDrop.preventDefault();
        this.loadFiles(eventDrop);
    }
    _traverseFolder(folder, files, remaining, callback) {
        const reader = folder.createReader();
        const relativePath = folder.fullPath.replace(/^\//, "").replace(/(.+?)\/?$/, "$1/");
        reader.readEntries((entries)=>{
            remaining.count += entries.length;
            for (const entry of entries){
                if (entry.isFile) {
                    entry.file((file)=>{
                        file.correctName = relativePath + file.name;
                        files.push(file);
                        if (--remaining.count === 0) {
                            callback();
                        }
                    });
                } else if (entry.isDirectory) {
                    this._traverseFolder(entry, files, remaining, callback);
                }
            }
            if (--remaining.count === 0) {
                callback();
            }
        });
    }
    _processFiles(files) {
        for(let i = 0; i < files.length; i++){
            const name = files[i].correctName.toLowerCase();
            const extension = name.split(".").pop();
            if (!this.onProcessFileCallback(files[i], name, extension, (sceneFile)=>this._sceneFileToLoad = sceneFile)) {
                continue;
            }
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Loading$2f$sceneLoader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SceneLoader"].IsPluginForExtensionAvailable("." + extension)) {
                this._sceneFileToLoad = files[i];
            }
            FilesInput.FilesToLoad[name] = files[i];
        }
    }
    /**
     * Load files from a drop event
     * @param event defines the drop event to use as source
     */ loadFiles(event) {
        // Handling data transfer via drag'n'drop
        if (event && event.dataTransfer && event.dataTransfer.files) {
            this._filesToLoad = event.dataTransfer.files;
        }
        // Handling files from input files
        if (event && event.target && event.target.files) {
            this._filesToLoad = event.target.files;
        }
        if (!this._filesToLoad || this._filesToLoad.length === 0) {
            return;
        }
        if (this._startingProcessingFilesCallback) {
            this._startingProcessingFilesCallback(this._filesToLoad);
        }
        if (this._filesToLoad && this._filesToLoad.length > 0) {
            const files = [];
            const folders = [];
            const items = event.dataTransfer ? event.dataTransfer.items : null;
            for(let i = 0; i < this._filesToLoad.length; i++){
                const fileToLoad = this._filesToLoad[i];
                const name = fileToLoad.name.toLowerCase();
                let entry;
                fileToLoad.correctName = name;
                if (items) {
                    const item = items[i];
                    if (item.getAsEntry) {
                        entry = item.getAsEntry();
                    } else if (item.webkitGetAsEntry) {
                        entry = item.webkitGetAsEntry();
                    }
                }
                if (!entry) {
                    files.push(fileToLoad);
                } else {
                    if (entry.isDirectory) {
                        folders.push(entry);
                    } else {
                        files.push(fileToLoad);
                    }
                }
            }
            if (folders.length === 0) {
                this._processFiles(files);
                this._processReload();
            } else {
                const remaining = {
                    count: folders.length
                };
                for (const folder of folders){
                    this._traverseFolder(folder, files, remaining, ()=>{
                        this._processFiles(files);
                        if (remaining.count === 0) {
                            this._processReload();
                        }
                    });
                }
            }
        }
    }
    _processReload() {
        if (this._onReloadCallback) {
            this._onReloadCallback(this._sceneFileToLoad);
        } else {
            this.reload();
        }
    }
    /**
     * Reload the current scene from the loaded files
     */ reload() {
        // If a scene file has been provided
        if (this._sceneFileToLoad) {
            if (!this.useAppend) {
                if (this._currentScene) {
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].errorsCount > 0) {
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].ClearLogCache();
                    }
                    this._engine.stopRenderLoop();
                }
            }
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Loading$2f$sceneLoaderFlags$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SceneLoaderFlags"].ShowLoadingScreen = false;
            if (this.displayLoadingUI) {
                this._engine.displayLoadingUI();
            }
            this.loadAsync(this._sceneFileToLoad, this._progressCallback)// eslint-disable-next-line github/no-then
            .then((scene)=>{
                // if appending do nothing
                if (!this.useAppend) {
                    if (this._currentScene) {
                        this._currentScene.dispose();
                    }
                    this._currentScene = scene;
                    // Wait for textures and shaders to be ready
                    this._currentScene.executeWhenReady(()=>{
                        if (this.displayLoadingUI) {
                            this._engine.hideLoadingUI();
                        }
                        if (!this.dontInjectRenderLoop) {
                            this._engine.runRenderLoop(()=>{
                                this._renderFunction();
                            });
                        }
                    });
                } else {
                    if (this.displayLoadingUI) {
                        this._engine.hideLoadingUI();
                    }
                }
                if (this._sceneLoadedCallback && this._currentScene) {
                    this._sceneLoadedCallback(this._sceneFileToLoad, this._currentScene);
                }
            })// eslint-disable-next-line github/no-then
            .catch((error)=>{
                if (this.displayLoadingUI) {
                    this._engine.hideLoadingUI();
                }
                if (this._errorCallback) {
                    this._errorCallback(this._sceneFileToLoad, this._currentScene, error.message);
                }
            });
        } else {
            if (this._filesToLoad.length === 1) {
                const name = this._filesToLoad[0].name.toLowerCase();
                const extension = name.split(".").pop();
                if (extension) {
                    switch(extension.toLowerCase()){
                        case "dds":
                        case "env":
                        case "hdr":
                            {
                                return; // Ignore error in that case
                            }
                    }
                }
            }
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Error("Please provide a valid .babylon file.");
        }
    }
} //# sourceMappingURL=filesInput.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/HighDynamicRange/index.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$HighDynamicRange$2f$cubemapToSphericalPolynomial$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/HighDynamicRange/cubemapToSphericalPolynomial.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$HighDynamicRange$2f$hdr$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/HighDynamicRange/hdr.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$HighDynamicRange$2f$panoramaToCubemap$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/HighDynamicRange/panoramaToCubemap.js [app-ssr] (ecmascript)"); //# sourceMappingURL=index.js.map
;
;
;
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/observable.extensions.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MultiObserver",
    ()=>MultiObserver
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/observable.js [app-ssr] (ecmascript)");
;
class MultiObserver {
    /**
     * Release associated resources
     */ dispose() {
        if (this._observers && this._observables) {
            for(let index = 0; index < this._observers.length; index++){
                this._observables[index].remove(this._observers[index]);
            }
        }
        this._observers = null;
        this._observables = null;
    }
    /**
     * Raise a callback when one of the observable will notify
     * @param observables defines a list of observables to watch
     * @param callback defines the callback to call on notification
     * @param mask defines the mask used to filter notifications
     * @param scope defines the current scope used to restore the JS context
     * @returns the new MultiObserver
     */ static Watch(observables, callback, mask = -1, scope = null) {
        const result = new MultiObserver();
        result._observers = new Array();
        result._observables = observables;
        for (const observable of observables){
            const observer = observable.add(callback, mask, false, scope);
            if (observer) {
                result._observers.push(observer);
            }
        }
        return result;
    }
}
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Observable"].prototype.notifyObserversWithPromise = async function(eventData, mask = -1, target, currentTarget, userInfo) {
    // create an empty promise
    let p = Promise.resolve(eventData);
    // no observers? return this promise.
    if (!this.observers.length) {
        return await p;
    }
    const state = this._eventState;
    state.mask = mask;
    state.target = target;
    state.currentTarget = currentTarget;
    state.skipNextObservers = false;
    state.userInfo = userInfo;
    // execute one callback after another (not using Promise.all, the order is important)
    for (const obs of this.observers){
        if (state.skipNextObservers) {
            continue;
        }
        if (obs._willBeUnregistered) {
            continue;
        }
        if (obs.mask & mask) {
            if (obs.scope) {
                // eslint-disable-next-line github/no-then
                p = p.then((lastReturnedValue)=>{
                    state.lastReturnValue = lastReturnedValue;
                    return obs.callback.apply(obs.scope, [
                        eventData,
                        state
                    ]);
                });
            } else {
                // eslint-disable-next-line github/no-then
                p = p.then((lastReturnedValue)=>{
                    state.lastReturnValue = lastReturnedValue;
                    return obs.callback(eventData, state);
                });
            }
            if (obs.unregisterOnNextCall) {
                this._deferUnregister(obs);
            }
        }
    }
    // return the eventData
    await p;
    return eventData;
}; //# sourceMappingURL=observable.extensions.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/sceneOptimizer.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CustomOptimization",
    ()=>CustomOptimization,
    "HardwareScalingOptimization",
    ()=>HardwareScalingOptimization,
    "LensFlaresOptimization",
    ()=>LensFlaresOptimization,
    "MergeMeshesOptimization",
    ()=>MergeMeshesOptimization,
    "ParticlesOptimization",
    ()=>ParticlesOptimization,
    "PostProcessesOptimization",
    ()=>PostProcessesOptimization,
    "RenderTargetsOptimization",
    ()=>RenderTargetsOptimization,
    "SceneOptimization",
    ()=>SceneOptimization,
    "SceneOptimizer",
    ()=>SceneOptimizer,
    "SceneOptimizerOptions",
    ()=>SceneOptimizerOptions,
    "ShadowsOptimization",
    ()=>ShadowsOptimization,
    "TextureOptimization",
    ()=>TextureOptimization
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engineStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Engines/engineStore.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/observable.js [app-ssr] (ecmascript)");
;
;
;
class SceneOptimization {
    /**
     * Gets a string describing the action executed by the current optimization
     * @returns description string
     */ getDescription() {
        return "";
    }
    /**
     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
     * @param scene defines the current scene where to apply this optimization
     * @param optimizer defines the current optimizer
     * @returns true if everything that can be done was applied
     */ apply(scene, optimizer) {
        return true;
    }
    /**
     * Creates the SceneOptimization object
     * @param priority defines the priority of this optimization (0 by default which means first in the list)
     */ constructor(/**
     * [0] Defines the priority of this optimization (0 by default which means first in the list)
     */ priority = 0){
        this.priority = priority;
    }
}
class TextureOptimization extends SceneOptimization {
    /**
     * Gets a string describing the action executed by the current optimization
     * @returns description string
     */ getDescription() {
        return "Reducing render target texture size to " + this.maximumSize;
    }
    /**
     * Creates the TextureOptimization object
     * @param priority defines the priority of this optimization (0 by default which means first in the list)
     * @param maximumSize defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter
     * @param step defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.
     */ constructor(/**
     * [0] Defines the priority of this optimization (0 by default which means first in the list)
     */ priority = 0, /**
     * [1024] Defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter
     */ maximumSize = 1024, /**
     * [0.5] Defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.
     */ step = 0.5){
        super(priority);
        this.priority = priority;
        this.maximumSize = maximumSize;
        this.step = step;
    }
    /**
     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
     * @param scene defines the current scene where to apply this optimization
     * @param optimizer defines the current optimizer
     * @returns true if everything that can be done was applied
     */ apply(scene, optimizer) {
        let allDone = true;
        for(let index = 0; index < scene.textures.length; index++){
            const texture = scene.textures[index];
            if (!texture.canRescale || texture.getContext) {
                continue;
            }
            const currentSize = texture.getSize();
            const maxDimension = Math.max(currentSize.width, currentSize.height);
            if (maxDimension > this.maximumSize) {
                texture.scale(this.step);
                allDone = false;
            }
        }
        return allDone;
    }
}
class HardwareScalingOptimization extends SceneOptimization {
    /**
     * Gets a string describing the action executed by the current optimization
     * @returns description string
     */ getDescription() {
        return "Setting hardware scaling level to " + this._currentScale;
    }
    /**
     * Creates the HardwareScalingOptimization object
     * @param priority defines the priority of this optimization (0 by default which means first in the list)
     * @param maximumScale defines the maximum scale to use (2 by default)
     * @param step defines the step to use between two passes (0.5 by default)
     */ constructor(/**
     * [0] Defines the priority of this optimization (0 by default which means first in the list)
     */ priority = 0, /**
     * [2] Defines the maximum scale to use (2 by default)
     */ maximumScale = 2, /**
     * [0.25] Defines the step to use between two passes (0.5 by default)
     */ step = 0.25){
        super(priority);
        this.priority = priority;
        this.maximumScale = maximumScale;
        this.step = step;
        this._currentScale = -1;
        this._directionOffset = 1;
    }
    /**
     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
     * @param scene defines the current scene where to apply this optimization
     * @param optimizer defines the current optimizer
     * @returns true if everything that can be done was applied
     */ apply(scene, optimizer) {
        if (this._currentScale === -1) {
            this._currentScale = scene.getEngine().getHardwareScalingLevel();
            if (this._currentScale > this.maximumScale) {
                this._directionOffset = -1;
            }
        }
        this._currentScale += this._directionOffset * this.step;
        this._currentScale = Math.min(this.maximumScale, this._currentScale);
        scene.getEngine().setHardwareScalingLevel(this._currentScale);
        return this._directionOffset === 1 ? this._currentScale >= this.maximumScale : this._currentScale <= this.maximumScale;
    }
}
class ShadowsOptimization extends SceneOptimization {
    /**
     * Gets a string describing the action executed by the current optimization
     * @returns description string
     */ getDescription() {
        return "Turning shadows on/off";
    }
    /**
     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
     * @param scene defines the current scene where to apply this optimization
     * @param optimizer defines the current optimizer
     * @returns true if everything that can be done was applied
     */ apply(scene, optimizer) {
        scene.shadowsEnabled = optimizer.isInImprovementMode;
        return true;
    }
}
class PostProcessesOptimization extends SceneOptimization {
    /**
     * Gets a string describing the action executed by the current optimization
     * @returns description string
     */ getDescription() {
        return "Turning post-processes on/off";
    }
    /**
     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
     * @param scene defines the current scene where to apply this optimization
     * @param optimizer defines the current optimizer
     * @returns true if everything that can be done was applied
     */ apply(scene, optimizer) {
        scene.postProcessesEnabled = optimizer.isInImprovementMode;
        return true;
    }
}
class LensFlaresOptimization extends SceneOptimization {
    /**
     * Gets a string describing the action executed by the current optimization
     * @returns description string
     */ getDescription() {
        return "Turning lens flares on/off";
    }
    /**
     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
     * @param scene defines the current scene where to apply this optimization
     * @param optimizer defines the current optimizer
     * @returns true if everything that can be done was applied
     */ apply(scene, optimizer) {
        scene.lensFlaresEnabled = optimizer.isInImprovementMode;
        return true;
    }
}
class CustomOptimization extends SceneOptimization {
    /**
     * Gets a string describing the action executed by the current optimization
     * @returns description string
     */ getDescription() {
        if (this.onGetDescription) {
            return this.onGetDescription();
        }
        return "Running user defined callback";
    }
    /**
     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
     * @param scene defines the current scene where to apply this optimization
     * @param optimizer defines the current optimizer
     * @returns true if everything that can be done was applied
     */ apply(scene, optimizer) {
        if (this.onApply) {
            return this.onApply(scene, optimizer);
        }
        return true;
    }
}
class ParticlesOptimization extends SceneOptimization {
    /**
     * Gets a string describing the action executed by the current optimization
     * @returns description string
     */ getDescription() {
        return "Turning particles on/off";
    }
    /**
     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
     * @param scene defines the current scene where to apply this optimization
     * @param optimizer defines the current optimizer
     * @returns true if everything that can be done was applied
     */ apply(scene, optimizer) {
        scene.particlesEnabled = optimizer.isInImprovementMode;
        return true;
    }
}
class RenderTargetsOptimization extends SceneOptimization {
    /**
     * Gets a string describing the action executed by the current optimization
     * @returns description string
     */ getDescription() {
        return "Turning render targets off";
    }
    /**
     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
     * @param scene defines the current scene where to apply this optimization
     * @param optimizer defines the current optimizer
     * @returns true if everything that can be done was applied
     */ apply(scene, optimizer) {
        scene.renderTargetsEnabled = optimizer.isInImprovementMode;
        return true;
    }
}
class MergeMeshesOptimization extends SceneOptimization {
    constructor(){
        super(...arguments);
        this._canBeMerged = (abstractMesh)=>{
            if (!(abstractMesh instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Mesh"])) {
                return false;
            }
            const mesh = abstractMesh;
            if (mesh.isDisposed()) {
                return false;
            }
            if (!mesh.isVisible || !mesh.isEnabled()) {
                return false;
            }
            if (mesh.instances.length > 0) {
                return false;
            }
            if (mesh.skeleton || mesh.hasLODLevels) {
                return false;
            }
            if (mesh.getTotalVertices() === 0) {
                return false;
            }
            return true;
        };
    }
    /**
     * Gets or sets a boolean which defines if optimization octree has to be updated
     */ static get UpdateSelectionTree() {
        return MergeMeshesOptimization._UpdateSelectionTree;
    }
    /**
     * Gets or sets a boolean which defines if optimization octree has to be updated
     */ static set UpdateSelectionTree(value) {
        MergeMeshesOptimization._UpdateSelectionTree = value;
    }
    /**
     * Gets a string describing the action executed by the current optimization
     * @returns description string
     */ getDescription() {
        return "Merging similar meshes together";
    }
    /**
     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
     * @param scene defines the current scene where to apply this optimization
     * @param optimizer defines the current optimizer
     * @param updateSelectionTree defines that the selection octree has to be updated (false by default)
     * @returns true if everything that can be done was applied
     */ apply(scene, optimizer, updateSelectionTree) {
        const globalPool = scene.meshes.slice(0);
        let globalLength = globalPool.length;
        for(let index = 0; index < globalLength; index++){
            const currentPool = [];
            const current = globalPool[index];
            // Checks
            if (!this._canBeMerged(current)) {
                continue;
            }
            currentPool.push(current);
            // Find compatible meshes
            for(let subIndex = index + 1; subIndex < globalLength; subIndex++){
                const otherMesh = globalPool[subIndex];
                if (!this._canBeMerged(otherMesh)) {
                    continue;
                }
                if (otherMesh.material !== current.material) {
                    continue;
                }
                if (otherMesh.checkCollisions !== current.checkCollisions) {
                    continue;
                }
                currentPool.push(otherMesh);
                globalLength--;
                globalPool.splice(subIndex, 1);
                subIndex--;
            }
            if (currentPool.length < 2) {
                continue;
            }
            // Merge meshes
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Mesh"].MergeMeshes(currentPool, undefined, true);
        }
        // Call the octree system optimization if it is defined.
        const sceneAsAny = scene;
        if (sceneAsAny.createOrUpdateSelectionOctree) {
            if (updateSelectionTree != undefined) {
                if (updateSelectionTree) {
                    sceneAsAny.createOrUpdateSelectionOctree();
                }
            } else if (MergeMeshesOptimization.UpdateSelectionTree) {
                sceneAsAny.createOrUpdateSelectionOctree();
            }
        }
        return true;
    }
}
MergeMeshesOptimization._UpdateSelectionTree = false;
class SceneOptimizerOptions {
    /**
     * Creates a new list of options used by SceneOptimizer
     * @param targetFrameRate defines the target frame rate to reach (60 by default)
     * @param trackerDuration defines the interval between two checks (2000ms by default)
     */ constructor(/**
     * [60] Defines the target frame rate to reach (60 by default)
     */ targetFrameRate = 60, /**
     * [2000] Defines the interval between two checks (2000ms by default)
     */ trackerDuration = 2000){
        this.targetFrameRate = targetFrameRate;
        this.trackerDuration = trackerDuration;
        /**
         * Gets the list of optimizations to apply
         */ this.optimizations = [];
    }
    /**
     * Add a new optimization
     * @param optimization defines the SceneOptimization to add to the list of active optimizations
     * @returns the current SceneOptimizerOptions
     */ addOptimization(optimization) {
        this.optimizations.push(optimization);
        return this;
    }
    /**
     * Add a new custom optimization
     * @param onApply defines the callback called to apply the custom optimization (true if everything that can be done was applied)
     * @param onGetDescription defines the callback called to get the description attached with the optimization.
     * @param priority defines the priority of this optimization (0 by default which means first in the list)
     * @returns the current SceneOptimizerOptions
     */ addCustomOptimization(onApply, onGetDescription, priority = 0) {
        const optimization = new CustomOptimization(priority);
        optimization.onApply = onApply;
        optimization.onGetDescription = onGetDescription;
        this.optimizations.push(optimization);
        return this;
    }
    /**
     * Creates a list of pre-defined optimizations aimed to reduce the visual impact on the scene
     * @param targetFrameRate defines the target frame rate (60 by default)
     * @returns a SceneOptimizerOptions object
     */ static LowDegradationAllowed(targetFrameRate) {
        const result = new SceneOptimizerOptions(targetFrameRate);
        let priority = 0;
        result.addOptimization(new MergeMeshesOptimization(priority));
        result.addOptimization(new ShadowsOptimization(priority));
        result.addOptimization(new LensFlaresOptimization(priority));
        // Next priority
        priority++;
        result.addOptimization(new PostProcessesOptimization(priority));
        result.addOptimization(new ParticlesOptimization(priority));
        // Next priority
        priority++;
        result.addOptimization(new TextureOptimization(priority, 1024));
        return result;
    }
    /**
     * Creates a list of pre-defined optimizations aimed to have a moderate impact on the scene visual
     * @param targetFrameRate defines the target frame rate (60 by default)
     * @returns a SceneOptimizerOptions object
     */ static ModerateDegradationAllowed(targetFrameRate) {
        const result = new SceneOptimizerOptions(targetFrameRate);
        let priority = 0;
        result.addOptimization(new MergeMeshesOptimization(priority));
        result.addOptimization(new ShadowsOptimization(priority));
        result.addOptimization(new LensFlaresOptimization(priority));
        // Next priority
        priority++;
        result.addOptimization(new PostProcessesOptimization(priority));
        result.addOptimization(new ParticlesOptimization(priority));
        // Next priority
        priority++;
        result.addOptimization(new TextureOptimization(priority, 512));
        // Next priority
        priority++;
        result.addOptimization(new RenderTargetsOptimization(priority));
        // Next priority
        priority++;
        result.addOptimization(new HardwareScalingOptimization(priority, 2));
        return result;
    }
    /**
     * Creates a list of pre-defined optimizations aimed to have a big impact on the scene visual
     * @param targetFrameRate defines the target frame rate (60 by default)
     * @returns a SceneOptimizerOptions object
     */ static HighDegradationAllowed(targetFrameRate) {
        const result = new SceneOptimizerOptions(targetFrameRate);
        let priority = 0;
        result.addOptimization(new MergeMeshesOptimization(priority));
        result.addOptimization(new ShadowsOptimization(priority));
        result.addOptimization(new LensFlaresOptimization(priority));
        // Next priority
        priority++;
        result.addOptimization(new PostProcessesOptimization(priority));
        result.addOptimization(new ParticlesOptimization(priority));
        // Next priority
        priority++;
        result.addOptimization(new TextureOptimization(priority, 256));
        // Next priority
        priority++;
        result.addOptimization(new RenderTargetsOptimization(priority));
        // Next priority
        priority++;
        result.addOptimization(new HardwareScalingOptimization(priority, 4));
        return result;
    }
}
class SceneOptimizer {
    /**
     * Gets or sets a boolean indicating if the optimizer is in improvement mode
     */ get isInImprovementMode() {
        return this._improvementMode;
    }
    set isInImprovementMode(value) {
        this._improvementMode = value;
    }
    /**
     * Gets the current priority level (0 at start)
     */ get currentPriorityLevel() {
        return this._currentPriorityLevel;
    }
    /**
     * Gets the current frame rate checked by the SceneOptimizer
     */ get currentFrameRate() {
        return this._currentFrameRate;
    }
    /**
     * Gets or sets the current target frame rate (60 by default)
     */ get targetFrameRate() {
        return this._targetFrameRate;
    }
    /**
     * Gets or sets the current target frame rate (60 by default)
     */ set targetFrameRate(value) {
        this._targetFrameRate = value;
    }
    /**
     * Gets or sets the current interval between two checks (every 2000ms by default)
     */ get trackerDuration() {
        return this._trackerDuration;
    }
    /**
     * Gets or sets the current interval between two checks (every 2000ms by default)
     */ set trackerDuration(value) {
        this._trackerDuration = value;
    }
    /**
     * Gets the list of active optimizations
     */ get optimizations() {
        return this._options.optimizations;
    }
    /**
     * Creates a new SceneOptimizer
     * @param scene defines the scene to work on
     * @param options defines the options to use with the SceneOptimizer
     * @param autoGeneratePriorities defines if priorities must be generated and not read from SceneOptimization property (true by default)
     * @param improvementMode defines if the scene optimizer must run the maximum optimization while staying over a target frame instead of trying to reach the target framerate (false by default)
     */ constructor(scene, options, autoGeneratePriorities = true, improvementMode = false){
        this._isRunning = false;
        this._currentPriorityLevel = 0;
        this._targetFrameRate = 60;
        this._trackerDuration = 2000;
        this._currentFrameRate = 0;
        this._improvementMode = false;
        /**
         * Defines an observable called when the optimizer reaches the target frame rate
         */ this.onSuccessObservable = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Observable"]();
        /**
         * Defines an observable called when the optimizer enables an optimization
         */ this.onNewOptimizationAppliedObservable = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Observable"]();
        /**
         * Defines an observable called when the optimizer is not able to reach the target frame rate
         */ this.onFailureObservable = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Observable"]();
        if (!options) {
            this._options = new SceneOptimizerOptions();
        } else {
            this._options = options;
        }
        if (this._options.targetFrameRate) {
            this._targetFrameRate = this._options.targetFrameRate;
        }
        if (this._options.trackerDuration) {
            this._trackerDuration = this._options.trackerDuration;
        }
        if (autoGeneratePriorities) {
            let priority = 0;
            for (const optim of this._options.optimizations){
                optim.priority = priority++;
            }
        }
        this._improvementMode = improvementMode;
        this._scene = scene || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Engines$2f$engineStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EngineStore"].LastCreatedScene;
        this._sceneDisposeObserver = this._scene.onDisposeObservable.add(()=>{
            this._sceneDisposeObserver = null;
            this.dispose();
        });
    }
    /**
     * Stops the current optimizer
     */ stop() {
        this._isRunning = false;
    }
    /**
     * Reset the optimizer to initial step (current priority level = 0)
     */ reset() {
        this._currentPriorityLevel = 0;
    }
    /**
     * Start the optimizer. By default it will try to reach a specific framerate
     * but if the optimizer is set with improvementMode === true then it will run all optimization while frame rate is above the target frame rate
     */ start() {
        if (this._isRunning) {
            return;
        }
        this._isRunning = true;
        // Let's wait for the scene to be ready before running our check
        this._scene.executeWhenReady(()=>{
            setTimeout(()=>{
                this._checkCurrentState();
            }, this._trackerDuration);
        });
    }
    _checkCurrentState() {
        if (!this._isRunning) {
            return;
        }
        const scene = this._scene;
        const options = this._options;
        this._currentFrameRate = Math.round(scene.getEngine().getFps());
        if (this._improvementMode && this._currentFrameRate <= this._targetFrameRate || !this._improvementMode && this._currentFrameRate >= this._targetFrameRate) {
            this._isRunning = false;
            this.onSuccessObservable.notifyObservers(this);
            return;
        }
        // Apply current level of optimizations
        let allDone = true;
        let noOptimizationApplied = true;
        for(let index = 0; index < options.optimizations.length; index++){
            const optimization = options.optimizations[index];
            if (optimization.priority === this._currentPriorityLevel) {
                noOptimizationApplied = false;
                allDone = allDone && optimization.apply(scene, this);
                this.onNewOptimizationAppliedObservable.notifyObservers(optimization);
            }
        }
        // If no optimization was applied, this is a failure :(
        if (noOptimizationApplied) {
            this._isRunning = false;
            this.onFailureObservable.notifyObservers(this);
            return;
        }
        // If all optimizations were done, move to next level
        if (allDone) {
            this._currentPriorityLevel++;
        }
        // Let's the system running for a specific amount of time before checking FPS
        scene.executeWhenReady(()=>{
            setTimeout(()=>{
                this._checkCurrentState();
            }, this._trackerDuration);
        });
    }
    /**
     * Release all resources
     */ dispose() {
        this.stop();
        this.onSuccessObservable.clear();
        this.onFailureObservable.clear();
        this.onNewOptimizationAppliedObservable.clear();
        if (this._sceneDisposeObserver) {
            this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);
        }
    }
    /**
     * Helper function to create a SceneOptimizer with one single line of code
     * @param scene defines the scene to work on
     * @param options defines the options to use with the SceneOptimizer
     * @param onSuccess defines a callback to call on success
     * @param onFailure defines a callback to call on failure
     * @returns the new SceneOptimizer object
     */ // This function i s not technically Async
    // eslint-disable-next-line no-restricted-syntax
    static OptimizeAsync(scene, options, onSuccess, onFailure) {
        const optimizer = new SceneOptimizer(scene, options || SceneOptimizerOptions.ModerateDegradationAllowed(), false);
        if (onSuccess) {
            optimizer.onSuccessObservable.add(()=>{
                onSuccess();
            });
        }
        if (onFailure) {
            optimizer.onFailureObservable.add(()=>{
                onFailure();
            });
        }
        optimizer.start();
        return optimizer;
    }
} //# sourceMappingURL=sceneOptimizer.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/sceneSerializer.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SceneSerializer",
    ()=>SceneSerializer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$multiMaterial$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/multiMaterial.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$serialization$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/decorators.serialization.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/Textures/texture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/logger.js [app-ssr] (ecmascript)");
;
;
;
;
;
let SerializedGeometries = [];
const SerializeGeometry = (geometry, serializationGeometries)=>{
    if (geometry.doNotSerialize) {
        return;
    }
    serializationGeometries.vertexData.push(geometry.serializeVerticeData());
    SerializedGeometries[geometry.id] = true;
};
const SerializeMesh = (mesh, serializationScene)=>{
    const serializationObject = {};
    // Geometry
    const geometry = mesh._geometry;
    if (geometry) {
        if (!mesh.getScene().getGeometryById(geometry.id)) {
            // Geometry was in the memory but not added to the scene, nevertheless it's better to serialize to be able to reload the mesh with its geometry
            SerializeGeometry(geometry, serializationScene.geometries);
        }
    }
    // Custom
    if (mesh.serialize) {
        mesh.serialize(serializationObject);
    }
    return serializationObject;
};
const FinalizeSingleNode = (node, serializationObject)=>{
    if (node._isMesh) {
        const mesh = node;
        //only works if the mesh is already loaded
        if (mesh.delayLoadState === 1 || mesh.delayLoadState === 0) {
            const serializeMaterial = (material)=>{
                serializationObject.materials = serializationObject.materials || [];
                if (mesh.material && !serializationObject.materials.some((mat)=>mat.id === mesh.material.id)) {
                    serializationObject.materials.push(material.serialize());
                }
            };
            //serialize material
            if (mesh.material && !mesh.material.doNotSerialize) {
                if (mesh.material instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$multiMaterial$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MultiMaterial"]) {
                    serializationObject.multiMaterials = serializationObject.multiMaterials || [];
                    if (!serializationObject.multiMaterials.some((mat)=>mat.id === mesh.material.id)) {
                        serializationObject.multiMaterials.push(mesh.material.serialize());
                        for (const submaterial of mesh.material.subMaterials){
                            if (submaterial) {
                                serializeMaterial(submaterial);
                            }
                        }
                    }
                } else {
                    serializeMaterial(mesh.material);
                }
            } else if (!mesh.material) {
                serializeMaterial(mesh.getScene().defaultMaterial);
            }
            //serialize geometry
            const geometry = mesh._geometry;
            if (geometry) {
                if (!serializationObject.geometries) {
                    serializationObject.geometries = {};
                    serializationObject.geometries.boxes = [];
                    serializationObject.geometries.spheres = [];
                    serializationObject.geometries.cylinders = [];
                    serializationObject.geometries.toruses = [];
                    serializationObject.geometries.grounds = [];
                    serializationObject.geometries.planes = [];
                    serializationObject.geometries.torusKnots = [];
                    serializationObject.geometries.vertexData = [];
                }
                SerializeGeometry(geometry, serializationObject.geometries);
            }
            // Skeletons
            if (mesh.skeleton && !mesh.skeleton.doNotSerialize) {
                serializationObject.skeletons = serializationObject.skeletons || [];
                serializationObject.skeletons.push(mesh.skeleton.serialize());
            }
            //serialize the actual mesh
            serializationObject.meshes = serializationObject.meshes || [];
            serializationObject.meshes.push(SerializeMesh(mesh, serializationObject));
        }
    } else if (node.getClassName() === "TransformNode") {
        const transformNode = node;
        serializationObject.transformNodes.push(transformNode.serialize());
    } else if (node.getClassName().indexOf("Camera") !== -1) {
        const camera = node;
        serializationObject.cameras.push(camera.serialize());
    } else if (node.getClassName().indexOf("Light") !== -1) {
        const light = node;
        serializationObject.lights.push(light.serialize());
    }
};
class SceneSerializer {
    /**
     * Clear cache used by a previous serialization
     */ static ClearCache() {
        SerializedGeometries = [];
    }
    /**
     * Serialize a scene into a JSON compatible object
     * Note that if the current engine does not support synchronous texture reading (like WebGPU), you should use SerializeAsync instead
     * as else you may not retrieve the proper base64 encoded texture data (when using the Texture.ForceSerializeBuffers flag)
     * @param scene defines the scene to serialize
     * @returns a JSON compatible object
     */ static Serialize(scene) {
        return SceneSerializer._Serialize(scene);
    }
    static _Serialize(scene, checkSyncReadSupported = true) {
        const serializationObject = {};
        if (checkSyncReadSupported && !scene.getEngine()._features.supportSyncTextureRead && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].ForceSerializeBuffers) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Warn("The serialization object may not contain the proper base64 encoded texture data! You should use the SerializeAsync method instead.");
        }
        SceneSerializer.ClearCache();
        // Scene
        serializationObject.useDelayedTextureLoading = scene.useDelayedTextureLoading;
        serializationObject.autoClear = scene.autoClear;
        serializationObject.clearColor = scene.clearColor.asArray();
        serializationObject.ambientColor = scene.ambientColor.asArray();
        serializationObject.gravity = scene.gravity.asArray();
        serializationObject.collisionsEnabled = scene.collisionsEnabled;
        serializationObject.useRightHandedSystem = scene.useRightHandedSystem;
        // Fog
        if (scene.fogMode !== undefined && scene.fogMode !== null) {
            serializationObject.fogMode = scene.fogMode;
        }
        if (scene.fogColor !== undefined && scene.fogColor !== null) {
            serializationObject.fogColor = scene.fogColor.asArray();
        }
        if (scene.fogStart !== undefined && scene.fogStart !== null) {
            serializationObject.fogStart = scene.fogStart;
        }
        if (scene.fogEnd !== undefined && scene.fogEnd !== null) {
            serializationObject.fogEnd = scene.fogEnd;
        }
        if (scene.fogDensity !== undefined && scene.fogDensity !== null) {
            serializationObject.fogDensity = scene.fogDensity;
        }
        //Physics
        if (scene.isPhysicsEnabled && scene.isPhysicsEnabled()) {
            const physicEngine = scene.getPhysicsEngine();
            if (physicEngine) {
                serializationObject.physicsEnabled = true;
                serializationObject.physicsGravity = physicEngine.gravity.asArray();
                serializationObject.physicsEngine = physicEngine.getPhysicsPluginName();
            }
        }
        // Metadata
        if (scene.metadata) {
            serializationObject.metadata = scene.metadata;
        }
        // Morph targets
        serializationObject.morphTargetManagers = [];
        for (const abstractMesh of scene.meshes){
            const manager = abstractMesh.morphTargetManager;
            if (manager) {
                serializationObject.morphTargetManagers.push(manager.serialize());
            }
        }
        // Lights
        serializationObject.lights = [];
        let index;
        let light;
        for(index = 0; index < scene.lights.length; index++){
            light = scene.lights[index];
            if (!light.doNotSerialize) {
                serializationObject.lights.push(light.serialize());
            }
        }
        // Cameras
        serializationObject.cameras = [];
        for(index = 0; index < scene.cameras.length; index++){
            const camera = scene.cameras[index];
            if (!camera.doNotSerialize) {
                serializationObject.cameras.push(camera.serialize());
            }
        }
        if (scene.activeCamera) {
            serializationObject.activeCameraID = scene.activeCamera.id;
        }
        // Animations
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$serialization$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SerializationHelper"].AppendSerializedAnimations(scene, serializationObject);
        // Animation Groups
        if (scene.animationGroups && scene.animationGroups.length > 0) {
            serializationObject.animationGroups = [];
            for(let animationGroupIndex = 0; animationGroupIndex < scene.animationGroups.length; animationGroupIndex++){
                const animationGroup = scene.animationGroups[animationGroupIndex];
                serializationObject.animationGroups.push(animationGroup.serialize());
            }
        }
        // Reflection probes
        if (scene.reflectionProbes && scene.reflectionProbes.length > 0) {
            serializationObject.reflectionProbes = [];
            for(index = 0; index < scene.reflectionProbes.length; index++){
                const reflectionProbe = scene.reflectionProbes[index];
                serializationObject.reflectionProbes.push(reflectionProbe.serialize());
            }
        }
        // Materials
        serializationObject.materials = [];
        serializationObject.multiMaterials = [];
        let material;
        for(index = 0; index < scene.materials.length; index++){
            material = scene.materials[index];
            if (!material.doNotSerialize) {
                serializationObject.materials.push(material.serialize());
            }
        }
        // MultiMaterials
        serializationObject.multiMaterials = [];
        for(index = 0; index < scene.multiMaterials.length; index++){
            const multiMaterial = scene.multiMaterials[index];
            serializationObject.multiMaterials.push(multiMaterial.serialize());
        }
        // Environment texture
        if (scene.environmentTexture) {
            if (scene.environmentTexture._files) {
                serializationObject.environmentTexture = scene.environmentTexture.serialize();
            } else {
                serializationObject.environmentTexture = scene.environmentTexture.name;
                serializationObject.environmentTextureRotationY = scene.environmentTexture.rotationY;
            }
        }
        // Environment Intensity
        serializationObject.environmentIntensity = scene.environmentIntensity;
        // IBL Intensity
        serializationObject.iblIntensity = scene.iblIntensity;
        // Skeletons
        serializationObject.skeletons = [];
        for(index = 0; index < scene.skeletons.length; index++){
            const skeleton = scene.skeletons[index];
            if (!skeleton.doNotSerialize) {
                serializationObject.skeletons.push(skeleton.serialize());
            }
        }
        // Transform nodes
        serializationObject.transformNodes = [];
        for(index = 0; index < scene.transformNodes.length; index++){
            if (!scene.transformNodes[index].doNotSerialize) {
                serializationObject.transformNodes.push(scene.transformNodes[index].serialize());
            }
        }
        // Geometries
        serializationObject.geometries = {};
        serializationObject.geometries.boxes = [];
        serializationObject.geometries.spheres = [];
        serializationObject.geometries.cylinders = [];
        serializationObject.geometries.toruses = [];
        serializationObject.geometries.grounds = [];
        serializationObject.geometries.planes = [];
        serializationObject.geometries.torusKnots = [];
        serializationObject.geometries.vertexData = [];
        SerializedGeometries = [];
        const geometries = scene.getGeometries();
        for(index = 0; index < geometries.length; index++){
            const geometry = geometries[index];
            if (geometry.isReady()) {
                SerializeGeometry(geometry, serializationObject.geometries);
            }
        }
        // Meshes
        serializationObject.meshes = [];
        for(index = 0; index < scene.meshes.length; index++){
            const abstractMesh = scene.meshes[index];
            if (abstractMesh instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Mesh"]) {
                const mesh = abstractMesh;
                if (!mesh.doNotSerialize) {
                    if (mesh.delayLoadState === 1 || mesh.delayLoadState === 0) {
                        serializationObject.meshes.push(SerializeMesh(mesh, serializationObject));
                    }
                }
            }
        }
        // Particles Systems
        serializationObject.particleSystems = [];
        for(index = 0; index < scene.particleSystems.length; index++){
            const particleSystem = scene.particleSystems[index];
            if (!particleSystem.doNotSerialize) {
                serializationObject.particleSystems.push(particleSystem.serialize(false));
            }
        }
        // Post processes
        serializationObject.postProcesses = [];
        for(index = 0; index < scene.postProcesses.length; index++){
            const postProcess = scene.postProcesses[index];
            if (!postProcess.doNotSerialize) {
                serializationObject.postProcesses.push(postProcess.serialize());
            }
        }
        // Action Manager
        if (scene.actionManager) {
            serializationObject.actions = scene.actionManager.serialize("scene");
        }
        // Components
        for (const component of scene._serializableComponents){
            component.serialize(serializationObject);
        }
        // Sprites
        if (scene.spriteManagers) {
            serializationObject.spriteManagers = [];
            for(index = 0; index < scene.spriteManagers.length; index++){
                const spriteManager = scene.spriteManagers[index];
                if (!spriteManager.doNotSerialize) {
                    serializationObject.spriteManagers.push(spriteManager.serialize(true));
                }
            }
        }
        return serializationObject;
    }
    /**
     * Serialize a scene into a JSON compatible object
     * @param scene defines the scene to serialize
     * @returns a JSON promise compatible object
     */ static async SerializeAsync(scene) {
        const serializationObject = SceneSerializer._Serialize(scene, false);
        const promises = [];
        this._CollectPromises(serializationObject, promises);
        await Promise.all(promises);
        return serializationObject;
    }
    static _CollectPromises(obj, promises) {
        if (Array.isArray(obj)) {
            for(let i = 0; i < obj.length; ++i){
                const o = obj[i];
                if (o instanceof Promise) {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return, github/no-then
                    promises.push(o.then((res)=>obj[i] = res));
                } else if (o instanceof Object || Array.isArray(o)) {
                    this._CollectPromises(o, promises);
                }
            }
        } else if (obj instanceof Object) {
            for(const name in obj){
                if (Object.prototype.hasOwnProperty.call(obj, name)) {
                    const o = obj[name];
                    if (o instanceof Promise) {
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-return, github/no-then
                        promises.push(o.then((res)=>obj[name] = res));
                    } else if (o instanceof Object || Array.isArray(o)) {
                        this._CollectPromises(o, promises);
                    }
                }
            }
        }
    }
    /**
     * Serialize a mesh into a JSON compatible object
     * @param toSerialize defines the mesh to serialize
     * @param withParents defines if parents must be serialized as well
     * @param withChildren defines if children must be serialized as well
     * @returns a JSON compatible object
     */ static SerializeMesh(toSerialize /* Mesh || Mesh[] */ , withParents = false, withChildren = false) {
        const serializationObject = {};
        serializationObject.meshes = [];
        serializationObject.transformNodes = [];
        serializationObject.cameras = [];
        serializationObject.lights = [];
        SceneSerializer.ClearCache();
        toSerialize = toSerialize instanceof Array ? toSerialize : [
            toSerialize
        ];
        if (withParents || withChildren) {
            //deliberate for loop! not for each, appended should be processed as well.
            for(let i = 0; i < toSerialize.length; ++i){
                if (withChildren) {
                    const descendants = toSerialize[i].getDescendants();
                    for (const node of descendants){
                        if (toSerialize.indexOf(node) < 0 && !node.doNotSerialize) {
                            toSerialize.push(node);
                        }
                    }
                }
                //make sure the array doesn't contain the object already
                if (withParents && toSerialize[i].parent && toSerialize.indexOf(toSerialize[i].parent) < 0 && !toSerialize[i].parent.doNotSerialize) {
                    toSerialize.push(toSerialize[i].parent);
                }
            }
        }
        for (const mesh of toSerialize){
            FinalizeSingleNode(mesh, serializationObject);
        }
        return serializationObject;
    }
} //# sourceMappingURL=sceneSerializer.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/videoRecorder.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "VideoRecorder",
    ()=>VideoRecorder
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tools.js [app-ssr] (ecmascript)");
;
class VideoRecorder {
    /**
     * Returns whether or not the VideoRecorder is available in your browser.
     * @param engine Defines the Babylon Engine.
     * @param canvas Defines the canvas to record. If not provided, the engine canvas will be used.
     * @returns true if supported otherwise false.
     */ static IsSupported(engine, canvas) {
        const targetCanvas = canvas ?? engine.getRenderingCanvas();
        return !!targetCanvas && typeof targetCanvas.captureStream === "function";
    }
    /**
     * True when a recording is already in progress.
     */ get isRecording() {
        return !!this._canvas && this._isRecording;
    }
    /**
     * Create a new VideoCapture object which can help converting what you see in Babylon to a video file.
     * @param engine Defines the BabylonJS Engine you wish to record.
     * @param options Defines options that can be used to customize the capture.
     */ constructor(engine, options = {}){
        if (!VideoRecorder.IsSupported(engine, options.canvas)) {
            // eslint-disable-next-line no-throw-literal
            throw "Your browser does not support recording so far.";
        }
        const canvas = options.canvas ?? engine.getRenderingCanvas();
        if (!canvas) {
            // eslint-disable-next-line no-throw-literal
            throw "The babylon engine must have a canvas to be recorded";
        }
        this._canvas = canvas;
        this._isRecording = false;
        this._options = {
            ...VideoRecorder._DefaultOptions,
            ...options
        };
        const stream = this._canvas.captureStream(this._options.fps);
        if (this._options.audioTracks) {
            for (const track of this._options.audioTracks){
                stream.addTrack(track);
            }
        }
        this._mediaRecorder = new MediaRecorder(stream, {
            mimeType: this._options.mimeType
        });
        this._mediaRecorder.ondataavailable = (evt)=>this._handleDataAvailable(evt);
        this._mediaRecorder.onerror = (evt)=>this._handleError(evt);
        this._mediaRecorder.onstop = ()=>this._handleStop();
    }
    /**
     * Stops the current recording before the default capture timeout passed in the startRecording function.
     */ stopRecording() {
        if (!this._canvas || !this._mediaRecorder) {
            return;
        }
        if (!this.isRecording) {
            return;
        }
        this._isRecording = false;
        this._mediaRecorder.stop();
    }
    /**
     * Starts recording the canvas for a max duration specified in parameters.
     * @param fileName Defines the name of the file to be downloaded when the recording stop.
     * If null no automatic download will start and you can rely on the promise to get the data back.
     * @param maxDuration Defines the maximum recording time in seconds.
     * It defaults to 7 seconds. A value of zero will not stop automatically, you would need to call stopRecording manually.
     * @returns A promise callback at the end of the recording with the video data in Blob.
     */ // eslint-disable-next-line @typescript-eslint/promise-function-async
    startRecording(fileName = "babylonjs.webm", maxDuration = 7) {
        if (!this._canvas || !this._mediaRecorder) {
            // eslint-disable-next-line no-throw-literal
            throw "Recorder has already been disposed";
        }
        if (this.isRecording) {
            // eslint-disable-next-line no-throw-literal
            throw "Recording already in progress";
        }
        if (maxDuration > 0) {
            setTimeout(()=>{
                this.stopRecording();
            }, maxDuration * 1000);
        }
        this._fileName = fileName;
        this._recordedChunks = [];
        this._resolve = null;
        this._reject = null;
        this._isRecording = true;
        this._mediaRecorder.start(this._options.recordChunckSize);
        return new Promise((resolve, reject)=>{
            this._resolve = resolve;
            this._reject = reject;
        });
    }
    /**
     * Releases internal resources used during the recording.
     */ dispose() {
        this._canvas = null;
        this._mediaRecorder = null;
        this._recordedChunks = [];
        this._fileName = null;
        this._resolve = null;
        this._reject = null;
    }
    _handleDataAvailable(event) {
        if (event.data.size > 0) {
            this._recordedChunks.push(event.data);
        }
    }
    _handleError(event) {
        this.stopRecording();
        if (this._reject) {
            this._reject(event.error);
        } else {
            throw new event.error();
        }
    }
    _handleStop() {
        this.stopRecording();
        const superBuffer = new Blob(this._recordedChunks);
        if (this._resolve) {
            this._resolve(superBuffer);
        }
        window.URL.createObjectURL(superBuffer);
        if (this._fileName) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].Download(superBuffer, this._fileName);
        }
    }
}
VideoRecorder._DefaultOptions = {
    mimeType: "video/webm",
    fps: 25,
    recordChunckSize: 3000
}; //# sourceMappingURL=videoRecorder.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/screenshotTools.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CreateScreenshot",
    ()=>CreateScreenshot,
    "CreateScreenshotAsync",
    ()=>CreateScreenshotAsync,
    "CreateScreenshotForFrameGraphAsync",
    ()=>CreateScreenshotForFrameGraphAsync,
    "CreateScreenshotUsingRenderTarget",
    ()=>CreateScreenshotUsingRenderTarget,
    "CreateScreenshotUsingRenderTargetAsync",
    ()=>CreateScreenshotUsingRenderTargetAsync,
    "CreateScreenshotWithResizeAsync",
    ()=>CreateScreenshotWithResizeAsync,
    "ScreenshotTools",
    ()=>ScreenshotTools
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/Textures/texture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$renderTargetTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/Textures/renderTargetTexture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$PostProcesses$2f$fxaaPostProcess$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/PostProcesses/fxaaPostProcess.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/logger.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$dumpTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/dumpTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/textureTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$timingTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/timingTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$FrameGraph$2f$frameGraphTypes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/FrameGraph/frameGraphTypes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$FrameGraph$2f$Tasks$2f$PostProcesses$2f$fxaaTask$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/FrameGraph/Tasks/PostProcesses/fxaaTask.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$FrameGraph$2f$Tasks$2f$PostProcesses$2f$passTask$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/FrameGraph/Tasks/PostProcesses/passTask.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$FrameGraph$2f$frameGraphUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/FrameGraph/frameGraphUtils.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
let screenshotCanvas = null;
function CreateScreenshot(engine, camera, size, successCallback, mimeType = "image/png", forceDownload = false, quality, useFill = false, clearWithSceneColor = false) {
    const { height, width } = GetScreenshotSize(engine, camera, size);
    if (!(height && width)) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Error("Invalid 'size' parameter !");
        return;
    }
    const scene = camera.getScene();
    let useRenderTarget = scene.activeCamera !== camera;
    if (scene.frameGraph) {
        const mainObjectRendererTask = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$FrameGraph$2f$frameGraphUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FrameGraphUtils"].FindMainObjectRenderer(scene.frameGraph);
        if (mainObjectRendererTask) {
            useRenderTarget = mainObjectRendererTask.camera !== camera;
        }
    }
    if (useRenderTarget) {
        CreateScreenshotUsingRenderTarget(engine, camera, size, (data)=>{
            if (forceDownload) {
                const blob = new Blob([
                    data
                ]);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].DownloadBlob(blob);
                if (successCallback) {
                    successCallback("");
                }
            } else if (successCallback) {
                successCallback(data);
            }
        }, mimeType, 1.0, engine.getCreationOptions().antialias, undefined, undefined, undefined, undefined, quality);
        return;
    }
    engine.onEndFrameObservable.addOnce(()=>{
        if (!screenshotCanvas) {
            screenshotCanvas = document.createElement("canvas");
        }
        screenshotCanvas.width = width;
        screenshotCanvas.height = height;
        const renderContext = screenshotCanvas.getContext("2d");
        const renderingCanvas = engine.getRenderingCanvas();
        if (!renderContext || !renderingCanvas) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Error("Failed to create screenshot. Rendering context or rendering canvas is not available.");
            return;
        }
        const srcWidth = renderingCanvas.width;
        const srcHeight = renderingCanvas.height;
        const destWidth = screenshotCanvas.width;
        const destHeight = screenshotCanvas.height;
        // Calculate scale factors for width and height.
        const scaleX = destWidth / srcWidth;
        const scaleY = destHeight / srcHeight;
        // Use the larger of the two scales to fill the screenshot dimensions, else use the smaller to fit.
        const scale = useFill ? Math.max(scaleX, scaleY) : Math.min(scaleX, scaleY);
        const newWidth = srcWidth * scale;
        const newHeight = srcHeight * scale;
        // Center the image in the screenshot canvas
        const offsetX = (destWidth - newWidth) / 2;
        const offsetY = (destHeight - newHeight) / 2;
        renderContext.save();
        renderContext.fillStyle = clearWithSceneColor ? scene.clearColor.toHexString() : "rgba(0, 0, 0, 0)";
        renderContext.fillRect(0, 0, width, height);
        renderContext.restore();
        renderContext.drawImage(renderingCanvas, 0, 0, srcWidth, srcHeight, offsetX, offsetY, newWidth, newHeight);
        if (forceDownload) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].EncodeScreenshotCanvasData(screenshotCanvas, undefined, mimeType, undefined, quality);
            if (successCallback) {
                successCallback("");
            }
        } else {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].EncodeScreenshotCanvasData(screenshotCanvas, successCallback, mimeType, undefined, quality);
        }
    });
}
async function CreateScreenshotAsync(engine, camera, size, mimeType = "image/png", quality, useFill = false, clearWithSceneColor = false, forceDownload = false) {
    return await new Promise((resolve, reject)=>{
        CreateScreenshot(engine, camera, size, (data)=>{
            if (typeof data !== "undefined") {
                resolve(data);
            } else {
                reject(new Error("Data is undefined"));
            }
        }, mimeType, forceDownload, quality, useFill, clearWithSceneColor);
    });
}
async function CreateScreenshotWithResizeAsync(engine, camera, width, height, mimeType = "image/png", quality, useFill = false) {
    return await new Promise((resolve)=>{
        CreateScreenshot(engine, camera, {
            width: width,
            height: height
        }, ()=>{
            resolve();
        }, mimeType, true, quality, useFill);
    });
}
function CreateScreenshotUsingRenderTarget(engine, camera, size, successCallback, mimeType = "image/png", samples = 1, antialiasing = false, fileName, renderSprites = false, enableStencilBuffer = false, useLayerMask = true, quality, customizeTexture, customDumpData) {
    const scene = camera.getScene();
    if (scene.frameGraph) {
        // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then
        CreateScreenshotForFrameGraphAsync(scene.frameGraph, camera, size, mimeType, samples, antialiasing, fileName, quality, customDumpData, !successCallback).then((data)=>{
            if (successCallback) {
                successCallback(data);
            }
        });
        return;
    }
    const { height, width, finalWidth, finalHeight } = GetScreenshotSize(engine, camera, size);
    const targetTextureSize = {
        width,
        height
    };
    if (!(height && width)) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Error("Invalid 'size' parameter !");
        return;
    }
    // Prevent engine to render on screen while we do the screenshot
    engine.skipFrameRender = true;
    const originalGetRenderWidth = engine.getRenderWidth;
    const originalGetRenderHeight = engine.getRenderHeight;
    // Override getRenderWidth and getRenderHeight to return the desired size of the render
    // A few internal methods are relying on the canvas size to compute the render size
    // so we need to override these methods to ensure the correct size is used during the preparation of the render
    // as well as the screenshot
    engine.getRenderWidth = (useScreen = false)=>{
        if (!useScreen && engine._currentRenderTarget) {
            return engine._currentRenderTarget.width;
        }
        return width;
    };
    engine.getRenderHeight = (useScreen = false)=>{
        if (!useScreen && engine._currentRenderTarget) {
            return engine._currentRenderTarget.height;
        }
        return height;
    };
    // Trigger a resize event to ensure the intermediate renders have the correct size
    if (engine.onResizeObservable.hasObservers()) {
        engine.onResizeObservable.notifyObservers(engine);
    }
    // At this point size can be a number, or an object (according to engine.prototype.createRenderTargetTexture method)
    const texture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$renderTargetTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RenderTargetTexture"]("screenShot", targetTextureSize, scene, false, false, 0, false, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].BILINEAR_SAMPLINGMODE, undefined, enableStencilBuffer, undefined, undefined, undefined, samples);
    texture.renderList = scene.meshes.slice();
    texture.samples = samples;
    texture.renderSprites = renderSprites;
    texture.activeCamera = camera;
    texture.forceLayerMaskCheck = useLayerMask;
    customizeTexture?.(texture);
    const dumpDataFunc = customDumpData || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$dumpTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DumpData"];
    const renderWhenReady = ()=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$timingTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_RetryWithInterval"])(()=>texture.isReadyForRendering() && camera.isReady(true), ()=>{
            engine.onEndFrameObservable.addOnce(()=>{
                if (finalWidth === width && finalHeight === height) {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then
                    texture.readPixels(undefined, undefined, undefined, false).then((data)=>{
                        dumpDataFunc(width, height, data, successCallback, mimeType, fileName, true, undefined, quality);
                        texture.dispose();
                    });
                } else {
                    const importPromise = engine.isWebGPU ? __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/pass.fragment.js [app-ssr] (ecmascript, async loader)") : __turbopack_context__.A("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/pass.fragment.js [app-ssr] (ecmascript, async loader)");
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then
                    importPromise.then(async ()=>// eslint-disable-next-line github/no-then
                        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ApplyPostProcess"])("pass", texture.getInternalTexture(), scene, undefined, undefined, undefined, finalWidth, finalHeight).then((texture)=>{
                            // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then
                            engine._readTexturePixels(texture, finalWidth, finalHeight, -1, 0, null, true, false, 0, 0).then((data)=>{
                                dumpDataFunc(finalWidth, finalHeight, data, successCallback, mimeType, fileName, true, undefined, quality);
                                texture.dispose();
                            });
                        }));
                }
            });
            scene.incrementRenderId();
            scene.resetCachedMaterial();
            // Record the original scene setup
            const originalCamera = scene.activeCamera;
            const originalCameras = scene.activeCameras;
            const originalOutputRenderTarget = camera.outputRenderTarget;
            const originalSpritesEnabled = scene.spritesEnabled;
            // Swap with the requested one
            scene.activeCamera = camera;
            scene.activeCameras = null;
            camera.outputRenderTarget = texture;
            scene.spritesEnabled = renderSprites;
            const currentMeshList = scene.meshes;
            scene.meshes = texture.renderList || scene.meshes;
            // render the scene on the RTT
            try {
                scene.render();
            } finally{
                // Restore the original scene camera setup
                scene.activeCamera = originalCamera;
                scene.activeCameras = originalCameras;
                camera.outputRenderTarget = originalOutputRenderTarget;
                scene.spritesEnabled = originalSpritesEnabled;
                scene.meshes = currentMeshList;
                engine.getRenderWidth = originalGetRenderWidth;
                engine.getRenderHeight = originalGetRenderHeight;
                // Trigger a resize event to ensure the intermediate renders have the correct size
                if (engine.onResizeObservable.hasObservers()) {
                    engine.onResizeObservable.notifyObservers(engine);
                }
                camera.getProjectionMatrix(true); // Force cache refresh;
                engine.skipFrameRender = false;
            }
        }, ()=>{
            // Restore engine frame rendering on error
            engine.skipFrameRender = false;
            engine.getRenderWidth = originalGetRenderWidth;
            engine.getRenderHeight = originalGetRenderHeight;
        });
    };
    const renderToTexture = ()=>{
        // render the RTT
        scene.incrementRenderId();
        scene.resetCachedMaterial();
        renderWhenReady();
    };
    if (antialiasing) {
        const fxaaPostProcess = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$PostProcesses$2f$fxaaPostProcess$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FxaaPostProcess"]("antialiasing", 1.0, scene.activeCamera);
        texture.addPostProcess(fxaaPostProcess);
        // Ensures the correct background color is used
        fxaaPostProcess.autoClear = true;
        // Async Shader Compilation can lead to none ready effects in synchronous code
        fxaaPostProcess.onEffectCreatedObservable.addOnce((e)=>{
            if (!e.isReady()) {
                e.onCompiled = ()=>{
                    renderToTexture();
                };
            } else {
                renderToTexture();
            }
        });
    } else {
        // No need to wait for extra resources to be ready
        renderToTexture();
    }
}
async function CreateScreenshotUsingRenderTargetAsync(engine, camera, size, mimeType = "image/png", samples = 1, antialiasing = false, fileName, renderSprites = false, enableStencilBuffer = false, useLayerMask = true, quality, customizeTexture, customDumpData) {
    return await new Promise((resolve, reject)=>{
        CreateScreenshotUsingRenderTarget(engine, camera, size, (data)=>{
            if (typeof data !== "undefined") {
                resolve(data);
            } else {
                reject(new Error("Data is undefined"));
            }
        }, mimeType, samples, antialiasing, fileName, renderSprites, enableStencilBuffer, useLayerMask, quality, customizeTexture, customDumpData);
    });
}
async function CreateScreenshotForFrameGraphAsync(frameGraph, camera, size, mimeType = "image/png", samples = 1, antialiasing = false, fileName, quality, customDumpData, automaticDownload = false, numberOfFramesToRender) {
    const engine = frameGraph.engine;
    const textureManager = frameGraph.textureManager;
    const { height, width, finalWidth, finalHeight } = GetScreenshotSize(engine, camera, size);
    const targetTextureSize = {
        width,
        height
    };
    const dumpDataFunc = customDumpData || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$dumpTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DumpData"];
    const tasks = frameGraph.tasks;
    const currentTaskListLength = tasks.length;
    const pausedExecution = frameGraph.pausedExecution;
    const currentParallelShaderCompile = engine.getCaps().parallelShaderCompile;
    textureManager.setBackBufferTextures(0, 0, {
        size: targetTextureSize,
        options: {
            createMipMaps: false,
            samples,
            types: [
                0
            ],
            formats: [
                5
            ],
            useSRGBBuffers: [
                false
            ],
            creationFlags: [
                0
            ],
            labels: [
                "screenshot color"
            ]
        },
        sizeIsPercentage: false
    }, {
        size: targetTextureSize,
        options: {
            createMipMaps: false,
            samples,
            types: [
                0
            ],
            formats: [
                engine.isStencilEnable ? 13 : 14
            ],
            useSRGBBuffers: [
                false
            ],
            creationFlags: [
                0
            ],
            labels: [
                "screenshot depth"
            ]
        },
        sizeIsPercentage: false
    });
    let outputTextureHandle = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$FrameGraph$2f$frameGraphTypes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["backbufferColorTextureHandle"];
    if (antialiasing) {
        const task = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$FrameGraph$2f$Tasks$2f$PostProcesses$2f$fxaaTask$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FrameGraphFXAATask"]("fxaa", frameGraph);
        task.sourceTexture = outputTextureHandle;
        outputTextureHandle = task.outputTexture;
        frameGraph.addTask(task);
    }
    if (finalWidth !== width || finalHeight !== height) {
        const task = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$FrameGraph$2f$Tasks$2f$PostProcesses$2f$passTask$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FrameGraphPassTask"]("pass", frameGraph);
        task.sourceTexture = outputTextureHandle;
        task.targetTexture = frameGraph.textureManager.createRenderTargetTexture("pass_output", {
            size: {
                width: finalWidth,
                height: finalHeight
            },
            options: {
                createMipMaps: false,
                types: [
                    0
                ],
                formats: [
                    5
                ],
                samples: 1,
                labels: [
                    "screenshot_final_texture"
                ],
                useSRGBBuffers: [
                    false
                ]
            },
            sizeIsPercentage: false
        });
        outputTextureHandle = task.outputTexture;
        frameGraph.addTask(task);
    }
    const mainObjectRendererTask = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$FrameGraph$2f$frameGraphUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FrameGraphUtils"].FindMainObjectRenderer(frameGraph);
    let currentCamera = null;
    if (mainObjectRendererTask) {
        currentCamera = mainObjectRendererTask.camera;
        mainObjectRendererTask.camera = camera;
    }
    /**
     * We need to disable parallel shader compile before running frameGraph.whenReadyAsync because of WebGL.
     * In some cases, when whenReadyAsync is not ready the first time readiness is checked, the execute call will
     * not render correctly. Disabling parallel shader compile fixes the problem. This does not happen with WebGPU.
     *
     * That's what happens in this PG: http://playground.babylonjs.com/#GAGVQO#16
     *
     * The FXAA task is injected in the frame graph (because antialiasing==true), and whenReadyAsync checks the readiness
     * of the FXAA task for the first time, it returns false because the shader is not yet imported/compiled.
     * If you uncomment line 2 in the PG, the FXAA shader will be preloaded/compiled before the screenshot is taken and
     * whenReadyAsync won't have to check readiness twice. In that case, disabling parallel shader compile won't be necessary to have a correct screenshot.
     *
     * Same problem in: http://playground.babylonjs.com/#Z6C5EF#3
     *
     * TODO: find a better solution for this problem?
     */ engine.getCaps().parallelShaderCompile = undefined;
    await frameGraph.buildAsync();
    const numberOfFrames = numberOfFramesToRender ?? (textureManager.hasHistoryTextures ? 32 : 1);
    for(let i = 0; i < numberOfFrames; ++i){
        frameGraph.execute();
    }
    // eslint-disable-next-line require-atomic-updates
    frameGraph.pausedExecution = true;
    engine.getCaps().parallelShaderCompile = currentParallelShaderCompile;
    for(let i = currentTaskListLength; i < tasks.length; ++i){
        frameGraph.tasks[i].dispose();
    }
    // eslint-disable-next-line require-atomic-updates
    frameGraph.tasks.length = currentTaskListLength;
    if (mainObjectRendererTask && currentCamera) {
        mainObjectRendererTask.camera = currentCamera;
    }
    const texture = frameGraph.textureManager.getTextureFromHandle(outputTextureHandle);
    texture.incrementReferences();
    textureManager.resetBackBufferTextures();
    await frameGraph.buildAsync();
    // eslint-disable-next-line require-atomic-updates
    frameGraph.pausedExecution = pausedExecution;
    // eslint-disable-next-line @typescript-eslint/return-await
    return new Promise((resolve)=>{
        // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then
        engine._readTexturePixels(texture, finalWidth, finalHeight, -1, 0, null, true, false, 0, 0).then(async (data)=>{
            texture.dispose();
            dumpDataFunc(finalWidth, finalHeight, data, automaticDownload ? undefined : (data)=>resolve(data), mimeType, fileName, true, undefined, quality);
            if (automaticDownload) {
                resolve(null);
            }
        });
    });
}
/**
 * Gets height and width for screenshot size
 * @param engine The engine to use for rendering
 * @param camera The camera to use for rendering
 * @param size This size of the screenshot. can be a number or an object implementing IScreenshotSize
 * @returns height and width for screenshot size
 */ function GetScreenshotSize(engine, camera, size) {
    let height = 0;
    let width = 0;
    let finalWidth = 0;
    let finalHeight = 0;
    //If a size value defined as object
    if (typeof size === "object") {
        const precision = size.precision ? Math.abs(size.precision) // prevent GL_INVALID_VALUE : glViewport: negative width/height
         : 1;
        //If a width and height values is specified
        if (size.width && size.height) {
            height = size.height * precision;
            width = size.width * precision;
        } else if (size.width && !size.height) {
            width = size.width * precision;
            height = Math.round(width / engine.getAspectRatio(camera));
        } else if (size.height && !size.width) {
            height = size.height * precision;
            width = Math.round(height * engine.getAspectRatio(camera));
        } else {
            width = Math.round(engine.getRenderWidth() * precision);
            height = Math.round(width / engine.getAspectRatio(camera));
        }
        //If a finalWidth and finalHeight values is specified
        if (size.finalWidth && size.finalHeight) {
            finalHeight = size.finalHeight;
            finalWidth = size.finalWidth;
        } else if (size.finalWidth && !size.finalHeight) {
            finalWidth = size.finalWidth;
            finalHeight = Math.round(finalWidth / engine.getAspectRatio(camera));
        } else if (size.finalHeight && !size.finalWidth) {
            finalHeight = size.finalHeight;
            finalWidth = Math.round(finalHeight * engine.getAspectRatio(camera));
        } else {
            finalWidth = width;
            finalHeight = height;
        }
    } else if (!isNaN(size)) {
        height = size;
        width = size;
        finalWidth = size;
        finalHeight = size;
    }
    // When creating the image data from the CanvasRenderingContext2D, the width and height is clamped to the size of the _gl context
    // On certain GPUs, it seems as if the _gl context truncates to an integer automatically. Therefore, if a user tries to pass the width of their canvas element
    // and it happens to be a float (1000.5 x 600.5 px), the engine.readPixels will return a different size array than context.createImageData
    // to resolve this, we truncate the floats here to ensure the same size
    if (width) {
        width = Math.floor(width);
    }
    if (height) {
        height = Math.floor(height);
    }
    if (finalWidth) {
        finalWidth = Math.floor(finalWidth);
    }
    if (finalHeight) {
        finalHeight = Math.floor(finalHeight);
    }
    return {
        height: height | 0,
        width: width | 0,
        finalWidth: finalWidth | 0,
        finalHeight: finalHeight | 0
    };
}
const ScreenshotTools = {
    /**
     * Captures a screenshot of the current rendering
     * Please note that simultaneous screenshots are not supported: you must wait until one screenshot is complete before taking another.
     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG
     * @param engine defines the rendering engine
     * @param camera defines the source camera. If the camera is not the scene's active camera, {@link CreateScreenshotUsingRenderTarget} will be used instead, and `useFill` will be ignored
     * @param size This parameter can be set to a single number or to an object with the
     * following (optional) properties: precision, width, height. If a single number is passed,
     * it will be used for both width and height. If an object is passed, the screenshot size
     * will be derived from the parameters. The precision property is a multiplier allowing
     * rendering at a higher or lower resolution
     * @param successCallback defines the callback receives a single parameter which contains the
     * screenshot as a string of base64-encoded characters. This string can be assigned to the
     * src parameter of an <img> to display it
     * @param mimeType defines the MIME type of the screenshot image (default: image/png).
     * Check your browser for supported MIME types
     * @param forceDownload force the system to download the image even if a successCallback is provided
     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
     * @param useFill fill the screenshot dimensions with the render canvas and clip any overflow. If false, fit the canvas within the screenshot, as in letterboxing.
     */ CreateScreenshot,
    /**
     * Captures a screenshot of the current rendering
     * Please note that simultaneous screenshots are not supported: you must wait until one screenshot is complete before taking another.
     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG
     * @param engine defines the rendering engine
     * @param camera defines the source camera. If the camera is not the scene's active camera, {@link CreateScreenshotUsingRenderTarget} will be used instead, and `useFill` will be ignored
     * @param size This parameter can be set to a single number or to an object with the
     * following (optional) properties: precision, width, height. If a single number is passed,
     * it will be used for both width and height. If an object is passed, the screenshot size
     * will be derived from the parameters. The precision property is a multiplier allowing
     * rendering at a higher or lower resolution
     * @param mimeType defines the MIME type of the screenshot image (default: image/png).
     * Check your browser for supported MIME types
     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
     * @param useFill fill the screenshot dimensions with the render canvas and clip any overflow. If false, fit the canvas within the screenshot, as in letterboxing.
     * @param forceDownload force the system to download the image
     * @returns screenshot as a string of base64-encoded characters. This string can be assigned
     * to the src parameter of an <img> to display it
     */ CreateScreenshotAsync,
    /**
     * Captures and automatically downloads a screenshot of the current rendering for a specific size. This will render the entire canvas but will generate a blink (due to canvas resize)
     * If screenshot image data is needed, use {@link CreateScreenshotAsync} instead.
     * Please note that simultaneous screenshots are not supported: you must wait until one screenshot is complete before taking another.
     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG
     * @param engine defines the rendering engine
     * @param camera defines the source camera. If the camera is not the scene's active camera, {@link CreateScreenshotUsingRenderTarget} will be used instead, and `useFill` will be ignored
     * @param width defines the expected width
     * @param height defines the expected height
     * @param mimeType defines the MIME type of the screenshot image (default: image/png).
     * Check your browser for supported MIME types
     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
     * @param useFill fill the screenshot dimensions with the render canvas and clip any overflow. If false, fit the canvas within the screenshot, as in letterboxing.
     * @returns promise that resolves once the screenshot is taken
     */ CreateScreenshotWithResizeAsync,
    /**
     * Generates an image screenshot from the specified camera.
     * Please note that simultaneous screenshots are not supported: you must wait until one screenshot is complete before taking another.
     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG
     * @param engine The engine to use for rendering
     * @param camera The camera to use for rendering
     * @param size This parameter can be set to a single number or to an object with the
     * following (optional) properties: precision, width, height. If a single number is passed,
     * it will be used for both width and height. If an object is passed, the screenshot size
     * will be derived from the parameters. The precision property is a multiplier allowing
     * rendering at a higher or lower resolution
     * @param successCallback The callback receives a single parameter which contains the
     * screenshot as a string of base64-encoded characters. This string can be assigned to the
     * src parameter of an <img> to display it
     * @param mimeType The MIME type of the screenshot image (default: image/png).
     * Check your browser for supported MIME types
     * @param samples Texture samples (default: 1)
     * @param antialiasing Whether antialiasing should be turned on or not (default: false)
     * @param fileName A name for for the downloaded file.
     * @param renderSprites Whether the sprites should be rendered or not (default: false)
     * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)
     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
     */ CreateScreenshotUsingRenderTarget,
    /**
     * Generates an image screenshot from the specified camera.
     * Please note that simultaneous screenshots are not supported: you must wait until one screenshot is complete before taking another.
     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG
     * @param engine The engine to use for rendering
     * @param camera The camera to use for rendering
     * @param size This parameter can be set to a single number or to an object with the
     * following (optional) properties: precision, width, height. If a single number is passed,
     * it will be used for both width and height. If an object is passed, the screenshot size
     * will be derived from the parameters. The precision property is a multiplier allowing
     * rendering at a higher or lower resolution
     * @param mimeType The MIME type of the screenshot image (default: image/png).
     * Check your browser for supported MIME types
     * @param samples Texture samples (default: 1)
     * @param antialiasing Whether antialiasing should be turned on or not (default: false)
     * @param fileName A name for for the downloaded file.
     * @param renderSprites Whether the sprites should be rendered or not (default: false)
     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
     * @returns screenshot as a string of base64-encoded characters. This string can be assigned
     * to the src parameter of an <img> to display it
     */ CreateScreenshotUsingRenderTargetAsync,
    /**
     * Generates an image screenshot from the specified frame graph and camera
     * Please note:
     *  - that the frame graph must write to the back buffer color for this to work! This is because the back buffer color is replaced by the texture of the screenshot during the operation.
     *  - the camera is set as the camera for the main object renderer of the frame graph during the operation, and restored afterwards.
     *    This will only work if the frame graph has a main object renderer (isMainObjectRenderer is true for one of its object renderers)
     *  - that simultaneous screenshots are not supported: you must wait until one screenshot is complete before taking another.
     * @param frameGraph The frame graph to use for rendering
     * @param camera The camera to use for rendering
     * @param size This parameter can be set to a single number or to an object with the
     * following (optional) properties: precision, width, height. If a single number is passed,
     * it will be used for both width and height. If an object is passed, the screenshot size
     * will be derived from the parameters. The precision property is a multiplier allowing
     * rendering at a higher or lower resolution
     * @param mimeType The MIME type of the screenshot image (default: image/png).
     * Check your browser for supported MIME types
     * @param samples Texture samples (default: 1)
     * @param antialiasing Whether antialiasing should be turned on or not (default: false)
     * @param fileName A name for for the downloaded file.
     * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
     * @param customDumpData The function to use to dump the data. If not provided, the default DumpData function will be used.
     * @param automaticDownload If true, the screenshot will be automatically downloaded as a file instead of being returned as a string: in this case, null is returned.
     * @returns screenshot as a string of base64-encoded characters. This string can be assigned
     * to the src parameter of an <img> to display it. If automaticDownload is true, null is returned instead
     */ CreateScreenshotForFrameGraphAsync
};
/**
 * This will be executed automatically for UMD and es5.
 * If esm dev wants the side effects to execute they will have to run it manually
 * Once we build native modules those need to be exported.
 * @internal
 */ const initSideEffects = ()=>{
    // References the dependencies.
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].CreateScreenshot = CreateScreenshot;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].CreateScreenshotAsync = CreateScreenshotAsync;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].CreateScreenshotUsingRenderTarget = CreateScreenshotUsingRenderTarget;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].CreateScreenshotUsingRenderTargetAsync = CreateScreenshotUsingRenderTargetAsync;
};
initSideEffects(); //# sourceMappingURL=screenshotTools.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/iInspectable.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Enum that determines the text-wrapping mode to use.
 */ __turbopack_context__.s([
    "InspectableType",
    ()=>InspectableType
]);
var InspectableType;
(function(InspectableType) {
    /**
     * Checkbox for booleans
     */ InspectableType[InspectableType["Checkbox"] = 0] = "Checkbox";
    /**
     * Sliders for numbers
     */ InspectableType[InspectableType["Slider"] = 1] = "Slider";
    /**
     * Vector3
     */ InspectableType[InspectableType["Vector3"] = 2] = "Vector3";
    /**
     * Quaternions
     */ InspectableType[InspectableType["Quaternion"] = 3] = "Quaternion";
    /**
     * Color3
     */ InspectableType[InspectableType["Color3"] = 4] = "Color3";
    /**
     * String
     */ InspectableType[InspectableType["String"] = 5] = "String";
    /**
     * Button
     */ InspectableType[InspectableType["Button"] = 6] = "Button";
    /**
     * Options
     */ InspectableType[InspectableType["Options"] = 7] = "Options";
    /**
     * Tab
     */ InspectableType[InspectableType["Tab"] = 8] = "Tab";
    /**
     * File button
     */ InspectableType[InspectableType["FileButton"] = 9] = "FileButton";
    /**
     * Vector2
     */ InspectableType[InspectableType["Vector2"] = 10] = "Vector2";
})(InspectableType || (InspectableType = {})); //# sourceMappingURL=iInspectable.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/gradients.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Color3Gradient",
    ()=>Color3Gradient,
    "ColorGradient",
    ()=>ColorGradient,
    "FactorGradient",
    ()=>FactorGradient,
    "GradientHelper",
    ()=>GradientHelper
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$color$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.color.js [app-ssr] (ecmascript)");
;
class ColorGradient {
    /**
     * Creates a new color4 gradient
     * @param gradient gets or sets the gradient value (between 0 and 1)
     * @param color1 gets or sets first associated color
     * @param color2 gets or sets first second color
     */ constructor(/**
     * Gets or sets the gradient value (between 0 and 1)
     */ gradient, /**
     * Gets or sets first associated color
     */ color1, /**
     * Gets or sets second associated color
     */ color2){
        this.gradient = gradient;
        this.color1 = color1;
        this.color2 = color2;
    }
    /**
     * Will get a color picked randomly between color1 and color2.
     * If color2 is undefined then color1 will be used
     * @param result defines the target Color4 to store the result in
     */ getColorToRef(result) {
        if (!this.color2) {
            result.copyFrom(this.color1);
            return;
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$color$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color4"].LerpToRef(this.color1, this.color2, Math.random(), result);
    }
}
class Color3Gradient {
    /**
     * Creates a new color3 gradient
     * @param gradient gets or sets the gradient value (between 0 and 1)
     * @param color gets or sets associated color
     */ constructor(/**
     * Gets or sets the gradient value (between 0 and 1)
     */ gradient, /**
     * Gets or sets the associated color
     */ color){
        this.gradient = gradient;
        this.color = color;
    }
}
class FactorGradient {
    /**
     * Creates a new factor gradient
     * @param gradient gets or sets the gradient value (between 0 and 1)
     * @param factor1 gets or sets first associated factor
     * @param factor2 gets or sets second associated factor
     */ constructor(/**
     * Gets or sets the gradient value (between 0 and 1)
     */ gradient, /**
     * Gets or sets first associated factor
     */ factor1, /**
     * Gets or sets second associated factor
     */ factor2){
        this.gradient = gradient;
        this.factor1 = factor1;
        this.factor2 = factor2;
    }
    /**
     * Will get a number picked randomly between factor1 and factor2.
     * If factor2 is undefined then factor1 will be used
     * @returns the picked number
     */ getFactor() {
        if (this.factor2 === undefined || this.factor2 === this.factor1) {
            return this.factor1;
        }
        return this.factor1 + (this.factor2 - this.factor1) * Math.random();
    }
}
class GradientHelper {
    /**
     * Gets the current gradient from an array of IValueGradient
     * @param ratio defines the current ratio to get
     * @param gradients defines the array of IValueGradient
     * @param updateFunc defines the callback function used to get the final value from the selected gradients
     */ static GetCurrentGradient(ratio, gradients, updateFunc) {
        // Use last index if over
        if (gradients[0].gradient > ratio) {
            updateFunc(gradients[0], gradients[0], 1.0);
            return;
        }
        for(let gradientIndex = 0; gradientIndex < gradients.length - 1; gradientIndex++){
            const currentGradient = gradients[gradientIndex];
            const nextGradient = gradients[gradientIndex + 1];
            if (ratio >= currentGradient.gradient && ratio <= nextGradient.gradient) {
                const scale = (ratio - currentGradient.gradient) / (nextGradient.gradient - currentGradient.gradient);
                updateFunc(currentGradient, nextGradient, scale);
                return;
            }
        }
        // Use last index if over
        const lastIndex = gradients.length - 1;
        updateFunc(gradients[lastIndex], gradients[lastIndex], 1.0);
    }
} //# sourceMappingURL=gradients.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/fileRequest.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
;
 //# sourceMappingURL=fileRequest.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/customAnimationFrameRequester.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
;
 //# sourceMappingURL=customAnimationFrameRequester.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/interfaces/screenshotSize.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
;
 //# sourceMappingURL=screenshotSize.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/interfaces/iPerfViewer.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
;
 //# sourceMappingURL=iPerfViewer.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/dataReader.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DataReader",
    ()=>DataReader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$stringTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/stringTools.js [app-ssr] (ecmascript)");
;
class DataReader {
    /**
     * Constructor
     * @param buffer The buffer to read
     */ constructor(buffer){
        /**
         * The current byte offset from the beginning of the data buffer.
         */ this.byteOffset = 0;
        this.buffer = buffer;
    }
    /**
     * Loads the given byte length.
     * @param byteLength The byte length to load
     * @returns A promise that resolves when the load is complete
     */ async loadAsync(byteLength) {
        const data = await this.buffer.readAsync(this.byteOffset, byteLength);
        this._dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
        this._dataByteOffset = 0;
    }
    /**
     * Read a unsigned 32-bit integer from the currently loaded data range.
     * @returns The 32-bit integer read
     */ readUint32() {
        const value = this._dataView.getUint32(this._dataByteOffset, true);
        this._dataByteOffset += 4;
        this.byteOffset += 4;
        return value;
    }
    /**
     * Read a byte array from the currently loaded data range.
     * @param byteLength The byte length to read
     * @returns The byte array read
     */ readUint8Array(byteLength) {
        const value = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._dataByteOffset, byteLength);
        this._dataByteOffset += byteLength;
        this.byteOffset += byteLength;
        return value;
    }
    /**
     * Read a string from the currently loaded data range.
     * @param byteLength The byte length to read
     * @returns The string read
     */ readString(byteLength) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$stringTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Decode"])(this.readUint8Array(byteLength));
    }
    /**
     * Skips the given byte length the currently loaded data range.
     * @param byteLength The byte length to skip
     */ skipBytes(byteLength) {
        this._dataByteOffset += byteLength;
        this.byteOffset += byteLength;
    }
} //# sourceMappingURL=dataReader.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/dataStorage.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Class for storing data to local storage if available or in-memory storage otherwise
 */ __turbopack_context__.s([
    "DataStorage",
    ()=>DataStorage
]);
class DataStorage {
    static _GetStorage() {
        try {
            localStorage.setItem("test", "");
            localStorage.removeItem("test");
            return localStorage;
        } catch  {
            const inMemoryStorage = {};
            return {
                getItem: (key)=>{
                    const value = inMemoryStorage[key];
                    return value === undefined ? null : value;
                },
                setItem: (key, value)=>{
                    inMemoryStorage[key] = value;
                }
            };
        }
    }
    /**
     * Reads a string from the data storage
     * @param key The key to read
     * @param defaultValue The value if the key doesn't exist
     * @returns The string value
     */ static ReadString(key, defaultValue) {
        const value = this._Storage.getItem(key);
        return value !== null ? value : defaultValue;
    }
    /**
     * Writes a string to the data storage
     * @param key The key to write
     * @param value The value to write
     */ static WriteString(key, value) {
        this._Storage.setItem(key, value);
    }
    /**
     * Reads a boolean from the data storage
     * @param key The key to read
     * @param defaultValue The value if the key doesn't exist
     * @returns The boolean value
     */ static ReadBoolean(key, defaultValue) {
        const value = this._Storage.getItem(key);
        return value !== null ? value === "true" : defaultValue;
    }
    /**
     * Writes a boolean to the data storage
     * @param key The key to write
     * @param value The value to write
     */ static WriteBoolean(key, value) {
        this._Storage.setItem(key, value ? "true" : "false");
    }
    /**
     * Reads a number from the data storage
     * @param key The key to read
     * @param defaultValue The value if the key doesn't exist
     * @returns The number value
     */ static ReadNumber(key, defaultValue) {
        const value = this._Storage.getItem(key);
        return value !== null ? parseFloat(value) : defaultValue;
    }
    /**
     * Writes a number to the data storage
     * @param key The key to write
     * @param value The value to write
     */ static WriteNumber(key, value) {
        this._Storage.setItem(key, value.toString());
    }
}
DataStorage._Storage = DataStorage._GetStorage(); //# sourceMappingURL=dataStorage.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/sceneRecorder.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SceneRecorder",
    ()=>SceneRecorder
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$sceneSerializer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/sceneSerializer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/mesh.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Lights$2f$light$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Lights/light.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Cameras$2f$camera$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Cameras/camera.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Bones$2f$skeleton$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Bones/skeleton.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$material$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/material.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$multiMaterial$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/multiMaterial.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$transformNode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Meshes/transformNode.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Particles$2f$particleSystem$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Particles/particleSystem.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Morph$2f$morphTargetManager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Morph/morphTargetManager.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Lights$2f$Shadows$2f$shadowGenerator$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Lights/Shadows/shadowGenerator.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$PostProcesses$2f$postProcess$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/PostProcesses/postProcess.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/Textures/texture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$serialization$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/decorators.serialization.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
class SceneRecorder {
    constructor(){
        this._trackedScene = null;
    }
    /**
     * Track a given scene. This means the current scene state will be considered the original state
     * @param scene defines the scene to track
     */ track(scene) {
        this._trackedScene = scene;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$serialization$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SerializationHelper"].AllowLoadingUniqueId = true;
        this._savedJSON = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$sceneSerializer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SceneSerializer"].Serialize(scene);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$serialization$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SerializationHelper"].AllowLoadingUniqueId = false;
    }
    /**
     * Get the delta between current state and original state
     * @returns a any containing the delta
     */ getDelta() {
        if (!this._trackedScene) {
            return null;
        }
        const currentForceSerializeBuffers = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].ForceSerializeBuffers;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].ForceSerializeBuffers = false;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$serialization$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SerializationHelper"].AllowLoadingUniqueId = true;
        const newJSON = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$sceneSerializer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SceneSerializer"].Serialize(this._trackedScene);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$serialization$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SerializationHelper"].AllowLoadingUniqueId = false;
        const deltaJSON = {};
        for(const node in newJSON){
            this._compareCollections(node, this._savedJSON[node], newJSON[node], deltaJSON);
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$texture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Texture"].ForceSerializeBuffers = currentForceSerializeBuffers;
        return deltaJSON;
    }
    _compareArray(key, original, current, deltaJSON) {
        if (original.length === 0 && current.length === 0) {
            return true;
        }
        // Numbers?
        if (original.length && !isNaN(original[0]) || current.length && !isNaN(current[0])) {
            if (original.length !== current.length) {
                return false;
            }
            if (original.length === 0) {
                return true;
            }
            for(let index = 0; index < original.length; index++){
                if (original[index] !== current[index]) {
                    deltaJSON[key] = current;
                    return false;
                }
            }
            return true;
        }
        // let's use uniqueId to find similar objects
        const originalUniqueIds = [];
        for(let index = 0; index < original.length; index++){
            const originalObject = original[index];
            const originalUniqueId = originalObject.uniqueId;
            originalUniqueIds.push(originalUniqueId);
            // Look for that object in current state
            const currentObjects = current.filter((c)=>c.uniqueId === originalUniqueId);
            if (currentObjects.length) {
                // We have a candidate
                const currentObject = currentObjects[0];
                const newObject = {};
                if (!this._compareObjects(originalObject, currentObject, newObject)) {
                    if (!deltaJSON[key]) {
                        deltaJSON[key] = [];
                    }
                    newObject.__state = {
                        id: currentObject.id || currentObject.name
                    };
                    deltaJSON[key].push(newObject);
                }
            } else {
                // We need to delete
                const newObject = {
                    __state: {
                        deleteId: originalObject.id || originalObject.name
                    }
                };
                if (!deltaJSON[key]) {
                    deltaJSON[key] = [];
                }
                deltaJSON[key].push(newObject);
            }
        }
        // Checking for new objects
        for(let index = 0; index < current.length; index++){
            const currentObject = current[index];
            const currentUniqueId = currentObject.uniqueId;
            // Object was added
            if (originalUniqueIds.indexOf(currentUniqueId) === -1) {
                if (!deltaJSON[key]) {
                    deltaJSON[key] = [];
                }
                deltaJSON[key].push(currentObject);
            }
        }
        return true;
    }
    _compareObjects(originalObjet, currentObject, deltaJSON) {
        let aDifferenceWasFound = false;
        for(const prop in originalObjet){
            if (!Object.prototype.hasOwnProperty.call(originalObjet, prop)) {
                continue;
            }
            const originalValue = originalObjet[prop];
            const currentValue = currentObject[prop];
            let diffFound = false;
            if (Array.isArray(originalValue)) {
                diffFound = JSON.stringify(originalValue) !== JSON.stringify(currentValue);
            } else if (!isNaN(originalValue) || Object.prototype.toString.call(originalValue) == "[object String]") {
                diffFound = originalValue !== currentValue;
            } else if (typeof originalValue === "object" && typeof currentValue === "object") {
                const newObject = {};
                if (!this._compareObjects(originalValue, currentValue, newObject)) {
                    deltaJSON[prop] = newObject;
                    aDifferenceWasFound = true;
                }
            }
            if (diffFound) {
                aDifferenceWasFound = true;
                deltaJSON[prop] = currentValue;
            }
        }
        return !aDifferenceWasFound;
    }
    _compareCollections(key, original, current, deltaJSON) {
        // Same ?
        if (original === current) {
            return;
        }
        if (original && current) {
            // Array?
            if (Array.isArray(original) && Array.isArray(current)) {
                if (this._compareArray(key, original, current, deltaJSON)) {
                    return;
                }
            } else if (typeof original === "object" && typeof current === "object") {
                // Object
                const newObject = {};
                if (!this._compareObjects(original, current, newObject)) {
                    deltaJSON[key] = newObject;
                }
                return;
            }
        }
    }
    static GetShadowGeneratorById(scene, id) {
        const allGenerators = scene.lights.map((l)=>l.getShadowGenerators());
        for (const generators of allGenerators){
            if (generators) {
                const iterator = generators.values();
                for(let key = iterator.next(); key.done !== true; key = iterator.next()){
                    const generator = key.value;
                    if (generator && generator.id === id) {
                        return generator;
                    }
                }
            }
        }
        return null;
    }
    /**
     * Apply a given delta to a given scene
     * @param deltaJSON defines the JSON containing the delta
     * @param scene defines the scene to apply the delta to
     */ static ApplyDelta(deltaJSON, scene) {
        if (typeof deltaJSON === "string") {
            deltaJSON = JSON.parse(deltaJSON);
        }
        // Scene
        const anyScene = scene;
        for(const prop in deltaJSON){
            const source = deltaJSON[prop];
            const property = anyScene[prop];
            if (Array.isArray(property) || prop === "shadowGenerators") {
                // Restore array
                switch(prop){
                    case "cameras":
                        this._ApplyDeltaForEntity(source, scene, scene.getCameraById.bind(scene), (data)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Cameras$2f$camera$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Camera"].Parse(data, scene));
                        break;
                    case "lights":
                        this._ApplyDeltaForEntity(source, scene, scene.getLightById.bind(scene), (data)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Lights$2f$light$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Light"].Parse(data, scene));
                        break;
                    case "shadowGenerators":
                        this._ApplyDeltaForEntity(source, scene, (id)=>this.GetShadowGeneratorById(scene, id), (data)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Lights$2f$Shadows$2f$shadowGenerator$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ShadowGenerator"].Parse(data, scene));
                        break;
                    case "meshes":
                        this._ApplyDeltaForEntity(source, scene, scene.getMeshById.bind(scene), (data)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$mesh$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Mesh"].Parse(data, scene, ""));
                        break;
                    case "skeletons":
                        this._ApplyDeltaForEntity(source, scene, scene.getSkeletonById.bind(scene), (data)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Bones$2f$skeleton$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Skeleton"].Parse(data, scene));
                        break;
                    case "materials":
                        this._ApplyDeltaForEntity(source, scene, scene.getMaterialById.bind(scene), (data)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$material$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Material"].Parse(data, scene, ""));
                        break;
                    case "multiMaterials":
                        this._ApplyDeltaForEntity(source, scene, scene.getMaterialById.bind(scene), (data)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$multiMaterial$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MultiMaterial"].Parse(data, scene, ""));
                        break;
                    case "transformNodes":
                        this._ApplyDeltaForEntity(source, scene, scene.getTransformNodeById.bind(scene), (data)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Meshes$2f$transformNode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TransformNode"].Parse(data, scene, ""));
                        break;
                    case "particleSystems":
                        this._ApplyDeltaForEntity(source, scene, scene.getParticleSystemById.bind(scene), (data)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Particles$2f$particleSystem$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ParticleSystem"].Parse(data, scene, ""));
                        break;
                    case "morphTargetManagers":
                        this._ApplyDeltaForEntity(source, scene, scene.getMorphTargetById.bind(scene), (data)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Morph$2f$morphTargetManager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MorphTargetManager"].Parse(data, scene));
                        break;
                    case "postProcesses":
                        this._ApplyDeltaForEntity(source, scene, scene.getPostProcessByName.bind(scene), (data)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$PostProcesses$2f$postProcess$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PostProcess"].Parse(data, scene, ""));
                        break;
                }
            } else if (!isNaN(property)) {
                anyScene[prop] = source;
            } else if (property.fromArray) {
                property.fromArray(source);
            }
        }
    }
    static _ApplyPropertiesToEntity(deltaJSON, entity) {
        for(const prop in deltaJSON){
            const source = deltaJSON[prop];
            const property = entity[prop];
            if (property === undefined) {
                continue;
            }
            if (!isNaN(property) || Array.isArray(property)) {
                entity[prop] = source;
            } else if (property.fromArray) {
                property.fromArray(source);
            } else if (typeof property === "object" && property !== null) {
                this._ApplyPropertiesToEntity(source, property);
            }
        }
    }
    static _ApplyDeltaForEntity(sources, scene, finder, addNew) {
        for (const source of sources){
            // Update
            if (source.__state && source.__state.id !== undefined) {
                const targetEntity = finder(source.__state.id);
                if (targetEntity) {
                    // This first pass applies properties that aren't on the serialization list
                    this._ApplyPropertiesToEntity(source, targetEntity);
                    // The second pass applies the serializable properties
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$serialization$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SerializationHelper"].ParseProperties(source, targetEntity, scene, null);
                }
            } else if (source.__state && source.__state.deleteId !== undefined) {
                const target = finder(source.__state.deleteId);
                target?.dispose();
            } else {
                // New
                addNew(source);
            }
        }
    }
} //# sourceMappingURL=sceneRecorder.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/trajectoryClassifier.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Trajectory",
    ()=>Trajectory,
    "TrajectoryClassifier",
    ()=>TrajectoryClassifier
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Maths/math.vector.js [app-ssr] (ecmascript)");
;
// This implementation was based on the original MIT-licensed TRACE repository
// from https://github.com/septagon/TRACE.
/**
 * Generic implementation of Levenshtein distance.
 */ var Levenshtein;
(function(Levenshtein) {
    /**
     * Alphabet from which to construct sequences to be compared using Levenshtein
     * distance.
     */ class Alphabet {
        /**
         * Serialize the Alphabet to JSON string.
         * @returns JSON serialization
         */ serialize() {
            const jsonObject = {};
            const characters = new Array(this._characterToIdx.size);
            this._characterToIdx.forEach((v, k)=>{
                characters[v] = k;
            });
            jsonObject["characters"] = characters;
            jsonObject["insertionCosts"] = this._insertionCosts;
            jsonObject["deletionCosts"] = this._deletionCosts;
            jsonObject["substitutionCosts"] = this._substitutionCosts;
            return JSON.stringify(jsonObject);
        }
        /**
         * Parse an Alphabet from a JSON serialization.
         * @param json JSON string to deserialize
         * @returns deserialized Alphabet
         */ static Deserialize(json) {
            const jsonObject = JSON.parse(json);
            const alphabet = new Alphabet(jsonObject["characters"]);
            alphabet._insertionCosts = jsonObject["insertionCosts"];
            alphabet._deletionCosts = jsonObject["deletionCosts"];
            alphabet._substitutionCosts = jsonObject["substitutionCosts"];
            return alphabet;
        }
        /**
         * Create a new Alphabet.
         * @param characters characters of the alphabet
         * @param charToInsertionCost function mapping characters to insertion costs
         * @param charToDeletionCost function mapping characters to deletion costs
         * @param charsToSubstitutionCost function mapping character pairs to substitution costs
         */ constructor(characters, charToInsertionCost = null, charToDeletionCost = null, charsToSubstitutionCost = null){
            charToInsertionCost = charToInsertionCost ?? (()=>1);
            charToDeletionCost = charToDeletionCost ?? (()=>1);
            charsToSubstitutionCost = charsToSubstitutionCost ?? ((a, b)=>a === b ? 0 : 1);
            this._characterToIdx = new Map();
            this._insertionCosts = new Array(characters.length);
            this._deletionCosts = new Array(characters.length);
            this._substitutionCosts = new Array(characters.length);
            let c;
            for(let outerIdx = 0; outerIdx < characters.length; ++outerIdx){
                c = characters[outerIdx];
                this._characterToIdx.set(c, outerIdx);
                this._insertionCosts[outerIdx] = charToInsertionCost(c);
                this._deletionCosts[outerIdx] = charToDeletionCost(c);
                this._substitutionCosts[outerIdx] = new Array(characters.length);
                for(let innerIdx = outerIdx; innerIdx < characters.length; ++innerIdx){
                    this._substitutionCosts[outerIdx][innerIdx] = charsToSubstitutionCost(c, characters[innerIdx]);
                }
            }
        }
        /**
         * Get the index (internally-assigned number) for a character.
         * @param char character
         * @returns index
         */ getCharacterIdx(char) {
            return this._characterToIdx.get(char);
        }
        /**
         * Get the insertion cost of a character from its index.
         * @param idx character index
         * @returns insertion cost
         */ getInsertionCost(idx) {
            return this._insertionCosts[idx];
        }
        /**
         * Get the deletion cost of a character from its index.
         * @param idx character index
         * @returns deletion cost
         */ getDeletionCost(idx) {
            return this._deletionCosts[idx];
        }
        /**
         * Gets the cost to substitute two characters. NOTE: this cost is
         * required to be bi-directional, meaning it cannot matter which of
         * the provided characters is being removed and which is being inserted.
         * @param idx1 the first character index
         * @param idx2 the second character index
         * @returns substitution cost
         */ getSubstitutionCost(idx1, idx2) {
            const min = Math.min(idx1, idx2);
            const max = Math.max(idx1, idx2);
            return this._substitutionCosts[min][max];
        }
    }
    Levenshtein.Alphabet = Alphabet;
    /**
     * Character sequence intended to be compared against other Sequences created
     * with the same Alphabet in order to compute Levenshtein distance.
     */ class Sequence {
        /**
         * Serialize to JSON string. JSON representation does NOT include the Alphabet
         * from which this Sequence was created; Alphabet must be independently
         * serialized.
         * @returns JSON string
         */ serialize() {
            return JSON.stringify(this._characters);
        }
        /**
         * Deserialize from JSON string and Alphabet. This should be the same Alphabet
         * from which the Sequence was originally created, which must be serialized and
         * deserialized independently so that it can be passed in here.
         * @param json JSON string representation of Sequence
         * @param alphabet Alphabet from which Sequence was originally created
         * @returns Sequence
         */ static Deserialize(json, alphabet) {
            const sequence = new Sequence([], alphabet);
            sequence._characters = JSON.parse(json);
            return sequence;
        }
        /**
         * Create a new Sequence.
         * @param characters characters in the new Sequence
         * @param alphabet Alphabet, which must include all used characters
         */ constructor(characters, alphabet){
            if (characters.length > Sequence._MAX_SEQUENCE_LENGTH) {
                throw new Error("Sequences longer than " + Sequence._MAX_SEQUENCE_LENGTH + " not supported.");
            }
            this._alphabet = alphabet;
            this._characters = characters.map((c)=>this._alphabet.getCharacterIdx(c));
        }
        /**
         * Get the distance between this Sequence and another.
         * @param other sequence to compare to
         * @returns Levenshtein distance
         */ distance(other) {
            return Sequence._Distance(this, other);
        }
        /**
         * Compute the Levenshtein distance between two Sequences.
         * @param a first Sequence
         * @param b second Sequence
         * @returns Levenshtein distance
         */ static _Distance(a, b) {
            const alphabet = a._alphabet;
            if (alphabet !== b._alphabet) {
                throw new Error("Cannot Levenshtein compare Sequences built from different alphabets.");
            }
            const aChars = a._characters;
            const bChars = b._characters;
            const aLength = aChars.length;
            const bLength = bChars.length;
            const costMatrix = Sequence._CostMatrix;
            costMatrix[0][0] = 0;
            for(let idx = 0; idx < aLength; ++idx){
                costMatrix[idx + 1][0] = costMatrix[idx][0] + alphabet.getInsertionCost(aChars[idx]);
            }
            for(let idx = 0; idx < bLength; ++idx){
                costMatrix[0][idx + 1] = costMatrix[0][idx] + alphabet.getInsertionCost(bChars[idx]);
            }
            for(let aIdx = 0; aIdx < aLength; ++aIdx){
                for(let bIdx = 0; bIdx < bLength; ++bIdx){
                    Sequence._InsertionCost = costMatrix[aIdx + 1][bIdx] + alphabet.getInsertionCost(bChars[bIdx]);
                    Sequence._DeletionCost = costMatrix[aIdx][bIdx + 1] + alphabet.getDeletionCost(aChars[aIdx]);
                    Sequence._SubstitutionCost = costMatrix[aIdx][bIdx] + alphabet.getSubstitutionCost(aChars[aIdx], bChars[bIdx]);
                    costMatrix[aIdx + 1][bIdx + 1] = Math.min(Sequence._InsertionCost, Sequence._DeletionCost, Sequence._SubstitutionCost);
                }
            }
            return costMatrix[aLength][bLength];
        }
    }
    // Scratch values
    Sequence._MAX_SEQUENCE_LENGTH = 256;
    Sequence._CostMatrix = [
        ...Array(Sequence._MAX_SEQUENCE_LENGTH + 1)
    ].map(()=>new Array(Sequence._MAX_SEQUENCE_LENGTH + 1));
    Levenshtein.Sequence = Sequence;
})(Levenshtein || (Levenshtein = {}));
class Trajectory {
    /**
     * Serialize to JSON.
     * @returns serialized JSON string
     */ serialize() {
        return JSON.stringify(this);
    }
    /**
     * Deserialize from JSON.
     * @param json serialized JSON string
     * @returns deserialized Trajectory
     */ static Deserialize(json) {
        const jsonObject = JSON.parse(json);
        const trajectory = new Trajectory(jsonObject["_segmentLength"]);
        trajectory._points = jsonObject["_points"].map((pt)=>{
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](pt["_x"], pt["_y"], pt["_z"]);
        });
        return trajectory;
    }
    /**
     * Create a new empty Trajectory.
     * @param segmentLength radius of discretization for Trajectory points
     */ constructor(segmentLength = 0.01){
        this._points = [];
        this._segmentLength = segmentLength;
    }
    /**
     * Get the length of the Trajectory.
     * @returns length of the Trajectory
     */ getLength() {
        return this._points.length * this._segmentLength;
    }
    /**
     * Append a new point to the Trajectory.
     * NOTE: This implementation has many allocations.
     * @param point point to append to the Trajectory
     */ add(point) {
        let numPoints = this._points.length;
        if (numPoints === 0) {
            this._points.push(point.clone());
        } else {
            const getT = ()=>this._segmentLength / __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"].Distance(this._points[numPoints - 1], point);
            for(let t = getT(); t <= 1.0; t = getT()){
                const newPoint = this._points[numPoints - 1].scale(1.0 - t);
                point.scaleAndAddToRef(t, newPoint);
                this._points.push(newPoint);
                ++numPoints;
            }
        }
    }
    /**
     * Create a new Trajectory with a segment length chosen to make it
     * probable that the new Trajectory will have a specified number of
     * segments. This operation is imprecise.
     * @param targetResolution number of segments desired
     * @returns new Trajectory with approximately the requested number of segments
     */ resampleAtTargetResolution(targetResolution) {
        const resampled = new Trajectory(this.getLength() / targetResolution);
        for (const pt of this._points){
            resampled.add(pt);
        }
        return resampled;
    }
    /**
     * Convert Trajectory segments into tokenized representation. This
     * representation is an array of numbers where each nth number is the
     * index of the token which is most similar to the nth segment of the
     * Trajectory.
     * @param tokens list of vectors which serve as discrete tokens
     * @returns list of indices of most similar token per segment
     */ tokenize(tokens) {
        const tokenization = [];
        const segmentDir = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"]();
        for(let idx = 2; idx < this._points.length; ++idx){
            if (Trajectory._TransformSegmentDirToRef(this._points[idx - 2], this._points[idx - 1], this._points[idx], segmentDir)) {
                tokenization.push(Trajectory._TokenizeSegment(segmentDir, tokens));
            }
        }
        return tokenization;
    }
    /**
     * Transform the rotation (i.e., direction) of a segment to isolate
     * the relative transformation represented by the segment. This operation
     * may or may not succeed due to singularities in the equations that define
     * motion relativity in this context.
     * @param priorVec the origin of the prior segment
     * @param fromVec the origin of the current segment
     * @param toVec the destination of the current segment
     * @param result reference to output variable
     * @returns whether or not transformation was successful
     */ static _TransformSegmentDirToRef(priorVec, fromVec, toVec, result) {
        const dotProductSampleRejectionThreshold = 0.98;
        fromVec.subtractToRef(priorVec, Trajectory._ForwardDir);
        Trajectory._ForwardDir.normalize();
        fromVec.scaleToRef(-1, Trajectory._InverseFromVec);
        Trajectory._InverseFromVec.normalize();
        if (Math.abs(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"].Dot(Trajectory._ForwardDir, Trajectory._InverseFromVec)) > dotProductSampleRejectionThreshold) {
            return false;
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"].CrossToRef(Trajectory._ForwardDir, Trajectory._InverseFromVec, Trajectory._UpDir);
        Trajectory._UpDir.normalize();
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"].LookAtLHToRef(priorVec, fromVec, Trajectory._UpDir, Trajectory._LookMatrix);
        toVec.subtractToRef(fromVec, Trajectory._FromToVec);
        Trajectory._FromToVec.normalize();
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"].TransformNormalToRef(Trajectory._FromToVec, Trajectory._LookMatrix, result);
        return true;
    }
    /**
     * Determine which token vector is most similar to the
     * segment vector.
     * @param segment segment vector
     * @param tokens token vector list
     * @returns index of the most similar token to the segment
     */ static _TokenizeSegment(segment, tokens) {
        Trajectory._BestMatch = 0;
        Trajectory._Score = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"].Dot(segment, tokens[0]);
        Trajectory._BestScore = Trajectory._Score;
        for(let idx = 1; idx < tokens.length; ++idx){
            Trajectory._Score = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"].Dot(segment, tokens[idx]);
            if (Trajectory._Score > Trajectory._BestScore) {
                Trajectory._BestMatch = idx;
                Trajectory._BestScore = Trajectory._Score;
            }
        }
        return Trajectory._BestMatch;
    }
}
Trajectory._ForwardDir = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"]();
Trajectory._InverseFromVec = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"]();
Trajectory._UpDir = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"]();
Trajectory._FromToVec = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"]();
Trajectory._LookMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"]();
/**
 * Collection of vectors intended to be used as the basis of Trajectory
 * tokenization for Levenshtein distance comparison. Canonically, a
 * Vector3Alphabet will resemble a "spikeball" of vectors distributed
 * roughly evenly over the surface of the unit sphere.
 */ class Vector3Alphabet {
    /**
     * Helper method to create new "spikeball" Vector3Alphabets. Uses a naive
     * optimize-from-random strategy to space points around the unit sphere
     * surface as a simple alternative to really doing the math to tile the
     * sphere.
     * @param alphabetSize size of the desired alphabet
     * @param iterations number of iterations over which to optimize the "spikeball"
     * @param startingStepSize distance factor to move points in early optimization iterations
     * @param endingStepSize distance factor to move points in late optimization iterations
     * @param fixedValues alphabet "characters" that are required and cannot be moved by optimization
     * @returns a new randomly generated and optimized Vector3Alphabet of the specified size
     */ static Generate(alphabetSize = 64, iterations = 256, startingStepSize = 0.1, endingStepSize = 0.001, fixedValues = []) {
        const epsilon = 0.001;
        const epsilonSquared = epsilon * epsilon;
        const alphabet = new Vector3Alphabet(alphabetSize);
        for(let idx = 0; idx < alphabetSize; ++idx){
            alphabet.chars[idx] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);
            alphabet.chars[idx].normalize();
        }
        for(let idx = 0; idx < fixedValues.length; ++idx){
            alphabet.chars[idx].copyFrom(fixedValues[idx]);
        }
        let stepSize;
        let distSq;
        const force = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"]();
        const scratch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"]();
        const lerp = (l, r, t)=>(1.0 - t) * l + t * r;
        for(let iteration = 0; iteration < iterations; ++iteration){
            stepSize = lerp(startingStepSize, endingStepSize, iteration / (iterations - 1));
            for(let idx = fixedValues.length; idx < alphabet.chars.length; ++idx){
                force.copyFromFloats(0, 0, 0);
                for (const pt of alphabet.chars){
                    alphabet.chars[idx].subtractToRef(pt, scratch);
                    distSq = scratch.lengthSquared();
                    if (distSq > epsilonSquared) {
                        scratch.scaleAndAddToRef(1 / (scratch.lengthSquared() * distSq), force);
                    }
                }
                force.scaleInPlace(stepSize);
                alphabet.chars[idx].addInPlace(force);
                alphabet.chars[idx].normalize();
            }
        }
        return alphabet;
    }
    /**
     * Serialize to JSON.
     * @returns JSON serialization
     */ serialize() {
        return JSON.stringify(this.chars);
    }
    /**
     * Deserialize from JSON.
     * @param json JSON serialization
     * @returns deserialized Vector3Alphabet
     */ static Deserialize(json) {
        const jsonObject = JSON.parse(json);
        const alphabet = new Vector3Alphabet(jsonObject.length);
        for(let idx = 0; idx < jsonObject.length; ++idx){
            alphabet.chars[idx] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](jsonObject[idx]["_x"], jsonObject[idx]["_y"], jsonObject[idx]["_z"]);
        }
        return alphabet;
    }
    constructor(size){
        this.chars = new Array(size);
    }
}
/**
 * Class which formalizes the manner in which a Vector3Alphabet is used to tokenize and
 * describe a Trajectory. This class houses the functionality which determines what
 * attributes of Trajectories are and are not considered important, such as scale.
 */ class TrajectoryDescriptor {
    /**
     * Serialize to JSON.
     * @returns JSON serialization
     */ serialize() {
        return JSON.stringify(this._sequences.map((sequence)=>sequence.serialize()));
    }
    /**
     * Deserialize from JSON string and Alphabet. This should be the same Alphabet
     * from which the descriptor was originally created, which must be serialized and
     * deserialized independently so that it can be passed in here.
     * @param json JSON serialization
     * @param alphabet Alphabet from which descriptor was originally created
     * @returns deserialized TrajectoryDescriptor
     */ static Deserialize(json, alphabet) {
        const descriptor = new TrajectoryDescriptor();
        descriptor._sequences = JSON.parse(json).map((s)=>Levenshtein.Sequence.Deserialize(s, alphabet));
        return descriptor;
    }
    /**
     * Create a new TrajectoryDescriptor to describe a provided Trajectory according
     * to the provided alphabets.
     * @param trajectory Trajectory to be described
     * @param vector3Alphabet Vector3Alphabet to be used to tokenize the Trajectory
     * @param levenshteinAlphabet Levenshtein.Alphabet to be used as basis for comparison with other descriptors
     * @returns TrajectoryDescriptor describing provided Trajectory
     */ static CreateFromTrajectory(trajectory, vector3Alphabet, levenshteinAlphabet) {
        return TrajectoryDescriptor.CreateFromTokenizationPyramid(TrajectoryDescriptor._GetTokenizationPyramid(trajectory, vector3Alphabet), levenshteinAlphabet);
    }
    /**
     * Create a new TrajectoryDescriptor from a pre-existing pyramid of tokens.
     * NOTE: This function exists to support an outdated serialization mechanism and should
     * be deleted if it is no longer useful.
     * @param pyramid tokenization pyramid
     * @param levenshteinAlphabet Levenshtein.Alphabet to be uses as basis for comparison with other descriptors
     * @returns TrajectoryDescriptor describing the Trajectory from which the pyramid was built
     */ static CreateFromTokenizationPyramid(pyramid, levenshteinAlphabet) {
        const descriptor = new TrajectoryDescriptor();
        descriptor._sequences = pyramid.map((tokens)=>new Levenshtein.Sequence(tokens, levenshteinAlphabet));
        return descriptor;
    }
    constructor(){
        this._sequences = [];
    }
    /**
     * Create the tokenization pyramid for the provided Trajectory according to the given
     * Vector3Alphabet.
     * @param trajectory Trajectory to be tokenized
     * @param alphabet Vector3Alphabet containing tokens
     * @param targetResolution finest resolution of descriptor
     * @returns tokenization pyramid for Trajectory
     */ static _GetTokenizationPyramid(trajectory, alphabet, targetResolution = TrajectoryDescriptor._FINEST_DESCRIPTOR_RESOLUTION) {
        const pyramid = [];
        for(let res = targetResolution; res > 4; res = Math.floor(res / 2)){
            pyramid.push(trajectory.resampleAtTargetResolution(res).tokenize(alphabet.chars));
        }
        return pyramid;
    }
    /**
     * Calculate a distance metric between this TrajectoryDescriptor and another. This is
     * essentially a similarity score and does not directly represent Euclidean distance,
     * edit distance, or any other formal distance metric.
     * @param other TrajectoryDescriptor from which to determine distance
     * @returns distance, a nonnegative similarity score where larger values indicate dissimilarity
     */ distance(other) {
        let totalDistance = 0;
        let weight;
        for(let idx = 0; idx < this._sequences.length; ++idx){
            weight = Math.pow(2, idx);
            totalDistance += weight * this._sequences[idx].distance(other._sequences[idx]);
        }
        return totalDistance;
    }
}
TrajectoryDescriptor._FINEST_DESCRIPTOR_RESOLUTION = 32;
/**
 * A set of TrajectoryDescriptors defined to be "the same." This is essentially a helper
 * class to facilitate methods of Trajectory clustering.
 */ class TrajectoryClass {
    /**
     * Serialize to JSON.
     * @returns JSON serialization
     */ serialize() {
        const jsonObject = {};
        jsonObject.descriptors = this._descriptors.map((desc)=>desc.serialize());
        jsonObject.centroidIdx = this._centroidIdx;
        jsonObject.averageDistance = this._averageDistance;
        return JSON.stringify(jsonObject);
    }
    /**
     * Deserialize from JSON string and Alphabet. This should be the same Alphabet
     * from which the descriptors were originally created, which must be serialized and
     * deserialized independently so that it can be passed in here.
     * @param json JSON string representation
     * @param alphabet Alphabet from which TrajectoryDescriptors were originally created
     * @returns deserialized TrajectoryDescriptor
     */ static Deserialize(json, alphabet) {
        const jsonObject = JSON.parse(json);
        const described = new TrajectoryClass();
        described._descriptors = jsonObject.descriptors.map((s)=>TrajectoryDescriptor.Deserialize(s, alphabet));
        described._centroidIdx = jsonObject.centroidIdx;
        described._averageDistance = jsonObject.averageDistance;
        return described;
    }
    /**
     * Create a new DescribedTrajectory.
     * @param descriptors currently-known TrajectoryDescriptors, if any
     */ constructor(descriptors = []){
        this._descriptors = descriptors;
        this._centroidIdx = -1;
        this._averageDistance = 0;
        this._refreshDescription();
    }
    /**
     * Add a new TrajectoryDescriptor to the list of descriptors known to describe
     * this same DescribedTrajectory.
     * @param descriptor descriptor to be added
     */ add(descriptor) {
        this._descriptors.push(descriptor);
        this._refreshDescription();
    }
    /**
     * Compute the cost, which is inversely related to the likelihood that the provided
     * TrajectoryDescriptor describes a Trajectory that is considered to be the same as
     * the class represented by this DescribedTrajectory.
     * @param descriptor the descriptor to be costed
     * @returns cost of the match, which is a nonnegative similarity metric where larger values indicate dissimilarity
     */ getMatchCost(descriptor) {
        return descriptor.distance(this._descriptors[this._centroidIdx]) / this._averageDistance;
    }
    /**
     * Compute the minimum distance between the queried TrajectoryDescriptor and a
     * descriptor which is a member of this collection. This is an alternative way of
     * conceptualizing match cost from getMatchCost(), and it serves a different function.
     * @param descriptor the descriptor to find the minimum distance to
     * @returns minimum descriptor distance to a member descriptor of this DescribedTrajectory
     */ getMatchMinimumDistance(descriptor) {
        return Math.min(...this._descriptors.map((desc)=>desc.distance(descriptor)));
    }
    /**
     * Refreshes the internal representation of this DescribedTrajectory.
     */ _refreshDescription() {
        this._centroidIdx = -1;
        let sum;
        const distances = this._descriptors.map((a)=>{
            sum = 0;
            for (const b of this._descriptors){
                sum += a.distance(b);
            }
            return sum;
        });
        for(let idx = 0; idx < distances.length; ++idx){
            if (this._centroidIdx < 0 || distances[idx] < distances[this._centroidIdx]) {
                this._centroidIdx = idx;
            }
        }
        this._averageDistance = 0;
        for (const desc of this._descriptors){
            this._averageDistance += desc.distance(this._descriptors[this._centroidIdx]);
        }
        if (this._descriptors.length > 0) {
            this._averageDistance = Math.max(this._averageDistance / this._descriptors.length, TrajectoryClass._MIN_AVERAGE_DISTANCE);
        }
    }
}
TrajectoryClass._MIN_AVERAGE_DISTANCE = 1;
class TrajectoryClassifier {
    /**
     * Serialize to JSON.
     * @returns JSON serialization
     */ serialize() {
        const jsonObject = {};
        jsonObject.maximumAllowableMatchCost = this._maximumAllowableMatchCost;
        jsonObject.vector3Alphabet = this._vector3Alphabet.serialize();
        jsonObject.levenshteinAlphabet = this._levenshteinAlphabet.serialize();
        jsonObject.nameToDescribedTrajectory = [];
        this._nameToDescribedTrajectory.forEach((described, name)=>{
            jsonObject.nameToDescribedTrajectory.push(name);
            jsonObject.nameToDescribedTrajectory.push(described.serialize());
        });
        return JSON.stringify(jsonObject);
    }
    /**
     * Deserialize from JSON.
     * @param json JSON serialization
     * @returns deserialized TrajectorySet
     */ static Deserialize(json) {
        const jsonObject = JSON.parse(json);
        const classifier = new TrajectoryClassifier();
        classifier._maximumAllowableMatchCost = jsonObject.maximumAllowableMatchCost;
        classifier._vector3Alphabet = Vector3Alphabet.Deserialize(jsonObject.vector3Alphabet);
        classifier._levenshteinAlphabet = Levenshtein.Alphabet.Deserialize(jsonObject.levenshteinAlphabet);
        for(let idx = 0; idx < jsonObject.nameToDescribedTrajectory.length; idx += 2){
            classifier._nameToDescribedTrajectory.set(jsonObject.nameToDescribedTrajectory[idx], TrajectoryClass.Deserialize(jsonObject.nameToDescribedTrajectory[idx + 1], classifier._levenshteinAlphabet));
        }
        return classifier;
    }
    /**
     * Initialize a new empty TrajectorySet with auto-generated Alphabets.
     * VERY naive, need to be generating these things from known
     * sets. Better version later, probably eliminating this one.
     * @returns auto-generated TrajectorySet
     */ static Generate() {
        const vecs = Vector3Alphabet.Generate(64, 256, 0.1, 0.001, [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"].Forward()
        ]);
        const charIdxs = new Array(vecs.chars.length);
        for(let idx = 0; idx < charIdxs.length; ++idx){
            charIdxs[idx] = idx;
        }
        const alphabet = new Levenshtein.Alphabet(charIdxs, (idx)=>idx === 0 ? 0 : 1, (idx)=>idx === 0 ? 0 : 1, (a, b)=>Math.min(1 - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Maths$2f$math$2e$vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"].Dot(vecs.chars[a], vecs.chars[b]), 1));
        const trajectorySet = new TrajectoryClassifier();
        trajectorySet._vector3Alphabet = vecs;
        trajectorySet._levenshteinAlphabet = alphabet;
        return trajectorySet;
    }
    constructor(){
        this._maximumAllowableMatchCost = 4;
        this._nameToDescribedTrajectory = new Map();
    }
    /**
     * Add a new Trajectory to the set with a given name.
     * @param trajectory new Trajectory to be added
     * @param classification name to which to add the Trajectory
     */ addTrajectoryToClassification(trajectory, classification) {
        if (!this._nameToDescribedTrajectory.has(classification)) {
            this._nameToDescribedTrajectory.set(classification, new TrajectoryClass());
        }
        this._nameToDescribedTrajectory.get(classification).add(TrajectoryDescriptor.CreateFromTrajectory(trajectory, this._vector3Alphabet, this._levenshteinAlphabet));
    }
    /**
     * Remove a known named trajectory and all Trajectories associated with it.
     * @param classification name to remove
     * @returns whether anything was removed
     */ deleteClassification(classification) {
        return this._nameToDescribedTrajectory.delete(classification);
    }
    /**
     * Attempt to recognize a Trajectory from among all the classifications
     * already known to the classifier.
     * @param trajectory Trajectory to be recognized
     * @returns classification of Trajectory if recognized, null otherwise
     */ classifyTrajectory(trajectory) {
        const descriptor = TrajectoryDescriptor.CreateFromTrajectory(trajectory, this._vector3Alphabet, this._levenshteinAlphabet);
        const allowableMatches = [];
        this._nameToDescribedTrajectory.forEach((trajectoryClass, classification)=>{
            if (trajectoryClass.getMatchCost(descriptor) < this._maximumAllowableMatchCost) {
                allowableMatches.push(classification);
            }
        });
        if (allowableMatches.length === 0) {
            return null;
        }
        let bestIdx = 0;
        let bestMatch = this._nameToDescribedTrajectory.get(allowableMatches[bestIdx]).getMatchMinimumDistance(descriptor);
        let match;
        for(let idx = 0; idx < allowableMatches.length; ++idx){
            match = this._nameToDescribedTrajectory.get(allowableMatches[idx]).getMatchMinimumDistance(descriptor);
            if (match < bestMatch) {
                bestMatch = match;
                bestIdx = idx;
            }
        }
        return allowableMatches[bestIdx];
    }
} //# sourceMappingURL=trajectoryClassifier.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/reflector.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Reflector",
    ()=>Reflector
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/logger.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$sceneSerializer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/sceneSerializer.js [app-ssr] (ecmascript)");
;
;
class Reflector {
    /**
     * Constructs a reflector object.
     * @param scene The scene to use
     * @param hostname The hostname of the reflector bridge
     * @param port The port of the reflector bridge
     */ constructor(scene, hostname, port){
        this._scene = scene;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Log(`[Reflector] Connecting to ws://${hostname}:${port}`);
        this._webSocket = new WebSocket(`ws://${hostname}:${port}`);
        this._webSocket.onmessage = (event)=>{
            const message = event.data;
            if (message.startsWith(Reflector._SERVER_PREFIX)) {
                const serverMessage = message.substring(Reflector._SERVER_PREFIX.length);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Log(`[Reflector] Received server message: ${serverMessage.substring(0, 64)}`);
                this._handleServerMessage(serverMessage);
                return;
            } else {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Log(`[Reflector] Received client message: ${message.substring(0, 64)}`);
                this._handleClientMessage();
            }
        };
        this._webSocket.onclose = (event)=>{
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Log(`[Reflector] Disconnected ${event.code} ${event.reason}`);
        };
    }
    /**
     * Closes the reflector connection
     */ close() {
        this._webSocket.close();
    }
    _handleServerMessage(message) {
        switch(message){
            case "connected":
                {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$sceneSerializer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SceneSerializer"].SerializeAsync(this._scene).then((serialized)=>{
                        this._webSocket.send(`load|${JSON.stringify(serialized)}`);
                    });
                    break;
                }
        }
    }
    _handleClientMessage() {
    // do nothing
    }
}
Reflector._SERVER_PREFIX = "$$"; //# sourceMappingURL=reflector.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/pressureObserverWrapper.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PressureObserverWrapper",
    ()=>PressureObserverWrapper
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/observable.js [app-ssr] (ecmascript)");
;
class PressureObserverWrapper {
    /**
     * A pressure observer will call this callback, whenever these thresholds are met.
     * @param options An object containing the thresholds used to decide what value to to return for each update property (average of start and end of a threshold boundary).
     */ constructor(options){
        this._observer = null;
        this._currentState = [];
        /**
         * An event triggered when the cpu usage/speed meets certain thresholds.
         * Note: pressure is an experimental API.
         */ this.onPressureChanged = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Observable"]();
        if (PressureObserverWrapper.IsAvailable) {
            this._observer = new PressureObserver((update)=>{
                this._currentState = update;
                this.onPressureChanged.notifyObservers(update);
            }, options);
        }
    }
    /**
     * Returns true if PressureObserver is available for use, false otherwise.
     */ static get IsAvailable() {
        return typeof PressureObserver !== "undefined" && PressureObserver.knownSources && PressureObserver.knownSources.includes("cpu");
    }
    /**
     * Method that must be called to begin observing changes, and triggering callbacks.
     * @param source defines the source to observe
     */ observe(source) {
        try {
            // eslint-disable-next-line github/no-then
            this._observer?.observe(source).catch(()=>{
            // Ignore any error
            });
            this.onPressureChanged.notifyObservers(this._currentState);
        } catch  {
        // Ignore error
        }
    }
    /**
     * Method that must be called to stop observing changes and triggering callbacks (cleanup function).
     * @param source defines the source to unobserve
     */ unobserve(source) {
        try {
            this._observer?.unobserve(source);
        } catch  {
        // Ignore error
        }
    }
    /**
     * Release the associated resources.
     */ dispose() {
        this._observer?.disconnect();
        this._observer = null;
        this.onPressureChanged.clear();
    }
} //# sourceMappingURL=pressureObserverWrapper.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/PerformanceViewer/dynamicFloat32Array.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DynamicFloat32Array",
    ()=>DynamicFloat32Array
]);
const GrowthFactor = 1.5;
class DynamicFloat32Array {
    /**
     * Creates a new DynamicFloat32Array with the desired item capacity.
     * @param itemCapacity The initial item capacity you would like to set for the array.
     */ constructor(itemCapacity){
        this._view = new Float32Array(itemCapacity);
        this._itemLength = 0;
    }
    /**
     * The number of items currently in the array.
     */ get itemLength() {
        return this._itemLength;
    }
    /**
     * Gets value at index, NaN if no such index exists.
     * @param index the index to get the value at.
     * @returns the value at the index provided.
     */ at(index) {
        if (index < 0 || index >= this._itemLength) {
            return NaN;
        }
        return this._view[index];
    }
    /**
     * Gets a view of the original array from start to end (exclusive of end).
     * @param start starting index.
     * @param end ending index.
     * @returns a subarray of the original array.
     */ subarray(start, end) {
        if (start >= end || start < 0) {
            return new Float32Array(0);
        }
        if (end > this._itemLength) {
            end = this._itemLength;
        }
        return this._view.subarray(start, end);
    }
    /**
     * Pushes items to the end of the array.
     * @param item The item to push into the array.
     */ push(item) {
        this._view[this._itemLength] = item;
        this._itemLength++;
        if (this._itemLength >= this._view.length) {
            this._growArray();
        }
    }
    /**
     * Grows the array by the growth factor when necessary.
     */ _growArray() {
        const newCapacity = Math.floor(this._view.length * GrowthFactor);
        const view = new Float32Array(newCapacity);
        view.set(this._view);
        this._view = view;
    }
} //# sourceMappingURL=dynamicFloat32Array.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/PerformanceViewer/performanceViewerCollector.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PerformanceViewerCollector",
    ()=>PerformanceViewerCollector
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/observable.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/precisionDate.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$dynamicFloat32Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/PerformanceViewer/dynamicFloat32Array.js [app-ssr] (ecmascript)");
;
;
;
;
// the initial size of our array, should be a multiple of two!
const InitialArraySize = 1800;
// three octets in a hexcode. #[AA][BB][CC], i.e. 24 bits of data.
const NumberOfBitsInHexcode = 24;
// Allows single numeral hex numbers to be appended by a 0.
const HexPadding = "0";
// header for the timestamp column
const TimestampColHeader = "timestamp";
// header for the numPoints column
const NumPointsColHeader = "numPoints";
// regex to capture all carriage returns in the string.
const CarriageReturnRegex = /\r/g;
// string to use as separator when exporting extra information along with the dataset id
const ExportedDataSeparator = "@";
class PerformanceViewerCollector {
    /**
     * The offset for when actual data values start appearing inside a slice.
     */ static get SliceDataOffset() {
        return 2;
    }
    /**
     * The offset for the value of the number of points inside a slice.
     */ static get NumberOfPointsOffset() {
        return 1;
    }
    /**
     * Handles the creation of a performance viewer collector.
     * @param _scene the scene to collect on.
     * @param _enabledStrategyCallbacks the list of data to collect with callbacks for initialization purposes.
     */ constructor(_scene, _enabledStrategyCallbacks){
        this._scene = _scene;
        /**
         * Collects data for every dataset by using the appropriate strategy. This is called every frame.
         * This method will then notify all observers with the latest slice.
         */ this._collectDataAtFrame = ()=>{
            const timestamp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now - this._startingTimestamp;
            const numPoints = this.datasets.ids.length;
            // add the starting index for the slice
            const numberOfIndices = this.datasets.startingIndices.itemLength;
            let startingIndex = 0;
            if (numberOfIndices > 0) {
                const previousStartingIndex = this.datasets.startingIndices.at(numberOfIndices - 1);
                startingIndex = previousStartingIndex + this.datasets.data.at(previousStartingIndex + PerformanceViewerCollector.NumberOfPointsOffset) + PerformanceViewerCollector.SliceDataOffset;
            }
            this.datasets.startingIndices.push(startingIndex);
            // add the first 2 items in our slice.
            this.datasets.data.push(timestamp);
            this.datasets.data.push(numPoints);
            // add the values inside the slice.
            for (const id of this.datasets.ids){
                const strategy = this._strategies.get(id);
                if (!strategy) {
                    return;
                }
                this.datasets.data.push(strategy.getData());
            }
            if (this.datasetObservable.hasObservers()) {
                const slice = [
                    timestamp,
                    numPoints
                ];
                for(let i = 0; i < numPoints; i++){
                    slice.push(this.datasets.data.at(startingIndex + PerformanceViewerCollector.SliceDataOffset + i));
                }
                this.datasetObservable.notifyObservers(slice);
            }
        };
        this.datasets = {
            ids: [],
            data: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$dynamicFloat32Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DynamicFloat32Array"](InitialArraySize),
            startingIndices: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$dynamicFloat32Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DynamicFloat32Array"](InitialArraySize)
        };
        this._strategies = new Map();
        this._datasetMeta = new Map();
        this._eventRestoreSet = new Set();
        this._customEventObservable = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Observable"]();
        this.datasetObservable = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Observable"]();
        this.metadataObservable = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Observable"]((observer)=>observer.callback(this._datasetMeta, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventState"](0)));
        if (_enabledStrategyCallbacks) {
            this.addCollectionStrategies(..._enabledStrategyCallbacks);
        }
    }
    /**
     * Registers a custom string event which will be callable via sendEvent. This method returns an event object which will contain the id of the event.
     * The user can set a value optionally, which will be used in the sendEvent method. If the value is set, we will record this value at the end of each frame,
     * if not we will increment our counter and record the value of the counter at the end of each frame. The value recorded is 0 if no sendEvent method is called, within a frame.
     * @param name The name of the event to register
     * @param forceUpdate if the code should force add an event, and replace the last one.
     * @param category the category for that event
     * @returns The event registered, used in sendEvent
     */ registerEvent(name, forceUpdate, category) {
        if (this._strategies.has(name) && !forceUpdate) {
            return;
        }
        if (this._strategies.has(name) && forceUpdate) {
            this._strategies.get(name)?.dispose();
            this._strategies.delete(name);
        }
        const strategy = (scene)=>{
            let counter = 0;
            let value = 0;
            const afterRenderObserver = scene.onAfterRenderObservable.add(()=>{
                value = counter;
                counter = 0;
            });
            const stringObserver = this._customEventObservable.add((eventVal)=>{
                if (name !== eventVal.name) {
                    return;
                }
                if (eventVal.value !== undefined) {
                    counter = eventVal.value;
                } else {
                    counter++;
                }
            });
            return {
                id: name,
                getData: ()=>value,
                dispose: ()=>{
                    scene.onAfterRenderObservable.remove(afterRenderObserver);
                    this._customEventObservable.remove(stringObserver);
                }
            };
        };
        const event = {
            name
        };
        this._eventRestoreSet.add(name);
        this.addCollectionStrategies({
            strategyCallback: strategy,
            category
        });
        return event;
    }
    /**
     * Lets the perf collector handle an event, occurences or event value depending on if the event.value params is set.
     * @param event the event to handle an occurence for
     */ sendEvent(event) {
        this._customEventObservable.notifyObservers(event);
    }
    /**
     * This event restores all custom string events if necessary.
     */ _restoreStringEvents() {
        if (this._eventRestoreSet.size !== this._customEventObservable.observers.length) {
            this._eventRestoreSet.forEach((event)=>{
                this.registerEvent(event, true);
            });
        }
    }
    /**
     * This method adds additional collection strategies for data collection purposes.
     * @param strategyCallbacks the list of data to collect with callbacks.
     */ addCollectionStrategies(...strategyCallbacks) {
        // eslint-disable-next-line prefer-const
        for (let { strategyCallback, category, hidden } of strategyCallbacks){
            const strategy = strategyCallback(this._scene);
            if (this._strategies.has(strategy.id)) {
                strategy.dispose();
                continue;
            }
            this.datasets.ids.push(strategy.id);
            if (category) {
                category = category.replace(new RegExp(ExportedDataSeparator, "g"), "");
            }
            this._datasetMeta.set(strategy.id, {
                color: this._getHexColorFromId(strategy.id),
                category,
                hidden
            });
            this._strategies.set(strategy.id, strategy);
        }
        this.metadataObservable.notifyObservers(this._datasetMeta);
    }
    /**
     * Gets a 6 character hexcode representing the colour from a passed in string.
     * @param id the string to get a hex code for.
     * @returns a hexcode hashed from the id.
     */ _getHexColorFromId(id) {
        // this first bit is just a known way of hashing a string.
        let hash = 0;
        for(let i = 0; i < id.length; i++){
            // (hash << 5) - hash is the same as hash * 31
            hash = id.charCodeAt(i) + ((hash << 5) - hash);
        }
        // then we build the string octet by octet.
        let hex = "#";
        for(let i = 0; i < NumberOfBitsInHexcode; i += 8){
            const octet = hash >> i & 0xff;
            const toStr = HexPadding + octet.toString(16);
            hex += toStr.substring(toStr.length - 2);
        }
        return hex;
    }
    /**
     * Collects and then sends the latest slice to any observers by using the appropriate strategy when the user wants.
     * The slice will be of the form [timestamp, numberOfPoints, value1, value2...]
     * This method does not add onto the collected data accessible via the datasets variable.
     */ getCurrentSlice() {
        const timestamp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now - this._startingTimestamp;
        const numPoints = this.datasets.ids.length;
        const slice = [
            timestamp,
            numPoints
        ];
        // add the values inside the slice.
        for (const id of this.datasets.ids){
            const strategy = this._strategies.get(id);
            if (!strategy) {
                return;
            }
            if (this.datasetObservable.hasObservers()) {
                slice.push(strategy.getData());
            }
        }
        if (this.datasetObservable.hasObservers()) {
            this.datasetObservable.notifyObservers(slice);
        }
    }
    /**
     * Updates a property for a dataset's metadata with the value provided.
     * @param id the id of the dataset which needs its metadata updated.
     * @param prop the property to update.
     * @param value the value to update the property with.
     */ updateMetadata(id, prop, value) {
        const meta = this._datasetMeta.get(id);
        if (!meta) {
            return;
        }
        meta[prop] = value;
        this.metadataObservable.notifyObservers(this._datasetMeta);
    }
    /**
     * Completely clear, data, ids, and strategies saved to this performance collector.
     * @param preserveStringEventsRestore if it should preserve the string events, by default will clear string events registered when called.
     */ clear(preserveStringEventsRestore) {
        this.datasets.data = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$dynamicFloat32Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DynamicFloat32Array"](InitialArraySize);
        this.datasets.ids.length = 0;
        this.datasets.startingIndices = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$dynamicFloat32Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DynamicFloat32Array"](InitialArraySize);
        this._datasetMeta.clear();
        this._strategies.forEach((strategy)=>strategy.dispose());
        this._strategies.clear();
        if (!preserveStringEventsRestore) {
            this._eventRestoreSet.clear();
        }
        this._hasLoadedData = false;
    }
    /**
     * Accessor which lets the caller know if the performance collector has data loaded from a file or not!
     * Call clear() to reset this value.
     * @returns true if the data is loaded from a file, false otherwise.
     */ get hasLoadedData() {
        return this._hasLoadedData;
    }
    /**
     * Given a string containing file data, this function parses the file data into the datasets object.
     * It returns a boolean to indicate if this object was successfully loaded with the data.
     * @param data string content representing the file data.
     * @param keepDatasetMeta if it should use reuse the existing dataset metadata
     * @returns true if the data was successfully loaded, false otherwise.
     */ loadFromFileData(data, keepDatasetMeta) {
        const lines = data.replace(CarriageReturnRegex, "").split("\n").map((line)=>line.split(",").filter((s)=>s.length > 0)).filter((line)=>line.length > 0);
        const timestampIndex = 0;
        const numPointsIndex = PerformanceViewerCollector.NumberOfPointsOffset;
        if (lines.length < 2) {
            return false;
        }
        const parsedDatasets = {
            ids: [],
            data: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$dynamicFloat32Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DynamicFloat32Array"](InitialArraySize),
            startingIndices: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$dynamicFloat32Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DynamicFloat32Array"](InitialArraySize)
        };
        // parse first line separately to populate ids!
        const [firstLine, ...dataLines] = lines;
        // make sure we have the correct beginning headers
        if (firstLine.length < 2 || firstLine[timestampIndex] !== TimestampColHeader || firstLine[numPointsIndex] !== NumPointsColHeader) {
            return false;
        }
        const idCategoryMap = new Map();
        // populate the ids.
        for(let i = PerformanceViewerCollector.SliceDataOffset; i < firstLine.length; i++){
            const [id, category] = firstLine[i].split(ExportedDataSeparator);
            parsedDatasets.ids.push(id);
            idCategoryMap.set(id, category);
        }
        let startingIndex = 0;
        for (const line of dataLines){
            if (line.length < 2) {
                return false;
            }
            const timestamp = parseFloat(line[timestampIndex]);
            const numPoints = parseInt(line[numPointsIndex]);
            if (isNaN(numPoints) || isNaN(timestamp)) {
                return false;
            }
            parsedDatasets.data.push(timestamp);
            parsedDatasets.data.push(numPoints);
            if (numPoints + PerformanceViewerCollector.SliceDataOffset !== line.length) {
                return false;
            }
            for(let i = PerformanceViewerCollector.SliceDataOffset; i < line.length; i++){
                const val = parseFloat(line[i]);
                if (isNaN(val)) {
                    return false;
                }
                parsedDatasets.data.push(val);
            }
            parsedDatasets.startingIndices.push(startingIndex);
            startingIndex += line.length;
        }
        this.datasets.ids = parsedDatasets.ids;
        this.datasets.data = parsedDatasets.data;
        this.datasets.startingIndices = parsedDatasets.startingIndices;
        if (!keepDatasetMeta) {
            this._datasetMeta.clear();
        }
        this._strategies.forEach((strategy)=>strategy.dispose());
        this._strategies.clear();
        // populate metadata.
        if (!keepDatasetMeta) {
            for (const id of this.datasets.ids){
                const category = idCategoryMap.get(id);
                this._datasetMeta.set(id, {
                    category,
                    color: this._getHexColorFromId(id)
                });
            }
        }
        this.metadataObservable.notifyObservers(this._datasetMeta);
        this._hasLoadedData = true;
        return true;
    }
    /**
     * Exports the datasets inside of the collector to a csv.
     */ exportDataToCsv() {
        let csvContent = "";
        // create the header line.
        csvContent += `${TimestampColHeader},${NumPointsColHeader}`;
        for(let i = 0; i < this.datasets.ids.length; i++){
            csvContent += `,${this.datasets.ids[i]}`;
            if (this._datasetMeta) {
                const meta = this._datasetMeta.get(this.datasets.ids[i]);
                if (meta?.category) {
                    csvContent += `${ExportedDataSeparator}${meta.category}`;
                }
            }
        }
        csvContent += "\n";
        // create the data lines
        for(let i = 0; i < this.datasets.startingIndices.itemLength; i++){
            const startingIndex = this.datasets.startingIndices.at(i);
            const timestamp = this.datasets.data.at(startingIndex);
            const numPoints = this.datasets.data.at(startingIndex + PerformanceViewerCollector.NumberOfPointsOffset);
            csvContent += `${timestamp},${numPoints}`;
            for(let offset = 0; offset < numPoints; offset++){
                csvContent += `,${this.datasets.data.at(startingIndex + PerformanceViewerCollector.SliceDataOffset + offset)}`;
            }
            // add extra commas.
            for(let diff = 0; diff < this.datasets.ids.length - numPoints; diff++){
                csvContent += ",";
            }
            csvContent += "\n";
        }
        const fileName = `${new Date().toISOString()}-perfdata.csv`;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"].Download(new Blob([
            csvContent
        ], {
            type: "text/csv"
        }), fileName);
    }
    /**
     * Starts the realtime collection of data.
     * @param shouldPreserve optional boolean param, if set will preserve the dataset between calls of start.
     */ start(shouldPreserve) {
        if (!shouldPreserve) {
            this.datasets.data = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$dynamicFloat32Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DynamicFloat32Array"](InitialArraySize);
            this.datasets.startingIndices = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$dynamicFloat32Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DynamicFloat32Array"](InitialArraySize);
            this._startingTimestamp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now;
        } else if (this._startingTimestamp === undefined) {
            this._startingTimestamp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now;
        }
        this._scene.onAfterRenderObservable.add(this._collectDataAtFrame);
        this._restoreStringEvents();
        this._isStarted = true;
    }
    /**
     * Stops the collection of data.
     */ stop() {
        this._scene.onAfterRenderObservable.removeCallback(this._collectDataAtFrame);
        this._isStarted = false;
    }
    /**
     * Returns if the perf collector has been started or not.
     */ get isStarted() {
        return this._isStarted;
    }
    /**
     * Disposes of the object
     */ dispose() {
        this._scene.onAfterRenderObservable.removeCallback(this._collectDataAtFrame);
        this._datasetMeta.clear();
        this._strategies.forEach((strategy)=>{
            strategy.dispose();
        });
        this.datasetObservable.clear();
        this.metadataObservable.clear();
        this._isStarted = false;
        this.datasets = null;
    }
} //# sourceMappingURL=performanceViewerCollector.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/PerformanceViewer/performanceViewerCollectionStrategies.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PerfCollectionStrategy",
    ()=>PerfCollectionStrategy
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Instrumentation$2f$engineInstrumentation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Instrumentation/engineInstrumentation.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/precisionDate.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Instrumentation$2f$sceneInstrumentation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Instrumentation/sceneInstrumentation.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$pressureObserverWrapper$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/pressureObserverWrapper.js [app-ssr] (ecmascript)");
;
;
;
;
// Dispose which does nothing.
const DefaultDisposeImpl = ()=>{};
class PerfCollectionStrategy {
    /**
     * Gets the initializer for the strategy used for collection of fps metrics
     * @returns the initializer for the fps strategy
     */ static FpsStrategy() {
        return (scene)=>{
            const engine = scene.getEngine();
            return {
                id: "FPS",
                getData: ()=>engine.getFps(),
                dispose: DefaultDisposeImpl
            };
        };
    }
    /**
     * Gets the initializer for the strategy used for collection of thermal utilization metrics.
     * Needs the experimental pressure API.
     * @returns the initializer for the thermal utilization strategy
     */ static ThermalStrategy() {
        return this._PressureStrategy("Thermal utilization", "thermal");
    }
    /**
     * Gets the initializer for the strategy used for collection of power supply utilization metrics.
     * Needs the experimental pressure API.
     * @returns the initializer for the power supply utilization strategy
     */ static PowerSupplyStrategy() {
        return this._PressureStrategy("Power supply utilization", "power-supply");
    }
    /**
     * Gets the initializer for the strategy used for collection of pressure metrics.
     * Needs the experimental pressure API.
     * @returns the initializer for the pressure strategy
     */ static PressureStrategy() {
        return this._PressureStrategy("Pressure");
    }
    static _PressureStrategy(name, factor = null) {
        return ()=>{
            let value = 0;
            const wrapper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$pressureObserverWrapper$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PressureObserverWrapper"]();
            wrapper.observe("cpu");
            wrapper.onPressureChanged.add((update)=>{
                for (const record of update){
                    if (factor && record.factors.includes(factor) || !factor && (record.factors?.length ?? 0) === 0) {
                        // Let s consider each step being 25% of the total pressure.
                        switch(record.state){
                            case "nominal":
                                value = 0;
                                break;
                            case "fair":
                                value = 0.25;
                                break;
                            case "serious":
                                value = 0.5;
                                break;
                            case "critical":
                                value = 1;
                                break;
                        }
                    }
                }
            });
            return {
                id: name,
                getData: ()=>value,
                dispose: ()=>wrapper.dispose()
            };
        };
    }
    /**
     * Gets the initializer for the strategy used for collection of total meshes metrics.
     * @returns the initializer for the total meshes strategy
     */ static TotalMeshesStrategy() {
        return (scene)=>{
            return {
                id: "Total meshes",
                getData: ()=>scene.meshes.length,
                dispose: DefaultDisposeImpl
            };
        };
    }
    /**
     * Gets the initializer for the strategy used for collection of active meshes metrics.
     * @returns the initializer for the active meshes strategy
     */ static ActiveMeshesStrategy() {
        return (scene)=>{
            return {
                id: "Active meshes",
                getData: ()=>scene.getActiveMeshes().length,
                dispose: DefaultDisposeImpl
            };
        };
    }
    /**
     * Gets the initializer for the strategy used for collection of active indices metrics.
     * @returns the initializer for the active indices strategy
     */ static ActiveIndicesStrategy() {
        return (scene)=>{
            return {
                id: "Active indices",
                getData: ()=>scene.getActiveIndices(),
                dispose: DefaultDisposeImpl
            };
        };
    }
    /**
     * Gets the initializer for the strategy used for collection of active faces metrics.
     * @returns the initializer for the active faces strategy
     */ static ActiveFacesStrategy() {
        return (scene)=>{
            return {
                id: "Active faces",
                getData: ()=>scene.getActiveIndices() / 3,
                dispose: DefaultDisposeImpl
            };
        };
    }
    /**
     * Gets the initializer for the strategy used for collection of active bones metrics.
     * @returns the initializer for the active bones strategy
     */ static ActiveBonesStrategy() {
        return (scene)=>{
            return {
                id: "Active bones",
                getData: ()=>scene.getActiveBones(),
                dispose: DefaultDisposeImpl
            };
        };
    }
    /**
     * Gets the initializer for the strategy used for collection of active particles metrics.
     * @returns the initializer for the active particles strategy
     */ static ActiveParticlesStrategy() {
        return (scene)=>{
            return {
                id: "Active particles",
                getData: ()=>scene.getActiveParticles(),
                dispose: DefaultDisposeImpl
            };
        };
    }
    /**
     * Gets the initializer for the strategy used for collection of draw calls metrics.
     * @returns the initializer for the draw calls strategy
     */ static DrawCallsStrategy() {
        return (scene)=>{
            let drawCalls = 0;
            const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(()=>{
                scene.getEngine()._drawCalls.fetchNewFrame();
            });
            const onAfterRenderObserver = scene.onAfterRenderObservable.add(()=>{
                drawCalls = scene.getEngine()._drawCalls.current;
            });
            return {
                id: "Draw calls",
                getData: ()=>drawCalls,
                dispose: ()=>{
                    scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);
                    scene.onAfterRenderObservable.remove(onAfterRenderObserver);
                }
            };
        };
    }
    /**
     * Gets the initializer for the strategy used for collection of total lights metrics.
     * @returns the initializer for the total lights strategy
     */ static TotalLightsStrategy() {
        return (scene)=>{
            return {
                id: "Total lights",
                getData: ()=>scene.lights.length,
                dispose: DefaultDisposeImpl
            };
        };
    }
    /**
     * Gets the initializer for the strategy used for collection of total vertices metrics.
     * @returns the initializer for the total vertices strategy
     */ static TotalVerticesStrategy() {
        return (scene)=>{
            return {
                id: "Total vertices",
                getData: ()=>scene.getTotalVertices(),
                dispose: DefaultDisposeImpl
            };
        };
    }
    /**
     * Gets the initializer for the strategy used for collection of total materials metrics.
     * @returns the initializer for the total materials strategy
     */ static TotalMaterialsStrategy() {
        return (scene)=>{
            return {
                id: "Total materials",
                getData: ()=>scene.materials.length,
                dispose: DefaultDisposeImpl
            };
        };
    }
    /**
     * Gets the initializer for the strategy used for collection of total textures metrics.
     * @returns the initializer for the total textures strategy
     */ static TotalTexturesStrategy() {
        return (scene)=>{
            return {
                id: "Total textures",
                getData: ()=>scene.textures.length,
                dispose: DefaultDisposeImpl
            };
        };
    }
    /**
     * Gets the initializer for the strategy used for collection of absolute fps metrics.
     * @returns the initializer for the absolute fps strategy
     */ static AbsoluteFpsStrategy() {
        return (scene)=>{
            const sceneInstrumentation = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Instrumentation$2f$sceneInstrumentation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SceneInstrumentation"](scene);
            sceneInstrumentation.captureFrameTime = true;
            return {
                id: "Absolute FPS",
                getData: ()=>{
                    return 1000.0 / sceneInstrumentation.frameTimeCounter.lastSecAverage;
                },
                dispose: DefaultDisposeImpl
            };
        };
    }
    /**
     * Gets the initializer for the strategy used for collection of meshes selection time metrics.
     * @returns the initializer for the meshes selection time strategy
     */ static MeshesSelectionStrategy() {
        return (scene)=>{
            let startTime = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now;
            let timeTaken = 0;
            const onBeforeActiveMeshesObserver = scene.onBeforeActiveMeshesEvaluationObservable.add(()=>{
                startTime = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now;
            });
            const onAfterActiveMeshesObserver = scene.onAfterActiveMeshesEvaluationObservable.add(()=>{
                timeTaken = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now - startTime;
            });
            return {
                id: "Meshes Selection",
                getData: ()=>timeTaken,
                dispose: ()=>{
                    scene.onBeforeActiveMeshesEvaluationObservable.remove(onBeforeActiveMeshesObserver);
                    scene.onAfterActiveMeshesEvaluationObservable.remove(onAfterActiveMeshesObserver);
                }
            };
        };
    }
    /**
     * Gets the initializer for the strategy used for collection of render targets time metrics.
     * @returns the initializer for the render targets time strategy
     */ static RenderTargetsStrategy() {
        return (scene)=>{
            let startTime = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now;
            let timeTaken = 0;
            const onBeforeRenderTargetsObserver = scene.onBeforeRenderTargetsRenderObservable.add(()=>{
                startTime = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now;
            });
            const onAfterRenderTargetsObserver = scene.onAfterRenderTargetsRenderObservable.add(()=>{
                timeTaken = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now - startTime;
            });
            return {
                id: "Render Targets",
                getData: ()=>timeTaken,
                dispose: ()=>{
                    scene.onBeforeRenderTargetsRenderObservable.remove(onBeforeRenderTargetsObserver);
                    scene.onAfterRenderTargetsRenderObservable.remove(onAfterRenderTargetsObserver);
                }
            };
        };
    }
    /**
     * Gets the initializer for the strategy used for collection of particles time metrics.
     * @returns the initializer for the particles time strategy
     */ static ParticlesStrategy() {
        return (scene)=>{
            let startTime = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now;
            let timeTaken = 0;
            const onBeforeParticlesObserver = scene.onBeforeParticlesRenderingObservable.add(()=>{
                startTime = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now;
            });
            const onAfterParticlesObserver = scene.onAfterParticlesRenderingObservable.add(()=>{
                timeTaken = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now - startTime;
            });
            return {
                id: "Particles",
                getData: ()=>timeTaken,
                dispose: ()=>{
                    scene.onBeforeParticlesRenderingObservable.remove(onBeforeParticlesObserver);
                    scene.onAfterParticlesRenderingObservable.remove(onAfterParticlesObserver);
                }
            };
        };
    }
    /**
     * Gets the initializer for the strategy used for collection of sprites time metrics.
     * @returns the initializer for the sprites time strategy
     */ static SpritesStrategy() {
        return (scene)=>{
            let startTime = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now;
            let timeTaken = 0;
            const onBeforeSpritesObserver = scene.onBeforeSpritesRenderingObservable?.add(()=>{
                startTime = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now;
            });
            const onAfterSpritesObserver = scene.onAfterSpritesRenderingObservable?.add(()=>{
                timeTaken = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now - startTime;
            });
            return {
                id: "Sprites",
                getData: ()=>timeTaken,
                dispose: ()=>{
                    scene.onBeforeSpritesRenderingObservable?.remove(onBeforeSpritesObserver);
                    scene.onAfterSpritesRenderingObservable?.remove(onAfterSpritesObserver);
                }
            };
        };
    }
    /**
     * Gets the initializer for the strategy used for collection of animations time metrics.
     * @returns the initializer for the animations time strategy
     */ static AnimationsStrategy() {
        return (scene)=>{
            let startTime = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now;
            let timeTaken = 0;
            const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(()=>{
                startTime = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now;
            });
            const onAfterAnimationsObserver = scene.onAfterAnimationsObservable.add(()=>{
                timeTaken = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now - startTime;
            });
            return {
                id: "Animations",
                getData: ()=>timeTaken,
                dispose: ()=>{
                    scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);
                    scene.onAfterAnimationsObservable.remove(onAfterAnimationsObserver);
                }
            };
        };
    }
    /**
     * Gets the initializer for the strategy used for collection of physics time metrics.
     * @returns the initializer for the physics time strategy
     */ static PhysicsStrategy() {
        return (scene)=>{
            let startTime = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now;
            let timeTaken = 0;
            const onBeforePhysicsObserver = scene.onBeforePhysicsObservable?.add(()=>{
                startTime = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now;
            });
            const onAfterPhysicsObserver = scene.onAfterPhysicsObservable?.add(()=>{
                timeTaken = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now - startTime;
            });
            return {
                id: "Physics",
                getData: ()=>timeTaken,
                dispose: ()=>{
                    scene.onBeforePhysicsObservable?.remove(onBeforePhysicsObserver);
                    scene.onAfterPhysicsObservable?.remove(onAfterPhysicsObserver);
                }
            };
        };
    }
    /**
     * Gets the initializer for the strategy used for collection of render time metrics.
     * @returns the initializer for the render time strategy
     */ static RenderStrategy() {
        return (scene)=>{
            let startTime = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now;
            let timeTaken = 0;
            const onBeforeDrawPhaseObserver = scene.onBeforeDrawPhaseObservable.add(()=>{
                startTime = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now;
            });
            const onAfterDrawPhaseObserver = scene.onAfterDrawPhaseObservable.add(()=>{
                timeTaken = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now - startTime;
            });
            return {
                id: "Render",
                getData: ()=>timeTaken,
                dispose: ()=>{
                    scene.onBeforeDrawPhaseObservable.remove(onBeforeDrawPhaseObserver);
                    scene.onAfterDrawPhaseObservable.remove(onAfterDrawPhaseObserver);
                }
            };
        };
    }
    /**
     * Gets the initializer for the strategy used for collection of total frame time metrics.
     * @returns the initializer for the total frame time strategy
     */ static FrameTotalStrategy() {
        return (scene)=>{
            let startTime = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now;
            let timeTaken = 0;
            const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(()=>{
                startTime = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now;
            });
            const onAfterRenderObserver = scene.onAfterRenderObservable.add(()=>{
                timeTaken = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now - startTime;
            });
            return {
                id: "Frame Total",
                getData: ()=>timeTaken,
                dispose: ()=>{
                    scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);
                    scene.onAfterRenderObservable.remove(onAfterRenderObserver);
                }
            };
        };
    }
    /**
     * Gets the initializer for the strategy used for collection of inter-frame time metrics.
     * @returns the initializer for the inter-frame time strategy
     */ static InterFrameStrategy() {
        return (scene)=>{
            let startTime = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now;
            let timeTaken = 0;
            const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(()=>{
                timeTaken = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now - startTime;
            });
            const onAfterRenderObserver = scene.onAfterRenderObservable.add(()=>{
                startTime = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"].Now;
            });
            return {
                id: "Inter-frame",
                getData: ()=>timeTaken,
                dispose: ()=>{
                    scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);
                    scene.onAfterRenderObservable.remove(onAfterRenderObserver);
                }
            };
        };
    }
    /**
     * Gets the initializer for the strategy used for collection of gpu frame time metrics.
     * @returns the initializer for the gpu frame time strategy
     */ static GpuFrameTimeStrategy() {
        return (scene)=>{
            const engineInstrumentation = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Instrumentation$2f$engineInstrumentation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EngineInstrumentation"](scene.getEngine());
            engineInstrumentation.captureGPUFrameTime = true;
            return {
                id: "GPU frame time",
                getData: ()=>Math.max(engineInstrumentation.gpuFrameTimeCounter.current * 0.000001, 0),
                dispose: ()=>{
                    engineInstrumentation.dispose();
                }
            };
        };
    }
} //# sourceMappingURL=performanceViewerCollectionStrategies.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/PerformanceViewer/performanceViewerSceneExtension.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$scene$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/scene.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$performanceViewerCollector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/PerformanceViewer/performanceViewerCollector.js [app-ssr] (ecmascript)");
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$scene$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Scene"].prototype.getPerfCollector = function() {
    if (!this._perfCollector) {
        this._perfCollector = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$performanceViewerCollector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PerformanceViewerCollector"](this);
    }
    return this._perfCollector;
}; //# sourceMappingURL=performanceViewerSceneExtension.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/PerformanceViewer/index.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

/* eslint-disable import/export */ __turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$performanceViewerCollector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/PerformanceViewer/performanceViewerCollector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$performanceViewerCollectionStrategies$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/PerformanceViewer/performanceViewerCollectionStrategies.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$dynamicFloat32Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/PerformanceViewer/dynamicFloat32Array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$performanceViewerSceneExtension$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/PerformanceViewer/performanceViewerSceneExtension.js [app-ssr] (ecmascript)"); //# sourceMappingURL=index.js.map
;
;
;
;
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/snapshotRenderingHelper.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SnapshotRenderingHelper",
    ()=>SnapshotRenderingHelper
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$materialHelper$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/materialHelper.functions.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/logger.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$FrameGraph$2f$Tasks$2f$Layers$2f$baseLayerTask$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/FrameGraph/Tasks/Layers/baseLayerTask.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$FrameGraph$2f$frameGraphUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/FrameGraph/frameGraphUtils.js [app-ssr] (ecmascript)");
;
;
;
;
class SnapshotRenderingHelper {
    /**
     * Creates a new snapshot rendering helper
     * Note that creating an instance of the helper will set the snapshot rendering mode to SNAPSHOTRENDERING_FAST but will not enable snapshot rendering (engine.snapshotRendering is not updated).
     * Note also that fixMeshes() is called as part of the construction
     * @param scene The scene to use the helper in
     * @param options The options for the helper
     */ constructor(scene, options){
        this._disableRenderingRefCount = 0;
        this._currentPerformancePriorityMode = 0 /* ScenePerformancePriority.BackwardCompatible */ ;
        this._isEnabling = false;
        this._enableCancelFunctions = new Map(); // first function is the callback, second function is the cancel function
        this._disableCancelFunctions = new Map(); // same as above
        /**
         * Indicates if debug logs should be displayed
         */ this.showDebugLogs = false;
        this._scene = scene;
        this._engine = scene.getEngine();
        if (!this._engine.isWebGPU) {
            return;
        }
        this._options = {
            morphTargetsNumMaxInfluences: 20,
            ...options
        };
        this._engine.snapshotRenderingMode = 1;
        this.fixMeshes();
        this._onResizeObserver = this._engine.onResizeObservable.add(()=>{
            this._log("onResize", "start");
            // enableSnapshotRendering() will delay the actual enabling of snapshot rendering by at least a frame, so these two lines are not redundant!
            if (this._fastSnapshotRenderingEnabled) {
                this.disableSnapshotRendering();
                this.enableSnapshotRendering();
            }
            this._log("onResize", "end");
        });
        this._scene.onBeforeRenderObservable.add(()=>{
            if (!this._fastSnapshotRenderingEnabled) {
                return;
            }
            // Animates skeletons
            for (const skeleton of scene.skeletons){
                skeleton.prepare(true);
            }
            // Handles meshes
            for (const mesh of scene.meshes){
                if (mesh.infiniteDistance) {
                    mesh.transferToEffect(mesh.computeWorldMatrix(true));
                }
                if (mesh.skeleton) {
                    mesh.transferToEffect(mesh.computeWorldMatrix(true));
                }
                if (mesh.getClassName() === "GaussianSplattingMesh") {
                    mesh._postToWorker();
                }
                if (mesh.morphTargetManager && mesh.subMeshes) {
                    // Make sure morph target animations work
                    for (const subMesh of mesh.subMeshes){
                        const dw = subMesh._drawWrapper;
                        const effect = dw.effect;
                        if (effect) {
                            const dataBuffer = dw.drawContext.buffers["LeftOver"];
                            const ubLeftOver = effect._pipelineContext?.uniformBuffer;
                            if (dataBuffer && ubLeftOver && ubLeftOver.setDataBuffer(dataBuffer)) {
                                mesh.morphTargetManager._bind(effect);
                                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$materialHelper$2e$functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["BindMorphTargetParameters"])(mesh, effect);
                                ubLeftOver.update();
                            }
                        }
                    }
                }
            }
            // Handles sprite renderers
            let camera = scene.activeCamera;
            if (scene.frameGraph) {
                camera = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$FrameGraph$2f$frameGraphUtils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FrameGraphUtils"].FindMainCamera(scene.frameGraph) || camera;
            }
            if (scene.spriteManagers && camera) {
                for (const imanager of scene.spriteManagers){
                    const manager = imanager;
                    const renderer = manager.spriteRenderer;
                    this._spriteRendererUpdateEffects(renderer._drawWrapperBase, renderer._drawWrapperDepth, camera);
                }
            }
        });
    }
    /**
     * Gets a value indicating if the helper is in a steady state (not in the process of enabling snapshot rendering).
     */ get isReady() {
        return !this._isEnabling;
    }
    /**
     * Enable snapshot rendering
     * Use this method instead of engine.snapshotRendering=true, to make sure everything is ready before enabling snapshot rendering.
     * Note that this method is ref-counted and works in pair with disableSnapshotRendering(): you should call enableSnapshotRendering() as many times as you call disableSnapshotRendering().
     */ enableSnapshotRendering() {
        if (!this._engine.isWebGPU) {
            return;
        }
        if (--this._disableRenderingRefCount > 0) {
            return;
        }
        this._log("enableSnapshotRendering", "called");
        if (this._disableCancelFunctions.size > 0) {
            this._log("enableSnapshotRendering", `cancelling ${this._disableCancelFunctions.size} "disable" callbacks`);
        }
        this._disableCancelFunctions.forEach((cancel)=>cancel());
        this._disableCancelFunctions.clear();
        this._isEnabling = true;
        this._disableRenderingRefCount = 0;
        this._currentPerformancePriorityMode = this._pendingCurrentPerformancePriorityMode ?? this._scene.performancePriority;
        this._pendingCurrentPerformancePriorityMode = undefined;
        this._scene.performancePriority = 0 /* ScenePerformancePriority.BackwardCompatible */ ;
        const callbackWhenSceneReady = ()=>{
            this._enableCancelFunctions.delete(callbackWhenSceneReady);
            // Make sure a full frame is rendered before enabling snapshot rendering, so use "+2" instead of "+1"
            const targetFrameId = this._engine.frameId + 2;
            this._log("enableSnapshotRendering", `scene ready, add callbacks for frames ${targetFrameId} and ${targetFrameId + 1}`);
            this._executeAtFrame(targetFrameId, ()=>{
                this._log("enableSnapshotRendering", `callback #1, enable snapshot rendering at the engine level`);
                this._engine.snapshotRendering = true;
            });
            // Render one frame with snapshot rendering enabled to make sure everything is ready
            this._executeAtFrame(targetFrameId + 1, ()=>{
                this._log("enableSnapshotRendering", `callback #2, signals that snapshot rendering helper is ready`);
                this._isEnabling = false;
            });
        };
        this._enableCancelFunctions.set(callbackWhenSceneReady, ()=>this._scene.onReadyObservable.removeCallback(callbackWhenSceneReady));
        this._scene.executeWhenReady(callbackWhenSceneReady);
    }
    /**
     * Disable snapshot rendering
     * Note that this method is ref-counted and works in pair with disableSnapshotRendering(): you should call enableSnapshotRendering() as many times as you call disableSnapshotRendering().
     */ disableSnapshotRendering() {
        if (!this._engine.isWebGPU) {
            return;
        }
        this._log("disableSnapshotRendering", "called");
        if (this._disableRenderingRefCount === 0) {
            if (this._enableCancelFunctions.size > 0) {
                this._log("disableSnapshotRendering", `cancelling ${this._enableCancelFunctions.size} "enable" callbacks`);
            }
            this._enableCancelFunctions.forEach((cancel)=>cancel());
            this._enableCancelFunctions.clear();
            this._isEnabling = false;
            // Snapshot rendering switches from enabled to disabled
            // We reset the performance priority mode to that which it was before enabling snapshot rendering, but first set it to BackwardCompatible to allow the system to regenerate resources that may have been optimized for snapshot rendering.
            // We'll then restore the original mode at the next frame.
            this._scene.performancePriority = 0 /* ScenePerformancePriority.BackwardCompatible */ ;
            if (this._currentPerformancePriorityMode !== 0 /* ScenePerformancePriority.BackwardCompatible */ ) {
                this._log("disableSnapshotRendering", `makes sure that the scene is rendered once in BackwardCompatible mode (code: ${0 /* ScenePerformancePriority.BackwardCompatible */ }) before switching to mode ${this._currentPerformancePriorityMode}`);
                this._pendingCurrentPerformancePriorityMode = this._currentPerformancePriorityMode;
                const callbackWhenSceneReady = ()=>{
                    this._log("disableSnapshotRendering", `scene ready, add callback for frame ${this._engine.frameId + 2}`);
                    this._executeAtFrame(this._engine.frameId + 2, ()=>{
                        this._log("disableSnapshotRendering", `switching to performance priority mode ${this._pendingCurrentPerformancePriorityMode}`);
                        this._scene.performancePriority = this._pendingCurrentPerformancePriorityMode;
                        this._pendingCurrentPerformancePriorityMode = undefined;
                    }, "whenDisabled");
                };
                this._disableCancelFunctions.set(callbackWhenSceneReady, ()=>this._scene.onReadyObservable.removeCallback(callbackWhenSceneReady));
                this._scene.executeWhenReady(callbackWhenSceneReady);
            }
        }
        this._engine.snapshotRendering = false;
        this._disableRenderingRefCount++;
    }
    /**
     * Fix meshes for snapshot rendering.
     * This method will make sure that some features are disabled or fixed to make sure snapshot rendering works correctly.
     * @param meshes List of meshes to fix. If not provided, all meshes in the scene will be fixed.
     */ fixMeshes(meshes) {
        if (!this._engine.isWebGPU) {
            return;
        }
        meshes = meshes || this._scene.meshes;
        for (const mesh of meshes){
            mesh.ignoreCameraMaxZ = false;
            if (mesh.morphTargetManager) {
                mesh.morphTargetManager.numMaxInfluencers = Math.min(mesh.morphTargetManager.numTargets, this._options.morphTargetsNumMaxInfluences);
            }
        }
    }
    /**
     * Call this method to update a mesh on the GPU after some properties have changed (position, rotation, scaling, visibility).
     * @param mesh The mesh to update. Can be a single mesh or an array of meshes to update.
     * @param updateInstancedMeshes If true, the method will also update instanced meshes. Default is true. If you know instanced meshes won't move (or you don't have instanced meshes), you can set this to false to save some CPU time.
     */ updateMesh(mesh, updateInstancedMeshes = true) {
        if (!this._fastSnapshotRenderingEnabled) {
            return;
        }
        if (Array.isArray(mesh)) {
            for (const m of mesh){
                if (!updateInstancedMeshes || !this._updateInstancedMesh(m)) {
                    m.transferToEffect(m.computeWorldMatrix());
                }
            }
            return;
        }
        if (!updateInstancedMeshes || !this._updateInstancedMesh(mesh)) {
            mesh.transferToEffect(mesh.computeWorldMatrix());
        }
    }
    _updateInstancedMesh(mesh) {
        if (mesh.hasInstances) {
            if (mesh.subMeshes) {
                const sourceMesh = mesh;
                for (const subMesh of sourceMesh.subMeshes){
                    const batch = sourceMesh._getInstancesRenderList(subMesh._id);
                    sourceMesh._updateInstancedBuffers(subMesh, batch, batch.parent.instancesBufferSize, this._engine);
                }
            }
            return true;
        } else if (mesh.isAnInstance) {
            return true;
        }
        return false;
    }
    /**
     * Update the meshes used in an effect layer to ensure that snapshot rendering works correctly for these meshes in this layer.
     * @param layer The effect layer or frame graph layer
     * @param autoUpdate If true, the helper will automatically update the meshes of the layer with each frame. If false, you'll need to call this method manually when the camera or layer meshes move or rotate.
     */ updateMeshesForEffectLayer(layer, autoUpdate = true) {
        if (!this._engine.isWebGPU) {
            return;
        }
        const renderPassId = layer instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$FrameGraph$2f$Tasks$2f$Layers$2f$baseLayerTask$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FrameGraphBaseLayerTask"] ? layer.objectRendererForLayer.objectRenderer.renderPassId : layer.mainTexture.renderPassId;
        if (autoUpdate) {
            this._onBeforeRenderObserverUpdateLayer = this._scene.onBeforeRenderObservable.add(()=>{
                this._updateMeshMatricesForRenderPassId(renderPassId);
            });
        } else {
            this._updateMeshMatricesForRenderPassId(renderPassId);
        }
    }
    /**
     * Dispose the helper
     */ dispose() {
        if (!this._engine.isWebGPU) {
            return;
        }
        this._scene.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
        this._scene.onBeforeRenderObservable.remove(this._onBeforeRenderObserverUpdateLayer);
        this._engine.onResizeObservable.remove(this._onResizeObserver);
    }
    get _fastSnapshotRenderingEnabled() {
        return this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1;
    }
    _updateMeshMatricesForRenderPassId(renderPassId) {
        if (!this._fastSnapshotRenderingEnabled) {
            return;
        }
        const sceneTransformationMatrix = this._scene.objectRenderers.find((renderer)=>renderer.renderPassId === renderPassId)?.activeCamera?.getTransformationMatrix() ?? this._scene.getTransformMatrix();
        for(let i = 0; i < this._scene.meshes.length; ++i){
            const mesh = this._scene.meshes[i];
            if (!mesh.subMeshes) {
                continue;
            }
            for(let j = 0; j < mesh.subMeshes.length; ++j){
                const dw = mesh.subMeshes[j]._getDrawWrapper(renderPassId);
                const effect = dw?.effect;
                if (effect) {
                    const dataBuffer = dw.drawContext.buffers["LeftOver"];
                    const ubLeftOver = effect._pipelineContext?.uniformBuffer;
                    if (dataBuffer && ubLeftOver && ubLeftOver.setDataBuffer(dataBuffer)) {
                        effect.setMatrix("viewProjection", sceneTransformationMatrix);
                        effect.setMatrix("world", mesh.computeWorldMatrix());
                        ubLeftOver.update();
                    }
                }
            }
        }
    }
    _spriteRendererDirectMatrixUpdate(dw, camera) {
        const effect = dw?.effect;
        if (effect) {
            const dataBuffer = dw.drawContext.buffers["LeftOver"];
            const ubLeftOver = effect._pipelineContext?.uniformBuffer;
            if (dataBuffer && ubLeftOver && ubLeftOver.setDataBuffer(dataBuffer)) {
                effect.setMatrix("view", camera.getViewMatrix());
                effect.setMatrix("projection", camera.getProjectionMatrix());
                ubLeftOver.update();
            }
        }
    }
    _spriteRendererUpdateEffects(drawWrapperBase, drawWrapperDepth, camera) {
        this._spriteRendererDirectMatrixUpdate(drawWrapperBase, camera);
        this._spriteRendererDirectMatrixUpdate(drawWrapperDepth, camera);
    }
    _executeAtFrame(frameId, func, mode = "whenEnabled") {
        const callback = ()=>{
            if (this._engine.frameId >= frameId) {
                this._engine.onEndFrameObservable.remove(obs);
                if (mode === "whenEnabled") {
                    this._enableCancelFunctions.delete(callback);
                } else {
                    this._disableCancelFunctions.delete(callback);
                }
                func();
            }
        };
        const obs = this._engine.onEndFrameObservable.add(callback);
        if (mode === "whenEnabled") {
            this._enableCancelFunctions.set(callback, ()=>this._engine.onEndFrameObservable.remove(obs));
        } else {
            this._disableCancelFunctions.set(callback, ()=>this._engine.onEndFrameObservable.remove(obs));
        }
    }
    _log(funcName, message) {
        if (this.showDebugLogs) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"].Log(`[Frame: ${this._engine.frameId}] SnapshotRenderingHelper:${funcName} - ${message}`);
        }
    }
} //# sourceMappingURL=snapshotRenderingHelper.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/observableCoroutine.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/observable.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$coroutine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/coroutine.js [app-ssr] (ecmascript)");
;
;
function CreateObservableScheduler(observable) {
    const coroutines = new Array();
    const onSteps = new Array();
    const onErrors = new Array();
    const observer = observable.add(()=>{
        const count = coroutines.length;
        for(let i = 0; i < count; i++){
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$coroutine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["inlineScheduler"])(coroutines.shift(), onSteps.shift(), onErrors.shift());
        }
    });
    const scheduler = (coroutine, onStep, onError)=>{
        coroutines.push(coroutine);
        onSteps.push(onStep);
        onErrors.push(onError);
    };
    return {
        scheduler: scheduler,
        dispose: ()=>{
            observable.remove(observer);
        }
    };
}
// eslint-disable-next-line @typescript-eslint/promise-function-async
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Observable"].prototype.runCoroutineAsync = function(coroutine) {
    if (!this._coroutineScheduler) {
        const schedulerAndDispose = CreateObservableScheduler(this);
        this._coroutineScheduler = schedulerAndDispose.scheduler;
        this._coroutineSchedulerDispose = schedulerAndDispose.dispose;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$coroutine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["runCoroutineAsync"])(coroutine, this._coroutineScheduler);
};
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Observable"].prototype.cancelAllCoroutines = function() {
    if (this._coroutineSchedulerDispose) {
        this._coroutineSchedulerDispose();
    }
    this._coroutineScheduler = undefined;
    this._coroutineSchedulerDispose = undefined;
}; //# sourceMappingURL=observableCoroutine.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/equirectangularCapture.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "captureEquirectangularFromScene",
    ()=>captureEquirectangularFromScene
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Probes$2f$reflectionProbe$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Probes/reflectionProbe.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$renderTargetTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/Textures/renderTargetTexture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$Procedurals$2f$customProceduralTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Materials/Textures/Procedurals/customProceduralTexture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$dumpTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/dumpTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$equirectangularPanorama$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/equirectangularPanorama.fragment.js [app-ssr] (ecmascript)");
;
;
;
;
;
async function captureEquirectangularFromScene(scene, options) {
    const probe = options.probe ?? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Probes$2f$reflectionProbe$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ReflectionProbe"]("tempProbe", options.size, scene);
    const wasProbeProvided = !!options.probe;
    if (!wasProbeProvided) {
        if (options.position) {
            probe.position = options.position.clone();
        } else if (scene.activeCamera) {
            probe.position = scene.activeCamera.position.clone();
        }
    }
    const meshesToConsider = options.meshesFilter ? scene.meshes.filter(options.meshesFilter) : scene.meshes;
    probe.renderList?.push(...meshesToConsider);
    probe.refreshRate = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$renderTargetTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RenderTargetTexture"].REFRESHRATE_RENDER_ONCE;
    probe.cubeTexture.render();
    const dumpTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Materials$2f$Textures$2f$Procedurals$2f$customProceduralTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CustomProceduralTexture"]("tempProceduralTexture", "equirectangularPanorama", {
        width: options.size * 2,
        height: options.size
    }, scene);
    dumpTexture.setTexture("cubeMap", probe.cubeTexture);
    return await new Promise((resolve, reject)=>{
        dumpTexture.onGeneratedObservable.addOnce(()=>{
            const pixelDataPromise = dumpTexture.readPixels();
            if (!pixelDataPromise) {
                reject(new Error("No Pixel Data found on procedural texture"));
                dumpTexture.dispose();
                if (!wasProbeProvided) {
                    probe.dispose();
                }
                return;
            }
            // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then
            pixelDataPromise.then((pixelData)=>{
                dumpTexture.dispose();
                if (!wasProbeProvided) {
                    probe.dispose();
                }
                if (options.filename) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$dumpTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DumpData"])(options.size * 2, options.size, pixelData, undefined, "image/png", options.filename);
                    resolve(null);
                } else {
                    resolve(pixelData);
                }
            });
        });
    });
} //# sourceMappingURL=equirectangularCapture.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/asyncLock.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AsyncLock",
    ()=>AsyncLock
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$deferred$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/deferred.js [app-ssr] (ecmascript)");
;
class AsyncLock {
    constructor(){
        this._currentOperation = Promise.resolve();
    }
    /**
     * Executes the provided function when the lock is acquired (e.g. when the previous operation finishes).
     * @param func The function to execute.
     * @param signal An optional signal that can be used to abort the operation.
     * @returns A promise that resolves when the func finishes executing.
     */ // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
    lockAsync(func, signal) {
        signal?.throwIfAborted();
        const wrappedFunc = signal ? ()=>{
            signal.throwIfAborted();
            return func();
        } : func;
        // eslint-disable-next-line github/no-then
        const newOperation = this._currentOperation.then(wrappedFunc);
        // NOTE: It would be simpler to just hold a Promise<unknown>, but this class should not prevent an object held by the returned promise from being garbage collected.
        this._currentOperation = new Promise((resolve)=>{
            // eslint-disable-next-line github/no-then
            newOperation.then(()=>resolve(), resolve);
        });
        return newOperation;
    }
    /**
     * Executes the provided function when all the specified locks are acquired.
     * @param func The function to execute.
     * @param locks The locks to acquire.
     * @param signal An optional signal that can be used to abort the operation.
     * @returns A promise that resolves when the func finishes executing.
     */ static async LockAsync(func, locks, signal) {
        signal?.throwIfAborted();
        if (locks.length === 0) {
            return await func();
        }
        const deferred = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$deferred$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Deferred"]();
        let acquiredLocks = 0;
        for (const lock of locks){
            lock.lockAsync(async ()=>{
                acquiredLocks++;
                if (acquiredLocks === locks.length) {
                    deferred.resolve(await func());
                }
                return await deferred.promise;
            // eslint-disable-next-line github/no-then
            }, signal).catch((e)=>deferred.reject(e));
        }
        return await deferred.promise;
    }
} //# sourceMappingURL=asyncLock.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/lazy.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * A class that lazily initializes a value given a factory function.
 */ __turbopack_context__.s([
    "Lazy",
    ()=>Lazy
]);
class Lazy {
    /**
     * Creates a new instance of the Lazy class.
     * @param factory A function that creates the value.
     */ constructor(factory){
        this._factory = factory;
    }
    /**
     * Gets the lazily initialized value.
     */ get value() {
        // If the factory function is still defined, it means we haven't called it yet.
        if (this._factory) {
            this._value = this._factory();
            // Set the factory function to undefined to allow it to be garbage collected.
            this._factory = undefined;
        }
        return this._value;
    }
} //# sourceMappingURL=lazy.js.map
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/index.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

/* eslint-disable @typescript-eslint/no-restricted-imports */ __turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$andOrNotEvaluator$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/andOrNotEvaluator.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$assetsManager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/assetsManager.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$basis$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/basis.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$dds$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/dds.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/decorators.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$deferred$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/deferred.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$environmentTextureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/environmentTextureTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$meshExploder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/meshExploder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$filesInput$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/filesInput.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$HighDynamicRange$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/HighDynamicRange/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$khronosTextureContainer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/khronosTextureContainer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/observable.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$extensions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/observable.extensions.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$performanceMonitor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/performanceMonitor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$sceneOptimizer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/sceneOptimizer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$sceneSerializer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/sceneSerializer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$smartArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/smartArray.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$stringDictionary$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/stringDictionary.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tags$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tags.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/textureTools.js [app-ssr] (ecmascript)");
// loaded from texture tools
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$lodCube$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/lodCube.fragment.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$lod$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/lod.fragment.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$lodCube$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/lodCube.fragment.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$lod$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/lod.fragment.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tga$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tga.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$videoRecorder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/videoRecorder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$virtualJoystick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/virtualJoystick.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$workerPool$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/workerPool.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/logger.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$typeStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/typeStore.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$filesInputStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/filesInputStore.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$deepCopier$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/deepCopier.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$deepMerger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/deepMerger.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$pivotTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/pivotTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/precisionDate.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$screenshotTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/screenshotTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$webRequest$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/webRequest.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$iInspectable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/iInspectable.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$brdfTextureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/brdfTextureTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$rgbdTextureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/rgbdTextureTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$gradients$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/gradients.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$perfCounter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/perfCounter.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileRequest$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/fileRequest.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$customAnimationFrameRequester$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/customAnimationFrameRequester.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$retryStrategy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/retryStrategy.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$interfaces$2f$screenshotSize$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/interfaces/screenshotSize.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$interfaces$2f$iPerfViewer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/interfaces/iPerfViewer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/fileTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$stringTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/stringTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$dataReader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/dataReader.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$minMaxReducer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/minMaxReducer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$depthReducer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/depthReducer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$dataStorage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/dataStorage.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$sceneRecorder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/sceneRecorder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$khronosTextureContainer2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/khronosTextureContainer2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$trajectoryClassifier$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/trajectoryClassifier.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$timer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/timer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$copyTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/copyTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$reflector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/reflector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$domManagement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/domManagement.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$pressureObserverWrapper$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/pressureObserverWrapper.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/PerformanceViewer/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$coroutine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/coroutine.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$guid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/guid.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/error.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$snapshotRenderingHelper$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/snapshotRenderingHelper.js [app-ssr] (ecmascript)");
// eslint-disable-next-line import/export
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observableCoroutine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/observableCoroutine.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$copyTextureToTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/copyTextureToTexture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$dumpTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/dumpTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$greasedLineTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/greasedLineTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$equirectangularCapture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/equirectangularCapture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$serialization$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/decorators.serialization.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$asyncLock$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/asyncLock.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$bitArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/bitArray.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$urlTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/urlTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$lazy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/lazy.js [app-ssr] (ecmascript)");
// RGBDTextureTools
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$rgbdDecode$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/rgbdDecode.fragment.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$rgbdEncode$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/rgbdEncode.fragment.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$rgbdDecode$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/rgbdDecode.fragment.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$rgbdEncode$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/rgbdEncode.fragment.js [app-ssr] (ecmascript)");
// CopyTextureToTexture
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$copyTextureToTexture$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/copyTextureToTexture.fragment.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$copyTextureToTexture$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/copyTextureToTexture.fragment.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$internals$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tools.internals.js [app-ssr] (ecmascript)"); //# sourceMappingURL=index.js.map
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/HighDynamicRange/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CubeMapToSphericalPolynomialTools",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$HighDynamicRange$2f$cubemapToSphericalPolynomial$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CubeMapToSphericalPolynomialTools"],
    "HDRTools",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$HighDynamicRange$2f$hdr$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HDRTools"],
    "PanoramaToCubeMapTools",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$HighDynamicRange$2f$panoramaToCubemap$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PanoramaToCubeMapTools"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$HighDynamicRange$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/HighDynamicRange/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$HighDynamicRange$2f$cubemapToSphericalPolynomial$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/HighDynamicRange/cubemapToSphericalPolynomial.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$HighDynamicRange$2f$hdr$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/HighDynamicRange/hdr.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$HighDynamicRange$2f$panoramaToCubemap$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/HighDynamicRange/panoramaToCubemap.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/PerformanceViewer/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DynamicFloat32Array",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$dynamicFloat32Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DynamicFloat32Array"],
    "PerfCollectionStrategy",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$performanceViewerCollectionStrategies$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PerfCollectionStrategy"],
    "PerformanceViewerCollector",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$performanceViewerCollector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PerformanceViewerCollector"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/PerformanceViewer/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$performanceViewerCollector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/PerformanceViewer/performanceViewerCollector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$performanceViewerCollectionStrategies$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/PerformanceViewer/performanceViewerCollectionStrategies.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$dynamicFloat32Array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/PerformanceViewer/dynamicFloat32Array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$performanceViewerSceneExtension$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/PerformanceViewer/performanceViewerSceneExtension.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AbortError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AbortError"],
    "AbstractAssetTask",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$assetsManager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AbstractAssetTask"],
    "AdvancedTimer",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$timer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AdvancedTimer"],
    "AndOrNotEvaluator",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$andOrNotEvaluator$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AndOrNotEvaluator"],
    "AnimationAssetTask",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$assetsManager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AnimationAssetTask"],
    "ApplyPostProcess",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ApplyPostProcess"],
    "AssetTaskState",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$assetsManager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AssetTaskState"],
    "AssetsManager",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$assetsManager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AssetsManager"],
    "AssetsProgressEvent",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$assetsManager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AssetsProgressEvent"],
    "AsyncLock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$asyncLock$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AsyncLock"],
    "AsyncLoop",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AsyncLoop"],
    "AutoReleaseWorkerPool",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$workerPool$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AutoReleaseWorkerPool"],
    "BRDFTextureTools",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$brdfTextureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BRDFTextureTools"],
    "BaseError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseError"],
    "BasisFileInfo",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$basis$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BasisFileInfo"],
    "BasisTools",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$basis$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BasisTools"],
    "BasisToolsOptions",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$basis$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BasisToolsOptions"],
    "BasisTranscodeConfiguration",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$basis$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BasisTranscodeConfiguration"],
    "BinaryFileAssetTask",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$assetsManager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BinaryFileAssetTask"],
    "BitArray",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$bitArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BitArray"],
    "Color3Gradient",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$gradients$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Color3Gradient"],
    "ColorGradient",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$gradients$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ColorGradient"],
    "ContainerAssetTask",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$assetsManager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ContainerAssetTask"],
    "ConversionMode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$copyTextureToTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ConversionMode"],
    "CopyTextureToTexture",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$copyTextureToTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CopyTextureToTexture"],
    "CopyTools",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$copyTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CopyTools"],
    "CreateEnvTextureAsync",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$environmentTextureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CreateEnvTextureAsync"],
    "CreateIrradianceImageDataArrayBufferViews",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$environmentTextureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CreateIrradianceImageDataArrayBufferViews"],
    "CreateRadianceImageDataArrayBufferViews",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$environmentTextureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CreateRadianceImageDataArrayBufferViews"],
    "CreateResizedCopy",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CreateResizedCopy"],
    "CreateScreenshot",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$screenshotTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CreateScreenshot"],
    "CreateScreenshotAsync",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$screenshotTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CreateScreenshotAsync"],
    "CreateScreenshotForFrameGraphAsync",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$screenshotTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CreateScreenshotForFrameGraphAsync"],
    "CreateScreenshotUsingRenderTarget",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$screenshotTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CreateScreenshotUsingRenderTarget"],
    "CreateScreenshotUsingRenderTargetAsync",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$screenshotTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CreateScreenshotUsingRenderTargetAsync"],
    "CreateScreenshotWithResizeAsync",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$screenshotTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CreateScreenshotWithResizeAsync"],
    "CubeMapToSphericalPolynomialTools",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$HighDynamicRange$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CubeMapToSphericalPolynomialTools"],
    "CubeTextureAssetTask",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$assetsManager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CubeTextureAssetTask"],
    "CustomOptimization",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$sceneOptimizer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CustomOptimization"],
    "DDSTools",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$dds$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DDSTools"],
    "DataReader",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$dataReader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataReader"],
    "DataStorage",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$dataStorage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataStorage"],
    "Decode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$stringTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Decode"],
    "DecodeBase64ToBinary",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$stringTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DecodeBase64ToBinary"],
    "DecodeBase64ToString",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$stringTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DecodeBase64ToString"],
    "DecodeBase64UrlToBinary",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DecodeBase64UrlToBinary"],
    "DecodeBase64UrlToString",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DecodeBase64UrlToString"],
    "DeepCopier",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$deepCopier$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DeepCopier"],
    "DefaultKTX2DecoderOptions",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$khronosTextureContainer2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DefaultKTX2DecoderOptions"],
    "Deferred",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$deferred$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Deferred"],
    "DepthReducer",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$depthReducer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DepthReducer"],
    "DomManagement",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$domManagement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DomManagement"],
    "DumpTools",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$dumpTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DumpTools"],
    "DynamicFloat32Array",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DynamicFloat32Array"],
    "EncodeArrayBufferToBase64",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$stringTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EncodeArrayBufferToBase64"],
    "EncodeImageAsync",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$dumpTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EncodeImageAsync"],
    "EndsWith",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$stringTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EndsWith"],
    "EnvironmentTextureTools",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$environmentTextureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EnvironmentTextureTools"],
    "EquiRectangularCubeTextureAssetTask",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$assetsManager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EquiRectangularCubeTextureAssetTask"],
    "ErrorCodes",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ErrorCodes"],
    "EventState",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EventState"],
    "FactorGradient",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$gradients$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FactorGradient"],
    "FileTools",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FileTools"],
    "FileToolsOptions",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FileToolsOptions"],
    "FilesInput",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$filesInput$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FilesInput"],
    "FilesInputStore",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$filesInputStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FilesInputStore"],
    "FromHalfFloat",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FromHalfFloat"],
    "GUID",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$guid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GUID"],
    "GenerateBase64StringFromPixelData",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$copyTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenerateBase64StringFromPixelData"],
    "GenerateBase64StringFromTexture",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$copyTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenerateBase64StringFromTexture"],
    "GenerateBase64StringFromTextureAsync",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$copyTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenerateBase64StringFromTextureAsync"],
    "GetClass",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$typeStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GetClass"],
    "GetClassName",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$typeStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GetClassName"],
    "GetDOMTextContent",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$domManagement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GetDOMTextContent"],
    "GetEnvInfo",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$environmentTextureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GetEnvInfo"],
    "GetEnvironmentBRDFTexture",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$brdfTextureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GetEnvironmentBRDFTexture"],
    "GetEnvironmentFuzzBRDFTexture",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$brdfTextureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GetEnvironmentFuzzBRDFTexture"],
    "GetExtensionFromUrl",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$urlTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GetExtensionFromUrl"],
    "GetInternalFormatFromBasisFormat",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$basis$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GetInternalFormatFromBasisFormat"],
    "GetMimeType",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GetMimeType"],
    "GetTGAHeader",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tga$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GetTGAHeader"],
    "GetTextureDataAsync",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GetTextureDataAsync"],
    "GradientHelper",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$gradients$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GradientHelper"],
    "GreasedLineTools",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$greasedLineTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GreasedLineTools"],
    "HDRCubeTextureAssetTask",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$assetsManager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HDRCubeTextureAssetTask"],
    "HDRTools",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$HighDynamicRange$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HDRTools"],
    "HardwareScalingOptimization",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$sceneOptimizer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HardwareScalingOptimization"],
    "ImageAssetTask",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$assetsManager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ImageAssetTask"],
    "InspectableType",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$iInspectable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InspectableType"],
    "IsBase64DataUrl",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["IsBase64DataUrl"],
    "IsDocumentAvailable",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$domManagement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["IsDocumentAvailable"],
    "IsFileURL",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["IsFileURL"],
    "IsNavigatorAvailable",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$domManagement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["IsNavigatorAvailable"],
    "IsWindowObjectExist",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$domManagement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["IsWindowObjectExist"],
    "JoystickAxis",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$virtualJoystick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["JoystickAxis"],
    "KhronosTextureContainer",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$khronosTextureContainer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["KhronosTextureContainer"],
    "KhronosTextureContainer2",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$khronosTextureContainer2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["KhronosTextureContainer2"],
    "Lazy",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$lazy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Lazy"],
    "LensFlaresOptimization",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$sceneOptimizer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LensFlaresOptimization"],
    "LoadFile",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LoadFile"],
    "LoadFileError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LoadFileError"],
    "LoadImage",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LoadImage"],
    "LoadImageConfiguration",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LoadImageConfiguration"],
    "LoadTextureFromTranscodeResult",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$basis$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LoadTextureFromTranscodeResult"],
    "Logger",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Logger"],
    "MergeMeshesOptimization",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$sceneOptimizer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MergeMeshesOptimization"],
    "MeshAssetTask",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$assetsManager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MeshAssetTask"],
    "MeshExploder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$meshExploder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MeshExploder"],
    "MinMaxReducer",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$minMaxReducer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MinMaxReducer"],
    "MultiObserver",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$extensions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MultiObserver"],
    "Observable",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Observable"],
    "Observer",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Observer"],
    "PadNumber",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$stringTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PadNumber"],
    "PanoramaToCubeMapTools",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$HighDynamicRange$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PanoramaToCubeMapTools"],
    "ParticlesOptimization",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$sceneOptimizer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ParticlesOptimization"],
    "PerfCollectionStrategy",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PerfCollectionStrategy"],
    "PerfCounter",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$perfCounter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PerfCounter"],
    "PerformanceMonitor",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$performanceMonitor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PerformanceMonitor"],
    "PerformanceViewerCollector",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PerformanceViewerCollector"],
    "PivotTools",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$pivotTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PivotTools"],
    "PostProcessesOptimization",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$sceneOptimizer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PostProcessesOptimization"],
    "PrecisionDate",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrecisionDate"],
    "PressureObserverWrapper",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$pressureObserverWrapper$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PressureObserverWrapper"],
    "RGBDTextureTools",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$rgbdTextureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RGBDTextureTools"],
    "RandomGUID",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$guid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RandomGUID"],
    "ReadFile",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ReadFile"],
    "ReadFileError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ReadFileError"],
    "Reflector",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$reflector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Reflector"],
    "RegisterClass",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$typeStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RegisterClass"],
    "RenderTargetsOptimization",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$sceneOptimizer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RenderTargetsOptimization"],
    "RequestFile",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RequestFile"],
    "RequestFileError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RequestFileError"],
    "RetryStrategy",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$retryStrategy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RetryStrategy"],
    "RollingAverage",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$performanceMonitor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RollingAverage"],
    "RuntimeError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RuntimeError"],
    "SceneOptimization",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$sceneOptimizer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SceneOptimization"],
    "SceneOptimizer",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$sceneOptimizer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SceneOptimizer"],
    "SceneOptimizerOptions",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$sceneOptimizer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SceneOptimizerOptions"],
    "SceneRecorder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$sceneRecorder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SceneRecorder"],
    "SceneSerializer",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$sceneSerializer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SceneSerializer"],
    "ScreenshotTools",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$screenshotTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ScreenshotTools"],
    "SerializationHelper",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$serialization$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SerializationHelper"],
    "SetBasisTranscoderWorker",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$basis$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SetBasisTranscoderWorker"],
    "SetCorsBehavior",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SetCorsBehavior"],
    "ShadowsOptimization",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$sceneOptimizer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ShadowsOptimization"],
    "SmartArray",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$smartArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SmartArray"],
    "SmartArrayNoDuplicate",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$smartArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SmartArrayNoDuplicate"],
    "SnapshotRenderingHelper",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$snapshotRenderingHelper$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SnapshotRenderingHelper"],
    "StartsWith",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$stringTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["StartsWith"],
    "StringDictionary",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$stringDictionary$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["StringDictionary"],
    "StringTools",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$stringTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["StringTools"],
    "TGATools",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tga$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TGATools"],
    "Tags",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tags$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tags"],
    "TestBase64DataUrl",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TestBase64DataUrl"],
    "TextFileAssetTask",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$assetsManager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TextFileAssetTask"],
    "TextureAssetTask",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$assetsManager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TextureAssetTask"],
    "TextureOptimization",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$sceneOptimizer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TextureOptimization"],
    "TextureTools",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TextureTools"],
    "TimerState",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$timer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TimerState"],
    "ToHalfFloat",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ToHalfFloat"],
    "Tools",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tools"],
    "Trajectory",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$trajectoryClassifier$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Trajectory"],
    "TrajectoryClassifier",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$trajectoryClassifier$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TrajectoryClassifier"],
    "TranscodeAsync",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$basis$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TranscodeAsync"],
    "UploadContent",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tga$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UploadContent"],
    "UploadEnvLevelsAsync",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$environmentTextureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UploadEnvLevelsAsync"],
    "UploadEnvSpherical",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$environmentTextureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UploadEnvSpherical"],
    "UploadIrradianceLevelsAsync",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$environmentTextureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UploadIrradianceLevelsAsync"],
    "UploadRadianceLevelsAsync",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$environmentTextureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UploadRadianceLevelsAsync"],
    "VideoRecorder",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$videoRecorder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VideoRecorder"],
    "VirtualJoystick",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$virtualJoystick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["VirtualJoystick"],
    "WebRequest",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$webRequest$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WebRequest"],
    "WhenTextureReadyAsync",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WhenTextureReadyAsync"],
    "WorkerPool",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$workerPool$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WorkerPool"],
    "_LoadScriptModuleAsync",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$internals$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_LoadScriptModuleAsync"],
    "_UpdateRGBDAsync",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$environmentTextureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_UpdateRGBDAsync"],
    "_injectLTSFileTools",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_injectLTSFileTools"],
    "addAccessorsForMaterialProperty",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addAccessorsForMaterialProperty"],
    "captureEquirectangularFromScene",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$equirectangularCapture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["captureEquirectangularFromScene"],
    "className",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["className"],
    "copyTextureToTexturePixelShader",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$copyTextureToTexture$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["copyTextureToTexturePixelShader"],
    "copyTextureToTexturePixelShaderWGSL",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$copyTextureToTexture$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["copyTextureToTexturePixelShaderWGSL"],
    "createYieldingScheduler",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$coroutine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createYieldingScheduler"],
    "deepMerge",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$deepMerger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["deepMerge"],
    "expandToProperty",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["expandToProperty"],
    "inlineScheduler",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$coroutine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["inlineScheduler"],
    "lodCubePixelShader",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$lodCube$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lodCubePixelShader"],
    "lodCubePixelShaderWGSL",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$lodCube$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lodCubePixelShaderWGSL"],
    "lodPixelShader",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$lod$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lodPixelShader"],
    "lodPixelShaderWGSL",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$lod$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lodPixelShaderWGSL"],
    "makeAsyncFunction",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$coroutine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["makeAsyncFunction"],
    "makeSyncFunction",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$coroutine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["makeSyncFunction"],
    "nativeOverride",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nativeOverride"],
    "normalizeEnvInfo",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$environmentTextureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["normalizeEnvInfo"],
    "rgbdDecodePixelShader",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$rgbdDecode$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rgbdDecodePixelShader"],
    "rgbdDecodePixelShaderWGSL",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$rgbdDecode$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rgbdDecodePixelShaderWGSL"],
    "rgbdEncodePixelShader",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$rgbdEncode$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rgbdEncodePixelShader"],
    "rgbdEncodePixelShaderWGSL",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$rgbdEncode$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rgbdEncodePixelShaderWGSL"],
    "runCoroutine",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$coroutine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["runCoroutine"],
    "runCoroutineAsync",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$coroutine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["runCoroutineAsync"],
    "runCoroutineSync",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$coroutine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["runCoroutineSync"],
    "serialize",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["serialize"],
    "serializeAsCameraReference",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["serializeAsCameraReference"],
    "serializeAsColor3",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["serializeAsColor3"],
    "serializeAsColor4",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["serializeAsColor4"],
    "serializeAsColorCurves",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["serializeAsColorCurves"],
    "serializeAsFresnelParameters",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["serializeAsFresnelParameters"],
    "serializeAsImageProcessingConfiguration",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["serializeAsImageProcessingConfiguration"],
    "serializeAsMatrix",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["serializeAsMatrix"],
    "serializeAsMeshReference",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["serializeAsMeshReference"],
    "serializeAsQuaternion",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["serializeAsQuaternion"],
    "serializeAsTexture",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["serializeAsTexture"],
    "serializeAsVector2",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["serializeAsVector2"],
    "serializeAsVector3",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["serializeAsVector3"],
    "setAndStartTimer",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$timer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["setAndStartTimer"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$andOrNotEvaluator$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/andOrNotEvaluator.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$assetsManager$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/assetsManager.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$basis$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/basis.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$dds$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/dds.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/decorators.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$deferred$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/deferred.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$environmentTextureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/environmentTextureTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$meshExploder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/meshExploder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$filesInput$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/filesInput.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$HighDynamicRange$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/HighDynamicRange/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$khronosTextureContainer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/khronosTextureContainer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/observable.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observable$2e$extensions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/observable.extensions.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$performanceMonitor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/performanceMonitor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$sceneOptimizer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/sceneOptimizer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$sceneSerializer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/sceneSerializer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$smartArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/smartArray.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$stringDictionary$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/stringDictionary.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tags$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tags.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$textureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/textureTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$lodCube$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/lodCube.fragment.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$lod$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/lod.fragment.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$lodCube$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/lodCube.fragment.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$lod$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/lod.fragment.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tga$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tga.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$videoRecorder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/videoRecorder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$virtualJoystick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/virtualJoystick.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$workerPool$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/workerPool.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/logger.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$typeStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/typeStore.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$filesInputStore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/filesInputStore.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$deepCopier$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/deepCopier.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$deepMerger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/deepMerger.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$pivotTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/pivotTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$precisionDate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/precisionDate.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$screenshotTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/screenshotTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$webRequest$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/webRequest.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$iInspectable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/iInspectable.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$brdfTextureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/brdfTextureTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$rgbdTextureTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/rgbdTextureTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$gradients$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/gradients.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$perfCounter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/perfCounter.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileRequest$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/fileRequest.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$customAnimationFrameRequester$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/customAnimationFrameRequester.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$retryStrategy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/retryStrategy.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$interfaces$2f$screenshotSize$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/interfaces/screenshotSize.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$interfaces$2f$iPerfViewer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/interfaces/iPerfViewer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$fileTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/fileTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$stringTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/stringTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$dataReader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/dataReader.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$minMaxReducer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/minMaxReducer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$depthReducer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/depthReducer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$dataStorage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/dataStorage.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$sceneRecorder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/sceneRecorder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$khronosTextureContainer2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/khronosTextureContainer2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$trajectoryClassifier$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/trajectoryClassifier.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$timer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/timer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$copyTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/copyTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$reflector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/reflector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$domManagement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/domManagement.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$pressureObserverWrapper$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/pressureObserverWrapper.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$PerformanceViewer$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/PerformanceViewer/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$coroutine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/coroutine.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$guid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/guid.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/error.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$snapshotRenderingHelper$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/snapshotRenderingHelper.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$observableCoroutine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/observableCoroutine.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$copyTextureToTexture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/copyTextureToTexture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$dumpTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/dumpTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$greasedLineTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/greasedLineTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$equirectangularCapture$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/equirectangularCapture.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$decorators$2e$serialization$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/decorators.serialization.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$asyncLock$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/asyncLock.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$bitArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/bitArray.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$urlTools$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/urlTools.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$lazy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/lazy.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$rgbdDecode$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/rgbdDecode.fragment.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$rgbdEncode$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/rgbdEncode.fragment.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$rgbdDecode$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/rgbdDecode.fragment.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$rgbdEncode$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/rgbdEncode.fragment.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Shaders$2f$copyTextureToTexture$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Shaders/copyTextureToTexture.fragment.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$ShadersWGSL$2f$copyTextureToTexture$2e$fragment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/ShadersWGSL/copyTextureToTexture.fragment.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$babylonjs$2b$core$40$8$2e$39$2e$0$2f$node_modules$2f40$babylonjs$2f$core$2f$Misc$2f$tools$2e$internals$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@babylonjs+core@8.39.0/node_modules/@babylonjs/core/Misc/tools.internals.js [app-ssr] (ecmascript)");
}),
];

//# sourceMappingURL=dcdbf_%40babylonjs_core_Misc_b0547968._.js.map